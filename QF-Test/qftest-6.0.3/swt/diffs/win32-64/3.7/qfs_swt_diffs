Index: org/eclipse/swt/ole/win32/OleAutomation.java
===================================================================
--- org/eclipse/swt/ole/win32/OleAutomation.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleAutomation.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -173,7 +173,7 @@
 	} catch (SWTException e) {
 		dispose();
 		throw e;
-	}
+ }
 }
 /**
  * Disposes the automation object.
@@ -192,7 +192,7 @@
 		objITypeInfo.Release();
 	}
 	objITypeInfo = null;
-	
+
 	if (objIUnknown != null){
 		objIUnknown.Release();
 		OS.OleUninitialize();
Index: org/eclipse/swt/ole/win32/OleClientSite.java
===================================================================
--- org/eclipse/swt/ole/win32/OleClientSite.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleClientSite.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -314,98 +314,98 @@
 	 */
 	boolean isOffice2007 = isOffice2007(true);
 	if (!isOffice2007 && COM.IsEqualGUID(appClsid, fileClsid)){
-		// Using the same application that created file, therefore, use default mechanism.
-		tempStorage = createTempStorage();
-		// Create ole object with storage object
-		long /*int*/[] address = new long /*int*/[1];
-		int result = COM.OleCreateFromFile(appClsid, fileName, COM.IIDIUnknown, COM.OLERENDER_DRAW, null, iOleClientSite.getAddress(), tempStorage.getAddress(), address);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		objIUnknown = new IUnknown(address[0]);
-	} else {
-		// Not using the same application that created file, therefore, copy from original file to a new storage file
-		IStorage storage = null;
-		if (COM.StgIsStorageFile(fileName) == COM.S_OK) {
+			// Using the same application that created file, therefore, use default mechanism.
+			tempStorage = createTempStorage();
+			// Create ole object with storage object
 			long /*int*/[] address = new long /*int*/[1];
-			int mode = COM.STGM_READ | COM.STGM_TRANSACTED | COM.STGM_SHARE_EXCLUSIVE;
-			int result = COM.StgOpenStorage(fileName, 0, mode, 0, 0, address); //Does an AddRef if successful
-			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			storage = new IStorage(address[0]);
+			int result = COM.OleCreateFromFile(appClsid, fileName, COM.IIDIUnknown, COM.OLERENDER_DRAW, null, iOleClientSite.getAddress(), tempStorage.getAddress(), address);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			objIUnknown = new IUnknown(address[0]);
 		} else {
-			// Original file is not a Storage file so copy contents to a stream in a new storage file
-			long /*int*/[] address = new long /*int*/[1];
-			int mode = COM.STGM_READWRITE | COM.STGM_DIRECT | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_CREATE;
-			int result = COM.StgCreateDocfile(null, mode | COM.STGM_DELETEONRELEASE, 0, address); // Increments ref count if successful
-			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			storage = new IStorage(address[0]);
-			// Create a stream on the storage object.
-			// Word does not follow the standard and does not use "CONTENTS" as the name of
-			// its primary stream
-			String streamName = "CONTENTS"; //$NON-NLS-1$
-			GUID wordGUID = getClassID(WORDPROGID);
-			if (wordGUID != null && COM.IsEqualGUID(appClsid, wordGUID)) streamName = "WordDocument"; //$NON-NLS-1$
+			// Not using the same application that created file, therefore, copy from original file to a new storage file
+			IStorage storage = null;
+			if (COM.StgIsStorageFile(fileName) == COM.S_OK) {
+				long /*int*/[] address = new long /*int*/[1];
+				int mode = COM.STGM_READ | COM.STGM_TRANSACTED | COM.STGM_SHARE_EXCLUSIVE;
+				int result = COM.StgOpenStorage(fileName, 0, mode, 0, 0, address); //Does an AddRef if successful
+				if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				storage = new IStorage(address[0]);
+			} else {
+				// Original file is not a Storage file so copy contents to a stream in a new storage file
+				long /*int*/[] address = new long /*int*/[1];
+				int mode = COM.STGM_READWRITE | COM.STGM_DIRECT | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_CREATE;
+				int result = COM.StgCreateDocfile(null, mode | COM.STGM_DELETEONRELEASE, 0, address); // Increments ref count if successful
+				if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				storage = new IStorage(address[0]);
+				// Create a stream on the storage object.
+				// Word does not follow the standard and does not use "CONTENTS" as the name of
+				// its primary stream
+				String streamName = "CONTENTS"; //$NON-NLS-1$
+				GUID wordGUID = getClassID(WORDPROGID);
+				if (wordGUID != null && COM.IsEqualGUID(appClsid, wordGUID)) streamName = "WordDocument"; //$NON-NLS-1$
 			if (isOffice2007) streamName = "Package"; //$NON-NLS-1$
-			address = new long /*int*/[1];
-			result = storage.CreateStream(streamName, mode, 0, 0, address); // Increments ref count if successful
-			if (result != COM.S_OK) {
-				storage.Release();
-				OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			}
-			IStream stream = new IStream(address[0]);
-			try {
-				// Copy over data in file to named stream
-				FileInputStream fileInput = new FileInputStream(file);
-				int increment = 1024*4;
-				byte[] buffer = new byte[increment];
-				int count = 0;
-				while((count = fileInput.read(buffer)) > 0){
-					long /*int*/ pv = COM.CoTaskMemAlloc(count);
-					OS.MoveMemory(pv, buffer, count);
-					result = stream.Write(pv, count, null) ;
-					COM.CoTaskMemFree(pv);
-					if (result != COM.S_OK) {
-						fileInput.close();
-						stream.Release();
-						storage.Release();
-						OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				address = new long /*int*/[1];
+				result = storage.CreateStream(streamName, mode, 0, 0, address); // Increments ref count if successful
+				if (result != COM.S_OK) {
+					storage.Release();
+					OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				}
+				IStream stream = new IStream(address[0]);
+				try {
+					// Copy over data in file to named stream
+					FileInputStream fileInput = new FileInputStream(file);
+					int increment = 1024*4;
+					byte[] buffer = new byte[increment];
+					int count = 0;
+					while((count = fileInput.read(buffer)) > 0){
+						long /*int*/ pv = COM.CoTaskMemAlloc(count);
+						OS.MoveMemory(pv, buffer, count);
+						result = stream.Write(pv, count, null) ;
+						COM.CoTaskMemFree(pv);
+						if (result != COM.S_OK) {
+							fileInput.close();
+							stream.Release();
+							storage.Release();
+							OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+						}
 					}
+					fileInput.close();
+					stream.Commit(COM.STGC_DEFAULT);
+					stream.Release();
+				} catch (IOException err) {
+					stream.Release();
+					storage.Release();
+					OLE.error(OLE.ERROR_CANNOT_OPEN_FILE);
 				}
-				fileInput.close();
-				stream.Commit(COM.STGC_DEFAULT);
-				stream.Release();
-			} catch (IOException err) {
-				stream.Release();
-				storage.Release();
-				OLE.error(OLE.ERROR_CANNOT_OPEN_FILE);
 			}
+			
+			// Open a temporary storage object
+			tempStorage = createTempStorage();
+			// Copy over contents of file
+			int result = storage.CopyTo(0, null, null, tempStorage.getAddress());
+			storage.Release();
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+
+			// create ole client
+			long /*int*/[] ppv = new long /*int*/[1];
+			result = COM.CoCreateInstance(appClsid, 0, COM.CLSCTX_INPROC_HANDLER | COM.CLSCTX_INPROC_SERVER, COM.IIDIUnknown, ppv);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			objIUnknown = new IUnknown(ppv[0]);
+			// get the persistent storage of the ole client
+			ppv = new long /*int*/[1];
+			result = objIUnknown.QueryInterface(COM.IIDIPersistStorage, ppv);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			IPersistStorage iPersistStorage = new IPersistStorage(ppv[0]);
+			// load the contents of the file into the ole client site
+			result = iPersistStorage.Load(tempStorage.getAddress());
+			iPersistStorage.Release();
+			if (result != COM.S_OK)OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
 		}
 		
-		// Open a temporary storage object
-		tempStorage = createTempStorage();
-		// Copy over contents of file
-		int result = storage.CopyTo(0, null, null, tempStorage.getAddress());
-		storage.Release();
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-
-		// create ole client
-		long /*int*/[] ppv = new long /*int*/[1];
-		result = COM.CoCreateInstance(appClsid, 0, COM.CLSCTX_INPROC_HANDLER | COM.CLSCTX_INPROC_SERVER, COM.IIDIUnknown, ppv);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		objIUnknown = new IUnknown(ppv[0]);
-		// get the persistent storage of the ole client
-		ppv = new long /*int*/[1];
-		result = objIUnknown.QueryInterface(COM.IIDIPersistStorage, ppv);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		IPersistStorage iPersistStorage = new IPersistStorage(ppv[0]);
-		// load the contents of the file into the ole client site
-		result = iPersistStorage.Load(tempStorage.getAddress());
-		iPersistStorage.Release();
-		if (result != COM.S_OK)OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-	}
-	
-	// Init sinks
-	addObjectReferences();
-	
-	if (COM.OleRun(objIUnknown.getAddress()) == OLE.S_OK) state = STATE_RUNNING;
+		// Init sinks
+		addObjectReferences();
+		
+		if (COM.OleRun(objIUnknown.getAddress()) == OLE.S_OK) state = STATE_RUNNING;
 }
 protected void addObjectReferences() {
 	//
@@ -442,7 +442,7 @@
 	long /*int*/[] ppvClientSite = new long /*int*/[1];
 	result = objIOleObject.GetClientSite(ppvClientSite);
 	if (ppvClientSite[0] == 0) {
-		objIOleObject.SetClientSite(iOleClientSite.getAddress());
+	objIOleObject.SetClientSite(iOleClientSite.getAddress());
 	} else {
 		Release(); // GetClientSite performs an AddRef so we must release it.
 	}
@@ -894,7 +894,7 @@
 }
 private void onDispose(Event e) {
 	inDispose = true;
-
+	
 	// remove listeners
 	removeListener(SWT.Dispose, listener);
 	removeListener(SWT.FocusIn, listener);
@@ -1140,7 +1140,7 @@
 	objIUnknown = null;
 	
 	if (COM.FreeUnusedLibraries) {
-		COM.CoFreeUnusedLibraries();
+	COM.CoFreeUnusedLibraries();
 	}
 }
 /**
Index: org/eclipse/swt/ole/win32/Variant.java
===================================================================
--- org/eclipse/swt/ole/win32/Variant.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/Variant.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -88,7 +88,7 @@
  * @param pVariant pointer to a variant
  *
  * @return a new <code>Variant</code>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  *
  * @since 3.3
Index: org/eclipse/swt/ole/win32/OleControlSite.java
===================================================================
--- org/eclipse/swt/ole/win32/OleControlSite.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleControlSite.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -196,7 +196,7 @@
 		throw e;
 	}			
 }
-/**
+/**	 
  * Create an OleClientSite child widget to edit the specified file using the specified OLE Document
  * application.  Use style bits to select a particular look or set of properties. 
  * <p>
Index: org/eclipse/swt/ole/win32/OleFrame.java
===================================================================
--- org/eclipse/swt/ole/win32/OleFrame.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleFrame.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -605,9 +605,9 @@
 	if (refCount == 0){
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 private void releaseObjectInterfaces() {
Index: org/eclipse/swt/browser/WebKit.java
===================================================================
--- org/eclipse/swt/browser/WebKit.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebKit.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -387,33 +387,33 @@
 				type = WebKit_win32.JSValueGetType (ctx, result[0]);
 				if (type == WebKit_win32.kJSTypeNumber) {
 					long token = ((Double)convertToJava (ctx, result[0])).longValue ();
-					BrowserFunction function = (BrowserFunction)functions.get (key);
+				BrowserFunction function = (BrowserFunction)functions.get (key);
 					if (function != null && token == function.token) {
-						try {
+					try {
 							C.memmove (result, arguments + 2 * C.PTR_SIZEOF, C.PTR_SIZEOF);
-							Object temp = convertToJava (ctx, result[0]);
-							if (temp instanceof Object[]) {
-								Object[] args = (Object[])temp;
-								try {
-									returnValue = function.function (args);
-								} catch (Exception e) {
-									/* exception during function invocation */
-									returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
-								}
+						Object temp = convertToJava (ctx, result[0]);
+						if (temp instanceof Object[]) {
+							Object[] args = (Object[])temp;
+							try {
+								returnValue = function.function (args);
+							} catch (Exception e) {
+								/* exception during function invocation */
+								returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 							}
-						} catch (IllegalArgumentException e) {
-							/* invalid argument value type */
-							if (function.isEvaluate) {
-								/* notify the function so that a java exception can be thrown */
-								function.function (new String[] {WebBrowser.CreateErrorString (new SWTException (SWT.ERROR_INVALID_RETURN_VALUE).getLocalizedMessage ())});
-							}
-							returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 						}
+					} catch (IllegalArgumentException e) {
+						/* invalid argument value type */
+						if (function.isEvaluate) {
+							/* notify the function so that a java exception can be thrown */
+							function.function (new String[] {WebBrowser.CreateErrorString (new SWTException (SWT.ERROR_INVALID_RETURN_VALUE).getLocalizedMessage ())});
+						}
+						returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 					}
 				}
 			}
 		}
 	}
+	}
 	return convertToJS (ctx, returnValue);
 }
 
Index: org/eclipse/swt/browser/WebSite.java
===================================================================
--- org/eclipse/swt/browser/WebSite.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebSite.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -359,11 +359,11 @@
 			case OS.VK_O:
 				if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_MENU) >= 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
 					if (msg.wParam == OS.VK_N || IE.IEVersion >= 8) {
-						frame.setData(CONSUME_KEY, "false"); //$NON-NLS-1$
-						result = COM.S_OK;
-						break;
-					}
+					frame.setData(CONSUME_KEY, "false"); //$NON-NLS-1$
+					result = COM.S_OK;
+					break;
 				}
+				}
 				// FALL THROUGH
 			default:
 				OS.TranslateMessage(msg);
@@ -376,45 +376,45 @@
 		case OS.WM_KEYDOWN:
 		case OS.WM_KEYUP: {
 			if (!OS.IsWinCE) {
-				boolean isAccent = false;
-				switch ((int)/*64*/msg.wParam) {
-					case OS.VK_SHIFT:
-					case OS.VK_MENU:
-					case OS.VK_CONTROL:
-					case OS.VK_CAPITAL:
-					case OS.VK_NUMLOCK:
-					case OS.VK_SCROLL:
-						break;
-					default: {
-						/*
-						* Bug in Windows. The high bit in the result of MapVirtualKey() on
-						* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
-						* They should both be bit 32.  The fix is to test the right bit.
-						*/
-						int mapKey = OS.MapVirtualKey ((int)/*64*/msg.wParam, 2);
-						if (mapKey != 0) {
-							isAccent = (mapKey & (OS.IsWinNT ? 0x80000000 : 0x8000)) != 0;
-							if (!isAccent) {
-								for (int i=0; i<ACCENTS.length; i++) {
-									int value = OS.VkKeyScan (ACCENTS [i]);
-									if (value != -1 && (value & 0xFF) == msg.wParam) {
-										int state = value >> 8;
-										if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
-											(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
-											(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
-												if ((state & 0x7) != 0) isAccent = true;
-												break;
-										}
-									}
-								}
+	boolean isAccent = false;
+	switch ((int)/*64*/msg.wParam) {
+		case OS.VK_SHIFT:
+		case OS.VK_MENU:
+		case OS.VK_CONTROL:
+		case OS.VK_CAPITAL:
+		case OS.VK_NUMLOCK:
+		case OS.VK_SCROLL:
+			break;
+		default: {
+			/* 
+			* Bug in Windows. The high bit in the result of MapVirtualKey() on
+			* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
+			* They should both be bit 32.  The fix is to test the right bit.
+			*/
+			int mapKey = OS.MapVirtualKey ((int)/*64*/msg.wParam, 2);
+			if (mapKey != 0) {
+				isAccent = (mapKey & (OS.IsWinNT ? 0x80000000 : 0x8000)) != 0;
+				if (!isAccent) {
+					for (int i=0; i<ACCENTS.length; i++) {
+						int value = OS.VkKeyScan (ACCENTS [i]);
+						if (value != -1 && (value & 0xFF) == msg.wParam) {
+							int state = value >> 8;
+							if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
+								(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
+								(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
+									if ((state & 0x7) != 0) isAccent = true;
+									break;
 							}
 						}
-						break;
 					}
 				}
-				if (isAccent) result = COM.S_OK;
 			}
+			break;
 		}
+				}
+	if (isAccent) result = COM.S_OK;
+			}
+		}
 	}
 	return result;
 }
@@ -495,13 +495,13 @@
 	return IE.INET_E_DEFAULT_ACTION;
 }
 
-int MapUrlToZone(long /*int*/ pwszUrl, long /*int*/ pdwZone, int dwFlags) {
+int MapUrlToZone(long /*int*/ pwszUrl, long /*int*/ pdwZone, int dwFlags) {	
 	/*
 	* Feature in IE.  HTML rendered in memory does not enable local links
 	* but the same HTML document loaded through a local file is permitted
 	* to follow local links.  The workaround is to return URLZONE_INTRANET
 	* instead of the default value URLZONE_LOCAL_MACHINE.
-	*/
+	*/	
 	IE ie = (IE)((Browser)getParent().getParent()).webBrowser;
 	/*
 	* For some reason IE8 invokes this function after the Browser has
@@ -508,8 +508,8 @@
 	* been disposed.  To detect this case check for ie.auto != null. 
 	*/
 	if (ie.auto != null && ie.isAboutBlank && !ie.untrustedText) {
-		COM.MoveMemory(pdwZone, new int[] {IE.URLZONE_INTRANET}, 4);
-		return COM.S_OK;
+	COM.MoveMemory(pdwZone, new int[] {IE.URLZONE_INTRANET}, 4);
+	return COM.S_OK;
 	}
 	return IE.INET_E_DEFAULT_ACTION;
 }
@@ -539,10 +539,10 @@
 		if (canExecuteApplets ()) {
 			policy = IE.URLPOLICY_JAVA_LOW;
 		} else {
-			policy = IE.URLPOLICY_JAVA_PROHIBIT;
-			ignoreNextMessage = true;
-		}
+		policy = IE.URLPOLICY_JAVA_PROHIBIT;
+		ignoreNextMessage = true;
 	}
+	}
 	if (dwAction == IE.URLACTION_ACTIVEX_RUN) {
 		GUID guid = new GUID();
 		COM.MoveMemory(guid, pContext, GUID.sizeof);
@@ -788,15 +788,15 @@
 	variant.dispose ();
 
 	if (pVarResult != 0) {
-		try {
-			variant = convertToJS (returnValue);
-		} catch (SWTException e) {
-			/* invalid return value type */
-			variant = convertToJS (WebBrowser.CreateErrorString (e.getLocalizedMessage ()));
+			try {
+				variant = convertToJS (returnValue);
+			} catch (SWTException e) {
+				/* invalid return value type */
+				variant = convertToJS (WebBrowser.CreateErrorString (e.getLocalizedMessage ()));
+			}
+			Variant.win32_copy (pVarResult, variant);
+			variant.dispose ();
 		}
-		Variant.win32_copy (pVarResult, variant);
-		variant.dispose ();
-	}
 	return COM.S_OK;
 }
 
@@ -872,85 +872,85 @@
 		return new Variant (((Number)value).doubleValue ());
 	}
 	if (value instanceof Object[]) {
-		/* get IHTMLDocument2 */
-		IE browser = (IE)((Browser)getParent ().getParent ()).webBrowser;
-		OleAutomation auto = browser.auto;
-		int[] rgdispid = auto.getIDsOfNames (new String[] {"Document"}); //$NON-NLS-1$
-		if (rgdispid == null) return new Variant ();
-		Variant pVarResult = auto.getProperty (rgdispid[0]);
-		if (pVarResult == null) return new Variant ();
-		if (pVarResult.getType () == COM.VT_EMPTY) {
+			/* get IHTMLDocument2 */
+			IE browser = (IE)((Browser)getParent ().getParent ()).webBrowser;
+			OleAutomation auto = browser.auto;
+			int[] rgdispid = auto.getIDsOfNames (new String[] {"Document"}); //$NON-NLS-1$
+			if (rgdispid == null) return new Variant ();
+			Variant pVarResult = auto.getProperty (rgdispid[0]);
+			if (pVarResult == null) return new Variant ();
+			if (pVarResult.getType () == COM.VT_EMPTY) {
+				pVarResult.dispose ();
+				return new Variant ();
+			}
+			OleAutomation document = pVarResult.getAutomation ();
 			pVarResult.dispose ();
-			return new Variant ();
-		}
-		OleAutomation document = pVarResult.getAutomation ();
-		pVarResult.dispose ();
 
-		/* get IHTMLWindow2 */
-		rgdispid = document.getIDsOfNames (new String[] {"parentWindow"}); //$NON-NLS-1$
-		if (rgdispid == null) {
+			/* get IHTMLWindow2 */
+			rgdispid = document.getIDsOfNames (new String[] {"parentWindow"}); //$NON-NLS-1$
+			if (rgdispid == null) {
+				document.dispose ();
+				return new Variant ();
+			}
+			pVarResult = document.getProperty (rgdispid[0]);
+			if (pVarResult == null || pVarResult.getType () == COM.VT_EMPTY) {
+				if (pVarResult != null) pVarResult.dispose ();
+				document.dispose ();
+				return new Variant ();	
+			}
+			OleAutomation ihtmlWindow2 = pVarResult.getAutomation ();
+			pVarResult.dispose ();
 			document.dispose ();
-			return new Variant ();
-		}
-		pVarResult = document.getProperty (rgdispid[0]);
-		if (pVarResult == null || pVarResult.getType () == COM.VT_EMPTY) {
-			if (pVarResult != null) pVarResult.dispose ();
-			document.dispose ();
-			return new Variant ();	
-		}
-		OleAutomation ihtmlWindow2 = pVarResult.getAutomation ();
-		pVarResult.dispose ();
-		document.dispose ();
 
-		/* create a new JS array to be returned */
-		rgdispid = ihtmlWindow2.getIDsOfNames (new String[] {"Array"}); //$NON-NLS-1$
-		if (rgdispid == null) {
+			/* create a new JS array to be returned */
+			rgdispid = ihtmlWindow2.getIDsOfNames (new String[] {"Array"}); //$NON-NLS-1$
+			if (rgdispid == null) {
+				ihtmlWindow2.dispose ();
+				return new Variant ();
+			}
+			Variant arrayType = ihtmlWindow2.getProperty (rgdispid[0]);
 			ihtmlWindow2.dispose ();
-			return new Variant ();
-		}
-		Variant arrayType = ihtmlWindow2.getProperty (rgdispid[0]);
-		ihtmlWindow2.dispose ();
-		IDispatch arrayTypeDispatch = arrayType.getDispatch ();
-		long /*int*/[] result = new long /*int*/[1];
-		int rc = arrayTypeDispatch.QueryInterface (COM.IIDIDispatchEx, result);
+			IDispatch arrayTypeDispatch = arrayType.getDispatch ();
+			long /*int*/[] result = new long /*int*/[1];
+			int rc = arrayTypeDispatch.QueryInterface (COM.IIDIDispatchEx, result);
 		arrayType.dispose ();
-		if (rc != COM.S_OK) return new Variant ();
+			if (rc != COM.S_OK) return new Variant ();
 
-		IDispatchEx arrayTypeDispatchEx = new IDispatchEx (result[0]);
-		result[0] = 0;
-		long /*int*/ resultPtr = OS.GlobalAlloc (OS.GMEM_FIXED | OS.GMEM_ZEROINIT, VARIANT.sizeof);
-		DISPPARAMS params = new DISPPARAMS ();
-		rc = arrayTypeDispatchEx.InvokeEx (COM.DISPID_VALUE, COM.LOCALE_USER_DEFAULT, COM.DISPATCH_CONSTRUCT, params, resultPtr, null, 0);
-		if (rc != COM.S_OK) {
+			IDispatchEx arrayTypeDispatchEx = new IDispatchEx (result[0]);
+			result[0] = 0;
+			long /*int*/ resultPtr = OS.GlobalAlloc (OS.GMEM_FIXED | OS.GMEM_ZEROINIT, VARIANT.sizeof);
+			DISPPARAMS params = new DISPPARAMS ();
+			rc = arrayTypeDispatchEx.InvokeEx (COM.DISPID_VALUE, COM.LOCALE_USER_DEFAULT, COM.DISPATCH_CONSTRUCT, params, resultPtr, null, 0);
+			if (rc != COM.S_OK) {
+				OS.GlobalFree (resultPtr);
+				return new Variant ();	
+			}
+			Variant array = Variant.win32_new (resultPtr);
 			OS.GlobalFree (resultPtr);
-			return new Variant ();	
-		}
-		Variant array = Variant.win32_new (resultPtr);
-		OS.GlobalFree (resultPtr);
 
-		/* populate the array */
+			/* populate the array */
 		Object[] arrayValue = (Object[])value;
 		int length = arrayValue.length;
-		auto = array.getAutomation ();
-		int[] rgdispids = auto.getIDsOfNames (new String[] {"push"}); //$NON-NLS-1$
-		if (rgdispids != null) {
-			for (int i = 0; i < length; i++) {
-				Object currentObject = arrayValue[i];
-				try {
-					Variant variant = convertToJS (currentObject);
-					auto.invoke (rgdispids[0], new Variant[] {variant});
-					variant.dispose ();
-				} catch (SWTException e) {
-					/* invalid return value type */
-					auto.dispose ();
-					array.dispose ();
-					throw e;
+			auto = array.getAutomation ();
+			int[] rgdispids = auto.getIDsOfNames (new String[] {"push"}); //$NON-NLS-1$
+			if (rgdispids != null) {
+				for (int i = 0; i < length; i++) {
+					Object currentObject = arrayValue[i];
+					try {
+						Variant variant = convertToJS (currentObject);
+						auto.invoke (rgdispids[0], new Variant[] {variant});
+						variant.dispose ();
+					} catch (SWTException e) {
+						/* invalid return value type */
+						auto.dispose ();
+						array.dispose ();
+						throw e;
+					}
 				}
 			}
+			auto.dispose ();
+			return array;
 		}
-		auto.dispose ();
-		return array;
-	}
 	SWT.error (SWT.ERROR_INVALID_RETURN_VALUE);
 	return null;
 }
Index: org/eclipse/swt/browser/WebUIDelegate.java
===================================================================
--- org/eclipse/swt/browser/WebUIDelegate.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebUIDelegate.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -254,7 +254,7 @@
 	hr = privateFrame.getPrintedPageCount (printDC, count);
 	if (hr != COM.S_OK || count[0] == 0) {
 		privateFrame.Release ();
-		return COM.S_OK;
+	return COM.S_OK;
 	}
 	int pageCount = count[0];
 	String jobName = null;
Index: org/eclipse/swt/browser/Mozilla.java
===================================================================
--- org/eclipse/swt/browser/Mozilla.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/Mozilla.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -60,7 +60,7 @@
 	static AppFileLocProvider LocationProvider;
 	static WindowCreator2 WindowCreator;
 	static int BrowserCount, NextJSFunctionIndex = 1;
-	static Hashtable AllFunctions = new Hashtable ();
+	static Hashtable AllFunctions = new Hashtable (); 
 	static Listener DisplayListener;
 	static boolean Initialized, IsPre_1_8, IsPre_1_9, IsXULRunner, PerformedVersionCheck, XPCOMWasGlued, XPCOMInitWasGlued;
 	static String MozillaPath;
@@ -460,7 +460,7 @@
 					}
 				}
 				if (!XPCOM.NS_Free (pathBytes_NSFree, cookieString)) {
-					C.free (cookieString);
+				C.free (cookieString);
 				}
 
 				String allCookies = new String (MozillaDelegate.mbcsToWcs (null, bytes));
@@ -543,120 +543,120 @@
 }
 
 static void LoadLibraries () {
-	boolean initLoaded = false;
+		boolean initLoaded = false;
 
-	String greInitialized = System.getProperty (GRE_INITIALIZED);
-	if (TRUE.equals (greInitialized)) {
-		/* 
-		 * Another browser has already initialized xulrunner in this process,
-		 * so just bind to it instead of trying to initialize a new one.
-		 */
-		Initialized = true;
-	}
+		String greInitialized = System.getProperty (GRE_INITIALIZED); 
+		if (TRUE.equals (greInitialized)) {
+			/* 
+			 * Another browser has already initialized xulrunner in this process,
+			 * so just bind to it instead of trying to initialize a new one.
+			 */
+			Initialized = true;
+		}
 
 	MozillaPath = System.getProperty (XULRUNNER_PATH);
-	/*
-	* Browser clients that ship XULRunner in a plug-in must have an opportunity 
-	* to set the org.eclipse.swt.browser.XULRunnerPath system property to point
-	* at their XULRunner before the first Mozilla-based Browser is created.  To
-	* facilitate this, reflection is used to reference non-existent class
-	* org.eclipse.swt.browser.XULRunnerInitializer the first time a Mozilla-
-	* based Browser is created.   A client wishing to use this hook can do so
-	* by creating a fragment of org.eclipse.swt that implements this class and
-	* sets the system property in its static initializer.
-	*/
+		/*
+		* Browser clients that ship XULRunner in a plug-in must have an opportunity 
+		* to set the org.eclipse.swt.browser.XULRunnerPath system property to point
+		* at their XULRunner before the first Mozilla-based Browser is created.  To
+		* facilitate this, reflection is used to reference non-existent class
+		* org.eclipse.swt.browser.XULRunnerInitializer the first time a Mozilla-
+		* based Browser is created.   A client wishing to use this hook can do so
+		* by creating a fragment of org.eclipse.swt that implements this class and
+		* sets the system property in its static initializer.
+		*/
 	if (MozillaPath == null) {
-		try {
-			Class.forName ("org.eclipse.swt.browser.XULRunnerInitializer"); //$NON-NLS-1$
+			try {
+				Class.forName ("org.eclipse.swt.browser.XULRunnerInitializer"); //$NON-NLS-1$
 			MozillaPath = System.getProperty (XULRUNNER_PATH);
-		} catch (ClassNotFoundException e) {
-			/* no fragment is providing this class, which is the typical case */
+			} catch (ClassNotFoundException e) {
+				/* no fragment is providing this class, which is the typical case */
+			}
 		}
-	}
 
 	if (MozillaPath == null) {
-		try {
+			try {
 			String libName = MozillaDelegate.GetSWTInitLibraryName ();
-			Library.loadLibrary (libName);
-			initLoaded = true;
-		} catch (UnsatisfiedLinkError e) {
-			/* 
-			* If this library failed to load then do not attempt to detect a
-			* xulrunner to use.  The Browser may still be usable if MOZILLA_FIVE_HOME
-			* points at a GRE. 
-			*/
-		}
-	} else {
-		/* ensure that client-supplied path is using correct separators */
-		if (SEPARATOR_OS == '/') {
+				Library.loadLibrary (libName);
+				initLoaded = true;
+			} catch (UnsatisfiedLinkError e) {
+				/* 
+				* If this library failed to load then do not attempt to detect a
+				* xulrunner to use.  The Browser may still be usable if MOZILLA_FIVE_HOME
+				* points at a GRE. 
+				*/
+			}
+		} else {
+			/* ensure that client-supplied path is using correct separators */
+			if (SEPARATOR_OS == '/') {
 			MozillaPath = MozillaPath.replace ('\\', SEPARATOR_OS);
-		} else {
+			} else {
 			MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
-		}
+			}
 
 		MozillaPath += SEPARATOR_OS + MozillaDelegate.getLibraryName ();
 		IsXULRunner = true;
-	}
+		}
 
-	if (initLoaded) {
-		/* attempt to discover a XULRunner to use as the GRE */
+		if (initLoaded) {
+			/* attempt to discover a XULRunner to use as the GRE */
 		MozillaPath = InitDiscoverXULRunner ();
 		IsXULRunner = MozillaPath.length () > 0;
 
-		/*
-		 * Test whether the detected XULRunner can be used as the GRE before loading swt's
-		 * XULRunner library.  If it cannot be used then fall back to attempting to use
-		 * the GRE pointed to by MOZILLA_FIVE_HOME.
-		 * 
-		 * One case where this will fail is attempting to use a 64-bit xulrunner while swt
-		 * is running in 32-bit mode, or vice versa.
-		 */
+				/*
+				 * Test whether the detected XULRunner can be used as the GRE before loading swt's
+				 * XULRunner library.  If it cannot be used then fall back to attempting to use
+				 * the GRE pointed to by MOZILLA_FIVE_HOME.
+				 * 
+				 * One case where this will fail is attempting to use a 64-bit xulrunner while swt
+				 * is running in 32-bit mode, or vice versa.
+				 */
 		if (IsXULRunner) {
 			byte[] bytes = MozillaDelegate.wcsToMbcs (null, MozillaPath, true);
 			int rc = XPCOMInit.XPCOMGlueStartup (bytes);
-			if (rc != XPCOM.NS_OK) {
+					if (rc != XPCOM.NS_OK) {
 				MozillaPath = MozillaPath.substring (0, MozillaPath.lastIndexOf (SEPARATOR_OS));
 				if (Device.DEBUG) System.out.println ("cannot use detected XULRunner: " + MozillaPath); //$NON-NLS-1$
 
-				/* attempt to XPCOMGlueStartup the GRE pointed at by MOZILLA_FIVE_HOME */
-				long /*int*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
-				if (ptr == 0) {
+						/* attempt to XPCOMGlueStartup the GRE pointed at by MOZILLA_FIVE_HOME */
+						long /*int*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
+						if (ptr == 0) {
 					IsXULRunner = false;
-				} else {
-					int length = C.strlen (ptr);
+						} else {
+						int length = C.strlen (ptr);
 					bytes = new byte[length];
 					C.memmove (bytes, ptr, length);
 					MozillaPath = new String (MozillaDelegate.mbcsToWcs (null, bytes));
-					/*
-					 * Attempting to XPCOMGlueStartup a mozilla-based GRE != xulrunner can
-					 * crash, so don't attempt unless the GRE appears to be xulrunner.
-					 */
+							/*
+							 * Attempting to XPCOMGlueStartup a mozilla-based GRE != xulrunner can
+							 * crash, so don't attempt unless the GRE appears to be xulrunner.
+							 */
 					if (MozillaPath.indexOf ("xulrunner") == -1) { //$NON-NLS-1$
 						IsXULRunner = false;	
-					} else {
+							} else {
 						MozillaPath += SEPARATOR_OS + MozillaDelegate.getLibraryName ();
 						bytes = MozillaDelegate.wcsToMbcs (null, MozillaPath, true);
 						rc = XPCOMInit.XPCOMGlueStartup (bytes);
-						if (rc == XPCOM.NS_OK) {
-							/* ensure that client-supplied path is using correct separators */
-							if (SEPARATOR_OS == '/') {
+							if (rc == XPCOM.NS_OK) {
+								/* ensure that client-supplied path is using correct separators */
+								if (SEPARATOR_OS == '/') {
 								MozillaPath = MozillaPath.replace ('\\', SEPARATOR_OS);
+								} else {
+								MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
+								}
 							} else {
-								MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
-							}
-						} else {
 							IsXULRunner = false;
 							MozillaPath = MozillaPath.substring (0, MozillaPath.lastIndexOf (SEPARATOR_OS));
 							if (Device.DEBUG) System.out.println ("failed to start as XULRunner: " + MozillaPath); //$NON-NLS-1$
-						}
+								}
+							}
+						} 
 					}
-				} 
-			}
 			if (IsXULRunner) {
-				XPCOMInitWasGlued = true;
+						XPCOMInitWasGlued = true;
+					}
+				}
 			}
-		}
-	}
 }
 
 public void create (Composite parent, int style) {
@@ -674,7 +674,7 @@
 			/*
 			* If style SWT.MOZILLA was specified then this initialization has already
 			* failed, because SWT.MOZILLA-style Browsers must utilize XULRunner.
-			*/
+			 */ 
 			if ((style & SWT.MOZILLA) != 0) {
 				browser.dispose ();
 				String errorString = (MozillaPath != null && MozillaPath.length () > 0) ?
@@ -698,7 +698,7 @@
 
 			/* load swt's mozilla/xulrunner library and invoke appropriate Init function */
 			initXPCOM (MozillaPath, IsXULRunner);
-		}
+				}
 
 		/* attempt to initialize JavaXPCOM in the detected XULRunner */
 		if (IsXULRunner) initJavaXPCOM (MozillaPath);
@@ -708,21 +708,21 @@
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+				}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+			}
 		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
 		result[0] = 0;
 
 		rc = XPCOM.NS_GetServiceManager (result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
-			error (rc);
-		}
+			if (rc != XPCOM.NS_OK) {
+				browser.dispose ();
+				error (rc);
+			}
 		if (result[0] == 0) {
-			browser.dispose ();
+				browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
@@ -743,7 +743,7 @@
 
 		/* init our WindowCreator, which mozilla uses for the creation of child browsers in external Shells */
 		if (!factoriesRegistered) {
-			initWindowCreator (serviceManager);
+		initWindowCreator (serviceManager);
 		}
 
 		/* notify mozilla that the profile directory has been changed from its default value */
@@ -752,7 +752,7 @@
 		/* init preference values that give desired mozilla behaviours */ 
 		initPreferences (serviceManager, componentManager);
 
-		/* init our various factories that mozilla can invoke as needed */
+		/* init our various factories that mozilla can invoke as needed */ 
 		if (!factoriesRegistered) {
 			initFactories (serviceManager, componentManager, IsXULRunner);
 		}
@@ -767,7 +767,7 @@
 		MozillaPendingCookies = null;
 
 		Initialized = true;
-	}
+			}
 
 	BrowserCount++;
 
@@ -774,32 +774,32 @@
 	if (display.getData (DISPOSE_LISTENER_HOOKED) == null) {
 		display.setData (DISPOSE_LISTENER_HOOKED, DISPOSE_LISTENER_HOOKED);
 		display.addListener (SWT.Dispose, DisplayListener);
-	}
+		}
 
 	/* get the nsIComponentManager, used throughout initialization */
-	int rc = XPCOM.NS_GetComponentManager (result);
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
-	if (result[0] == 0) {
-		browser.dispose ();
-		error (XPCOM.NS_NOINTERFACE);
-	}
-	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
-	result[0] = 0;
+		int rc = XPCOM.NS_GetComponentManager (result);
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
+		if (result[0] == 0) {
+			browser.dispose ();
+			error (XPCOM.NS_NOINTERFACE);
+		}
+		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
+		result[0] = 0;
 
 	/* create the nsIWebBrowser instance */
 	nsID NS_IWEBBROWSER_CID = new nsID ("F1EAC761-87E9-11d3-AF80-00A024FFC08C"); //$NON-NLS-1$
 	rc = componentManager.CreateInstance (NS_IWEBBROWSER_CID, 0, nsIWebBrowser.NS_IWEBBROWSER_IID, result);
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
-	if (result[0] == 0) {
-		browser.dispose ();
-		error (XPCOM.NS_NOINTERFACE);	
-	}
+				if (rc != XPCOM.NS_OK) {
+					browser.dispose ();
+					error (rc);
+				}
+				if (result[0] == 0) {
+					browser.dispose ();
+					error (XPCOM.NS_NOINTERFACE);
+				}
 	webBrowser = new nsIWebBrowser (result[0]);
 	result[0] = 0;
 
@@ -806,13 +806,13 @@
 	/* create the instance-based callback interfaces */
 	createCOMInterfaces ();
 	AddRef ();
-
+	
 	/* init the nsIWebBrowser's container and base windows */
 	initWebBrowserWindows ();
 
 	if (!PerformedVersionCheck) {
 		PerformedVersionCheck = true;
-
+		
 		rc = componentManager.QueryInterface (nsIComponentRegistrar.NS_ICOMPONENTREGISTRAR_IID, result);
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
@@ -823,7 +823,7 @@
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		nsIComponentRegistrar componentRegistrar = new nsIComponentRegistrar (result[0]);
-		result[0] = 0;
+		result[0] = 0;		
 
 		/*
 		 * Check for the property indicating that factories have already been registered,
@@ -836,17 +836,17 @@
 		}
 
 		if (!factoriesRegistered) {
-			HelperAppLauncherDialogFactory dialogFactory = new HelperAppLauncherDialogFactory ();
-			dialogFactory.AddRef ();
-			byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_HELPERAPPLAUNCHERDIALOG_CONTRACTID, true);
-			byte[] aClassName = MozillaDelegate.wcsToMbcs (null, "swtHelperAppLauncherDialog", true); //$NON-NLS-1$
-			rc = componentRegistrar.RegisterFactory (XPCOM.NS_HELPERAPPLAUNCHERDIALOG_CID, aClassName, aContractID, dialogFactory.getAddress ());
-			if (rc != XPCOM.NS_OK) {
-				browser.dispose ();
-				error (rc);
-			}
-			dialogFactory.Release ();
+		HelperAppLauncherDialogFactory dialogFactory = new HelperAppLauncherDialogFactory ();
+		dialogFactory.AddRef ();
+		byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_HELPERAPPLAUNCHERDIALOG_CONTRACTID, true);
+		byte[] aClassName = MozillaDelegate.wcsToMbcs (null, "swtHelperAppLauncherDialog", true); //$NON-NLS-1$
+		rc = componentRegistrar.RegisterFactory (XPCOM.NS_HELPERAPPLAUNCHERDIALOG_CID, aClassName, aContractID, dialogFactory.getAddress ());
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
 		}
+		dialogFactory.Release ();
+		}
 
 		/*
 		* Check for the availability of the pre-1.8 implementation of nsIDocShell
@@ -853,14 +853,14 @@
 		* to determine if the GRE's version is < 1.8.
 		*/
 		rc = webBrowser.QueryInterface (nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
+			if (rc != XPCOM.NS_OK) {
+				browser.dispose ();
 			error (XPCOM.NS_ERROR_FAILURE);
-		}
-		if (result[0] == 0) {
-			browser.dispose ();
+			}
+			if (result[0] == 0) {
+				browser.dispose ();
 			error (XPCOM.NS_ERROR_NO_INTERFACE);
-		}
+			}
 		nsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor (result[0]);
 		result[0] = 0;
 
@@ -869,7 +869,7 @@
 			IsPre_1_8 = true;
 			new nsISupports (result[0]).Release ();
 		}
-		result[0] = 0;
+			result[0] = 0;
 		IsPre_1_9 = true;
 
 		/*
@@ -888,30 +888,30 @@
 				result[0] = 0;
 
 				if (!factoriesRegistered) {
-					DownloadFactory_1_8 downloadFactory_1_8 = new DownloadFactory_1_8 ();
-					downloadFactory_1_8.AddRef ();
+				DownloadFactory_1_8 downloadFactory_1_8 = new DownloadFactory_1_8 ();
+				downloadFactory_1_8.AddRef ();
 					byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_TRANSFER_CONTRACTID, true);
 					byte[] aClassName = MozillaDelegate.wcsToMbcs (null, "swtTransfer", true); //$NON-NLS-1$
-					rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory_1_8.getAddress ());
-					if (rc != XPCOM.NS_OK) {
-						browser.dispose ();
-						error (rc);
-					}
-					downloadFactory_1_8.Release ();
+				rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory_1_8.getAddress ());
+	            	if (rc != XPCOM.NS_OK) {
+	            		browser.dispose ();
+	            		error (rc);
+	            	}
+				downloadFactory_1_8.Release ();
 				}
 			} else { /* >= 1.9 */
 				IsPre_1_9 = false;
 			}
-		}
+				}
 		result[0] = 0;
 		interfaceRequestor.Release ();
 		componentRegistrar.Release ();
 
 		System.setProperty (FACTORIES_REGISTERED, TRUE);
-	}
+	        }
 	componentManager.Release ();
 
-	/*
+		/*
 	 * Bug in XULRunner 1.9.  On win32, Mozilla does not clear its background before content has
 	 * been set into it.  As a result, embedders appear broken if they do not immediately display
 	 * a URL or text.  The Mozilla bug for this is https://bugzilla.mozilla.org/show_bug.cgi?id=453523.
@@ -918,7 +918,7 @@
 	 * 
 	 * The workaround is to subclass the Mozilla window and clear it whenever WM_ERASEBKGND is received.
 	 * This subclass should be removed once content has been set into the browser.
-	 */
+		 */
 	if (!IsPre_1_9) {
 		delegate.addWindowSubclass ();
 	}
@@ -925,15 +925,15 @@
 
 	/* add listeners for progress and content */
 	rc = webBrowser.AddWebBrowserListener (weakReference.getAddress (), nsIWebProgressListener.NS_IWEBPROGRESSLISTENER_IID);
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
 	rc = webBrowser.SetParentURIContentListener (uriContentListener.getAddress ());
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
 
 	delegate.init ();
 
@@ -945,13 +945,13 @@
 					if (ignoreDispose) {
 						ignoreDispose = false;
 						break;
-					}
+			}
 					ignoreDispose = true;
 					browser.notifyListeners (event.type, event);
 					event.type = SWT.NONE;
 					onDispose (event.display);
 					break;
-				}
+			}
 				case SWT.Resize: onResize (); break;
 				case SWT.FocusIn: Activate (); break;
 				case SWT.Activate: Activate (); break;
@@ -959,25 +959,25 @@
 					Display display = event.display;
 					if (Mozilla.this.browser == display.getFocusControl ()) Deactivate ();
 					break;
-				}
+			}
 				case SWT.Show: {
-					/*
+		/*
 					* Feature in GTK Mozilla.  Mozilla does not show up when
 					* its container (a GTK fixed handle) is made visible
 					* after having been hidden.  The workaround is to reset
 					* its size after the container has been made visible. 
-					*/
+		 */
 					Display display = event.display;
 					display.asyncExec(new Runnable () {
 						public void run() {
 							if (browser.isDisposed ()) return;
 							onResize ();
-						}
+			}
 					});
 					break;
 				}
 			}
-		}
+				}
 	};	
 	int[] folderEvents = new int[] {
 		SWT.Dispose,
@@ -990,7 +990,7 @@
 	};
 	for (int i = 0; i < folderEvents.length; i++) {
 		browser.addListener (folderEvents[i], listener);
-	}
+		}
 }
 
 public boolean back () {
@@ -1000,7 +1000,7 @@
 	int rc = webBrowser.QueryInterface (nsIWebNavigation.NS_IWEBNAVIGATION_IID, result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
-	
+
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);		 	
 	rc = webNavigation.GoBack ();	
 	webNavigation.Release ();
@@ -1016,7 +1016,7 @@
 				/* implies that the user did not veto the page unload */
 				result[0] = true;
 			}
-		} 
+		}
 	};
 	execute ("window.location.replace('about:blank');"); //$NON-NLS-1$
 	locationListeners = oldListeners;
@@ -1030,7 +1030,7 @@
 		public long /*int*/ method1 (long /*int*/[] args) {return AddRef ();}
 		public long /*int*/ method2 (long /*int*/[] args) {return Release ();}
 	};
-	
+
 	weakReference = new XPCOMObject (new int[] {2, 0, 0, 2}) {
 		public long /*int*/ method0 (long /*int*/[] args) {return QueryInterface (args[0], args[1]);}
 		public long /*int*/ method1 (long /*int*/[] args) {return AddRef ();}
@@ -1048,7 +1048,7 @@
 		public long /*int*/ method6 (long /*int*/[] args) {return OnStatusChange (args[0], args[1], (int)/*64*/args[2], args[3]);}
 		public long /*int*/ method7 (long /*int*/[] args) {return OnSecurityChange (args[0], args[1], (int)/*64*/args[2]);}
 	};
-	
+
 	webBrowserChrome = new XPCOMObject (new int[] {2, 0, 0, 2, 1, 1, 1, 1, 0, 2, 0, 1, 1}) {
 		public long /*int*/ method0 (long /*int*/[] args) {return QueryInterface (args[0], args[1]);}
 		public long /*int*/ method1 (long /*int*/[] args) {return AddRef ();}
@@ -1202,15 +1202,15 @@
 	if (badCertListener != null) {
 		badCertListener.dispose ();
 		badCertListener = null;
-	}
+		}
 }
 
 public boolean execute (String script) {
-	/*
+		/*
 	* This could be the first content that is set into the browser, so
 	* ensure that the custom subclass that works around Mozilla bug
 	* https://bugzilla.mozilla.org/show_bug.cgi?id=453523 is removed.
-	*/
+		*/
 	delegate.removeWindowSubclass ();
 
 	/*
@@ -1251,8 +1251,8 @@
 				principal = new nsIPrincipal (result[0]);
 				result[0] = 0;
 				securityManager.Release ();
-			}
 		}
+		}
 
 		if (principal != null) {
 			rc = webBrowser.QueryInterface (nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);
@@ -1267,12 +1267,12 @@
 				result[0] = 0;
 				nsID scriptGlobalObjectNSID_1_9_2 = new nsID ("e9f3f2c1-2d94-4722-bbd4-2bf6fdf42f48"); /* nsIScriptGlobalObject */ //$NON-NLS-1$
 				rc = interfaceRequestor.GetInterface (scriptGlobalObjectNSID_1_9_2, result);
-			}
+		}
 			interfaceRequestor.Release ();
-
+		
 			if (rc == XPCOM.NS_OK && result[0] != 0) {
 				long /*int*/ scriptGlobalObject = result[0];
-				result[0] = 0;
+		result[0] = 0;
 				rc = (int/*64*/)XPCOM.nsIScriptGlobalObject_EnsureScriptEnvironment (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
 				if (rc != XPCOM.NS_OK) error (rc);
 				long /*int*/ scriptContext = XPCOM.nsIScriptGlobalObject_GetScriptContext (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
@@ -1287,7 +1287,7 @@
 						result[0] = 0;
 						nsID scriptContextNSID_1_9_2 = new nsID ("87482b5e-e019-4df5-9bc2-b2a51b1f2d28"); /* nsIScriptContext */ //$NON-NLS-1$					
 						rc = new nsISupports (scriptContext).QueryInterface (scriptContextNSID_1_9_2, result);
-					}
+		}
 
 					if (rc == XPCOM.NS_OK && result[0] != 0) {
 						new nsISupports (result[0]).Release ();
@@ -1306,25 +1306,25 @@
 								principal.Release ();
 								if (pathBytes_JSEvaluateUCScriptForPrincipals == null) {
 									String mozillaPath = getMozillaPath () + delegate.getJSLibraryName () + '\0';
-									try {
+								try {
 										pathBytes_JSEvaluateUCScriptForPrincipals = mozillaPath.getBytes ("UTF-8"); //$NON-NLS-1$
-									} catch (UnsupportedEncodingException e) {
+								} catch (UnsupportedEncodingException e) {
 										pathBytes_JSEvaluateUCScriptForPrincipals = mozillaPath.getBytes ();
 									}
-								}
+		}
 
 								aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_CONTEXTSTACK_CONTRACTID, true);
 								rc = serviceManager.GetServiceByContractID (aContractID, nsIJSContextStack.NS_IJSCONTEXTSTACK_IID, result);
-								if (rc != XPCOM.NS_OK) error (rc);
-								if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-								serviceManager.Release ();
+		if (rc != XPCOM.NS_OK) error (rc);
+		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+		serviceManager.Release ();
 
 								nsIJSContextStack stack = new nsIJSContextStack (result[0]);
-								result[0] = 0;
+		result[0] = 0;
 								rc = stack.Push (nativeContext);
 								if (rc != XPCOM.NS_OK) error (rc);
 								boolean success = XPCOM.JS_EvaluateUCScriptForPrincipals (pathBytes_JSEvaluateUCScriptForPrincipals, nativeContext, globalJSObject, principals, scriptChars, length, urlbytes, 0, result) != 0;
-								result[0] = 0;
+		result[0] = 0;
 								rc = stack.Pop (result);
 								if (rc != XPCOM.NS_OK) error (rc);
 								stack.Release ();
@@ -1338,7 +1338,7 @@
 			principal.Release ();
 		}
 		serviceManager.Release ();
-	}
+		}
 
 	/* fall back to the pre-1.9 approach */
 
@@ -1361,13 +1361,13 @@
 }
 
 static Browser findBrowser (nsIDOMWindow aDOMWindow) {
-	long /*int*/[] result = new long /*int*/[1];
-	int rc = XPCOM.NS_GetServiceManager (result);
+				long /*int*/[] result = new long /*int*/[1];
+				int rc = XPCOM.NS_GetServiceManager (result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 
-	nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
-	result[0] = 0;
+				nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
+				result[0] = 0;		
 	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_WINDOWWATCHER_CONTRACTID, true);
 	rc = serviceManager.GetServiceByContractID (aContractID, nsIWindowWatcher.NS_IWINDOWWATCHER_IID, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error(rc);
@@ -1381,7 +1381,7 @@
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 	long /*int*/ topDOMWindow = result[0];
-	result[0] = 0;
+				result[0] = 0;
 	rc = windowWatcher.GetChromeForWindow (topDOMWindow, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	new nsISupports (topDOMWindow).Release ();
@@ -1391,14 +1391,14 @@
 	nsIWebBrowserChrome webBrowserChrome = new nsIWebBrowserChrome (result[0]);
 	result[0] = 0;
 	rc = webBrowserChrome.QueryInterface (nsIEmbeddingSiteWindow.NS_IEMBEDDINGSITEWINDOW_IID, result);
-	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 	webBrowserChrome.Release ();
 
 	nsIEmbeddingSiteWindow embeddingSiteWindow = new nsIEmbeddingSiteWindow (result[0]);
-	result[0] = 0;
+					result[0] = 0;
 	rc = embeddingSiteWindow.GetSiteWindow (result);
-	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 	embeddingSiteWindow.Release ();
 
@@ -1410,9 +1410,9 @@
 
 	long /*int*/[] result = new long /*int*/[1];
 	int rc = webBrowser.QueryInterface (nsIWebNavigation.NS_IWEBNAVIGATION_IID, result);
-	if (rc != XPCOM.NS_OK) error (rc);
+					if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
-	
+
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 	rc = webNavigation.GoForward ();
 	webNavigation.Release ();
@@ -1487,13 +1487,13 @@
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 	window.Release ();
-
+	
 	long /*int*/ document = result[0];
 	result[0] = 0;
 	rc = XPCOM.NS_GetComponentManager (result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+	
 	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
 	result[0] = 0;
 	byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_DOMSERIALIZER_CONTRACTID, true);
@@ -1508,7 +1508,7 @@
 		long /*int*/ string = XPCOM.nsEmbedString_new ();
 		rc = serializer.SerializeToString (document, string);
 		serializer.Release ();
-
+			
 		int length = XPCOM.nsEmbedString_Length (string);
 		long /*int*/ buffer = XPCOM.nsEmbedString_get (string);
 		chars = new char[length];
@@ -1518,9 +1518,9 @@
 		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIDOMSerializer.NS_IDOMSERIALIZER_IID, result);
 		if (rc != XPCOM.NS_OK) error (rc);
 		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+	
 		nsIDOMSerializer serializer = new nsIDOMSerializer (result[0]);
-		result[0] = 0;
+	result[0] = 0;
 		rc = serializer.SerializeToString (document, result);
 		serializer.Release ();
 
@@ -1558,14 +1558,14 @@
 		XPCOM.memmove (dest, buffer, length);
 		XPCOM.nsEmbedCString_delete (aSpec);
 		uri.Release ();
-	}
+		}
 	if (dest == null) return ""; //$NON-NLS-1$
 
 	String location = new String (dest);
-	/*
+		/*
 	 * If the URI indicates that the page is being rendered from memory
 	 * (via setText()) then set it to about:blank to be consistent with IE.
-	 */
+		*/
 	if (location.equals (URI_FILEROOT)) {
 		location = ABOUT_BLANK;
 	} else {
@@ -1572,8 +1572,8 @@
 		int length = URI_FILEROOT.length ();
 		if (location.startsWith (URI_FILEROOT) && location.charAt (length) == '#') {
 			location = ABOUT_BLANK + location.substring (length);
-		}
-	}
+				}
+			}
 	return location;
 }
 
@@ -1587,10 +1587,10 @@
 		Object mozilla = method.invoke (null, new Object[0]);
 		method = clazz.getMethod ("wrapXPCOMObject", new Class[] {Long.TYPE, String.class}); //$NON-NLS-1$
 		webBrowserObject = method.invoke (mozilla, new Object[] {new Long (webBrowser.getAddress ()), nsIWebBrowser.NS_IWEBBROWSER_IID_STR});
-		/*
+	/*
 		 * The following AddRef() is needed to offset the automatic Release() that
 		 * will be performed by JavaXPCOM when webBrowserObject is finalized.
-		 */
+	 */
 		webBrowser.AddRef ();
 		return webBrowserObject;
 	} catch (ClassNotFoundException e) {
@@ -1646,14 +1646,14 @@
 		rc = XPCOMInit.GRE_GetGREPathWithProperties (range, 1, property, 0, greBuffer, length); /* note: propertiesLength is 0 */
 		if (rc != XPCOM.NS_OK) {
 			/* Fall back to attempt #3 */
-			C.free (lower);
-			bytes = MozillaDelegate.wcsToMbcs (null, GRERANGE_LOWER_FALLBACK, true);
-			lower = C.malloc (bytes.length);
-			C.memmove (lower, bytes, bytes.length);
-			range.lower = lower;
+		C.free (lower);
+		bytes = MozillaDelegate.wcsToMbcs (null, GRERANGE_LOWER_FALLBACK, true);
+		lower = C.malloc (bytes.length);
+		C.memmove (lower, bytes, bytes.length);
+		range.lower = lower;
 			rc = XPCOMInit.GRE_GetGREPathWithProperties (range, 1, property, 0, greBuffer, length); /* note: propertiesLength is 0 */
 		}
-	}
+						}
 	C.free (value);
 	C.free (name);
 	C.free (lower);
@@ -1668,7 +1668,7 @@
 		result = new String (MozillaDelegate.mbcsToWcs (null, bytes));
 	} else {
 		result = ""; //$NON-NLS-1$
-	}
+				}
 	C.free (greBuffer);
 	return result;
 }
@@ -1679,7 +1679,7 @@
 	if (is != null) {
 		if (!componentsDir.exists ()) {
 			componentsDir.mkdirs ();
-		}
+			}
 		int read;
 		byte [] buffer = new byte [4096];
 		File file = new File (componentsDir, "external.xpt"); //$NON-NLS-1$
@@ -1687,13 +1687,13 @@
 			FileOutputStream os = new FileOutputStream (file);
 			while ((read = is.read (buffer)) != -1) {
 				os.write(buffer, 0, read);
-			}
+		}
 			os.close ();
 			is.close ();
 		} catch (FileNotFoundException e) {
 		} catch (IOException e) {
-		}
-	}
+			}
+		} 
 }
 
 void initFactories (nsIServiceManager serviceManager, nsIComponentManager componentManager, boolean isXULRunner) {
@@ -1723,7 +1723,7 @@
 		error (rc);
 	}
 	factory.Release ();
-
+	
 	ExternalFactory externalFactory = new ExternalFactory ();
 	externalFactory.AddRef ();
 	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.EXTERNAL_CONTRACTID, true); 
@@ -1734,11 +1734,11 @@
 		error (rc);
 	}
 	externalFactory.Release ();
-
+	
 	rc = serviceManager.GetService (XPCOM.NS_CATEGORYMANAGER_CID, nsICategoryManager.NS_ICATEGORYMANAGER_IID, result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+		
 	nsICategoryManager categoryManager = new nsICategoryManager (result[0]);
 	result[0] = 0;
 	byte[] category = MozillaDelegate.wcsToMbcs (null, "JavaScript global property", true); //$NON-NLS-1$
@@ -1746,7 +1746,7 @@
 	rc = categoryManager.AddCategoryEntry(category, entry, aContractID, 1, 1, result);
 	result[0] = 0;
 	categoryManager.Release ();
-
+	
 	/*
 	* This Download factory will be used if the GRE version is < 1.8.
 	* If the GRE version is 1.8.x then the Download factory that is registered later for
@@ -1764,7 +1764,7 @@
 		error (rc);
 	}
 	downloadFactory.Release ();
-
+		
 	FilePickerFactory pickerFactory = isXULRunner ? new FilePickerFactory_1_8 () : new FilePickerFactory ();
 	pickerFactory.AddRef ();
 	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_FILEPICKER_CONTRACTID, true);
@@ -1775,10 +1775,10 @@
 		error (rc);
 	}
 	pickerFactory.Release ();
-
+	
 	componentRegistrar.Release ();
 }
-
+	
 void initJavaXPCOM (String mozillaPath) {
 	try {
 		Class clazz = Class.forName ("org.mozilla.xpcom.Mozilla"); //$NON-NLS-1$
@@ -1805,7 +1805,7 @@
 	} catch (InstantiationException e) {
 	}
 }
-
+	
 String initMozilla (String mozillaPath) {
 	/* attempt to use the GRE pointed at by MOZILLA_FIVE_HOME */
 	long /*int*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
@@ -1874,7 +1874,7 @@
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_ERROR_NULL_POINTER);
-	}
+	}	
 
 	nsILocalFile localFile = new nsILocalFile (result[0]);
 	result[0] = 0;
@@ -1900,11 +1900,11 @@
 		if (functionPtr == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_ERROR_NULL_POINTER);
-		}
+	}
 		rc = XPCOM.Call (functionPtr, localFile.getAddress (), localFile.getAddress (), LocationProvider.getAddress (), 0, 0);
 		if (rc == XPCOM.NS_OK) {
 			System.setProperty (XULRUNNER_PATH, mozillaPath);
-		}
+	}
 	} else {
 		rc = XPCOM.NS_InitXPCOM2 (0, localFile.getAddress(), LocationProvider.getAddress ());
 	}
@@ -1933,7 +1933,7 @@
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_NOINTERFACE);
-	}
+	}		
 
 	nsIPrefService prefService = new nsIPrefService (result[0]);
 	result[0] = 0;
@@ -1943,7 +1943,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+	}	
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_NOINTERFACE);
@@ -1969,7 +1969,7 @@
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+	}
 		localizedString = new nsIPrefLocalizedString (result[0]);
 		result[0] = 0;
 		rc = localizedString.ToString (result);
@@ -1976,11 +1976,11 @@
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+	}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+	}
 		int length = XPCOM.strlen_PRUnichar (result[0]);
 		char[] dest = new char[length];
 		XPCOM.memmove (dest, result[0], length * 2);
@@ -1991,7 +1991,7 @@
 	/*
 	 * construct the new locale preference value by prepending the
 	 * user's current locale and language to the original value 
-	 */
+	*/
 	Locale locale = Locale.getDefault ();
 	String language = locale.getLanguage ();
 	String country = locale.getCountry ();
@@ -2054,26 +2054,26 @@
 	String prefCharset = null;
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_CHARSET, true);
 	rc = prefBranch.GetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
-	/* 
+	/*
 	 * Feature of Debian.  For some reason attempting to query for the current charset
 	 * preference fails on Debian.  The workaround for this is to assume a value of
 	 * "ISO-8859-1" since this is typically the default value when mozilla is used
 	 * without a profile.
-	 */
+	*/
 	if (rc != XPCOM.NS_OK) {
 		prefCharset = "ISO-8859-1";	//$NON-NLS-1$
-	} else {
+		} else {
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		localizedString = new nsIPrefLocalizedString (result[0]);
-		result[0] = 0;
+				result[0] = 0;
 		rc = localizedString.ToString (result);
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+			}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
@@ -2082,8 +2082,8 @@
 		char[] dest = new char[length];
 		XPCOM.memmove (dest, result[0], length * 2);
 		prefCharset = new String (dest);
-	}
-	result[0] = 0;
+			}
+				result[0] = 0;
 
 	String newCharset = System.getProperty ("file.encoding");	// $NON-NLS-1$
 	if (!newCharset.equals (prefCharset)) {
@@ -2103,8 +2103,8 @@
 				error (XPCOM.NS_NOINTERFACE);
 			}
 			localizedString = new nsIPrefLocalizedString (result[0]);
-			result[0] = 0;
-		}
+						result[0] = 0;
+					}
 		localizedString.SetDataWithLength (length, charBuffer);
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
 	}
@@ -2119,22 +2119,22 @@
 
 	int port = -1;
 	if (proxyPortString != null) {
-		try {
+								try {
 			int value = Integer.valueOf (proxyPortString).intValue ();
 			if (0 <= value && value <= MAX_PORT) port = value;
 		} catch (NumberFormatException e) {
 			/* do nothing, java property has non-integer value */
 		}
-	}
+								}
 
 	if (proxyHost != null) {
 		byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_PREFLOCALIZEDSTRING_CONTRACTID, true);
 		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
-		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+								if (rc != XPCOM.NS_OK) error (rc);
+								if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 
 		localizedString = new nsIPrefLocalizedString (result[0]);
-		result[0] = 0;
+								result[0] = 0;
 		
 		int length = proxyHost.length ();
 		char[] charBuffer = new char[length];
@@ -2180,7 +2180,7 @@
 		}
 		result[0] = 0;
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
-		if (rc != XPCOM.NS_OK) error (rc);
+								if (rc != XPCOM.NS_OK) error (rc);
 
 		buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_PROXYHOST_SSL, true);
 		rc = prefBranch.GetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
@@ -2200,7 +2200,7 @@
 		}
 		result[0] = 0;
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
-		if (rc != XPCOM.NS_OK) error (rc);
+								if (rc != XPCOM.NS_OK) error (rc);
 
 		localizedString.Release ();
 	}
@@ -2230,7 +2230,7 @@
 		intResult[0] = 0;
 		rc = prefBranch.SetIntPref (buffer, port);
 		if (rc != XPCOM.NS_OK) error (rc);
-	}
+							}
 
 	if (proxyHost != null || port != -1) {
 		buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_PROXYTYPE, true);
@@ -2240,7 +2240,7 @@
 		intResult[0] = 0;
 		rc = prefBranch.SetIntPref (buffer, 1);
 		if (rc != XPCOM.NS_OK) error (rc);
-	}
+						}
 
 	/*
 	* Ensure that windows that are shown during page loads are not blocked.  Firefox may
@@ -2254,7 +2254,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+					}
 
 	/* Ensure that the status text can be set through means like javascript */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_DISABLEWINDOWSTATUSCHANGE, true);
@@ -2262,7 +2262,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+				}
 
 	/* Ensure that the status line can be hidden when opening a window from javascript */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_DISABLEOPENWINDOWSTATUSHIDE, true);
@@ -2270,7 +2270,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+			}
 
 	/* Ensure that javascript execution is enabled since this is the Browser's default behaviour */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_JAVASCRIPTENABLED, true);
@@ -2331,7 +2331,7 @@
 		XPCOM.XPCOMGlueLoadXULFunctions (ptr);
 		C.memmove (result, functionLoad.function, C.PTR_SIZEOF);
 		long /*int*/ functionPtr = result[0];
-		result[0] = 0;
+	result[0] = 0;
 		C.free (functionLoad.function);
 		C.free (functionLoad.functionName);
 		C.free (ptr);
@@ -2348,8 +2348,8 @@
 
 void initSpinup (nsIComponentManager componentManager) {
 	if (delegate.needsSpinup ()) {
-		long /*int*/[] result = new long /*int*/[1];
-
+	long /*int*/[] result = new long /*int*/[1];
+	
 		/* nsIAppShell is discontinued as of xulrunner 1.9, so do not fail if it is not found */
 		int rc = componentManager.CreateInstance (XPCOM.NS_APPSHELL_CID, 0, nsIAppShell.NS_IAPPSHELL_IID, result);
 		if (rc != XPCOM.NS_ERROR_NO_INTERFACE) {
@@ -2395,7 +2395,7 @@
 		browser.dispose ();
 		error (XPCOM.NS_ERROR_NO_INTERFACE);
 	}
-	
+
 	nsIBaseWindow baseWindow = new nsIBaseWindow (result[0]);
 	result[0] = 0;
 	Rectangle rect = browser.getClientArea ();
@@ -2427,7 +2427,7 @@
 void initWindowCreator (nsIServiceManager serviceManager) {
 	WindowCreator = new WindowCreator2 ();
 	WindowCreator.AddRef ();
-	
+
 	long /*int*/[] result = new long /*int*/[1];
 	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_WINDOWWATCHER_CONTRACTID, true);
 	int rc = serviceManager.GetServiceByContractID (aContractID, nsIWindowWatcher.NS_IWINDOWWATCHER_IID, result);
@@ -2441,7 +2441,7 @@
 	}
 
 	nsIWindowWatcher windowWatcher = new nsIWindowWatcher (result[0]);
-	result[0] = 0;
+		result[0] = 0;
 	rc = windowWatcher.SetWindowCreator (WindowCreator.getAddress());
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
@@ -2462,13 +2462,13 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+		}
 	XPCOMWasGlued = true;
 
-	/*
+		/*
 	 * Remove the trailing xpcom lib name from mozillaPath because the
 	 * Mozilla.initialize and NS_InitXPCOM2 invocations require a directory name only.
-	 */ 
+		 */
 	return mozillaPath.substring (0, mozillaPath.lastIndexOf (SEPARATOR_OS));
 }
 
@@ -2623,7 +2623,7 @@
 
 	/*
 	* The following error conditions do not indicate unrecoverable problems:
-	* 
+	*
 	* - NS_ERROR_INVALID_POINTER: happens when Reload is called immediately
 	* after calling LoadURI.
 	* - NS_ERROR_FILE_NOT_FOUND: happens when attempting to reload a file that
@@ -2709,8 +2709,8 @@
 		if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
 		nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 		result[0] = 0;
-		char[] uri = new char[ABOUT_BLANK.length () + 1];
-		ABOUT_BLANK.getChars (0, ABOUT_BLANK.length (), uri, 0);
+	    char[] uri = new char[ABOUT_BLANK.length () + 1];
+	    ABOUT_BLANK.getChars (0, ABOUT_BLANK.length (), uri, 0);
 		rc = webNavigation.LoadURI (uri, nsIWebNavigation.LOAD_FLAGS_NONE, 0, 0, 0);
 		if (rc != XPCOM.NS_OK) error (rc);
 		webNavigation.Release ();
@@ -2797,39 +2797,39 @@
 
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 	result[0] = 0;
-	char[] uri = new char[url.length () + 1];
-	url.getChars (0, url.length (), uri, 0);
+    char[] uri = new char[url.length () + 1];
+    url.getChars (0, url.length (), uri, 0);
 
-	nsIMIMEInputStream postDataStream = null;
-	InputStream dataStream = null;
+    nsIMIMEInputStream postDataStream = null;
+    InputStream dataStream = null;
 	if (postData != null) {
-		rc = XPCOM.NS_GetComponentManager (result);
-		if (rc != XPCOM.NS_OK) error (rc);
-		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
-		result[0] = 0;
-		byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MIMEINPUTSTREAM_CONTRACTID, true);
-		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIMIMEInputStream.NS_IMIMEINPUTSTREAM_IID, result);
-		componentManager.Release();
+    	rc = XPCOM.NS_GetComponentManager (result);
+    	if (rc != XPCOM.NS_OK) error (rc);
+    	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+    	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
+    	result[0] = 0;
+    	byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MIMEINPUTSTREAM_CONTRACTID, true);
+    	rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIMIMEInputStream.NS_IMIMEINPUTSTREAM_IID, result);
+    	componentManager.Release();
 
-		if (rc == XPCOM.NS_OK && result[0] != 0) { /* nsIMIMEInputStream is not in mozilla 1.4 */
-			byte[] bytes = MozillaDelegate.wcsToMbcs (null, postData, false);
-			dataStream = new InputStream (bytes);
-			dataStream.AddRef ();
-			postDataStream = new nsIMIMEInputStream (result[0]);
-			rc = postDataStream.SetData (dataStream.getAddress ());
-			if (rc != XPCOM.NS_OK) error (rc);
-			rc = postDataStream.SetAddContentLength (1);
-			if (rc != XPCOM.NS_OK) error (rc);
-			byte[] name = MozillaDelegate.wcsToMbcs (null, HEADER_CONTENTTYPE, true);
-			byte[] value = MozillaDelegate.wcsToMbcs (null, MIMETYPE_FORMURLENCODED, true);
-			rc = postDataStream.AddHeader (name, value);
-			if (rc != XPCOM.NS_OK) error (rc);
-		}
-		result[0] = 0;
+    	if (rc == XPCOM.NS_OK && result[0] != 0) { /* nsIMIMEInputStream is not in mozilla 1.4 */
+    		byte[] bytes = MozillaDelegate.wcsToMbcs (null, postData, false);
+    		dataStream = new InputStream (bytes);
+    		dataStream.AddRef ();
+    		postDataStream = new nsIMIMEInputStream (result[0]);
+    		rc = postDataStream.SetData (dataStream.getAddress ());
+    		if (rc != XPCOM.NS_OK) error (rc);
+    		rc = postDataStream.SetAddContentLength (1);
+    		if (rc != XPCOM.NS_OK) error (rc);
+    		byte[] name = MozillaDelegate.wcsToMbcs (null, HEADER_CONTENTTYPE, true);
+    		byte[] value = MozillaDelegate.wcsToMbcs (null, MIMETYPE_FORMURLENCODED, true);
+    		rc = postDataStream.AddHeader (name, value);
+    		if (rc != XPCOM.NS_OK) error (rc);
+    	}
+    	result[0] = 0;
 	}
 
-	InputStream headersStream = null;
+    InputStream headersStream = null;
     if (headers != null) {
 		StringBuffer buffer = new StringBuffer ();
 		for (int i = 0; i < headers.length; i++) {
@@ -2848,9 +2848,9 @@
 				}
 			}
 		}
-		byte[] bytes = MozillaDelegate.wcsToMbcs (null, buffer.toString (), true);
-		headersStream = new InputStream (bytes);
-		headersStream.AddRef ();
+    	byte[] bytes = MozillaDelegate.wcsToMbcs (null, buffer.toString (), true);
+    	headersStream = new InputStream (bytes);
+    	headersStream.AddRef ();
     }
 
 	rc = webNavigation.LoadURI (
@@ -3136,10 +3136,10 @@
 		while (elements.hasMoreElements ()) {
 			BrowserFunction function = (BrowserFunction)elements.nextElement ();
 			if (!function.isEvaluate) {
-				execute (function.functionString);
-			}
+			execute (function.functionString);
 		}
 	}
+	}
 
 	/*
 	* Feature of Mozilla.  When a redirect occurs to a site with an invalid
@@ -3332,9 +3332,9 @@
 				while (elements.hasMoreElements ()) {
 					BrowserFunction function = (BrowserFunction)elements.nextElement ();
 					if (!function.isEvaluate) {
-						execute (function.functionString);
-					}
+					execute (function.functionString);
 				}
+				}
 				/* 
 				* For Mozilla >= 1.9.2, when content is being set via nsIWebBrowserStream,
 				* registered functions must be re-installed in the subsequent Start Request
@@ -3435,27 +3435,27 @@
 
 			int rc = request.QueryInterface (nsIChannel.NS_ICHANNEL_IID, result);
 			if (rc == XPCOM.NS_OK && result[0] != 0) {
-				nsIChannel channel = new nsIChannel (result[0]);
-				result[0] = 0;
-				rc = channel.GetURI (result);
-				if (rc != XPCOM.NS_OK) error (rc);
-				if (result[0] == 0) error (XPCOM.NS_ERROR_NULL_POINTER);
-				channel.Release ();
+			nsIChannel channel = new nsIChannel (result[0]);
+			result[0] = 0;
+			rc = channel.GetURI (result);
+			if (rc != XPCOM.NS_OK) error (rc);
+			if (result[0] == 0) error (XPCOM.NS_ERROR_NULL_POINTER);
+			channel.Release ();
 
-				nsIURI uri = new nsIURI (result[0]);
-				result[0] = 0;
-				long /*int*/ aSpec = XPCOM.nsEmbedCString_new ();
-				rc = uri.GetSpec (aSpec);
-				if (rc != XPCOM.NS_OK) error (rc);
-				int length = XPCOM.nsEmbedCString_Length (aSpec);
-				long /*int*/ buffer = XPCOM.nsEmbedCString_get (aSpec);
-				byte[] bytes = new byte[length];
-				XPCOM.memmove (bytes, buffer, length);
-				lastNavigateURL = new String (bytes);
-				XPCOM.nsEmbedCString_delete (aSpec);
-				uri.Release ();
-			}
+			nsIURI uri = new nsIURI (result[0]);
+			result[0] = 0;
+			long /*int*/ aSpec = XPCOM.nsEmbedCString_new ();
+			rc = uri.GetSpec (aSpec);
+			if (rc != XPCOM.NS_OK) error (rc);
+			int length = XPCOM.nsEmbedCString_Length (aSpec);
+			long /*int*/ buffer = XPCOM.nsEmbedCString_get (aSpec);
+			byte[] bytes = new byte[length];
+			XPCOM.memmove (bytes, buffer, length);
+			lastNavigateURL = new String (bytes);
+			XPCOM.nsEmbedCString_delete (aSpec);
+			uri.Release ();
 		}
+		}
 
 		/*
 		* Hook DOM listeners to the page's nsIDOMWindow here because this is
@@ -3665,7 +3665,7 @@
 	browser.dispose ();
 	return XPCOM.NS_OK;
 }
-
+   	
 int SizeBrowserTo (int aCX, int aCY) {
 	size = new Point (aCX, aCY);
 	boolean isChrome = (chromeFlags & nsIWebBrowserChrome.CHROME_OPENAS_CHROME) != 0;
@@ -3717,7 +3717,7 @@
 	return XPCOM.NS_OK;
 }
 
-/* nsIEmbeddingSiteWindow */
+/* nsIEmbeddingSiteWindow */ 
 
 int SetDimensions (int flags, int x, int y, int cx, int cy) {
 	boolean isChrome = (chromeFlags & nsIWebBrowserChrome.CHROME_OPENAS_CHROME) != 0;
@@ -3724,20 +3724,20 @@
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_POSITION) != 0) {
 		location = new Point (x, y);
 		if (isChrome) {
-			browser.getShell ().setLocation (x, y);
-		}
+		browser.getShell ().setLocation (x, y);
 	}
+	}
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_SIZE_INNER) != 0) {
 		size = new Point (cx, cy);
 		if (isChrome) {
-			browser.setSize (cx, cy);
-		}
+		browser.setSize (cx, cy);
 	}
+	}
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_SIZE_OUTER) != 0) {
 		if (isChrome) {
-			browser.getShell ().setSize (cx, cy);
-		}
+		browser.getShell ().setSize (cx, cy);
 	}
+	}
 	return XPCOM.NS_OK;
 }
 
@@ -4320,7 +4320,7 @@
 		if (delegate.sendTraverse ()) {
 			doit = sendKeyEvent (keyEvent);
 		} else {
-			browser.notifyListeners (keyEvent.type, keyEvent);
+		browser.notifyListeners (keyEvent.type, keyEvent);
 			doit = keyEvent.doit; 
 		}
 		if (!doit || browser.isDisposed ()) {
Index: org/eclipse/swt/browser/External.java
===================================================================
--- org/eclipse/swt/browser/External.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/External.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -533,8 +533,8 @@
 			C.free (arrayPtr);
 			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 		}
-		return variant;
-	}
+			return variant;
+		}
 
 	variant.Release ();
 	SWT.error (SWT.ERROR_INVALID_RETURN_VALUE);
@@ -548,10 +548,10 @@
 
 	if (function != null) {
 		try {
-			short[] type = new short[1]; /* PRUint16 */
+		short[] type = new short[1]; /* PRUint16 */
 			nsIVariant variant = new nsIVariant (tokenVariant);
-			int rc = variant.GetDataType (type);
-			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+		int rc = variant.GetDataType (type);
+		if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 			Object temp = convertToJava (variant, type[0]);
 			type[0] = 0;
 			if (temp instanceof Number) {
@@ -561,17 +561,17 @@
 					rc = variant.GetDataType (type);
 					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 					temp = convertToJava (variant, type[0]);
-					if (temp instanceof Object[]) {
-						Object[] arguments = (Object[])temp;
-						try {
-							returnValue = function.function (arguments);
-						} catch (Exception e) {
-							/* exception during function invocation */
-							returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
-						}
-					}
+			if (temp instanceof Object[]) {
+				Object[] arguments = (Object[])temp;
+				try {
+					returnValue = function.function (arguments);
+				} catch (Exception e) {
+					/* exception during function invocation */
+					returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 				}
 			}
+				}
+			}
 		} catch (IllegalArgumentException e) {
 			/* invalid argument value type */
 			if (function.isEvaluate) {
Index: org/eclipse/swt/browser/Browser.java
===================================================================
--- org/eclipse/swt/browser/Browser.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/Browser.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -94,13 +94,13 @@
 
 	style = getStyle ();
 	webBrowser = new BrowserFactory ().createWebBrowser (style);
-	if (webBrowser != null) {
-		webBrowser.setBrowser (this);
+			if (webBrowser != null) {
+				webBrowser.setBrowser (this);
 		webBrowser.create (parent, style);
 		return;
 	}
-	dispose ();
-	SWT.error (SWT.ERROR_NO_HANDLES);
+		dispose ();
+		SWT.error (SWT.ERROR_NO_HANDLES);
 }
 
 static Composite checkParent (Composite parent) {
@@ -204,7 +204,7 @@
 	WebBrowser.clearSessions ();
 }
 
-/**
+/**	 
  * Returns the value of a cookie that is associated with a URL.
  * Note that cookies are shared amongst all Browser instances.
  * 
Index: org/eclipse/swt/browser/PromptService2.java
===================================================================
--- org/eclipse/swt/browser/PromptService2.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/PromptService2.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -20,7 +20,7 @@
 	XPCOMObject promptService;
 	XPCOMObject promptService2;
 	int refCount = 0;
-	
+
 	static final String[] certErrorCodes = new String[] {
 		"ssl_error_bad_cert_domain",
 		"sec_error_ca_cert_invalid",
@@ -180,7 +180,7 @@
 	* detected then instead of showing it, re-navigate to the page with the invalid
 	* certificate so that the browser's nsIBadCertListener2 will be invoked.
 	*/
-	if (browser != null) {
+			if (browser != null) {
 		for (int i = 0; i < certErrorCodes.length; i++) {
 			if (textLabel.indexOf (certErrorCodes[i]) != -1) {
 				Mozilla mozilla = (Mozilla)browser.webBrowser;
@@ -188,8 +188,8 @@
 				browser.setUrl (mozilla.lastNavigateURL);
 				return XPCOM.NS_OK;
 			}
-		}
 	}
+	}
 
 	Shell shell = browser == null ? new Shell () : browser.getShell (); 
 	MessageBox messageBox = new MessageBox (shell, SWT.OK | SWT.ICON_WARNING);
@@ -232,7 +232,7 @@
 
 int Confirm (long /*int*/ aParent, long /*int*/ aDialogTitle, long /*int*/ aText, long /*int*/ _retval) {
 	Browser browser = getBrowser (aParent);
-
+	
 	if (browser != null && ((Mozilla)browser.webBrowser).ignoreAllMessages) {
 		XPCOM.memmove (_retval, new int[] {1}, 4); /* PRBool */
 		return XPCOM.NS_OK;
@@ -353,22 +353,22 @@
 		* value that we override must be freed using the nsIMemory service.
 		*/
 		if (valueLabel[0] != null) {
-			long /*int*/[] result2 = new long /*int*/[1];
-			int rc = XPCOM.NS_GetServiceManager (result2);
-			if (rc != XPCOM.NS_OK) SWT.error (rc);
-			if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
+		long /*int*/[] result2 = new long /*int*/[1];
+				int rc = XPCOM.NS_GetServiceManager (result2);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
+			
+				nsIServiceManager serviceManager = new nsIServiceManager (result2[0]);
+				result2[0] = 0;
+				byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
+				rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result2);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
+				serviceManager.Release ();
+				
+				nsIMemory memory = new nsIMemory (result2[0]);
+				result2[0] = 0;
 
-			nsIServiceManager serviceManager = new nsIServiceManager (result2[0]);
-			result2[0] = 0;
-			byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
-			rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result2);
-			if (rc != XPCOM.NS_OK) SWT.error (rc);
-			if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
-			serviceManager.Release ();
-
-			nsIMemory memory = new nsIMemory (result2[0]);
-			result2[0] = 0;
-
 			int cnt = valueLabel[0].length ();
 			char[] buffer = new char[cnt + 1];
 			valueLabel[0].getChars (0, cnt, buffer, 0);
@@ -380,9 +380,9 @@
 			if (valueAddr[0] != 0) {
 				memory.Free (valueAddr[0]);
 			}
-			memory.Release ();
+				memory.Release ();
+			}
 		}
-	}
 	if (aCheckState != 0) XPCOM.memmove (aCheckState, check, 4);
 	return XPCOM.NS_OK;
 }
@@ -554,59 +554,59 @@
 	if (user == null) {
 		/* no listener handled the challenge, so show an authentication dialog */
 
-		String titleLabel, textLabel, checkLabel = null;
-		String[] userLabel = new String[1], passLabel = new String[1];
-		char[] dest;
-		int length;
-		if (aDialogTitle != 0) {
-			length = XPCOM.strlen_PRUnichar (aDialogTitle);
-			dest = new char[length];
-			XPCOM.memmove (dest, aDialogTitle, length * 2);
-			titleLabel = new String (dest);
-		} else {
-			titleLabel = SWT.getMessage ("SWT_Authentication_Required");	//$NON-NLS-1$
-		}
-		
-		length = XPCOM.strlen_PRUnichar (aText);
+	String titleLabel, textLabel, checkLabel = null;
+	String[] userLabel = new String[1], passLabel = new String[1];
+	char[] dest;
+	int length;
+	if (aDialogTitle != 0) {
+		length = XPCOM.strlen_PRUnichar (aDialogTitle);
 		dest = new char[length];
-		XPCOM.memmove (dest, aText, length * 2);
-		textLabel = new String (dest);
-
-		long /*int*/[] userAddr = new long /*int*/[1];
-		XPCOM.memmove (userAddr, aUsername, C.PTR_SIZEOF);
-		if (userAddr[0] != 0) {
-			length = XPCOM.strlen_PRUnichar (userAddr[0]);
+		XPCOM.memmove (dest, aDialogTitle, length * 2);
+		titleLabel = new String (dest);
+	} else {
+		titleLabel = SWT.getMessage ("SWT_Authentication_Required");	//$NON-NLS-1$
+	}
+	
+	length = XPCOM.strlen_PRUnichar (aText);
+	dest = new char[length];
+	XPCOM.memmove (dest, aText, length * 2);
+	textLabel = new String (dest);
+	
+	long /*int*/[] userAddr = new long /*int*/[1];
+	XPCOM.memmove (userAddr, aUsername, C.PTR_SIZEOF);
+	if (userAddr[0] != 0) {
+		length = XPCOM.strlen_PRUnichar (userAddr[0]);
+		dest = new char[length];
+		XPCOM.memmove (dest, userAddr[0], length * 2);
+		userLabel[0] = new String (dest);		
+	}
+	
+	long /*int*/[] passAddr = new long /*int*/[1];
+	XPCOM.memmove (passAddr, aPassword, C.PTR_SIZEOF);
+	if (passAddr[0] != 0) {
+		length = XPCOM.strlen_PRUnichar (passAddr[0]);
+		dest = new char[length];
+		XPCOM.memmove (dest, passAddr[0], length * 2);
+		passLabel[0] = new String (dest);		
+	}
+	
+	if (aCheckMsg != 0) {
+		length = XPCOM.strlen_PRUnichar (aCheckMsg);
+		if (length > 0) {
 			dest = new char[length];
-			XPCOM.memmove (dest, userAddr[0], length * 2);
-			userLabel[0] = new String (dest);		
+			XPCOM.memmove (dest, aCheckMsg, length * 2);
+			checkLabel = new String (dest);
 		}
+	}
 
-		long /*int*/[] passAddr = new long /*int*/[1];
-		XPCOM.memmove (passAddr, aPassword, C.PTR_SIZEOF);
-		if (passAddr[0] != 0) {
-			length = XPCOM.strlen_PRUnichar (passAddr[0]);
-			dest = new char[length];
-			XPCOM.memmove (dest, passAddr[0], length * 2);
-			passLabel[0] = new String (dest);		
-		}
-		
-		if (aCheckMsg != 0) {
-			length = XPCOM.strlen_PRUnichar (aCheckMsg);
-			if (length > 0) {
-				dest = new char[length];
-				XPCOM.memmove (dest, aCheckMsg, length * 2);
-				checkLabel = new String (dest);
-			}
-		}
-	
-		Shell shell = browser == null ? new Shell () : browser.getShell ();
-		PromptDialog dialog = new PromptDialog (shell);
-		int[] check = new int[1], result = new int[1];
-		if (aCheckState != 0) XPCOM.memmove (check, aCheckState, 4);	/* PRBool */
-		dialog.promptUsernameAndPassword (titleLabel, textLabel, checkLabel, userLabel, passLabel, check, result);
-	
-		XPCOM.memmove (_retval, result, 4);	/* PRBool */
-		if (result[0] == 1) {
+	Shell shell = browser == null ? new Shell () : browser.getShell ();
+	PromptDialog dialog = new PromptDialog (shell);
+	int[] check = new int[1], result = new int[1];
+	if (aCheckState != 0) XPCOM.memmove (check, aCheckState, 4);	/* PRBool */
+	dialog.promptUsernameAndPassword (titleLabel, textLabel, checkLabel, userLabel, passLabel, check, result);
+
+	XPCOM.memmove (_retval, result, 4);	/* PRBool */
+	if (result[0] == 1) {
 			/* User selected OK */
 			user = userLabel[0];
 			password = passLabel[0];
@@ -626,22 +626,22 @@
 
 		long /*int*/[] result = new long /*int*/[1];
 		int rc = XPCOM.NS_GetServiceManager (result);
-		if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
 		if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
-
+			
 		nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
 		result[0] = 0;
-		byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
+				byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
 		rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result);
-		if (rc != XPCOM.NS_OK) SWT.error (rc);
-		if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
-		serviceManager.Release ();
-
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
+				serviceManager.Release ();
+				
 		nsIMemory memory = new nsIMemory (result[0]);
 		result[0] = 0;
 		if (userAddr[0] != 0) memory.Free (userAddr[0]);
 		if (passAddr[0] != 0) memory.Free (passAddr[0]);
-		memory.Release ();
+				memory.Release ();
 
 		/* write the name and password values */
 
@@ -654,14 +654,14 @@
 		XPCOM.memmove (aUsername, new long /*int*/[] {ptr}, C.PTR_SIZEOF);
 
 		cnt = password.length ();
-		buffer = new char[cnt + 1];
+			buffer = new char[cnt + 1];
 		password.getChars (0, cnt, buffer, 0);
-		size = buffer.length * 2;
-		ptr = C.malloc (size);
-		XPCOM.memmove (ptr, buffer, size);
-		XPCOM.memmove (aPassword, new long /*int*/[] {ptr}, C.PTR_SIZEOF);
+			size = buffer.length * 2;
+			ptr = C.malloc (size);
+			XPCOM.memmove (ptr, buffer, size);
+			XPCOM.memmove (aPassword, new long /*int*/[] {ptr}, C.PTR_SIZEOF);
 	}
-
+			
 	return XPCOM.NS_OK;
 }
 
Index: org/eclipse/swt/browser/AppFileLocProvider.java
===================================================================
--- org/eclipse/swt/browser/AppFileLocProvider.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/AppFileLocProvider.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -23,7 +23,7 @@
 	String mozillaPath, profilePath;
 	String[] pluginDirs;
 	boolean isXULRunner;
-
+	
 	static final String SEPARATOR_OS = System.getProperty ("file.separator"); //$NON-NLS-1$
 	static final String CHROME_DIR = "chrome"; //$NON-NLS-1$
 	static final String COMPONENTS_DIR = "components"; //$NON-NLS-1$
@@ -33,7 +33,7 @@
 	static final String PLUGINS_DIR = "plugins"; //$NON-NLS-1$
 	static final String USER_PLUGINS_DIR = ".mozilla" + SEPARATOR_OS + "plugins"; //$NON-NLS-1$ //$NON-NLS-2$
 	static final String PREFERENCES_FILE = "prefs.js"; //$NON-NLS-1$
-
+	
 	static boolean IsSparc;
 	static {
 		String osName = System.getProperty ("os.name").toLowerCase (); //$NON-NLS-1$
@@ -195,7 +195,7 @@
 			* to not add the directory containing this plug-in to the plug-in search path. 
 			*/
 			if (!IsSparc) {
-				pluginDirs[index++] = mozillaPath + PLUGINS_DIR;
+			pluginDirs[index++] = mozillaPath + PLUGINS_DIR;
 			}
 
 			/* set the next value to the home directory + "/.mozilla/plugins" */
Index: org/eclipse/swt/browser/IE.java
===================================================================
--- org/eclipse/swt/browser/IE.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/browser/IE.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -269,7 +269,7 @@
 		browser.dispose();
 		SWT.error(SWT.ERROR_NO_HANDLES);
 	}
-
+	
 	if (!Initialized) {
 		Initialized = true;
 		int version = 0;
@@ -402,8 +402,8 @@
 					if (e.detail == SWT.TRAVERSE_TAB_PREVIOUS && e.widget instanceof WebSite) {
 						/* otherwise will traverse to the Browser control */
 						browser.traverse(SWT.TRAVERSE_TAB_PREVIOUS, e);
-						e.doit = false;
-					}
+							e.doit = false;
+						}
 					if (e.detail == SWT.TRAVERSE_TAB_NEXT && e.widget instanceof Browser) {
 						/* otherwise will traverse to the WebSite control */
 						site.traverse(SWT.TRAVERSE_TAB_NEXT, e);
@@ -447,7 +447,7 @@
 						String url = varResult.getString();
 
 						if (uncRedirect != null) {
-							/*
+						/*
 							* Silently allow the navigate to proceed if the url is the first segment of a
 							* UNC path being navigated to (initiated by the NavigateError listener to show
 							* a name/password prompter), or if the url is the full UNC path (initiated by
@@ -530,8 +530,8 @@
 							if (pendingText != null) {
 								setText((String)pendingText[0], ((Boolean)pendingText[1]).booleanValue());
 							} else if (pendingUrl != null) {
-								setUrl((String)pendingUrl[0], (String)pendingUrl[1], (String[])pendingUrl[2]);
-							}
+									setUrl((String)pendingUrl[0], (String)pendingUrl[1], (String[])pendingUrl[2]);
+								}
 							pendingText = pendingUrl = null;
 							break;
 						}
@@ -538,7 +538,7 @@
 
 						Variant varResult = event.arguments[0];
 						IDispatch dispatch = varResult.getDispatch();
-
+	
 						varResult = event.arguments[1];
 						String url = varResult.getString();
 						/*
@@ -554,13 +554,13 @@
 							if (delaySetText) {
 								delaySetText = false;
 								browser.getDisplay().asyncExec(new Runnable() {
-									public void run() {
-										if (browser.isDisposed() || html == null) return;
+								public void run() {
+									if (browser.isDisposed() || html == null) return;
 										setHTML(html);
-										html = null;
-									}
+									html = null;
+												}
 								});
-							} else {
+										} else {
 								setHTML(html);
 								html = null;
 							}
@@ -597,12 +597,12 @@
 								IE ie = (IE)browser.webBrowser;
 								if (ie.installFunctionsOnDocumentComplete) {
 									ie.installFunctionsOnDocumentComplete = false;
-									Enumeration elements = functions.elements ();
-									while (elements.hasMoreElements ()) {
-										BrowserFunction function = (BrowserFunction)elements.nextElement ();
-										execute (function.functionString);
-									}
+								Enumeration elements = functions.elements ();
+								while (elements.hasMoreElements ()) {
+									BrowserFunction function = (BrowserFunction)elements.nextElement ();
+									execute (function.functionString);
 								}
+								}
 
 								ProgressEvent progressEvent = new ProgressEvent(browser);
 								progressEvent.display = browser.getDisplay();
@@ -659,7 +659,7 @@
 						Variant varResult = event.arguments[1];
 						String url = varResult.getString();
 						if (!performingInitialNavigate) {
-							isAboutBlank = url.startsWith(ABOUT_BLANK);
+						isAboutBlank = url.startsWith(ABOUT_BLANK);
 						}
 
 						/*
@@ -678,17 +678,17 @@
 						}
 						if (path != null) {
 							int extensionIndex = path.lastIndexOf('.');
-							if (extensionIndex != -1) {
+						if (extensionIndex != -1) {
 								String extension = path.substring(extensionIndex);
-								if (extension.equalsIgnoreCase(EXTENSION_PDF)) {
+							if (extension.equalsIgnoreCase(EXTENSION_PDF)) {
 									isPDF = true;
-									PDFCount++;
-									if (PDFCount > MAX_PDF) {
-										COM.FreeUnusedLibraries = false;
-									}
+								PDFCount++;
+								if (PDFCount > MAX_PDF) {
+									COM.FreeUnusedLibraries = false;
 								}
 							}
 						}
+						}
 
 						if (uncRedirect != null) {
 							if (uncRedirect.equals(url)) {
@@ -731,7 +731,7 @@
 							}
 						}
 						if (!isPDF) {
-							hookDOMListeners(webBrowser, isTop);
+						hookDOMListeners(webBrowser, isTop);
 						}
 						webBrowser.dispose();
 						break;
@@ -1025,11 +1025,11 @@
 	site.addEventListener(WindowSetLeft, oleListener);
 	site.addEventListener(WindowSetTop, oleListener);
 	site.addEventListener(WindowSetWidth, oleListener);
-
+	
 	Variant variant = new Variant(true);
 	auto.setProperty(RegisterAsBrowser, variant);
 	variant.dispose();
-
+	
 	variant = new Variant(false);
 	int[] rgdispid = auto.getIDsOfNames(new String[] {"RegisterAsDropTarget"}); //$NON-NLS-1$
 	if (rgdispid != null) auto.setProperty(rgdispid[0], variant);
@@ -1403,7 +1403,7 @@
 	this.html = html;
 	untrustedText = !trusted;
 	if (blankLoading) return true;
-
+	
 	/*
 	* Navigate to the blank page and insert the given html when
 	* receiving the next DocumentComplete notification.  See the
@@ -1421,14 +1421,14 @@
 	* that instance was created.
 	*/
 
-	/*
-	* Stopping the loading of a page causes DocumentComplete events from previous
-	* requests to be received before the DocumentComplete for this page.  In such
-	* cases we must be sure to not set the html into the browser too soon, since
-	* doing so could result in its page being cleared out by a subsequent
-	* DocumentComplete.  The Browser's ReadyState can be used to determine whether
-	* these extra events will be received or not.
-	*/
+		/*
+		* Stopping the loading of a page causes DocumentComplete events from previous
+		* requests to be received before the DocumentComplete for this page.  In such
+		* cases we must be sure to not set the html into the browser too soon, since
+		* doing so could result in its page being cleared out by a subsequent
+		* DocumentComplete.  The Browser's ReadyState can be used to determine whether
+		* these extra events will be received or not.
+		*/
 	if (_getUrl().length() != 0) {
 		int[] rgdispid = auto.getIDsOfNames(new String[] { "ReadyState" }); //$NON-NLS-1$
 		Variant pVarResult = auto.getProperty(rgdispid[0]);
@@ -1540,7 +1540,7 @@
 		rgdispid = event.getIDsOfNames (new String[] {PROPERTY_RETURNVALUE});
 		pVarResult = event.getProperty (rgdispid[0]);
 		boolean consume = pVarResult != null && pVarResult.getType () == OLE.VT_BOOL && !pVarResult.getBoolean ();
-		pVarResult.dispose ();
+				pVarResult.dispose ();
 
 		MSG msg = new MSG ();
 		int flags = OS.PM_NOYIELD | (consume ? OS.PM_REMOVE : OS.PM_NOREMOVE);
@@ -1660,7 +1660,7 @@
 		* KeyDown to be sent for this key.  However, keydown and keypress events are 
 		* both sometimes received for OS.VK_RETURN, depending on the page's focus
 		* control.  To handle this, do not send a KeyDown for CR or LF here since
-		* one is always sent for it from the keydown handler.
+		* one is always sent for it from the keydown handler. 
 		*/
 		if (lastCharCode == SWT.CR || lastCharCode == SWT.LF) {
 			event.dispose();
@@ -1806,7 +1806,7 @@
 	pVarResult = event.getProperty(dispIdMember);
 	int screenY = pVarResult.getInt();
 	pVarResult.dispose();
-	
+
 	Point position = new Point(screenX, screenY);
 	position = browser.getDisplay().map(null, browser, position);
 	newEvent.x = position.x; newEvent.y = position.y;
@@ -1901,7 +1901,7 @@
 void hookDOMListeners(OleAutomation webBrowser, final boolean isTop) {
 	int[] rgdispid = webBrowser.getIDsOfNames(new String[] { PROPERTY_DOCUMENT });
 	int dispIdMember = rgdispid[0];
-	Variant pVarResult = webBrowser.getProperty(dispIdMember);
+	Variant	pVarResult = webBrowser.getProperty(dispIdMember);
 	if (pVarResult == null) return;
 	if (pVarResult.getType() == COM.VT_EMPTY) {
 		pVarResult.dispose();
Index: org/eclipse/swt/accessibility/ACC.java
===================================================================
--- org/eclipse/swt/accessibility/ACC.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/ACC.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -20,12 +20,12 @@
  * @since 2.0
  */
 public class ACC {
-	public static final int STATE_NORMAL = 			0x00000000;
-	public static final int STATE_SELECTED = 		0x00000002;
-	public static final int STATE_SELECTABLE = 		0x00200000;
+	public static final int STATE_NORMAL = 0x00000000;
+	public static final int STATE_SELECTED = 0x00000002;
+	public static final int STATE_SELECTABLE = 0x00200000;
 	public static final int STATE_MULTISELECTABLE = 0x01000000;
-	public static final int STATE_FOCUSED = 		0x00000004;
-	public static final int STATE_FOCUSABLE = 		0x00100000;
+	public static final int STATE_FOCUSED = 0x00000004;
+	public static final int STATE_FOCUSABLE = 0x00100000;
 	public static final int STATE_PRESSED = 		0x00000008;
 	public static final int STATE_CHECKED = 		0x00000010;
 	public static final int STATE_EXPANDED = 		0x00000200;
@@ -133,7 +133,7 @@
 	public static final int CHILDID_SELF = -1;
 	public static final int CHILDID_NONE = -2;
 	public static final int CHILDID_MULTIPLE = -3;
-
+	
 	/**
 	 * An AT is requesting the accessible child object at the specified index.
 	 * 
@@ -406,7 +406,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_VALUE_CHANGED = 0x800E;
-
+	
 	/**
 	 * Send when the loading of a document has completed.
 	 * 
@@ -413,7 +413,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_LOAD_COMPLETE = 0x105;
-
+	
 	/**
 	 * Send when the loading of a document was interrupted.
 	 * 
@@ -420,14 +420,14 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_LOAD_STOPPED = 0x106;
-
+	
 	/**
 	 * Send when the document contents are being reloaded.
 	 * 
-	 * @since 3.6
+	 *  @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_RELOAD = 0x107;
-
+	
 	/**
 	 * Send when a slide changed in a presentation document
 	 * or a page boundary was crossed in a word processing document. 
@@ -435,7 +435,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_PAGE_CHANGED = 0x111;
-
+	
 	/**
 	 * Send when the caret moved from one section to the next.
 	 * 
@@ -442,7 +442,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_SECTION_CHANGED = 0x112;
-
+	
 	/**
 	 * Send when the count or attributes of an accessible object's actions have changed.
 	 * 
@@ -449,7 +449,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_ACTION_CHANGED = 0x100;
-
+	
 	/**
 	 * Send when the starting index of this link within the containing string has changed.
 	 * 
@@ -456,7 +456,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_START_INDEX_CHANGED = 0x10d;
-
+	
 	/**
 	 * Send when the ending index of this link within the containing string has changed.
 	 * 
@@ -463,7 +463,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_END_INDEX_CHANGED = 0x108;
-
+	
 	/**
 	 * Send when the number of anchors associated with this hyperlink object has changed.
 	 * 
@@ -470,7 +470,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_ANCHOR_COUNT_CHANGED = 0x109;
-
+	
 	/**
 	 * Send when the hyperlink selected state changed from selected to unselected
 	 * or from unselected to selected.
@@ -478,7 +478,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_SELECTED_LINK_CHANGED = 0x10a;
-
+	
 	/**
 	 * Send when the hyperlink has been activated.
 	 * 
@@ -485,7 +485,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_ACTIVATED = 0x10b;
-
+	
 	/**
 	 * Send when one of the links associated with the hypertext object has been selected.
 	 * <p>
@@ -496,7 +496,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERTEXT_LINK_SELECTED = 0x10c;
-
+	
 	/**
 	 * Send when the number of hyperlinks associated with a hypertext object has changed.
 	 * 
@@ -503,7 +503,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERTEXT_LINK_COUNT_CHANGED = 0x10f;
-
+	
 	/**
 	 * Send when an object's attributes have changed.
 	 * 
@@ -578,13 +578,13 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_TEXT_ATTRIBUTE_CHANGED = 0x20a;
-	 
+
 	/**
 	 * Send when the caret has moved to a new position.
 	 * 
 	 * @since 3.6
 	 */
-	public static final int EVENT_TEXT_CARET_MOVED = 0x11b;
+	public static final int EVENT_TEXT_CARET_MOVED = 0x11b; 
 
 	/**
 	 * Send when the caret has moved from one column to the next.
@@ -718,5 +718,5 @@
 	 * 
 	 * @since 3.6
 	 */
-	public static final int RELATION_SUBWINDOW_OF = 14;	
+	public static final int RELATION_SUBWINDOW_OF = 14;
 }
Index: org/eclipse/swt/accessibility/Relation.java
===================================================================
--- org/eclipse/swt/accessibility/Relation.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/Relation.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -80,7 +80,7 @@
 			public long /*int*/ method7(long /*int*/[] args) {return get_targets((int)/*64*/args[0], args[1], args[2]);}
 		};
 	}
-
+	
 	/* QueryInterface([in] iid, [out] ppvObject)
 	 * Ownership of ppvObject transfers from callee to caller so reference count on ppvObject 
 	 * must be incremented before returning.  Caller is responsible for releasing ppvObject.
Index: org/eclipse/swt/accessibility/Accessible.java
===================================================================
--- org/eclipse/swt/accessibility/Accessible.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/Accessible.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -84,7 +84,7 @@
 			UseIA2 = false;
 		}
 	}
-	
+
 	/**
 	 * Constructs a new instance of this class given its parent.
 	 * 
@@ -171,7 +171,7 @@
 			public long /*int*/ method26(long /*int*/[] args) {return put_accName(args[0], args[1]);}
 			public long /*int*/ method27(long /*int*/[] args) {return put_accValue(args[0], args[1]);}
 		};
-	
+
 		/* If the callback takes a struct parameter (for example, a VARIANT),
 		 * then create a custom callback that dereferences the struct and
 		 * passes a pointer to the original callback.
@@ -515,7 +515,7 @@
 		    public long /*int*/ method3(long /*int*/[] args) {return QueryService(args[0], args[1], args[2]);}
 		};
 	}
-
+	
 	/**
 	 * Invokes platform specific functionality to allocate a new accessible object.
 	 * <p>
@@ -857,7 +857,7 @@
 		if (objIAccessible == null) createIAccessible();
 		return objIAccessible.getAddress();
 	}
-
+	
 	/**
 	 * Returns the control for this Accessible object. 
 	 *
@@ -867,7 +867,7 @@
 	public Control getControl() {
 		return control;
 	}
-	
+
 	/**
 	 * Invokes platform specific functionality to dispose an accessible object.
 	 * <p>
@@ -1013,7 +1013,7 @@
 	 *    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>
 	 *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>
 	 * </ul>
-	 *
+	 * 
 	 * @see AccessibleActionListener
 	 * @see #addAccessibleActionListener
 	 * 
@@ -1059,7 +1059,7 @@
 	 *
 	 * @param listener the listener that should no longer be notified when the receiver
 	 * is asked for <code>AccessibleHyperlinkListener</code> interface properties
-	 *
+	 * 
 	 * @exception IllegalArgumentException <ul>
 	 *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
 	 * </ul>
@@ -1500,7 +1500,7 @@
 			if (DEBUG) print(this + ".QueryInterface guid=" + guidString(guid) + " returning " + objIEnumVARIANT.getAddress() + hresult(COM.S_OK));
 			return COM.S_OK;
 		}
-		
+
 		if (COM.IsEqualGUID(guid, COM.IIDIServiceProvider)) {
 			if (!UseIA2) return COM.E_NOINTERFACE;
 			if (accessibleActionListeners.size() > 0 || accessibleAttributeListeners.size() > 0 ||
@@ -1507,12 +1507,12 @@
 				accessibleHyperlinkListeners.size() > 0 || accessibleTableListeners.size() > 0 ||
 				accessibleTableCellListeners.size() > 0 || accessibleTextExtendedListeners.size() > 0 ||
 				accessibleValueListeners.size() > 0 || getRelationCount() > 0) {
-				if (objIServiceProvider == null) createIServiceProvider();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIServiceProvider.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
+			if (objIServiceProvider == null) createIServiceProvider();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIServiceProvider.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
 				if (DEBUG) print(this + ".QueryInterface guid=" + guidString(guid) + " returning " + objIServiceProvider.getAddress() + hresult(COM.S_OK));
-				return COM.S_OK;
-			}
+			return COM.S_OK;
+		}
 			if (DEBUG) if (interesting(guid)) print("QueryInterface guid=" + guidString(guid) + " returning" + hresult(COM.E_NOINTERFACE));
 			return COM.E_NOINTERFACE;
 		}
@@ -1525,9 +1525,9 @@
 
 		if (iaccessible != null) {
 			/* Forward any other GUIDs to the OS proxy. */
-			long /*int*/[] ppv = new long /*int*/[1];
+		long /*int*/[] ppv = new long /*int*/[1];
 			code = iaccessible.QueryInterface(guid, ppv);
-			COM.MoveMemory(ppvObject, ppv, OS.PTR_SIZEOF);
+		COM.MoveMemory(ppvObject, ppv, OS.PTR_SIZEOF);
 			if (DEBUG) if (interesting(guid)) print("QueryInterface guid=" + guidString(guid) + " returning super" + hresult(code));
 			return code;
 		}
@@ -1670,21 +1670,21 @@
 					accessibleHyperlinkListeners.size() > 0 || accessibleTableListeners.size() > 0 ||
 					accessibleTableCellListeners.size() > 0 || accessibleTextExtendedListeners.size() > 0 ||
 					accessibleValueListeners.size() > 0 || getRelationCount() > 0) {
-				if (objIAccessible2 == null) createIAccessible2();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessible2.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessible2 == null) createIAccessible2();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessible2.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleAction)) {
 			if (accessibleActionListeners.size() > 0) {
-				if (objIAccessibleAction == null) createIAccessibleAction();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleAction.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleAction == null) createIAccessibleAction();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleAction.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
@@ -1718,21 +1718,21 @@
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleHyperlink)) {
 			if (accessibleHyperlinkListeners.size() > 0) {
-				if (objIAccessibleHyperlink == null) createIAccessibleHyperlink();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleHyperlink.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleHyperlink == null) createIAccessibleHyperlink();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleHyperlink.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleHypertext)) {
 			if (accessibleTextExtendedListeners.size() > 0) {
-				if (objIAccessibleHypertext == null) createIAccessibleHypertext();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleHypertext.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleHypertext == null) createIAccessibleHypertext();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleHypertext.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
@@ -1754,41 +1754,41 @@
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleTable2)) {
 			if (accessibleTableListeners.size() > 0) {
-				if (objIAccessibleTable2 == null) createIAccessibleTable2();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleTable2.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleTable2 == null) createIAccessibleTable2();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleTable2.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleTableCell)) {
 			if (accessibleTableCellListeners.size() > 0) {
-				if (objIAccessibleTableCell == null) createIAccessibleTableCell();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleTableCell.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleTableCell == null) createIAccessibleTableCell();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleTableCell.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleText)) {
 			if (accessibleTextExtendedListeners.size() > 0 /* || accessibleAttributeListeners.size() > 0*/) {
-				if (objIAccessibleText == null) createIAccessibleText();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleText.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleText == null) createIAccessibleText();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleText.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleValue)) {
 			if (accessibleValueListeners.size() > 0) {
-				if (objIAccessibleValue == null) createIAccessibleValue();
-				COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleValue.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleValue == null) createIAccessibleValue();
+			COM.MoveMemory(ppvObject, new long /*int*/[] { objIAccessibleValue.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 
@@ -1904,7 +1904,7 @@
 		OS.MoveMemory(pcyHeight, new int[] { event.height }, 4);
 		return COM.S_OK;
 	}
-	
+
 	/* IAccessible::accNavigate([in] navDir, [in] varStart, [out] pvarEndUpAt) */
 	int accNavigate(int navDir, long /*int*/ varStart, long /*int*/ pvarEndUpAt) {
 		if (DEBUG) print(this + ".IAccessible::accNavigate");
@@ -1931,7 +1931,7 @@
 		if (DEBUG) print(this + ".IAccessible::accSelect(" + flagsSelect + ") returning" + hresult(code));
 		return code;
 	}
-
+	
 	/* IAccessible::get_accChild([in] varChild, [out] ppdispChild)
 	 * Ownership of ppdispChild transfers from callee to caller so reference count on ppdispChild 
 	 * must be incremented before returning.  The caller is responsible for releasing ppdispChild.
@@ -2025,13 +2025,13 @@
 	int get_accChildCount(long /*int*/ pcountChildren) {
 		int osChildCount = 0;
 		if (iaccessible != null) {
-			/* Get the default child count from the OS. */
-			int code = iaccessible.get_accChildCount(pcountChildren);
-			if (code == COM.S_OK) {
-				int[] pChildCount = new int[1];
-				COM.MoveMemory(pChildCount, pcountChildren, 4);
-				osChildCount = pChildCount[0];
-			}
+		/* Get the default child count from the OS. */
+		int code = iaccessible.get_accChildCount(pcountChildren);
+		if (code == COM.S_OK) {
+			int[] pChildCount = new int[1];
+			COM.MoveMemory(pChildCount, pcountChildren, 4);
+			osChildCount = pChildCount[0];
+		}
 			if (accessibleControlListeners.size() == 0) {
 				if (DEBUG) print(this + ".IAccessible::get_accChildCount() returning " + osChildCount + " from super" + hresult(code));
 				return code;
@@ -2058,21 +2058,21 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osDefaultAction = null;
 		if (iaccessible != null) {
-			/* Get the default defaultAction from the OS. */
+		/* Get the default defaultAction from the OS. */
 			code = iaccessible.get_accDefaultAction(varChild, pszDefaultAction);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			if (accessibleControlListeners.size() == 0) return code;
-			if (code == COM.S_OK) {
-				long /*int*/[] pDefaultAction = new long /*int*/[1];
-				COM.MoveMemory(pDefaultAction, pszDefaultAction, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pDefaultAction[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pDefaultAction[0], size);
-					osDefaultAction = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (accessibleControlListeners.size() == 0) return code;
+		if (code == COM.S_OK) {
+			long /*int*/[] pDefaultAction = new long /*int*/[1];
+			COM.MoveMemory(pDefaultAction, pszDefaultAction, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pDefaultAction[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pDefaultAction[0], size);
+				osDefaultAction = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2108,22 +2108,22 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osDescription = null;
 		if (iaccessible != null) {
-			/* Get the default description from the OS. */
+		/* Get the default description from the OS. */
 			code = iaccessible.get_accDescription(varChild, pszDescription);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			// TEMPORARY CODE - process tree even if there are no apps listening
-			if (accessibleListeners.size() == 0 && !(control instanceof Tree)) return code;
-			if (code == COM.S_OK) {
-				long /*int*/[] pDescription = new long /*int*/[1];
-				COM.MoveMemory(pDescription, pszDescription, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pDescription[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pDescription[0], size);
-					osDescription = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		// TEMPORARY CODE - process tree even if there are no apps listening
+		if (accessibleListeners.size() == 0 && !(control instanceof Tree)) return code;
+		if (code == COM.S_OK) {
+			long /*int*/[] pDescription = new long /*int*/[1];
+			COM.MoveMemory(pDescription, pszDescription, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pDescription[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pDescription[0], size);
+				osDescription = new String(buffer);
 			}
 		}
+		}
 		
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2173,10 +2173,10 @@
 	int get_accFocus(long /*int*/ pvarChild) {
 		int osChild = ACC.CHILDID_NONE;
 		if (iaccessible != null) {
-			/* Get the default focus child from the OS. */
-			int code = iaccessible.get_accFocus(pvarChild);
-			if (code == COM.S_OK) {
-				VARIANT v = getVARIANT(pvarChild);
+		/* Get the default focus child from the OS. */
+		int code = iaccessible.get_accFocus(pvarChild);
+		if (code == COM.S_OK) {
+			VARIANT v = getVARIANT(pvarChild);
 				if (v.vt == COM.VT_I4) osChild = v.lVal;
 				// TODO: need to check VT_DISPATCH (don't use struct)
 				if (DEBUG) if (v.vt == COM.VT_DISPATCH) print("IAccessible::get_accFocus() super returned VT_DISPATCH"); 
@@ -2184,8 +2184,8 @@
 			if (accessibleControlListeners.size() == 0) {
 				if (DEBUG) print(this + ".IAccessible::get_accFocus() returning childID=" + osChild + " from super" + hresult(code));
 				return code;
-			}
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osChild == ACC.CHILDID_NONE ? ACC.CHILDID_NONE : osToChildID(osChild);
@@ -2225,21 +2225,21 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osHelp = null;
 		if (iaccessible != null) {
-			/* Get the default help string from the OS. */
+		/* Get the default help string from the OS. */
 			code = iaccessible.get_accHelp(varChild, pszHelp);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			if (accessibleListeners.size() == 0) return code;
-			if (code == COM.S_OK) {
-				long /*int*/[] pHelp = new long /*int*/[1];
-				COM.MoveMemory(pHelp, pszHelp, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pHelp[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pHelp[0], size);
-					osHelp = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (accessibleListeners.size() == 0) return code;
+		if (code == COM.S_OK) {
+			long /*int*/[] pHelp = new long /*int*/[1];
+			COM.MoveMemory(pHelp, pszHelp, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pHelp[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pHelp[0], size);
+				osHelp = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2263,7 +2263,7 @@
 			/* Since it is possible that a native control might still handle get_accHelpTopic,
 			 * we will continue to send this through to the proxy. */
 			code = iaccessible.get_accHelpTopic(pszHelpFile, varChild, pidTopic);
-			if (code == COM.E_INVALIDARG) code = COM.DISP_E_MEMBERNOTFOUND; // proxy doesn't know about app childID
+		if (code == COM.E_INVALIDARG) code = COM.DISP_E_MEMBERNOTFOUND; // proxy doesn't know about app childID
 		}
 		return code;
 	}
@@ -2276,22 +2276,22 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osKeyboardShortcut = null;
 		if (iaccessible != null) {
-			/* Get the default keyboard shortcut from the OS. */
+		/* Get the default keyboard shortcut from the OS. */
 			code = iaccessible.get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
 			/* Process TabFolder even if there are no apps listening. */
 			if (accessibleListeners.size() == 0 && !(control instanceof TabFolder)) return code;
-			if (code == COM.S_OK) {
-				long /*int*/[] pKeyboardShortcut = new long /*int*/[1];
-				COM.MoveMemory(pKeyboardShortcut, pszKeyboardShortcut, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pKeyboardShortcut[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pKeyboardShortcut[0], size);
-					osKeyboardShortcut = new String(buffer);
-				}
+		if (code == COM.S_OK) {
+			long /*int*/[] pKeyboardShortcut = new long /*int*/[1];
+			COM.MoveMemory(pKeyboardShortcut, pszKeyboardShortcut, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pKeyboardShortcut[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pKeyboardShortcut[0], size);
+				osKeyboardShortcut = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2317,18 +2317,18 @@
 		int code = COM.S_FALSE;
 		String osName = null;
 		if (iaccessible != null) {
-			/* Get the default name from the OS. */
+		/* Get the default name from the OS. */
 			code = iaccessible.get_accName(varChild, pszName);
-			if (code == COM.S_OK) {
-				long /*int*/[] pName = new long /*int*/[1];
-				COM.MoveMemory(pName, pszName, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pName[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pName[0], size);
-					osName = new String(buffer);
-				}
+		if (code == COM.S_OK) {
+			long /*int*/[] pName = new long /*int*/[1];
+			COM.MoveMemory(pName, pszName, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pName[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pName[0], size);
+				osName = new String(buffer);
 			}
+		}
 			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
 			if (accessibleListeners.size() == 0) {
 				if (DEBUG) print(this + ".IAccessible::get_accName(" + v.lVal + ") returning name=" + osName + " from super" + hresult(code));
@@ -2376,13 +2376,13 @@
 		if (v.vt != COM.VT_I4) return COM.E_INVALIDARG;
 		int osRole = COM.ROLE_SYSTEM_CLIENT;
 		if (iaccessible != null) {
-			/* Get the default role from the OS. */
-			int code = iaccessible.get_accRole(varChild, pvarRole);
-			if (code == COM.S_OK) {
-				VARIANT v2 = getVARIANT(pvarRole);
-				if (v2.vt == COM.VT_I4) osRole = v2.lVal;
-			}
+		/* Get the default role from the OS. */
+		int code = iaccessible.get_accRole(varChild, pvarRole);
+		if (code == COM.S_OK) {
+			VARIANT v2 = getVARIANT(pvarRole);
+			if (v2.vt == COM.VT_I4) osRole = v2.lVal;
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2390,7 +2390,7 @@
 		// TEMPORARY CODE
 		/* Currently our checkbox table and tree are emulated using state mask images,
 		 * so we need to specify 'checkbox' role for the items. */
-		if (control instanceof Tree || control instanceof Table) {
+			if (control instanceof Tree || control instanceof Table) {
 			if (v.lVal != COM.CHILDID_SELF && (control.getStyle() & SWT.CHECK) != 0) event.detail = ACC.ROLE_CHECKBUTTON;
 		}
 		for (int i = 0; i < accessibleControlListeners.size(); i++) {
@@ -2519,7 +2519,7 @@
 		setIntVARIANT(pvarState, COM.VT_I4, state);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessible::get_accValue([in] varChild, [out] pszValue) */
 	int get_accValue(long /*int*/ varChild, long /*int*/ pszValue) {
 		VARIANT v = getVARIANT(varChild);
@@ -2680,7 +2680,7 @@
 		}
 		return COM.S_FALSE;
 	}
-
+	
 	/* IEnumVARIANT::Skip([in] celt) over the specified number of elements in the enumeration sequence. */
 	int Skip(int celt) {
 		if (DEBUG) print(this + ".IEnumVARIANT::Skip");
@@ -3136,8 +3136,8 @@
 		if (DEBUG) print(this + ".IAccessibleAction::get_localizedName(" + actionIndex + ") returning " + event.result + hresult(event.result == null || event.result.length() == 0 ? COM.S_FALSE : COM.S_OK));
 		if (event.result == null || event.result.length() == 0) {
 			setString(pbstrLocalizedName, null);
-			return COM.S_FALSE;
-		}
+		return COM.S_FALSE;
+	}
 		setString(pbstrLocalizedName, event.result);
 		return COM.S_OK;
 	}
@@ -3504,7 +3504,7 @@
 			setIntVARIANT(ppHyperlink, COM.VT_EMPTY, 0);
 			return COM.E_INVALIDARG;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppHyperlink, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3581,7 +3581,7 @@
 		Accessible accessible = event.accessible;
 		if (DEBUG) print(this + ".IAccessibleTable2::get_cellAt(row=" + row + ", column=" + column + ") returning " + accessible);
 		if (accessible == null) return COM.E_INVALIDARG;
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppCell, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3599,7 +3599,7 @@
 			COM.MoveMemory(ppAccessible, new long /*int*/[] { 0 }, OS.PTR_SIZEOF);
 			return COM.S_FALSE;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppAccessible, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3710,8 +3710,8 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
 			}
@@ -3864,8 +3864,8 @@
 		if (DEBUG) print(this + ".IAccessibleTable2::get_modelChange() returning " + (tableChange == null ? "null" : "tableChange=" + tableChange[0] + ", " + tableChange[1] + ", " + tableChange[2] + ", " + tableChange[3]));
 		if (tableChange == null) {
 			COM.MoveMemory(pModelChange, new long /*int*/ [] { 0 }, OS.PTR_SIZEOF);
-			return COM.S_FALSE;
-		}
+		return COM.S_FALSE;
+	}
 		COM.MoveMemory(pModelChange, tableChange, tableChange.length * 4);
 		return COM.S_OK;
 	}
@@ -3900,12 +3900,12 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
-			}
 		}
+		}
 		COM.MoveMemory(ppCellAccessibles, new long /*int*/ [] { pv }, OS.PTR_SIZEOF);
 		COM.MoveMemory(pNColumnHeaderCells, new int [] { count }, 4);
 		return COM.S_OK;
@@ -3953,8 +3953,8 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
 			}
@@ -3975,7 +3975,7 @@
 		COM.MoveMemory(pRowIndex, new int [] { event.index }, 4);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleTableCell::get_isSelected([out] pIsSelected) */
 	int get_isSelected(long /*int*/ pIsSelected) {
 		AccessibleTableCellEvent event = new AccessibleTableCellEvent(this);
@@ -4003,7 +4003,7 @@
 //		COM.MoveMemory(pRowExtents, new int [] { event.rowExtents }, 4);
 //		COM.MoveMemory(pColumnExtents, new int [] { event.columnExtents }, 4);
 //		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleTableCell::get_table([out] ppTable) */
 	int get_table(long /*int*/ ppTable) {
@@ -4019,10 +4019,10 @@
 			COM.MoveMemory(ppTable, new long /*int*/[] { 0 }, OS.PTR_SIZEOF);
 			return COM.S_FALSE;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppTable, new long /*int*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
-		return COM.S_OK;
-	}
+			return COM.S_OK;
+		}
 
 	/* IAccessibleText::addSelection([in] startOffset, [in] endOffset) */
 	int addSelection(int startOffset, int endOffset) {
@@ -4035,8 +4035,8 @@
 			listener.addSelection(event);
 		}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
-		return COM.S_OK;
-	}
+			return COM.S_OK;
+		}
 
 	/* IAccessibleText::get_attributes([in] offset, [out] pStartOffset, [out] pEndOffset, [out] pbstrTextAttributes) */
 	int get_attributes(int offset, long /*int*/ pStartOffset, long /*int*/ pEndOffset, long /*int*/ pbstrTextAttributes) {
@@ -4098,7 +4098,7 @@
 		if (textAttributes.length() == 0) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_caretOffset([out] pOffset) */
 	int get_caretOffset(long /*int*/ pOffset) {
 		int offset = getCaretOffset();
@@ -4106,7 +4106,7 @@
 		COM.MoveMemory(pOffset, new int [] { offset }, 4);
 		if (offset == -1) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+				}
 
 	/* IAccessibleText::get_characterExtents([in] offset, [in] coordType, [out] pX, [out] pY, [out] pWidth, [out] pHeight) */
 	int get_characterExtents(int offset, int coordType, long /*int*/ pX, long /*int*/ pY, long /*int*/ pWidth, long /*int*/ pHeight) {
@@ -4117,7 +4117,7 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.getTextBounds(event);
-		}
+				}
 		/* Note: event.rectangles is not used here, because IAccessibleText::get_characterExtents is just for one character. */
 		if (DEBUG) print(this + ".IAccessibleText::get_characterExtents(" + offset + ") returning " + event.x + ", " + event.y + ", " + event.width + ", " + event.height);
 		COM.MoveMemory(pX, new int [] { event.x }, 4);
@@ -4126,7 +4126,7 @@
 		COM.MoveMemory(pHeight, new int [] { event.height }, 4);
 		if (event.width == 0 && event.height == 0) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::get_nSelections([out] pNSelections) */
 	int get_nSelections(long /*int*/ pNSelections) {
@@ -4149,7 +4149,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::get_nSelections returning " + event.count);
 		COM.MoveMemory(pNSelections, new int [] { event.count }, 4);
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_offsetAtPoint([in] x, [in] y, [in] coordType, [out] pOffset) */
 	int get_offsetAtPoint(int x, int y, int coordType, long /*int*/ pOffset) {
@@ -4170,7 +4170,7 @@
 		if (event.offset == -1) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_selection([in] selectionIndex, [out] pStartOffset, [out] pEndOffset) */
 	int get_selection(int selectionIndex, long /*int*/ pStartOffset, long /*int*/ pEndOffset) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4180,7 +4180,7 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.getSelection(event);
-		}
+			}
 		if (event.start == -1 && selectionIndex == 0) {
 			event.childID = ACC.CHILDID_SELF;
 			event.offset = -1;
@@ -4201,7 +4201,7 @@
 		 */
 		if (event.start == -1) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_text([in] startOffset, [in] endOffset, [out] pbstrText) */
 	int get_text(int startOffset, int endOffset, long /*int*/ pbstrText) {
@@ -4238,7 +4238,7 @@
 		if (event.result == null) return COM.E_INVALIDARG;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_textBeforeOffset([in] offset, [in] boundaryType, [out] pStartOffset, [out] pEndOffset, [out] pbstrText) */
 	int get_textBeforeOffset(int offset, int boundaryType, long /*int*/ pStartOffset, long /*int*/ pEndOffset, long /*int*/ pbstrText) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4291,7 +4291,7 @@
 		if (event.result == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_textAfterOffset([in] offset, [in] boundaryType, [out] pStartOffset, [out] pEndOffset, [out] pbstrText) */
 	int get_textAfterOffset(int offset, int boundaryType, long /*int*/ pStartOffset, long /*int*/ pEndOffset, long /*int*/ pbstrText) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4404,7 +4404,7 @@
 		if (event.result == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	 
 	/* IAccessibleText::removeSelection([in] selectionIndex) */
 	int removeSelection(int selectionIndex) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4416,7 +4416,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::removeSelection(" + selectionIndex + ") returning" + hresult(event.result == null || !event.result.equals(ACC.OK) ? COM.E_INVALIDARG : COM.S_OK));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::setCaretOffset([in] offset) */
 	int setCaretOffset(int offset) {
@@ -4429,7 +4429,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::setCaretOffset(" + offset + ") returning" + hresult(event.result == null || !event.result.equals(ACC.OK) ? COM.E_INVALIDARG : COM.S_OK));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG; // TODO: @retval E_FAIL if the caret cannot be set ?
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::setSelection([in] selectionIndex, [in] startOffset, [in] endOffset) */
 	int setSelection(int selectionIndex, int startOffset, int endOffset) {
@@ -4440,11 +4440,11 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.setSelection(event);
-		}
+		}	
 		if (DEBUG) print(this + ".IAccessibleText::setSelection(index=" + selectionIndex + ", start=" + event.start + ", end=" + event.end + ") returning " + (event.result.equals(ACC.OK) ? "OK" : "INVALIDARG"));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+					}
 
 	/* IAccessibleText::get_nCharacters([out] pNCharacters) */
 	int get_nCharacters(long /*int*/ pNCharacters) {
@@ -4452,7 +4452,7 @@
 		COM.MoveMemory(pNCharacters, new int [] { count }, 4);
 		if (DEBUG) print(this + ".IAccessibleText::get_nCharacters returning " + count);
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::scrollSubstringTo([in] startIndex, [in] endIndex, [in] scrollType) */
 	int scrollSubstringTo(int startIndex, int endIndex, int scrollType) {
@@ -4475,7 +4475,7 @@
 		}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+				}
 
 	/* IAccessibleText::scrollSubstringToPoint([in] startIndex, [in] endIndex, [in] coordinateType, [in] x, [in] y) */
 	int scrollSubstringToPoint(int startIndex, int endIndex, int coordinateType, int x, int y) {
@@ -4489,10 +4489,10 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.scrollText(event);
-		}
+			}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG; // TODO: @retval S_FALSE if the object is already at the specified location.
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_newText([out] pNewText) */
 	int get_newText(long /*int*/ pNewText) {
@@ -4511,7 +4511,7 @@
 		if (textInserted == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_oldText([out] pOldText) */
 	int get_oldText(long /*int*/ pOldText) {
 		if (DEBUG) print(this + ".IAccessibleText::get_oldText");
@@ -4528,7 +4528,7 @@
 		COM.MoveMemory(pOldText + OS.PTR_SIZEOF + 4, new int [] {end}, 4);
 		if (textDeleted == null) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleValue::get_currentValue([out] pCurrentValue) */
 	int get_currentValue(long /*int*/ pCurrentValue) {
@@ -4541,7 +4541,7 @@
 		setNumberVARIANT(pCurrentValue, event.value);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleValue::setCurrentValue([in] value) */
 	int setCurrentValue(long /*int*/ value) {
 		if (DEBUG) print(this + ".IAccessibleValue::setCurrentValue");
@@ -4553,8 +4553,8 @@
 		}
 		//if (event.value == null) return COM.S_FALSE;
 		return COM.S_OK;
-	}
-
+		}
+		
 	/* IAccessibleValue::get_maximumValue([out] pMaximumValue) */
 	int get_maximumValue(long /*int*/ pMaximumValue) {
 		AccessibleValueEvent event = new AccessibleValueEvent(this);
@@ -4578,7 +4578,7 @@
 		setNumberVARIANT(pMinimumValue, event.value);
 		return COM.S_OK;
 	}
-
+	
 	int eventChildID() {
 		if (parent == null) return COM.CHILDID_SELF;
 		if (uniqueID == -1) uniqueID = UniqueID--;
@@ -4605,8 +4605,8 @@
 		/* ChildIDs are 1-based indices. */
 		int osChildID = childID + 1;
 		if (control instanceof Tree) {
-			/*
-			* Feature of Windows:
+		/*
+		* Feature of Windows:
 			* Before Windows XP, tree item ids were 1-based indices.
 			* Windows XP and later use the tree item handle for the
 			* accessible child ID. For backward compatibility, we still
@@ -4895,7 +4895,7 @@
 		COM.MoveMemory(v, variant, VARIANT.sizeof);
 		return v;
 	}
-	
+
 	Number getNumberVARIANT(long /*int*/ variant) {
 		VARIANT v = new VARIANT();
 		COM.MoveMemory(v, variant, VARIANT.sizeof);
@@ -4916,7 +4916,7 @@
 			COM.MoveMemory(variant + 8, new long /*int*/ [] { lVal }, OS.PTR_SIZEOF);
 		}
 	}
-	
+
 	void setNumberVARIANT(long /*int*/ variant, Number number) {
 		if (number == null) {
 			COM.MoveMemory(variant, new short[] { COM.VT_EMPTY }, 2);
@@ -4939,7 +4939,7 @@
 	void setString(long /*int*/ psz, String string) {
 		long /*int*/ ptr = 0;
 		if (string != null) {
-			char[] data = (string + "\0").toCharArray();
+		char[] data = (string + "\0").toCharArray();
 			ptr = COM.SysAllocString(data);
 		}
 		COM.MoveMemory(psz, new long /*int*/ [] { ptr }, OS.PTR_SIZEOF);
Index: org/eclipse/swt/printing/Printer.java
===================================================================
--- org/eclipse/swt/printing/Printer.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/printing/Printer.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -242,28 +242,28 @@
 	
 	/* Initialize DEVMODE struct fields from the printerData. */
 	if (lpInitData != 0) {
-		DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-		OS.MoveMemory(devmode, lpInitData, DEVMODE.sizeof);
-		devmode.dmFields |= OS.DM_ORIENTATION;
-		devmode.dmOrientation = data.orientation == PrinterData.LANDSCAPE ? OS.DMORIENT_LANDSCAPE : OS.DMORIENT_PORTRAIT;
-		if (data.copyCount != 1) {
-			devmode.dmFields |= OS.DM_COPIES;
-			devmode.dmCopies = (short)data.copyCount;
+	DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+	OS.MoveMemory(devmode, lpInitData, DEVMODE.sizeof);
+	devmode.dmFields |= OS.DM_ORIENTATION;
+	devmode.dmOrientation = data.orientation == PrinterData.LANDSCAPE ? OS.DMORIENT_LANDSCAPE : OS.DMORIENT_PORTRAIT;
+	if (data.copyCount != 1) {
+		devmode.dmFields |= OS.DM_COPIES;
+		devmode.dmCopies = (short)data.copyCount;
+	}
+	if (data.collate != false) {
+		devmode.dmFields |= OS.DM_COLLATE;
+		devmode.dmCollate = OS.DMCOLLATE_TRUE;
+	}
+	if (data.duplex != SWT.DEFAULT) {
+		devmode.dmFields |= OS.DM_DUPLEX;
+		switch (data.duplex) {
+			case PrinterData.DUPLEX_SHORT_EDGE: devmode.dmDuplex = OS.DMDUP_HORIZONTAL; break;
+			case PrinterData.DUPLEX_LONG_EDGE: devmode.dmDuplex = OS.DMDUP_VERTICAL; break;
+			default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
 		}
-		if (data.collate != false) {
-			devmode.dmFields |= OS.DM_COLLATE;
-			devmode.dmCollate = OS.DMCOLLATE_TRUE;
-		}
-		if (data.duplex != SWT.DEFAULT) {
-			devmode.dmFields |= OS.DM_DUPLEX;
-			switch (data.duplex) {
-				case PrinterData.DUPLEX_SHORT_EDGE: devmode.dmDuplex = OS.DMDUP_HORIZONTAL; break;
-				case PrinterData.DUPLEX_LONG_EDGE: devmode.dmDuplex = OS.DMDUP_VERTICAL; break;
-				default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
-			}
-		}
-		OS.MoveMemory(lpInitData, devmode, DEVMODE.sizeof);
 	}
+	OS.MoveMemory(lpInitData, devmode, DEVMODE.sizeof);
+	}
 	handle = OS.CreateDC(driver, device, 0, lpInitData);
 	if (lpInitData != 0) OS.HeapFree(hHeap, 0, lpInitData);
 	if (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);
Index: org/eclipse/swt/printing/PrintDialog.java
===================================================================
--- org/eclipse/swt/printing/PrintDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/printing/PrintDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -336,55 +336,55 @@
 			}
 		}
 		if (success) {
-			/* Initialize PRINTDLG DEVNAMES for the specified printer. */
-			TCHAR buffer = new TCHAR(0, printerData.name, true);
-			int size = buffer.length() * TCHAR.sizeof;
-			short[] offsets = new short[4]; // DEVNAMES (4 offsets)
-			int offsetsSize = offsets.length * 2; // 2 bytes each
-			offsets[1] = (short) offsets.length; // offset 1 points to wDeviceOffset
-			long /*int*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, offsetsSize + size);
-			long /*int*/ ptr = OS.GlobalLock(hMem);
-			OS.MoveMemory(ptr, offsets, offsetsSize);
-			OS.MoveMemory(ptr + offsetsSize, buffer, size);
-			OS.GlobalUnlock(hMem);
-			pd.hDevNames = hMem;
+		/* Initialize PRINTDLG DEVNAMES for the specified printer. */
+		TCHAR buffer = new TCHAR(0, printerData.name, true);
+		int size = buffer.length() * TCHAR.sizeof;
+		short[] offsets = new short[4]; // DEVNAMES (4 offsets)
+		int offsetsSize = offsets.length * 2; // 2 bytes each
+		offsets[1] = (short) offsets.length; // offset 1 points to wDeviceOffset
+		long /*int*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, offsetsSize + size);
+		long /*int*/ ptr = OS.GlobalLock(hMem);
+		OS.MoveMemory(ptr, offsets, offsetsSize);
+		OS.MoveMemory(ptr + offsetsSize, buffer, size);
+		OS.GlobalUnlock(hMem);
+		pd.hDevNames = hMem;
 		}
 	}
 	if (!success) {
 		/* Initialize PRINTDLG fields, including DEVMODE, for the default printer. */
-		pd.Flags = OS.PD_RETURNDEFAULT;
+	pd.Flags = OS.PD_RETURNDEFAULT;
 		if (success = OS.PrintDlg(pd)) {
-			if (pd.hDevNames != 0) {
-				OS.GlobalFree(pd.hDevNames);
-				pd.hDevNames = 0;
-			}
+		if (pd.hDevNames != 0) {
+			OS.GlobalFree(pd.hDevNames);
+			pd.hDevNames = 0;
 		}
+		}
 	}
 
 	if (success) {
-		/*
-		 * If user setup info from a previous print dialog was specified,
-		 * then restore the previous DEVMODE struct.
-		 */
-		byte devmodeData [] = printerData.otherData;
-		if (devmodeData != null && devmodeData.length != 0) {
+	/*
+	 * If user setup info from a previous print dialog was specified,
+	 * then restore the previous DEVMODE struct.
+	 */
+	byte devmodeData [] = printerData.otherData;
+	if (devmodeData != null && devmodeData.length != 0) {
 			long /*int*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, devmodeData.length);
 			long /*int*/ ptr = OS.GlobalLock(hMem);
 			OS.MoveMemory(ptr, devmodeData, devmodeData.length);
 			OS.GlobalUnlock(hMem);
-			if (pd.hDevMode != 0) OS.GlobalFree(pd.hDevMode);
+		if (pd.hDevMode != 0) OS.GlobalFree(pd.hDevMode);
 			pd.hDevMode = hMem;
 		}
-		
-		/* Initialize the DEVMODE struct's fields from the printerData. */
-		long /*int*/ hMem = pd.hDevMode;
+	
+	/* Initialize the DEVMODE struct's fields from the printerData. */
+	long /*int*/ hMem = pd.hDevMode;
 		if (hMem == 0) {
 			hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, DEVMODE.sizeof);
 			pd.hDevMode = hMem;
 		}
-		long /*int*/ ptr = OS.GlobalLock(hMem);
-		DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-		OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+	long /*int*/ ptr = OS.GlobalLock(hMem);
+	DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+	OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
 		if (printerData.name != null) {
 			/* Copy PRINTDLG DEVNAMES into DEVMODE dmDeviceName (truncate if necessary). */
 			int max = Math.min(printerData.name.length(), OS.CCHDEVICENAME - 1);
@@ -399,16 +399,16 @@
 				}
 			}
 		}
-		devmode.dmFields |= OS.DM_ORIENTATION;
-		devmode.dmOrientation = printerData.orientation == PrinterData.PORTRAIT ? OS.DMORIENT_PORTRAIT : OS.DMORIENT_LANDSCAPE;
-		if (printerData.copyCount != 1) {
-			devmode.dmFields |= OS.DM_COPIES;
-			devmode.dmCopies = (short)printerData.copyCount;
-		}
-		if (printerData.collate != false) {
-			devmode.dmFields |= OS.DM_COLLATE;
-			devmode.dmCollate = OS.DMCOLLATE_TRUE;
-		}
+	devmode.dmFields |= OS.DM_ORIENTATION;
+	devmode.dmOrientation = printerData.orientation == PrinterData.PORTRAIT ? OS.DMORIENT_PORTRAIT : OS.DMORIENT_LANDSCAPE;
+	if (printerData.copyCount != 1) {
+		devmode.dmFields |= OS.DM_COPIES;
+		devmode.dmCopies = (short)printerData.copyCount;
+	}
+	if (printerData.collate != false) {
+		devmode.dmFields |= OS.DM_COLLATE;
+		devmode.dmCollate = OS.DMCOLLATE_TRUE;
+	}
 		if (printerData.duplex != SWT.DEFAULT) {
 			devmode.dmFields |= OS.DM_DUPLEX;
 			switch (printerData.duplex) {
@@ -417,110 +417,110 @@
 				default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
 			}
 		}
-		OS.MoveMemory(ptr, devmode, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
-		OS.GlobalUnlock(hMem);
-	
-		pd.Flags = OS.PD_USEDEVMODECOPIESANDCOLLATE;
-		if (printerData.printToFile) pd.Flags |= OS.PD_PRINTTOFILE;
-		switch (printerData.scope) {
-			case PrinterData.PAGE_RANGE: pd.Flags |= OS.PD_PAGENUMS; break;
-			case PrinterData.SELECTION: pd.Flags |= OS.PD_SELECTION; break;
-			default: pd.Flags |= OS.PD_ALLPAGES;
-		}
-		pd.nMinPage = 1;
-		pd.nMaxPage = -1;
-		pd.nFromPage = (short) Math.min (0xFFFF, Math.max (1, printerData.startPage));
-		pd.nToPage = (short) Math.min (0xFFFF, Math.max (1, printerData.endPage));
-	
-		Display display = parent.getDisplay();
-		Shell [] shells = display.getShells();
-		if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
-			for (int i=0; i<shells.length; i++) {
-				if (shells[i].isEnabled() && shells[i] != parent) {
-					shells[i].setEnabled(false);
-				} else {
-					shells[i] = null;
-				}
+	OS.MoveMemory(ptr, devmode, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+	OS.GlobalUnlock(hMem);
+
+	pd.Flags = OS.PD_USEDEVMODECOPIESANDCOLLATE;
+	if (printerData.printToFile) pd.Flags |= OS.PD_PRINTTOFILE;
+	switch (printerData.scope) {
+		case PrinterData.PAGE_RANGE: pd.Flags |= OS.PD_PAGENUMS; break;
+		case PrinterData.SELECTION: pd.Flags |= OS.PD_SELECTION; break;
+		default: pd.Flags |= OS.PD_ALLPAGES;
+	}
+	pd.nMinPage = 1;
+	pd.nMaxPage = -1;
+	pd.nFromPage = (short) Math.min (0xFFFF, Math.max (1, printerData.startPage));
+	pd.nToPage = (short) Math.min (0xFFFF, Math.max (1, printerData.endPage));
+
+	Display display = parent.getDisplay();
+	Shell [] shells = display.getShells();
+	if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
+		for (int i=0; i<shells.length; i++) {
+			if (shells[i].isEnabled() && shells[i] != parent) {
+				shells[i].setEnabled(false);
+			} else {
+				shells[i] = null;
 			}
 		}
-		String key = "org.eclipse.swt.internal.win32.runMessagesInIdle"; //$NON-NLS-1$
-		Object oldValue = display.getData(key);
-		display.setData(key, new Boolean(true));
+	}
+	String key = "org.eclipse.swt.internal.win32.runMessagesInIdle"; //$NON-NLS-1$
+	Object oldValue = display.getData(key);
+	display.setData(key, new Boolean(true));
 		success = OS.PrintDlg(pd);
-		display.setData(key, oldValue);
-		if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
-			for (int i=0; i<shells.length; i++) {
-				if (shells[i] != null && !shells[i].isDisposed ()) {
-					shells[i].setEnabled(true);
-				}
+	display.setData(key, oldValue);
+	if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
+		for (int i=0; i<shells.length; i++) {
+			if (shells[i] != null && !shells[i].isDisposed ()) {
+				shells[i].setEnabled(true);
 			}
 		}
-		
-		if (success) {
-			/* Get driver and device from the DEVNAMES struct */
-			hMem = pd.hDevNames;
-			/* Ensure size is a multiple of 2 bytes on UNICODE platforms */
-			int size = OS.GlobalSize(hMem) / TCHAR.sizeof * TCHAR.sizeof;
-			ptr = OS.GlobalLock(hMem);
-			short[] offsets = new short[4];
-			OS.MoveMemory(offsets, ptr, 2 * offsets.length);
-			TCHAR buffer = new TCHAR(0, size);
-			OS.MoveMemory(buffer, ptr, size);	
-			OS.GlobalUnlock(hMem);
+	}
 	
-			int driverOffset = offsets[0];
-			int i = 0;
-			while (driverOffset + i < size) {
-				if (buffer.tcharAt(driverOffset + i) == 0) break;
-				i++;
-			}
-			String driver = buffer.toString(driverOffset, i);
-	
-			int deviceOffset = offsets[1];
-			i = 0;
-			while (deviceOffset + i < size) {
-				if (buffer.tcharAt(deviceOffset + i) == 0) break;
-				i++;
-			}
-			String device = buffer.toString(deviceOffset, i);	
+	if (success) {
+		/* Get driver and device from the DEVNAMES struct */
+		hMem = pd.hDevNames;
+		/* Ensure size is a multiple of 2 bytes on UNICODE platforms */
+		int size = OS.GlobalSize(hMem) / TCHAR.sizeof * TCHAR.sizeof;
+		ptr = OS.GlobalLock(hMem);
+		short[] offsets = new short[4];
+		OS.MoveMemory(offsets, ptr, 2 * offsets.length);
+		TCHAR buffer = new TCHAR(0, size);
+		OS.MoveMemory(buffer, ptr, size);	
+		OS.GlobalUnlock(hMem);
 
-			/* Create PrinterData object and set fields from PRINTDLG */
-			data = new PrinterData(driver, device);
-			if ((pd.Flags & OS.PD_PAGENUMS) != 0) {
-				data.scope = PrinterData.PAGE_RANGE;
-				data.startPage = pd.nFromPage & 0xFFFF;
-				data.endPage = pd.nToPage & 0xFFFF;
-			} else if ((pd.Flags & OS.PD_SELECTION) != 0) {
-				data.scope = PrinterData.SELECTION;
-			}
-			data.printToFile = (pd.Flags & OS.PD_PRINTTOFILE) != 0;
+		int driverOffset = offsets[0];
+		int i = 0;
+		while (driverOffset + i < size) {
+			if (buffer.tcharAt(driverOffset + i) == 0) break;
+			i++;
+		}
+		String driver = buffer.toString(driverOffset, i);
+
+		int deviceOffset = offsets[1];
+		i = 0;
+		while (deviceOffset + i < size) {
+			if (buffer.tcharAt(deviceOffset + i) == 0) break;
+			i++;
+		}
+		String device = buffer.toString(deviceOffset, i);	
+
+		/* Create PrinterData object and set fields from PRINTDLG */
+		data = new PrinterData(driver, device);
+		if ((pd.Flags & OS.PD_PAGENUMS) != 0) {
+			data.scope = PrinterData.PAGE_RANGE;
+			data.startPage = pd.nFromPage & 0xFFFF;
+			data.endPage = pd.nToPage & 0xFFFF;
+		} else if ((pd.Flags & OS.PD_SELECTION) != 0) {
+			data.scope = PrinterData.SELECTION;
+		}
+		data.printToFile = (pd.Flags & OS.PD_PRINTTOFILE) != 0;
 			if (data.printToFile) data.fileName = printerData.fileName;
-			data.copyCount = pd.nCopies;
-			data.collate = (pd.Flags & OS.PD_COLLATE) != 0;
-	
-			/* Bulk-save the printer-specific settings in the DEVMODE struct */
-			hMem = pd.hDevMode;
-			size = OS.GlobalSize(hMem);
-			ptr = OS.GlobalLock(hMem);
-			data.otherData = new byte[size];
-			OS.MoveMemory(data.otherData, ptr, size);
+		data.copyCount = pd.nCopies;
+		data.collate = (pd.Flags & OS.PD_COLLATE) != 0;
+
+		/* Bulk-save the printer-specific settings in the DEVMODE struct */
+		hMem = pd.hDevMode;
+		size = OS.GlobalSize(hMem);
+		ptr = OS.GlobalLock(hMem);
+		data.otherData = new byte[size];
+		OS.MoveMemory(data.otherData, ptr, size);
 			
 			/* Set PrinterData fields from DEVMODE */
-			devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-			OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
-			if ((devmode.dmFields & OS.DM_ORIENTATION) != 0) {
-				int dmOrientation = devmode.dmOrientation;
-				data.orientation = dmOrientation == OS.DMORIENT_LANDSCAPE ? PrinterData.LANDSCAPE : PrinterData.PORTRAIT;
-			}
+		devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+		OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+		if ((devmode.dmFields & OS.DM_ORIENTATION) != 0) {
+			int dmOrientation = devmode.dmOrientation;
+			data.orientation = dmOrientation == OS.DMORIENT_LANDSCAPE ? PrinterData.LANDSCAPE : PrinterData.PORTRAIT;
+		}
 			if ((devmode.dmFields & OS.DM_DUPLEX) != 0) {
 				short dmDuplex = devmode.dmDuplex;
 				data.duplex = dmDuplex == OS.DMDUP_SIMPLEX ? PrinterData.DUPLEX_NONE : dmDuplex == OS.DMDUP_HORIZONTAL ? PrinterData.DUPLEX_SHORT_EDGE : PrinterData.DUPLEX_LONG_EDGE;
 			}
 
-			OS.GlobalUnlock(hMem);
-			printerData = data;
-		}
+		OS.GlobalUnlock(hMem);
+		printerData = data;
 	}
+	}
 	if (pd.hDevNames != 0) {
 		OS.GlobalFree(pd.hDevNames);
 		pd.hDevNames = 0;
Index: org/eclipse/swt/printing/PrinterData.java
===================================================================
--- org/eclipse/swt/printing/PrinterData.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/printing/PrinterData.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -155,7 +155,7 @@
 	 * the current selection should be printed
 	 */	
 	public static final int SELECTION = 2;
-		
+	
 	/**
 	 * <code>orientation</code> field value indicating
 	 * portrait paper orientation
@@ -172,7 +172,7 @@
 	 */
 	public static final int LANDSCAPE = 2;
 	
- 	/**
+	/**
 	 * <code>duplex</code> field value indicating
 	 * single-sided printing.
 	 * <p>
Index: org/eclipse/swt/awt/SWT_AWT.java
===================================================================
--- org/eclipse/swt/awt/SWT_AWT.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/awt/SWT_AWT.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -324,7 +324,7 @@
 		}
 	};
 	if (Library.JAVA_VERSION < Library.JAVA_VERSION(1, 5, 0)) {
-		parent.addListener (SWT.Activate, listener);
+	parent.addListener (SWT.Activate, listener);
 	} else {
 		parent.addListener (SWT.FocusIn, listener);
 	}
Index: org/eclipse/swt/SWT.java
===================================================================
--- org/eclipse/swt/SWT.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/SWT.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt;
 
@@ -34,9 +35,9 @@
  *
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
  */
- 
+
 /* NOTE:
- *   Good javadoc coding style is to put the values of static final 
+ *   Good javadoc coding style is to put the values of static final
  *   constants in the comments. This reinforces the fact that
  *   consumers are allowed to rely on the value (and they must
  *   since the values are compiled inline in their code). We
@@ -44,23 +45,23 @@
  *   releases.
  */
 public class SWT {
-	
+
 	/* Widget Event Constants */
-	
+
 	/**
 	 * The null event type (value is 0).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int None = 0;
-	
+
 	/**
 	 * The key down event type (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addKeyListener
 	 * @see org.eclipse.swt.widgets.Tracker#addKeyListener
 	 * @see org.eclipse.swt.events.KeyListener#keyPressed
@@ -67,14 +68,14 @@
 	 * @see org.eclipse.swt.events.KeyEvent
 	 */
 	public static final int KeyDown = 1;
-	
+
 	/**
 	 * The key up event type (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addKeyListener
 	 * @see org.eclipse.swt.widgets.Tracker#addKeyListener
 	 * @see org.eclipse.swt.events.KeyListener#keyReleased
@@ -81,105 +82,105 @@
 	 * @see org.eclipse.swt.events.KeyEvent
 	 */
 	public static final int KeyUp = 2;
-	
+
 	/**
 	 * The mouse down event type (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseDown
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseDown = 3;
-	
+
 	/**
 	 * The mouse up event type (value is 4).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseUp
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseUp = 4;
-	
+
 	/**
 	 * The mouse move event type (value is 5).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseMoveListener
 	 * @see org.eclipse.swt.events.MouseMoveListener#mouseMove
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseMove = 5;
-	
+
 	/**
 	 * The mouse enter event type (value is 6).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseEnter
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
-	public static final int MouseEnter = 6;		
-	
+	public static final int MouseEnter = 6;
+
 	/**
 	 * The mouse exit event type (value is 7).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseExit
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseExit = 7;
-	
+
 	/**
 	 * The mouse double click event type (value is 8).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseDoubleClick
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
-	public static final int MouseDoubleClick = 8;	
-	
+	public static final int MouseDoubleClick = 8;
+
 	/**
 	 * The paint event type (value is 9).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addPaintListener
 	 * @see org.eclipse.swt.events.PaintListener#paintControl
 	 * @see org.eclipse.swt.events.PaintEvent
 	 */
-	public static final int Paint = 9;	
-	
+	public static final int Paint = 9;
+
 	/**
 	 * The move event type (value is 10).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addControlListener
 	 * @see org.eclipse.swt.widgets.TableColumn#addControlListener
 	 * @see org.eclipse.swt.widgets.Tracker#addControlListener
@@ -188,14 +189,14 @@
 	 * @see org.eclipse.swt.events.ControlEvent
 	 */
 	public static final int Move = 10;
-	
+
 	/**
 	 * The resize event type (value is 11).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addControlListener
 	 * @see org.eclipse.swt.widgets.TableColumn#addControlListener
 	 * @see org.eclipse.swt.widgets.Tracker#addControlListener
@@ -204,28 +205,28 @@
 	 * @see org.eclipse.swt.events.ControlEvent
 	 */
 	public static final int Resize = 11;
-	
+
 	/**
 	 * The dispose event type (value is 12).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addDisposeListener
 	 * @see org.eclipse.swt.events.DisposeListener#widgetDisposed
 	 * @see org.eclipse.swt.events.DisposeEvent
 	 */
 	public static final int Dispose = 12;
-	
+
 	/**
 	 * The selection event type (value is 13).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Button#addSelectionListener
 	 * @see org.eclipse.swt.widgets.Combo#addSelectionListener
 	 * @see org.eclipse.swt.widgets.CoolItem#addSelectionListener
@@ -247,14 +248,14 @@
 	 * @see org.eclipse.swt.events.SelectionEvent
 	 */
 	public static final int Selection = 13;
-	
+
 	/**
 	 * The default selection event type (value is 14).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Combo#addSelectionListener
 	 * @see org.eclipse.swt.widgets.List#addSelectionListener
 	 * @see org.eclipse.swt.widgets.Spinner#addSelectionListener
@@ -266,132 +267,132 @@
 	 * @see org.eclipse.swt.events.SelectionEvent
 	 */
 	public static final int DefaultSelection = 14;
-	
+
 	/**
 	 * The focus in event type (value is 15).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addFocusListener
 	 * @see org.eclipse.swt.events.FocusListener#focusGained
 	 * @see org.eclipse.swt.events.FocusEvent
 	 */
 	public static final int FocusIn = 15;
-	
+
 	/**
 	 * The focus out event type (value is 16).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addFocusListener
 	 * @see org.eclipse.swt.events.FocusListener#focusLost
 	 * @see org.eclipse.swt.events.FocusEvent
 	 */
 	public static final int FocusOut = 16;
-	
+
 	/**
 	 * The expand event type (value is 17).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Tree#addTreeListener
 	 * @see org.eclipse.swt.events.TreeListener#treeExpanded
 	 * @see org.eclipse.swt.events.TreeEvent
 	 */
 	public static final int Expand = 17;
-	
+
 	/**
 	 * The collapse event type (value is 18).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Tree#addTreeListener
 	 * @see org.eclipse.swt.events.TreeListener#treeCollapsed
 	 * @see org.eclipse.swt.events.TreeEvent
 	 */
 	public static final int Collapse = 18;
-	
+
 	/**
 	 * The iconify event type (value is 19).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellIconified
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Iconify = 19;
-	
+
 	/**
 	 * The de-iconify event type (value is 20).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellDeiconified
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Deiconify = 20;
-	
+
 	/**
 	 * The close event type (value is 21).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellClosed
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Close = 21;
-	
+
 	/**
 	 * The show event type (value is 22).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Menu#addMenuListener
 	 * @see org.eclipse.swt.events.MenuListener#menuShown
 	 * @see org.eclipse.swt.events.MenuEvent
 	 */
 	public static final int Show = 22;
-	
+
 	/**
 	 * The hide event type (value is 23).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Menu#addMenuListener
 	 * @see org.eclipse.swt.events.MenuListener#menuHidden
 	 * @see org.eclipse.swt.events.MenuEvent
 	 */
 	public static final int Hide = 23;
-	
+
 	/**
 	 * The modify event type (value is 24).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Combo#addModifyListener
 	 * @see org.eclipse.swt.widgets.Spinner#addModifyListener
 	 * @see org.eclipse.swt.widgets.Text#addModifyListener
@@ -399,14 +400,14 @@
 	 * @see org.eclipse.swt.events.ModifyEvent
 	 */
 	public static final int Modify = 24;
-	
+
 	/**
 	 * The verify event type (value is 25).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.custom.CCombo#addVerifyListener
 	 * @see org.eclipse.swt.widgets.Combo#addVerifyListener
 	 * @see org.eclipse.swt.custom.StyledText#addVerifyListener
@@ -415,40 +416,40 @@
 	 * @see org.eclipse.swt.events.VerifyEvent
 	 */
 	public static final int Verify = 25;
-	
+
 	/**
 	 * The activate event type (value is 26).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellActivated
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Activate = 26;
-	
+
 	/**
 	 * The deactivate event type (value is 27).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellDeactivated
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
-	public static final int Deactivate = 27;	
-	
+	public static final int Deactivate = 27;
+
 	/**
 	 * The help event type (value is 28).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addHelpListener
 	 * @see org.eclipse.swt.widgets.Menu#addHelpListener
 	 * @see org.eclipse.swt.widgets.MenuItem#addHelpListener
@@ -456,14 +457,14 @@
 	 * @see org.eclipse.swt.events.HelpEvent
 	 */
 	public static final int Help = 28;
-	
+
 	/**
 	 * The drag detect event type (value is 29).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addDragDetectListener
 	 * @see org.eclipse.swt.events.DragDetectListener#dragDetected
 	 * @see org.eclipse.swt.events.DragDetectEvent
@@ -470,40 +471,40 @@
 	 * @see org.eclipse.swt.dnd.DragSource
 	 */
 	public static final int DragDetect = 29;
-	
+
 	/**
 	 * The arm event type (value is 30).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.MenuItem#addArmListener
 	 * @see org.eclipse.swt.events.ArmListener#widgetArmed
 	 * @see org.eclipse.swt.events.ArmEvent
 	 */
 	public static final int Arm = 30;
-	
+
 	/**
 	 * The traverse event type (value is 31).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addTraverseListener
 	 * @see org.eclipse.swt.events.TraverseListener#keyTraversed
 	 * @see org.eclipse.swt.events.TraverseEvent
 	 */
 	public static final int Traverse = 31;
-	
+
 	/**
 	 * The mouse hover event type (value is 32).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseHover
 	 * @see org.eclipse.swt.events.MouseEvent
@@ -512,16 +513,16 @@
 
 	/**
 	 * The hardware key down event type (value is 33).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
 	 */
 	public static final int HardKeyDown = 33;
-	
+
 	/**
 	 * The hardware key up event type (value is 34).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
@@ -530,25 +531,25 @@
 
 	/**
 	 * The menu detect event type (value is 35).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int MenuDetect = 35;
-	
+
 	/**
 	 * The set data event type (value is 36).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Table
 	 * @see org.eclipse.swt.widgets.Tree
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int SetData = 36;
@@ -580,11 +581,11 @@
 	 * This is a synonym for {@link #MouseVerticalWheel} (value is 37).  
 	 * Newer applications should use {@link #MouseVerticalWheel} instead 
 	 * of {@link #MouseWheel} to make code more understandable.
-	 *  
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseWheelListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int MouseWheel = MouseVerticalWheel;
@@ -602,55 +603,55 @@
 	 * cached value.  The operating system automatically redraws and
 	 * lays out all widgets after this event is sent.
 	 * </p>
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int Settings = 39;
-	
+
 	/**
 	 * The erase item event type (value is 40).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int EraseItem = 40;
-	
+
 	/**
 	 * The measure item event type (value is 41).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int MeasureItem = 41;
-	
+
 	/**
 	 * The paint item event type (value is 42).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
-	public static final int PaintItem = 42;	
-	
+	public static final int PaintItem = 42;
+
 	/**
-	 * The IME composition event type (value is 43).  
+	 * The IME composition event type (value is 43).
 	 * <p>
 	 * The IME composition event is sent to allow
 	 * custom text editors to implement in-line
-	 * editing of international text. 
-	 * </p> 
-	 * 
+	 * editing of international text.
+	 * </p>
+	 *
 	 * The detail field indicates the action to be taken:
 	 * <p><ul>
 	 * <li>{@link SWT#COMPOSITION_CHANGED}</li>
@@ -657,11 +658,11 @@
 	 * <li>{@link SWT#COMPOSITION_OFFSET}</li>
 	 * <li>{@link SWT#COMPOSITION_SELECTION}</li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int ImeComposition = 43;
@@ -749,47 +750,47 @@
 	public static final int Gesture = 48;
 
 	/* Event Details */
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * a change in the IME composition. The text field
-	 * of the event is the new composition text. 
+	 * of the event is the new composition text.
 	 * The start and end indicate the offsets where the
 	 * composition text should be inserted.
-	 * The styles and ranges are stored in the IME 
+	 * The styles and ranges are stored in the IME
 	 * object (value is 1).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_CHANGED = 1;
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * that the IME needs the offset for a given location.
-	 * The x and y fields of the event are used by the 
+	 * The x and y fields of the event are used by the
 	 * application to determine the offset.
-	 * 
-	 * The index field of the event should be set to the 
-	 * text offset at that location. The count field should 
+	 *
+	 * The index field of the event should be set to the
+	 * text offset at that location. The count field should
 	 * be set to indicate whether the location is closer to
 	 * the leading edge (0) or the trailing edge (1) (value is 2).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
 	 * @see org.eclipse.swt.graphics.TextLayout#getOffset(int, int, int[])
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_OFFSET = 2;
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * that IME needs the selected text and its start
 	 * and end offsets (value is 3).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_SELECTION = 3;
@@ -799,7 +800,7 @@
 	 * for example dragging the thumb of a scroll bar (value is 1).
 	 */
 	public static final int DRAG = 1;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is selected (value is 1&lt;&lt;1).
@@ -807,15 +808,15 @@
 	 * @since 3.2
 	 */
 	public static final int SELECTED = 1 << 1;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is focused (value is 1&lt;&lt;2).
 	 *
 	 * @since 3.2
-	 */	
+	 */
 	public static final int FOCUSED = 1 << 2;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * draws the background (value is 1&lt;&lt;3).
@@ -823,7 +824,7 @@
 	 * @since 3.2
 	 */
 	public static final int BACKGROUND = 1 << 3;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * draws the foreground (value is 1&lt;&lt;4).
@@ -831,7 +832,7 @@
 	 * @since 3.2
 	 */
 	public static final int FOREGROUND = 1 << 4;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is hot (value is 1&lt;&lt;5).
@@ -839,7 +840,7 @@
 	 * @since 3.3
 	 */
 	public static final int HOT = 1 << 5;
-	
+
 	/* This code is intentionally commented */
 	//public static final int PRESSED = 1 << 3;
 	//public static final int ACTIVE = 1 << 4;
@@ -848,14 +849,14 @@
 	//public static final int DEFAULTED = 1 << 7;
 
 	/**
-	 * Traversal event detail field value indicating that no 
+	 * Traversal event detail field value indicating that no
 	 * traversal action should be taken
 	 * (value is 0).
 	 */
 	public static final int TRAVERSE_NONE = 0;
-	
+
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that a dialog should be cancelled was
 	 * pressed; typically, this is the ESC key
 	 * (value is 1&lt;&lt;1).
@@ -871,7 +872,7 @@
 	public static final int TRAVERSE_RETURN = 1 << 2;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab group was pressed; typically, this is the
 	 * SHIFT-TAB key sequence
@@ -880,7 +881,7 @@
 	public static final int TRAVERSE_TAB_PREVIOUS = 1 << 3;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * next tab group was pressed; typically, this is the
 	 * TAB key
@@ -889,7 +890,7 @@
 	public static final int TRAVERSE_TAB_NEXT = 1 << 4;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab item was pressed; typically, this is either
 	 * the LEFT-ARROW or UP-ARROW keys
@@ -898,7 +899,7 @@
 	public static final int TRAVERSE_ARROW_PREVIOUS = 1 << 5;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab item was pressed; typically, this is either
 	 * the RIGHT-ARROW or DOWN-ARROW keys
@@ -907,7 +908,7 @@
 	public static final int TRAVERSE_ARROW_NEXT = 1 << 6;
 
 	/**
-	 * Traversal event detail field value indicating that a 
+	 * Traversal event detail field value indicating that a
 	 * mnemonic key sequence was pressed
 	 * (value is 1&lt;&lt;7).
 	 */
@@ -914,7 +915,7 @@
 	public static final int TRAVERSE_MNEMONIC = 1 << 7;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that the previous page of a multi-page
 	 * window should be shown was pressed; typically, this
 	 * is the CTRL-PAGEUP key sequence
@@ -921,9 +922,9 @@
 	 * (value is 1&lt;&lt;8).
 	 */
 	public static final int TRAVERSE_PAGE_PREVIOUS = 1 << 8;
-	
+
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that the next page of a multi-page
 	 * window should be shown was pressed; typically, this
 	 * is the CTRL-PAGEDOWN key sequence
@@ -1040,13 +1041,13 @@
 	 * which take bit flags to indicate that "no bits are set".
 	 */
 	public static final int NONE = 0;
-	
+
 	/**
 	 * A constant known to be zero (0), used in operations which
 	 * take pointers to indicate a null argument.
 	 */
 	public static final int NULL = 0;
-	
+
 	/**
 	 * Indicates that a default should be used (value is -1).
 	 */
@@ -1054,14 +1055,14 @@
 
 	/**
 	 * Indicates that a property is off (value is 0).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int OFF = 0;
-	
+
 	/**
 	 * Indicates that a property is on (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ON = 1;
@@ -1068,7 +1069,7 @@
 
 	/**
 	 * Indicates low quality (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int LOW = 1;
@@ -1075,7 +1076,7 @@
 
 	/**
 	 * Indicates high quality (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int HIGH = 2;
@@ -1118,7 +1119,7 @@
 	 */
 	public static final int SEPARATOR = 1 << 1;
 
-    /**
+	/**
      * Constant representing a flexible space separator in a ToolBar.
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>ToolItem.setWidth()</code></li>
@@ -1234,7 +1235,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Text</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int SEARCH = 1 << 7;
@@ -1253,11 +1254,11 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Text</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PASSWORD = 1 << 22;
-	
+
 	/**
 	 * Style constant for shadow in behavior (value is 1&lt;&lt;2).
 	 * <br>Note that this is a <em>HINT</em>.
@@ -1314,7 +1315,7 @@
 	 * </ul></p>
 	 */
 	public static final int INDETERMINATE = 1 << 1;
-	
+
 	/**
 	 * Style constant for tool window behavior (value is 1&lt;&lt;2).
 	 * <p>
@@ -1326,7 +1327,7 @@
 	 * <li><code>Decorations</code> and subclasses</li>
 	 * </ul></p>
 	 */
-	public static final int TOOL = 1 << 2; 
+	public static final int TOOL = 1 << 2;
 
 	/**
 	 * Style constant to ensure no trimmings are used (value is 1&lt;&lt;3).
@@ -1336,7 +1337,7 @@
 	 * </ul></p>
 	 */
 	public static final int NO_TRIM = 1 << 3;
-	
+
 	/**
 	 * Style constant for resize box trim (value is 1&lt;&lt;4).
 	 * <p><b>Used By:</b><ul>
@@ -1411,7 +1412,7 @@
 	 * are free to create the default scroll bars for the control.
 	 * Using NO_SCROLL overrides the default and forces the control
 	 * to have no scroll bars.
-	 * 
+	 *
 	 * <b>Used By:</b><ul>
 	 * <li><code>Tree</code></li>
 	 * <li><code>Table</code></li>
@@ -1420,7 +1421,7 @@
 	 * @since 3.4
 	 */
 	public static final int NO_SCROLL = 1 << 4;
-	
+
 	/**
 	 * Style constant for bordered behavior (value is 1&lt;&lt;11).
 	 * <br>Note that this is a <em>HINT</em>.
@@ -1438,7 +1439,7 @@
 	 * <li><code>Control</code> and subclasses</li>
 	 * </ul></p>
 	 */
-	public static final int CLIP_CHILDREN = 1 << 12; 
+	public static final int CLIP_CHILDREN = 1 << 12;
 
 	/**
 	 * Style constant indicating that the window manager should clip
@@ -1458,7 +1459,7 @@
 	 * </ul></p>
 	 */
 	public static final int ON_TOP = 1 << 14;
-	
+
 	/**
 	 * Style constant for sheet window behavior (value is 1&lt;&lt;28).
 	 * <p>
@@ -1546,8 +1547,8 @@
 	public static final int HIDE_SELECTION = 1 << 15;
 
 	/**
-	 * Style constant for full row selection behavior and 
-	 * selection constant indicating that a full line should be 
+	 * Style constant for full row selection behavior and
+	 * selection constant indicating that a full line should be
 	 * drawn. (value is 1&lt;&lt;16).
 	 * <br>Note that for some widgets this is a <em>HINT</em>.
 	 * <p><b>Used By:</b><ul>
@@ -1554,7 +1555,7 @@
 	 * <li><code>Table</code></li>
 	 * <li><code>Tree</code></li>
 	 * <li><code>StyledText</code></li>
-	 * <li><code>TextLayout</code></li> 
+	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
 	 */
 	public static final int FULL_SELECTION = 1 << 16;
@@ -1601,7 +1602,7 @@
 	 * tool bars and sashes, don't normally take focus when the mouse is clicked
 	 * or accept focus when assigned from within the program.  This style allows
 	 * Composites to implement "no focus" mouse behavior.
-	 * 
+	 *
 	 * <br>Note that this is a <em>HINT</em>.
 	 * </p>
 	 * <p><b>Used By:</b><ul>
@@ -1618,7 +1619,7 @@
 	 * the SWT.Paint event is not sent. When it gets bigger, an SWT.Paint event is
 	 * sent with a GC clipped to only the new areas to be painted. Without this
 	 * style, the entire client area will be repainted.
-	 * 
+	 *
 	 * <br>Note that this is a <em>HINT</em>.
 	 * </p><p><b>Used By:</b><ul>
 	 * <li><code>Composite</code></li>
@@ -1628,7 +1629,7 @@
 
 	/**
 	 * Style constant for no paint event merging behavior (value is 1&lt;&lt;21).
-	 * 
+	 *
 	 * <br>Note that this is a <em>HINT</em>.
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Composite</code></li>
@@ -1644,7 +1645,7 @@
 	 * </ul></p>
 	 */
 	public static final int NO_RADIO_GROUP = 1 << 22;
-	
+
 	/**
 	 * Style constant for left to right orientation (value is 1&lt;&lt;25).
 	 * <p>
@@ -1658,13 +1659,13 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
-	 * <li><code>GC</code></li> 
+	 * <li><code>GC</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int LEFT_TO_RIGHT = 1 << 25;
-	
+
 	/**
 	 * Style constant for right to left orientation (value is 1&lt;&lt;26).
 	 * <p>
@@ -1678,13 +1679,13 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
-	 * <li><code>GC</code></li> 
+	 * <li><code>GC</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int RIGHT_TO_LEFT = 1 << 26;
-	
+
 	/**
 	 * Style constant to indicate coordinate mirroring (value is 1&lt;&lt;27).
 	 * <p><b>Used By:</b><ul>
@@ -1691,21 +1692,21 @@
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int MIRRORED = 1 << 27;
-	
+
 	/**
 	 * Style constant to allow embedding (value is 1&lt;&lt;24).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Composite</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int EMBEDDED = 1 << 24;
-	
+
 	/**
 	 * Style constant to allow virtual data (value is 1&lt;&lt;28).
 	 * <p><b>Used By:</b><ul>
@@ -1712,7 +1713,7 @@
 	 * <li><code>Table</code></li>
 	 * <li><code>Tree</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int VIRTUAL = 1 << 28;
@@ -1722,11 +1723,11 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int DOUBLE_BUFFERED = 1 << 29;
-	
+
 	/**
 	 * Style constant for transparent behavior (value is 1&lt;&lt;30).
 	 * <p>
@@ -1738,11 +1739,11 @@
 	 * </ul></p>
 	 *
 	 * @since 3.4
-	 * 
+	 *
 	 * WARNING: THIS API IS UNDER CONSTRUCTION AND SHOULD NOT BE USED
 	 */
 	public static final int TRANSPARENT = 1 << 30;
-	
+
 	/**
 	 * Style constant for align up behavior (value is 1&lt;&lt;7,
 	 * since align UP and align TOP are considered the same).
@@ -1754,13 +1755,13 @@
 	 * </ul></p>
 	 */
 	public static final int UP = 1 << 7;
-	
+
 	/**
 	 * Style constant to indicate single underline (value is 0).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_SINGLE = 0;
@@ -1770,31 +1771,31 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_DOUBLE = 1;
-	
+
 	/**
 	 * Style constant to indicate error underline (value is 2).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_ERROR = 2;
-	
+
 	/**
 	 * Style constant to indicate squiggle underline (value is 3).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_SQUIGGLE = 3;
-	
+
 	/**
 	 * Style constant to indicate link underline (value is 0).
 	 * <p>
@@ -1818,7 +1819,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_SOLID = 1;
@@ -1828,21 +1829,21 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_DASH = 2;
-	
+
 	/**
 	 * Style constant to indicate dotted border (value is 4).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_DOT = 4;
-	
+
 	/**
 	 * Style constant for align top behavior (value is 1&lt;&lt;7,
 	 * since align UP and align TOP are considered the same).
@@ -1883,11 +1884,11 @@
 	 * <li><code>Tracker</code></li>
 	 * <li><code>FormAttachment</code> in a <code>FormLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int LEAD               = 1 << 14;
-	
+
 	/**
 	 * Style constant for align left behavior (value is 1&lt;&lt;14).
 	 * This is a synonym for {@link #LEAD} (value is 1&lt;&lt;14).  Newer
@@ -1909,11 +1910,11 @@
 	 * <li><code>Tracker</code></li>
 	 * <li><code>FormAttachment</code> in a <code>FormLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int TRAIL              = 1 << 17;
-		
+
 	/**
 	 * Style constant for align right behavior (value is 1&lt;&lt;17).
 	 * This is a synonym for {@link #TRAIL} (value is 1&lt;&lt;17).  Newer
@@ -1975,7 +1976,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int DATE = 1 << 5;
@@ -1985,17 +1986,17 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int TIME = 1 << 7;
-	
+
 	/**
 	 * Style constant for calendar display (value is 1&lt;&lt;10).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int CALENDAR = 1 << 10;
@@ -2010,7 +2011,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int SHORT = 1 << 15;
@@ -2025,7 +2026,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int MEDIUM = 1 << 16;
@@ -2041,7 +2042,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int LONG = 1 << 28;
@@ -2053,7 +2054,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Browser</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int MOZILLA = 1 << 15;
@@ -2077,9 +2078,9 @@
 	 * </ul></p>
 	 *
 	 * @since 3.2
-	 */	
+	 */
 	public static final int BALLOON = 1 << 12;
-	
+
 	/**
 	 * Style constant for vertical alignment or orientation behavior (value is 1).
 	 * <p><b>Used By:</b><ul>
@@ -2087,7 +2088,7 @@
 	 * </ul></p>
 	 */
 	public static final int BEGINNING = 1;
-	
+
 	/**
 	 * Style constant for vertical alignment or orientation behavior (value is 4).
 	 * <p><b>Used By:</b><ul>
@@ -2095,7 +2096,7 @@
 	 * </ul></p>
 	 */
 	public static final int FILL = 4;
-	
+
 	/**
 	 * Input Method Editor style constant for double byte
 	 * input behavior (value is 1&lt;&lt;1).
@@ -2143,7 +2144,7 @@
 	 * (value is the <code>char</code> with value 127).
 	 */
 	public static final char DEL = 0x7F;
- 
+
 	/**
 	 * ASCII character convenience constant for the escape character
 	 * (value is the <code>char</code> with value 27).
@@ -2159,11 +2160,11 @@
 	/**
 	 * ASCII character convenience constant for the tab character
 	 * (value is the <code>char</code> '\t').
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final char TAB = '\t';
-						
+
 	/**
 	 * ASCII character convenience constant for the space character
 	 * (value is the <code>char</code> ' ').
@@ -2178,7 +2179,7 @@
 	 * (value is 1&lt;&lt;16).
 	 */
 	public static final int ALT = 1 << 16;
-					
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the SHIFT key
 	 * was pushed on the keyboard when the event was generated
@@ -2185,7 +2186,7 @@
 	 * (value is 1&lt;&lt;17).
 	 */
 	public static final int SHIFT = 1 << 17;
-					
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the CTRL key
 	 * was pushed on the keyboard when the event was generated
@@ -2204,27 +2205,27 @@
 	 * Keyboard and/or mouse event mask indicating that the COMMAND key
 	 * was pushed on the keyboard when the event was generated
 	 * (value is 1&lt;&lt;22).
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int COMMAND = 1 << 22;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating all possible
 	 * keyboard modifiers.
-	 * 
-	 * To allow for the future, this mask  is intended to be used in 
-	 * place of code that references  each individual keyboard mask. 
-	 *  For example, the following expression will determine whether 
-	 * any modifier is pressed and will continue to work as new modifier 
+	 *
+	 * To allow for the future, this mask  is intended to be used in
+	 * place of code that references  each individual keyboard mask.
+	 *  For example, the following expression will determine whether
+	 * any modifier is pressed and will continue to work as new modifier
 	 * masks are added.
-	 * 
+	 *
  	 * <code>(stateMask & SWT.MODIFIER_MASK) != 0</code>.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MODIFIER_MASK;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button one
 	 * was pushed when the event was generated. (value is 1&lt;&lt;19).
@@ -2246,7 +2247,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button four
 	 * was pushed when the event was generated. (value is 1&lt;&lt;23).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int BUTTON4 = 1 << 23;
@@ -2254,7 +2255,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button five
 	 * was pushed when the event was generated. (value is 1&lt;&lt;25).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int BUTTON5 = 1 << 25;
@@ -2262,35 +2263,35 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating all possible
 	 * mouse buttons.
-	 * 
-	 * To allow for the future, this mask  is intended to be used 
-	 * in place of code that references each individual button mask.  
+	 *
+	 * To allow for the future, this mask  is intended to be used
+	 * in place of code that references each individual button mask.
 	 * For example, the following expression will determine whether
-	 * any button is pressed and will continue to work as new button 
+	 * any button is pressed and will continue to work as new button
 	 * masks are added.
-	 * 
+	 *
  	 * <code>(stateMask & SWT.BUTTON_MASK) != 0</code>.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int BUTTON_MASK;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD1 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * This is the primary keyboard modifier for the platform.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD1;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD2 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * This is the secondary keyboard modifier for the platform.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD2;
@@ -2298,7 +2299,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD3 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD3;
@@ -2306,17 +2307,17 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD4 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD4;
-	
+
 	/**
 	 * Constants to indicate line scrolling (value is 1).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int SCROLL_LINE = 1;
@@ -2326,46 +2327,46 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int SCROLL_PAGE = 2;
-	
+
 	/**
 	 * Accelerator constant used to differentiate a key code from a
 	 * unicode character.
-	 * 
+	 *
 	 * If this bit is set, then the key stroke
 	 * portion of an accelerator represents a key code.  If this bit
 	 * is not set, then the key stroke portion of an accelerator is
 	 * a unicode character.
-	 * 
+	 *
 	 * The following expression is false:
-	 * 
+	 *
 	 * <code>((SWT.MOD1 | SWT.MOD2 | 'T') & SWT.KEYCODE_BIT) != 0</code>.
-	 * 
+	 *
 	 * The following expression is true:
-	 * 
+	 *
 	 * <code>((SWT.MOD3 | SWT.F2) & SWT.KEYCODE_BIT) != 0</code>.
-	 * 
+	 *
 	 * (value is (1&lt;&lt;24))
-	 * 
+	 *
 	 * @since 2.1
-	 */	
+	 */
 	public static final int KEYCODE_BIT = (1 << 24);
 
 	/**
 	 * Accelerator constant used to extract the key stroke portion of
 	 * an accelerator.
-	 * 
+	 *
 	 * The key stroke may be a key code or a unicode
 	 * value.  If the key stroke is a key code <code>KEYCODE_BIT</code>
 	 * will be set.
-	 * 
+	 *
 	 * @since 2.1
-	 */	
+	 */
 	public static final int KEY_MASK = KEYCODE_BIT + 0xFFFF;
-	
+
 	/**
 	 * Keyboard event constant representing the UP ARROW key
 	 * (value is (1&lt;&lt;24)+1).
@@ -2425,67 +2426,67 @@
 	 * (value is (1&lt;&lt;24)+10).
 	 */
 	public static final int F1 = KEYCODE_BIT + 10;
-	
+
 	/**
 	 * Keyboard event constant representing the F2 key
 	 * (value is (1&lt;&lt;24)+11).
 	 */
 	public static final int F2 = KEYCODE_BIT + 11;
-	
+
 	/**
 	 * Keyboard event constant representing the F3 key
 	 * (value is (1&lt;&lt;24)+12).
 	 */
 	public static final int F3 = KEYCODE_BIT + 12;
-	
+
 	/**
 	 * Keyboard event constant representing the F4 key
 	 * (value is (1&lt;&lt;24)+13).
 	 */
 	public static final int F4 = KEYCODE_BIT + 13;
-	
+
 	/**
 	 * Keyboard event constant representing the F5 key
 	 * (value is (1&lt;&lt;24)+14).
 	 */
 	public static final int F5 = KEYCODE_BIT + 14;
-	
+
 	/**
 	 * Keyboard event constant representing the F6 key
 	 * (value is (1&lt;&lt;24)+15).
 	 */
 	public static final int F6 = KEYCODE_BIT + 15;
-	
+
 	/**
 	 * Keyboard event constant representing the F7 key
 	 * (value is (1&lt;&lt;24)+16).
 	 */
 	public static final int F7 = KEYCODE_BIT + 16;
-	
+
 	/**
 	 * Keyboard event constant representing the F8 key
 	 * (value is (1&lt;&lt;24)+17).
 	 */
 	public static final int F8 = KEYCODE_BIT + 17;
-	
+
 	/**
 	 * Keyboard event constant representing the F9 key
 	 * (value is (1&lt;&lt;24)+18).
 	 */
 	public static final int F9 = KEYCODE_BIT + 18;
-	
+
 	/**
 	 * Keyboard event constant representing the F10 key
 	 * (value is (1&lt;&lt;24)+19).
 	 */
 	public static final int F10 = KEYCODE_BIT + 19;
-	
+
 	/**
 	 * Keyboard event constant representing the F11 key
 	 * (value is (1&lt;&lt;24)+20).
 	 */
 	public static final int F11 = KEYCODE_BIT + 20;
-	
+
 	/**
 	 * Keyboard event constant representing the F12 key
 	 * (value is (1&lt;&lt;24)+21).
@@ -2495,27 +2496,27 @@
 	/**
 	 * Keyboard event constant representing the F13 key
 	 * (value is (1&lt;&lt;24)+22).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F13 = KEYCODE_BIT + 22;
-	
+
 	/**
 	 * Keyboard event constant representing the F14 key
 	 * (value is (1&lt;&lt;24)+23).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F14 = KEYCODE_BIT + 23;
-	
+
 	/**
 	 * Keyboard event constant representing the F15 key
 	 * (value is (1&lt;&lt;24)+24).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F15 = KEYCODE_BIT + 24;
-	
+
 	/**
 	 * Keyboard event constant representing the F16 key
 	 * (value is (1&lt;&lt;25)+25).
@@ -2570,23 +2571,23 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad multiply key (value is (1&lt;&lt;24)+42).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_MULTIPLY = KEYCODE_BIT + 42;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad add key (value is (1&lt;&lt;24)+43).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_ADD = KEYCODE_BIT + 43;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad subtract key (value is (1&lt;&lt;24)+45).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_SUBTRACT = KEYCODE_BIT + 45;
@@ -2594,7 +2595,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad decimal key (value is (1&lt;&lt;24)+46).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_DECIMAL = KEYCODE_BIT + 46;
@@ -2602,7 +2603,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad divide key (value is (1&lt;&lt;24)+47).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_DIVIDE = KEYCODE_BIT + 47;
@@ -2610,7 +2611,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad zero key (value is (1&lt;&lt;24)+48).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_0 = KEYCODE_BIT + 48;
@@ -2618,7 +2619,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad one key (value is (1&lt;&lt;24)+49).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_1 = KEYCODE_BIT + 49;
@@ -2626,7 +2627,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad two key (value is (1&lt;&lt;24)+50).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_2 = KEYCODE_BIT + 50;
@@ -2634,7 +2635,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad three key (value is (1&lt;&lt;24)+51).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_3 = KEYCODE_BIT + 51;
@@ -2642,23 +2643,23 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad four key (value is (1&lt;&lt;24)+52).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_4 = KEYCODE_BIT + 52;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad five key (value is (1&lt;&lt;24)+53).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_5 = KEYCODE_BIT + 53;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad six key (value is (1&lt;&lt;24)+54).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_6 = KEYCODE_BIT + 54;
@@ -2666,7 +2667,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad seven key (value is (1&lt;&lt;24)+55).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_7 = KEYCODE_BIT + 55;
@@ -2674,15 +2675,15 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad eight key (value is (1&lt;&lt;24)+56).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_8 = KEYCODE_BIT + 56;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad nine key (value is (1&lt;&lt;24)+57).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_9 = KEYCODE_BIT + 57;
@@ -2690,82 +2691,82 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad equal key (value is (1&lt;&lt;24)+61).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_EQUAL = KEYCODE_BIT + 61;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad enter key (value is (1&lt;&lt;24)+80).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_CR = KEYCODE_BIT + 80;
-	
+
 	/**
 	 * Keyboard event constant representing the help
 	 * key (value is (1&lt;&lt;24)+81).
-	 * 
+	 *
 	 * NOTE: The HELP key maps to the key labeled "help",
 	 * not "F1". If your keyboard does not have a HELP key,
 	 * you will never see this key press.  To listen for
 	 * help on a control, use SWT.Help.
-	 * 
+	 *
 	 * @since 3.0
-	 * 
+	 *
 	 * @see SWT#Help
 	 */
 	public static final int HELP = KEYCODE_BIT + 81;
-	
+
 	/**
 	 * Keyboard event constant representing the caps
 	 * lock key (value is (1&lt;&lt;24)+82).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int CAPS_LOCK = KEYCODE_BIT + 82;
-	
+
 	/**
 	 * Keyboard event constant representing the num
 	 * lock key (value is (1&lt;&lt;24)+83).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int NUM_LOCK = KEYCODE_BIT + 83;
-	
+
 	/**
 	 * Keyboard event constant representing the scroll
 	 * lock key (value is (1&lt;&lt;24)+84).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int SCROLL_LOCK = KEYCODE_BIT + 84;
-	
+
 	/**
 	 * Keyboard event constant representing the pause
 	 * key (value is (1&lt;&lt;24)+85).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PAUSE = KEYCODE_BIT + 85;
-	
+
 	/**
 	 * Keyboard event constant representing the break
 	 * key (value is (1&lt;&lt;24)+86).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int BREAK = KEYCODE_BIT + 86;
-	
+
 	/**
 	 * Keyboard event constant representing the print screen
 	 * key (value is (1&lt;&lt;24)+87).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PRINT_SCREEN = KEYCODE_BIT + 87;
-	
+
 	/**
 	 * The <code>MessageBox</code> style constant for error icon
 	 * behavior (value is 1).
@@ -2795,7 +2796,7 @@
 	 * behavior (value is 1&lt;&lt;4).
 	 */
 	public static final int ICON_WORKING = 1 << 4;
-	
+
 	/**
 	 * The style constant for "search" icon. This style constant is 
 	 * used with <code>Text</code> in combination with <code>SWT.SEARCH
@@ -2856,7 +2857,7 @@
 	 * The <code>MessageBox</code> style constant for a CANCEL button;
 	 * valid combinations are OK|CANCEL, YES|NO|CANCEL, RETRY|CANCEL
 	 * (value is 1&lt;&lt;8).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>MessageBox</code></li>
 	 * </ul></p>
@@ -2904,7 +2905,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_NONE = 0;
-	
+
 	/**
 	 * The <code>Composite</code> constant to indicate that
 	 * an attribute (such as background) is inherited by
@@ -2916,7 +2917,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_DEFAULT = 1;
-	
+
 	/**
 	 * The <code>Composite</code> constant to indicate that
 	 * an attribute (such as background) is inherited by
@@ -2925,7 +2926,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_FORCE = 2;
-	
+
 	/**
 	 * Default color white (value is 1).
 	 */
@@ -3005,7 +3006,7 @@
 	 * Default color dark gray (value is 16).
 	 */
 	public static final int COLOR_DARK_GRAY = 16;
-	
+
 	/*
 	 * System Colors
 	 *
@@ -3021,7 +3022,7 @@
 	 *	It is expected that the list of supported colors
 	 * will grow over time.
 	 */
-	
+
 	/**
 	 * System color used to paint dark shadow areas (value is 17).
 	 */
@@ -3086,7 +3087,7 @@
 	 * System color used to paint tooltip background areas (value is 29).
 	 */
 	public static final int COLOR_INFO_BACKGROUND = 29;
-	
+
 	/**
 	 * System color used to paint title text (value is 30).
 	 */
@@ -3101,7 +3102,7 @@
 	 * System color used to paint title background gradient (value is 32).
 	 */
 	public static final int COLOR_TITLE_BACKGROUND_GRADIENT = 32;
-	
+
 	/**
 	 * System color used to paint inactive title text (value is 33).
 	 */
@@ -3116,7 +3117,7 @@
 	 * System color used to paint inactive title background gradient (value is 35).
 	 */
 	public static final int COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT = 35;
-	
+
 	/**
 	 * Draw constant indicating whether the drawing operation
 	 * should fill the background (value is 1&lt;&lt;0).
@@ -3139,13 +3140,13 @@
 	 * Draw constant indicating whether the string drawing operation
 	 * should handle mnemonics (value is 1&lt;&lt;3).
 	 */
-	public static final int DRAW_MNEMONIC = 1 << 3;	
+	public static final int DRAW_MNEMONIC = 1 << 3;
 
-	
+
 	/**
-	 * Selection constant indicating that a line delimiter should be 
+	 * Selection constant indicating that a line delimiter should be
 	 * drawn (value is 1&lt;&lt;17).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
@@ -3152,80 +3153,80 @@
 	 *
 	 * @see #FULL_SELECTION
 	 * @see #LAST_LINE_SELECTION
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int DELIMITER_SELECTION = 1 << 17;
-	
+
 	/**
 	 * Selection constant indicating that the last line is selected
-	 * to the end and should be drawn using either a line delimiter 
+	 * to the end and should be drawn using either a line delimiter
 	 * or full line selection (value is 1&lt;&lt;20).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @see #DELIMITER_SELECTION
 	 * @see #FULL_SELECTION
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int LAST_LINE_SELECTION = 1 << 20;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no error number was specified
 	 * (value is 1).
 	 */
 	public static final int ERROR_UNSPECIFIED = 1;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no more handles for an
 	 * operating system resource are available
 	 * (value is 2).
 	 */
 	public static final int ERROR_NO_HANDLES = 2;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no more callback resources are available
 	 * (value is 3).
 	 */
 	public static final int ERROR_NO_MORE_CALLBACKS = 3;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a null argument was passed in
-	 * (value is 4). 
+	 * (value is 4).
 	 */
 	public static final int ERROR_NULL_ARGUMENT = 4;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an invalid argument was passed in
 	 * (value is 5).
 	 */
 	public static final int ERROR_INVALID_ARGUMENT = 5;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a value was found to be
 	 * outside the allowable range
 	 * (value is 6).
 	 */
 	public static final int ERROR_INVALID_RANGE = 6;
-	
-	/** 
-	 * SWT error constant indicating that a value which can not be 
+
+	/**
+	 * SWT error constant indicating that a value which can not be
 	 * zero was found to be
 	 * (value is 7).
 	 */
 	public static final int ERROR_CANNOT_BE_ZERO = 7;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the value of an item
 	 * (value is 8).
 	 */
 	public static final int ERROR_CANNOT_GET_ITEM = 8;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the selection
 	 * (value is 9).
@@ -3232,15 +3233,15 @@
 	 */
 	public static final int ERROR_CANNOT_GET_SELECTION = 9;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the matrix is not invertible
 	 * (value is 10).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_CANNOT_INVERT_MATRIX = 10;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the height of an item
 	 * (value is 11).
@@ -3247,7 +3248,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_ITEM_HEIGHT = 11;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the text of a widget
 	 * (value is 12).
@@ -3254,7 +3255,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_TEXT = 12;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the text of a widget
 	 * (value is 13).
@@ -3261,7 +3262,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_TEXT = 13;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to add an item
 	 * (value is 14).
@@ -3268,7 +3269,7 @@
 	 */
 	public static final int ERROR_ITEM_NOT_ADDED = 14;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to remove an item
 	 * (value is 15).
@@ -3275,7 +3276,7 @@
 	 */
 	public static final int ERROR_ITEM_NOT_REMOVED = 15;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the graphics library
 	 * is not available
 	 * (value is 16).
@@ -3282,7 +3283,7 @@
 	 */
 	public static final int ERROR_NO_GRAPHICS_LIBRARY = 16;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a particular feature has
 	 * not been implemented on this platform
 	 * (value is 20).
@@ -3289,7 +3290,7 @@
 	 */
 	public static final int ERROR_NOT_IMPLEMENTED = 20;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the drop down style had some other style instead
 	 * (value is 21).
@@ -3296,7 +3297,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_DROP_DOWN = 21;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation which can only be executed by the
 	 * user-interface thread from some other thread
@@ -3304,15 +3305,15 @@
 	 */
 	public static final int ERROR_THREAD_INVALID_ACCESS = 22;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a widget which had already
 	 * been disposed
-	 * (value is 24). 
+	 * (value is 24).
 	 */
 	public static final int ERROR_WIDGET_DISPOSED = 24;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu item which needed
 	 * to have the cascade style had some other style instead
 	 * (value is 27).
@@ -3319,7 +3320,7 @@
 	 */
 	public static final int ERROR_MENUITEM_NOT_CASCADE = 27;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the selection of a widget
 	 * (value is 28).
@@ -3326,7 +3327,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_SELECTION = 28;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the menu
 	 * (value is 29).
@@ -3333,7 +3334,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_MENU = 29;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the enabled state
 	 * (value is 30).
@@ -3340,7 +3341,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_ENABLED = 30;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide enabled/disabled state information
 	 * (value is 31).
@@ -3347,14 +3348,14 @@
 	 */
 	public static final int ERROR_CANNOT_GET_ENABLED = 31;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a provided widget can
 	 * not be used as a parent in the current operation
 	 * (value is 32).
 	 */
 	public static final int ERROR_INVALID_PARENT = 32;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the menu bar style had some other style instead
 	 * (value is 33).
@@ -3361,7 +3362,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_BAR = 33;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide count information
 	 * (value is 36).
@@ -3368,7 +3369,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_COUNT = 36;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the pop up menu style had some other style instead
 	 * (value is 37).
@@ -3375,7 +3376,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_POP_UP = 37;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image of an unsupported depth
 	 * (value is 38).
@@ -3382,7 +3383,7 @@
 	 */
 	public static final int ERROR_UNSUPPORTED_DEPTH = 38;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an input/output operation
 	 * failed during the execution of an SWT operation
 	 * (value is 39).
@@ -3389,7 +3390,7 @@
 	 */
 	public static final int ERROR_IO = 39;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image having an invalid format
 	 * (value is 40).
@@ -3396,7 +3397,7 @@
 	 */
 	public static final int ERROR_INVALID_IMAGE = 40;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image having a valid but unsupported
 	 * format
@@ -3404,13 +3405,13 @@
 	 */
 	public static final int ERROR_UNSUPPORTED_FORMAT = 42;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made
 	 * to subclass an SWT widget class without implementing the
 	 * <code>checkSubclass()</code> method
 	 * (value is 43).
-	 * 
-	 * For additional information see the comment in 
+	 *
+	 * For additional information see the comment in
 	 * <code>Widget.checkSubclass()</code>.
 	 *
 	 * @see org.eclipse.swt.widgets.Widget#checkSubclass
@@ -3417,7 +3418,7 @@
 	 */
 	public static final int ERROR_INVALID_SUBCLASS = 43;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a graphics object which had
 	 * already been disposed
@@ -3424,40 +3425,40 @@
 	 * (value is 44).
 	 */
 	public static final int ERROR_GRAPHIC_DISPOSED = 44;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a device which had already
 	 * been disposed
-	 * (value is 45). 
+	 * (value is 45).
 	 */
 	public static final int ERROR_DEVICE_DISPOSED = 45;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an exception happened
 	 * when executing a runnable
 	 * (value is 46).
 	 */
 	public static final int ERROR_FAILED_EXEC = 46;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an unsatisfied link
 	 * error occurred while attempting to load a library
 	 * (value is 47).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_FAILED_LOAD_LIBRARY = 47;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a font is not valid
 	 * (value is 48).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_INVALID_FONT = 48;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * use an BrowserFunction object which had already been disposed
 	 * (value is 49).
@@ -3485,12 +3486,12 @@
 
 	/**
 	 * Constant indicating that an image or operation is of type bitmap  (value is 0).
-	 */	
+	 */
 	public static final int BITMAP = 0;
 
 	/**
 	 * Constant indicating that an image or operation is of type icon  (value is 1).
-	 */	
+	 */
 	public static final int ICON = 1;
 
 	/**
@@ -3497,7 +3498,7 @@
 	 * The <code>Image</code> constructor argument indicating that
 	 * the new image should be a copy of the image provided as
 	 * an argument  (value is 0).
-	 */	
+	 */
 	public static final int IMAGE_COPY = 0;
 
 	/**
@@ -3505,36 +3506,36 @@
 	 * the new image should have the appearance of a "disabled"
 	 * (using the platform's rules for how this should look)
 	 * copy of the image provided as an argument  (value is 1).
-	 */	
+	 */
 	public static final int IMAGE_DISABLE = 1;
-	
+
 	/**
 	 * The <code>Image</code> constructor argument indicating that
 	 * the new image should have the appearance of a "gray scaled"
 	 * copy of the image provided as an argument  (value is 2).
-	 */	
+	 */
 	public static final int IMAGE_GRAY = 2;
-	
+
 	/**
 	 * Constant to indicate an error state (value is 1).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>ProgressBar</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int ERROR = 1;
-	
+
 	/**
 	 * Constant to a indicate a paused state (value is 4).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>ProgressBar</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int PAUSED = 1 << 2;
-	
+
 	/**
 	 * The font style constant indicating a normal weight, non-italic font
 	 * (value is 0). This constant is also used with <code>ProgressBar</code>
@@ -3544,135 +3545,135 @@
 	 * </ul></p>
 	 */
 	public static final int NORMAL = 0;
-	
+
 	/**
 	 * The font style constant indicating a bold weight font
 	 * (value is 1&lt;&lt;0).
 	 */
 	public static final int BOLD = 1 << 0;
-	
+
 	/**
 	 * The font style constant indicating an italic font
 	 * (value is 1&lt;&lt;1).
 	 */
 	public static final int ITALIC = 1 << 1;
-		
+
 	/**
 	 * System arrow cursor  (value is 0).
 	 */
 	public static final int CURSOR_ARROW = 0;
-		
+
 	/**
 	 * System wait cursor  (value is 1).
 	 */
 	public static final int CURSOR_WAIT = 1;
-		
+
 	/**
 	 * System cross hair cursor  (value is 2).
 	 */
 	public static final int CURSOR_CROSS = 2;
-		
+
 	/**
 	 * System app startup cursor  (value is 3).
 	 */
 	public static final int CURSOR_APPSTARTING = 3;
-		
+
 	/**
 	 * System help cursor  (value is 4).
 	 */
 	public static final int CURSOR_HELP = 4;
-		
+
 	/**
 	 * System resize all directions cursor (value is 5).
 	 */
 	public static final int CURSOR_SIZEALL = 5;
-		
+
 	/**
 	 * System resize north-east-south-west cursor  (value is 6).
 	 */
 	public static final int CURSOR_SIZENESW = 6;
-		
+
 	/**
 	 * System resize north-south cursor  (value is 7).
 	 */
 	public static final int CURSOR_SIZENS = 7;
-		
+
 	/**
 	 * System resize north-west-south-east cursor  (value is 8).
 	 */
 	public static final int CURSOR_SIZENWSE = 8;
-		
+
 	/**
 	 * System resize west-east cursor  (value is 9).
 	 */
 	public static final int CURSOR_SIZEWE = 9;
-		
+
 	/**
 	 * System resize north cursor  (value is 10).
 	 */
 	public static final int CURSOR_SIZEN = 10;
-		
+
 	/**
 	 * System resize south cursor  (value is 11).
 	 */
 	public static final int CURSOR_SIZES = 11;
-		
+
 	/**
 	 * System resize east cursor  (value is 12).
 	 */
 	public static final int CURSOR_SIZEE = 12;
-		
+
 	/**
 	 * System resize west cursor  (value is 13).
 	 */
 	public static final int CURSOR_SIZEW = 13;
-		
+
 	/**
 	 * System resize north-east cursor (value is 14).
 	 */
 	public static final int CURSOR_SIZENE = 14;
-		
+
 	/**
 	 * System resize south-east cursor (value is 15).
 	 */
 	public static final int CURSOR_SIZESE = 15;
-		
+
 	/**
 	 * System resize south-west cursor (value is 16).
 	 */
 	public static final int CURSOR_SIZESW = 16;
-		
+
 	/**
 	 * System resize north-west cursor (value is 17).
 	 */
 	public static final int CURSOR_SIZENW = 17;
-		
+
 	/**
 	 * System up arrow cursor  (value is 18).
 	 */
 	public static final int CURSOR_UPARROW = 18;
-		
+
 	/**
 	 * System i-beam cursor (value is 19).
 	 */
 	public static final int CURSOR_IBEAM = 19;
-		
+
 	/**
 	 * System "not allowed" cursor (value is 20).
 	 */
 	public static final int CURSOR_NO = 20;
-		
+
 	/**
 	 * System hand cursor (value is 21).
 	 */
 	public static final int CURSOR_HAND = 21;
-		
+
 	/**
 	 * Line drawing style for flat end caps (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_FLAT = 1;
@@ -3679,10 +3680,10 @@
 
 	/**
 	 * Line drawing style for rounded end caps (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_ROUND = 2;
@@ -3689,10 +3690,10 @@
 
 	/**
 	 * Line drawing style for square end caps (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_SQUARE = 3;
@@ -3699,10 +3700,10 @@
 
 	/**
 	 * Line drawing style for miter joins (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_MITER = 1;
@@ -3709,10 +3710,10 @@
 
 	/**
 	 * Line drawing  style for rounded joins (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_ROUND = 2;
@@ -3719,10 +3720,10 @@
 
 	/**
 	 * Line drawing style for bevel joins (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_BEVEL = 3;
@@ -3731,22 +3732,22 @@
 	 * Line drawing style for solid lines  (value is 1).
 	 */
 	public static final int LINE_SOLID = 1;
-		
+
 	/**
 	 * Line drawing style for dashed lines (value is 2).
 	 */
 	public static final int LINE_DASH = 2;
-		
+
 	/**
 	 * Line drawing style for dotted lines (value is 3).
 	 */
 	public static final int LINE_DOT = 3;
-		
+
 	/**
 	 * Line drawing style for alternating dash-dot lines (value is 4).
 	 */
 	public static final int LINE_DASHDOT = 4;
-		
+
 	/**
 	 * Line drawing style for dash-dot-dot lines (value is 5).
 	 */
@@ -3754,17 +3755,17 @@
 
 	/**
 	 * Line drawing style for custom dashed lines (value is 6).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineDash(int[])
 	 * @see org.eclipse.swt.graphics.GC#getLineDash()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int LINE_CUSTOM = 6;
-	
+
 	/**
 	 * Path constant that represents a "move to" operation (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_MOVE_TO = 1;
@@ -3771,7 +3772,7 @@
 
 	/**
 	 * Path constant that represents a "line to" operation (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_LINE_TO = 2;
@@ -3778,7 +3779,7 @@
 
 	/**
 	 * Path constant that represents a "quadratic curve to" operation (value is 3).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_QUAD_TO = 3;
@@ -3785,7 +3786,7 @@
 
 	/**
 	 * Path constant that represents a "cubic curve to" operation (value is 4).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_CUBIC_TO = 4;
@@ -3792,7 +3793,7 @@
 
 	/**
 	 * Path constant that represents a "close" operation (value is 5).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_CLOSE = 5;
@@ -3799,7 +3800,7 @@
 
 	/**
 	 * Even odd rule for filling operations (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int FILL_EVEN_ODD = 1;
@@ -3806,7 +3807,7 @@
 
 	/**
 	 * Winding rule for filling operations (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int FILL_WINDING = 2;
@@ -3822,7 +3823,7 @@
 	public static final int IMAGE_BMP = 0;
 
 	/**
-	 * Image format constant indicating a run-length encoded 
+	 * Image format constant indicating a run-length encoded
 	 * Windows BMP format image (value is 1).
 	 */
 	public static final int IMAGE_BMP_RLE = 1;
@@ -3865,7 +3866,7 @@
 
 	/**
 	 * GIF image disposal method constants indicating that the
-	 * disposal method is to do nothing; that is, to leave the 
+	 * disposal method is to do nothing; that is, to leave the
 	 * previous image in place (value is 1).
 	 */
 	public static final int DM_FILL_NONE = 0x1;
@@ -3883,25 +3884,25 @@
 	 * (value is 3).
 	 */
 	public static final int DM_FILL_PREVIOUS = 0x3;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains no transparency information (value is 0).
 	 */
 	public static final int TRANSPARENCY_NONE = 0x0;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains alpha transparency information (value is 1&lt;&lt;0).
 	 */
 	public static final int TRANSPARENCY_ALPHA = 1 << 0;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains a transparency mask (value is 1&lt;&lt;1).
 	 */
 	public static final int TRANSPARENCY_MASK = 1 << 1;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains a transparent pixel (value is 1&lt;&lt;2).
@@ -3911,24 +3912,24 @@
 	/**
 	 * The character movement type (value is 1&lt;&lt;0).
 	 * This constant is used to move a text offset over a character.
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
-	 */	
+	 */
 	public static final int MOVEMENT_CHAR = 1 << 0;
 
 	/**
 	 * The cluster movement type (value is 1&lt;&lt;1).
 	 * This constant is used to move a text offset over a cluster.
-	 * A cluster groups one or more characters. A cluster is 
+	 * A cluster groups one or more characters. A cluster is
 	 * undivisible, this means that a caret offset can not be placed in the
-	 * middle of a cluster.  
-	 * 
+	 * middle of a cluster.
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int MOVEMENT_CLUSTER = 1 << 1;
@@ -3936,42 +3937,42 @@
 	/**
 	 * The word movement type (value is 1&lt;&lt;2).
 	 * This constant is used to move a text offset over a word.
-	 * The behavior of this constant depends on the platform and on the 
-	 * direction of the movement. For example, on Windows the stop is 
-	 * always at the start of the word. On GTK and Mac the stop is at the end 
-	 * of the word if the direction is next and at the start of the word if the 
+	 * The behavior of this constant depends on the platform and on the
+	 * direction of the movement. For example, on Windows the stop is
+	 * always at the start of the word. On GTK and Mac the stop is at the end
+	 * of the word if the direction is next and at the start of the word if the
 	 * direction is previous.
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
-	 */	
+	 */
 	public static final int MOVEMENT_WORD = 1 << 2;
 
 	/**
 	 * The word end movement type (value is 1&lt;&lt;3).
 	 * This constant is used to move a text offset to the next or previous
-	 * word end. The behavior of this constant does not depend on the platform.  
-	 * 
-	 * 
+	 * word end. The behavior of this constant does not depend on the platform.
+	 *
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.3
-	 */	
+	 */
 	public static final int MOVEMENT_WORD_END = 1 << 3;
 
 	/**
 	 * The word start movement type (value is 1&lt;&lt;4).
 	 * This constant is used to move a text offset to the next or previous
-	 * word start. The behavior of this constant does not depend on the platform.  
-	 * 
+	 * word start. The behavior of this constant does not depend on the platform.
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.3
-	 */	
+	 */
 	public static final int MOVEMENT_WORD_START = 1 << 4;
 
 	/**
@@ -4068,7 +4069,7 @@
 	 */
 	public static final String SKIN_ID = "org.eclipse.swt.skin.id";
 
-	
+
 /**
  * Answers a concise, human readable description of the error code.
  *
@@ -4127,10 +4128,10 @@
 
 /**
  * Returns the NLS'ed message for the given argument.
- * 
+ *
  * @param key the key to look up
  * @return the message for the given key
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the key is null</li>
  * </ul>
@@ -4138,7 +4139,7 @@
 public static String getMessage(String key) {
 	return Compatibility.getMessage(key);
 }
-	
+
 /**
  * Returns the SWT platform name.
  * Examples: "win32", "motif", "gtk", "photon", "carbon", "cocoa", "wpf"
@@ -4149,7 +4150,19 @@
 	return Platform.PLATFORM;
 }
 
+// <QFS>
 /**
+ * Returns the SWT platform name including architecture.
+ * Examples: "win32", "motif", "gtk", "gtk-64", "photon", "carbon"
+ *
+ * @return the SWT platform name
+ */
+public static String getPlatformAndArch () {
+    return "win32-64";
+}
+// </QFS>
+
+/**
  * Returns the SWT version number as an integer.
  * Example: "SWT051" == 51
  *
@@ -4222,7 +4235,7 @@
  * @see SWTError
  * @see SWTException
  * @see IllegalArgumentException
- * 
+ *
  * @since 3.0
  */
 public static void error (int code, Throwable throwable, String detail) {
@@ -4229,7 +4242,7 @@
 
 	/*
 	* This code prevents the creation of "chains" of SWTErrors and
-	* SWTExceptions which in turn contain other SWTErrors and 
+	* SWTExceptions which in turn contain other SWTErrors and
 	* SWTExceptions as their throwable. This can occur when low level
 	* code throws an exception past a point where a higher layer is
 	* being "safe" and catching all exceptions. (Note that, this is
@@ -4237,7 +4250,7 @@
 	*
 	* On the theory that the low level code is closest to the
 	* original problem, we simply re-throw the original exception here.
-	* 
+	*
 	* NOTE: Exceptions thrown in syncExec and asyncExec must be
 	* wrapped.
 	*/
@@ -4249,9 +4262,9 @@
 	String message = findErrorText (code);
 	if (detail != null) message += detail;
 	switch (code) {
-		
+
 		/* Illegal Arguments (non-fatal) */
-		case ERROR_NULL_ARGUMENT: 
+		case ERROR_NULL_ARGUMENT:
 		case ERROR_CANNOT_BE_ZERO:
 		case ERROR_INVALID_ARGUMENT:
 		case ERROR_MENU_NOT_BAR:
@@ -4258,11 +4271,11 @@
 		case ERROR_MENU_NOT_DROP_DOWN:
 		case ERROR_MENU_NOT_POP_UP:
 		case ERROR_MENUITEM_NOT_CASCADE:
-		case ERROR_INVALID_PARENT: 		
+		case ERROR_INVALID_PARENT:
 		case ERROR_INVALID_RANGE: {
 			throw new IllegalArgumentException (message);
 		}
-		
+
 		/* SWT Exceptions (non-fatal) */
 		case ERROR_INVALID_SUBCLASS:
 		case ERROR_THREAD_INVALID_ACCESS:
@@ -4283,7 +4296,7 @@
 			exception.throwable = throwable;
 			throw exception;
 		}
-		
+
 		/* Operation System Errors (fatal, may occur only on some platforms) */
 		case ERROR_CANNOT_GET_COUNT:
 		case ERROR_CANNOT_GET_ENABLED:
@@ -4299,7 +4312,7 @@
 		case ERROR_ITEM_NOT_REMOVED:
 		case ERROR_NO_HANDLES:
 		//FALL THROUGH
-		
+
 		/* SWT Errors (fatal, may occur only on some platforms) */
 		case ERROR_FAILED_LOAD_LIBRARY:
 		case ERROR_NO_MORE_CALLBACKS:
@@ -4310,7 +4323,7 @@
 			throw error;
 		}
 	}
-	
+
 	/* Unknown/Undefined Error */
 	SWTError error = new SWTError (code, message);
 	error.throwable = throwable;
@@ -4325,7 +4338,7 @@
 	*/
 	BUTTON_MASK = BUTTON1 | BUTTON2 | BUTTON3 | BUTTON4 | BUTTON5;
 	MODIFIER_MASK = ALT | SHIFT | CTRL | COMMAND;
-	
+
 	/*
 	* These values can be different on different platforms.
 	* Therefore they are not initialized in the declaration
Index: org/eclipse/swt/graphics/TextStyle.java
===================================================================
--- org/eclipse/swt/graphics/TextStyle.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/graphics/TextStyle.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -138,8 +138,8 @@
 	 * @since 3.2
 	 */	
 	public int rise;
+
 	
-	
 	/**
 	 * the data. An user data field. It can be used to hold the HREF when the range 
 	 * is used as a link or the embed object when the range is used with <code>GlyphMetrics</code>.
Index: org/eclipse/swt/graphics/Cursor.java
===================================================================
--- org/eclipse/swt/graphics/Cursor.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Cursor.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -387,8 +387,8 @@
 		hMask = OS.CreateBitmap(source.width, source.height, 1, 1, new byte[(((source.width + 7) / 8) + 3) / 4 * 4 * source.height]);
 		if (hMask == 0) SWT.error(SWT.ERROR_NO_HANDLES);
 	} else {
-		ImageData mask = source.getTransparencyMask();
-		long /*int*/ [] result = Image.init(this.device, null, source, mask);
+	ImageData mask = source.getTransparencyMask();
+	long /*int*/ [] result = Image.init(this.device, null, source, mask);
 		hBitmap = result[0];
 		hMask = result[1];
 	}
Index: org/eclipse/swt/graphics/Image.java
===================================================================
--- org/eclipse/swt/graphics/Image.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Image.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -666,75 +666,75 @@
 						if (lockedBitmapData != 0) {
 							status = Gdip.Bitmap_LockBits(bitmap, 0, 0, pixelFormat, lockedBitmapData);
 							if (status == 0) {
-								BitmapData bitmapData = new BitmapData();
-								Gdip.MoveMemory(bitmapData, lockedBitmapData);
-								int stride = bitmapData.Stride;
-								long /*int*/ pixels = bitmapData.Scan0;
-								int depth = 0, scanlinePad = 4, transparentPixel = -1;
+							BitmapData bitmapData = new BitmapData();
+							Gdip.MoveMemory(bitmapData, lockedBitmapData);
+							int stride = bitmapData.Stride;
+							long /*int*/ pixels = bitmapData.Scan0;
+							int depth = 0, scanlinePad = 4, transparentPixel = -1;
+							switch (bitmapData.PixelFormat) {
+								case Gdip.PixelFormat1bppIndexed: depth = 1; break;
+								case Gdip.PixelFormat4bppIndexed: depth = 4; break;
+								case Gdip.PixelFormat8bppIndexed: depth = 8; break;
+								case Gdip.PixelFormat16bppARGB1555:
+								case Gdip.PixelFormat16bppRGB555:
+								case Gdip.PixelFormat16bppRGB565: depth = 16; break;
+								case Gdip.PixelFormat24bppRGB: depth = 24; break;
+								case Gdip.PixelFormat32bppRGB:
+								case Gdip.PixelFormat32bppARGB: depth = 32; break;
+							}
+							if (depth != 0) {
+								PaletteData paletteData = null;
 								switch (bitmapData.PixelFormat) {
-									case Gdip.PixelFormat1bppIndexed: depth = 1; break;
-									case Gdip.PixelFormat4bppIndexed: depth = 4; break;
-									case Gdip.PixelFormat8bppIndexed: depth = 8; break;
+									case Gdip.PixelFormat1bppIndexed:
+									case Gdip.PixelFormat4bppIndexed:
+									case Gdip.PixelFormat8bppIndexed:
+										int paletteSize = Gdip.Image_GetPaletteSize(bitmap);
+										long /*int*/ hHeap = OS.GetProcessHeap();
+										long /*int*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);
+										if (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);
+										Gdip.Image_GetPalette(bitmap, palette, paletteSize);
+										ColorPalette colorPalette = new ColorPalette();
+										Gdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);
+										int[] entries = new int[colorPalette.Count];
+										OS.MoveMemory(entries, palette + 8, entries.length * 4);
+										OS.HeapFree(hHeap, 0, palette);
+										RGB[] rgbs = new RGB[colorPalette.Count];
+										paletteData = new PaletteData(rgbs);
+										for (int i = 0; i < entries.length; i++) {
+											if (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {
+												transparentPixel = i;
+											}
+											rgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));
+										}
+										break;
 									case Gdip.PixelFormat16bppARGB1555:
-									case Gdip.PixelFormat16bppRGB555:
-									case Gdip.PixelFormat16bppRGB565: depth = 16; break;
-									case Gdip.PixelFormat24bppRGB: depth = 24; break;
+									case Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;
+									case Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;
+									case Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;
 									case Gdip.PixelFormat32bppRGB:
-									case Gdip.PixelFormat32bppARGB: depth = 32; break;
+									case Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;
 								}
-								if (depth != 0) {
-									PaletteData paletteData = null;
-									switch (bitmapData.PixelFormat) {
-										case Gdip.PixelFormat1bppIndexed:
-										case Gdip.PixelFormat4bppIndexed:
-										case Gdip.PixelFormat8bppIndexed:
-											int paletteSize = Gdip.Image_GetPaletteSize(bitmap);
-											long /*int*/ hHeap = OS.GetProcessHeap();
-											long /*int*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);
-											if (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);
-											Gdip.Image_GetPalette(bitmap, palette, paletteSize);
-											ColorPalette colorPalette = new ColorPalette();
-											Gdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);
-											int[] entries = new int[colorPalette.Count];
-											OS.MoveMemory(entries, palette + 8, entries.length * 4);
-											OS.HeapFree(hHeap, 0, palette);
-											RGB[] rgbs = new RGB[colorPalette.Count];
-											paletteData = new PaletteData(rgbs);
-											for (int i = 0; i < entries.length; i++) {
-												if (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {
-													transparentPixel = i;
-												}
-												rgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));
-											}
-											break;
-										case Gdip.PixelFormat16bppARGB1555:
-										case Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;
-										case Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;
-										case Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;
-										case Gdip.PixelFormat32bppRGB:
-										case Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;
-									}
-									byte[] data = new byte[stride * height], alphaData = null;
-									OS.MoveMemory(data, pixels, data.length);
-									switch (bitmapData.PixelFormat) {
-										case Gdip.PixelFormat16bppARGB1555:
-							 		 		alphaData = new byte[width * height];
-							 		 		for (int i = 1, j = 0; i < data.length; i += 2, j++) {
-							 		 			alphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);
-							 		 		}
-											break;
-										case Gdip.PixelFormat32bppARGB:
-							 		 		alphaData = new byte[width * height];
-							 		 		for (int i = 3, j = 0; i < data.length; i += 4, j++) {
-							 		 			alphaData[j] = data[i];
-							 		 		}
-											break;
-									}
-									ImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);
-									img.transparentPixel = transparentPixel;
-									img.alphaData = alphaData;
-									init(img);
+								byte[] data = new byte[stride * height], alphaData = null;
+								OS.MoveMemory(data, pixels, data.length);
+								switch (bitmapData.PixelFormat) {
+									case Gdip.PixelFormat16bppARGB1555:
+						 		 		alphaData = new byte[width * height];
+						 		 		for (int i = 1, j = 0; i < data.length; i += 2, j++) {
+						 		 			alphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);
+						 		 		}
+										break;
+									case Gdip.PixelFormat32bppARGB:
+						 		 		alphaData = new byte[width * height];
+						 		 		for (int i = 3, j = 0; i < data.length; i += 4, j++) {
+						 		 			alphaData[j] = data[i];
+						 		 		}
+										break;
 								}
+								ImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);
+								img.transparentPixel = transparentPixel;
+								img.alphaData = alphaData;
+								init(img);
+							}
 				 		 		Gdip.Bitmap_UnlockBits(bitmap, lockedBitmapData);
 							} else {
 								error = SWT.ERROR_INVALID_IMAGE;								
@@ -2016,7 +2016,7 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data
+ * @param data the platform specific GC data 
  * 
  * @noreference This method is not intended to be referenced by clients.
  */
Index: org/eclipse/swt/graphics/TextLayout.java
===================================================================
--- org/eclipse/swt/graphics/TextLayout.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/graphics/TextLayout.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -247,21 +247,21 @@
 	for (int i=0; i<allRuns.length - 1; i++) {
 		StyleItem run = allRuns[i];
 		if (tabs != null && run.tab) {
-			int tabsLength = tabs.length, j;
-			for (j = 0; j < tabsLength; j++) {
-				if (tabs[j] > lineWidth) {
-					run.width = tabs[j] - lineWidth;
-					break;
-				}
-			}
-			if (j == tabsLength) {
-				int tabX = tabs[tabsLength-1];
-				int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
-				if (lastTabWidth > 0) {
-					while (tabX <= lineWidth) tabX += lastTabWidth;
-					run.width = tabX - lineWidth;
-				}
-			}
+					int tabsLength = tabs.length, j;
+					for (j = 0; j < tabsLength; j++) {
+						if (tabs[j] > lineWidth) {
+							run.width = tabs[j] - lineWidth;
+							break;
+						}
+					}
+					if (j == tabsLength) {
+						int tabX = tabs[tabsLength-1];
+						int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
+						if (lastTabWidth > 0) {
+							while (tabX <= lineWidth) tabX += lastTabWidth;
+							run.width = tabX - lineWidth;
+						}
+					}
 			int length = run.length;
 			if (length > 1) {
 				int stop = j + length - 1;
@@ -271,7 +271,7 @@
 					if (j < tabsLength) {
 						run.width += tabs[tabsLength - 1] - tabs[j];
 						length -= (tabsLength - 1) - j;
-					}
+				}
 					int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
 					run.width += lastTabWidth * (length - 1);
 				}
@@ -657,8 +657,8 @@
 		if (hasSelection) {
 			selectionStart = translateOffset(Math.min(Math.max(0, selectionStart), length - 1));
 			selectionEnd = translateOffset(Math.min(Math.max(0, selectionEnd), length - 1));
-		}
 	}
+	}
 	RECT rect = new RECT();
 	OS.SetBkMode(hdc, OS.TRANSPARENT);
 	for (int line=0; line<runs.length; line++) {
@@ -950,20 +950,20 @@
 }
 
 void drawRunBackground(StyleItem run, long /*int*/ hdc, RECT rect, int selectionStart, int selectionEnd, long /*int*/ selBrush, boolean hasSelection) {
-	int end = run.start + run.length - 1;
-	boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
-	if (fullSelection) {
-		OS.SelectObject(hdc, selBrush);
+					int end = run.start + run.length - 1;
+					boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
+					if (fullSelection) {
+							OS.SelectObject(hdc, selBrush);
 		OS.PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, OS.PATCOPY);
-	} else {
-		if (run.style != null && run.style.background != null) {
-			int bg = run.style.background.handle;
-			long /*int*/ hBrush = OS.CreateSolidBrush (bg);
-			long /*int*/ oldBrush = OS.SelectObject(hdc, hBrush);
+					} else {
+						if (run.style != null && run.style.background != null) {
+							int bg = run.style.background.handle;
+								long /*int*/ hBrush = OS.CreateSolidBrush (bg);
+								long /*int*/ oldBrush = OS.SelectObject(hdc, hBrush);
 			OS.PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, OS.PATCOPY);
-			OS.SelectObject(hdc, oldBrush);
-			OS.DeleteObject(hBrush);
-		}
+								OS.SelectObject(hdc, oldBrush);
+								OS.DeleteObject(hBrush);
+							}
 		boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
 		if (partialSelection) {
 			getPartialSelection(run, selectionStart, selectionEnd, rect);
@@ -983,18 +983,18 @@
 			long /*int*/ brush = createGdipBrush(run.style.background, alpha);
 			Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 			Gdip.SolidBrush_delete(brush);
-		}
-		boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
-		if (partialSelection) {
+						}
+						boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
+						if (partialSelection) {
 			getPartialSelection(run, selectionStart, selectionEnd, rect);
-			if (rect.left > rect.right) {
-				int tmp = rect.left;
-				rect.left = rect.right;
-				rect.right = tmp;
-			}
+								if (rect.left > rect.right) {
+									int tmp = rect.left;
+									rect.left = rect.right;
+									rect.right = tmp;
+								}
 			Gdip.Graphics_FillRectangle(graphics, selBrush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
-		}
-	}
+							}
+						}
 }
 
 RECT drawRunText(long /*int*/ hdc, StyleItem run, RECT rect, int baseline, int color, int selectionColor, int selectionStart, int selectionEnd) {
@@ -1012,8 +1012,8 @@
 	} else {
 		if (run.style != null && run.style.foreground != null) {
 			color = run.style.foreground.handle;
-		}
-	}
+					}
+				}
 	OS.SetTextColor(hdc, color);
 	OS.ScriptTextOut(hdc, run.psc, x, y, 0, null, run.analysis , 0, 0, run.glyphs, run.glyphCount, run.advances, run.justify, run.goffsets);
 	if (partialSelection) {
@@ -1020,35 +1020,35 @@
 		getPartialSelection(run, selectionStart, selectionEnd, rect);
 		OS.SetTextColor(hdc, selectionColor);
 		OS.ScriptTextOut(hdc, run.psc, x, y, OS.ETO_CLIPPED, rect, run.analysis , 0, 0, run.glyphs, run.glyphCount, run.advances, run.justify, run.goffsets);
-	}
+			}
 	return fullSelection || partialSelection ? rect : null;
 }
 
 RECT drawRunTextGDIP(long /*int*/ graphics, StyleItem run, RECT rect, long /*int*/ gdipFont, int baseline, long /*int*/ color, long /*int*/ selectionColor, int selectionStart, int selectionEnd, int alpha) {
-	int end = run.start + run.length - 1;
+					int end = run.start + run.length - 1;
 	boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
-	boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
-	boolean partialSelection = hasSelection && !fullSelection && !(selectionStart > end || run.start > selectionEnd);
+					boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
+					boolean partialSelection = hasSelection && !fullSelection && !(selectionStart > end || run.start > selectionEnd);
 	int drawY = rect.top + baseline;
 	if (run.style != null && run.style.rise != 0) drawY -= run.style.rise;
 	int drawX = rect.left;
 	long /*int*/ brush = color;
-	if (fullSelection) {
+						if (fullSelection) {
 		brush = selectionColor;
-	} else {
-		if (run.style != null && run.style.foreground != null) {
+						} else {
+							if (run.style != null && run.style.foreground != null) {
 			brush = createGdipBrush(run.style.foreground, alpha);
-		}
-	}
-	int gstate = 0;
+							}
+						}
+						int gstate = 0;
 	Rect gdipRect = null;
-	if (partialSelection) {
+						if (partialSelection) {
 		gdipRect = new Rect();
 		getPartialSelection(run, selectionStart, selectionEnd, rect);
-		gdipRect.X = rect.left;
-		gdipRect.Y = rect.top;
-		gdipRect.Width = rect.right - rect.left;
-		gdipRect.Height = rect.bottom - rect.top;
+							gdipRect.X = rect.left;
+							gdipRect.Y = rect.top;
+							gdipRect.Width = rect.right - rect.left;
+							gdipRect.Height = rect.bottom - rect.top;
 		gstate = Gdip.Graphics_Save(graphics);
 		Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
 	}
@@ -1102,9 +1102,9 @@
 			case Gdip.BrushTypeTextureFill:
 				Gdip.TextureBrush_ResetTransform(brush);
 				break;
-		}
+						}
 		Gdip.Graphics_Restore(graphics, gstateMirrored);
-	}
+						}
 	if (brush != selectionColor && brush != color) Gdip.SolidBrush_delete(brush);
 	return fullSelection || partialSelection ? rect : null;
 }
@@ -1127,7 +1127,7 @@
 	if (!Gdip.Matrix_IsIdentity(matrix)) {
 		lpXform = new float[6];
 		Gdip.Matrix_GetElements(matrix, lpXform);
-	}
+						}
 	Gdip.Matrix_delete(matrix);
 	long /*int*/ hdc = Gdip.Graphics_GetHDC(graphics);
 	int state = OS.SaveDC(hdc);
@@ -1134,14 +1134,14 @@
 	if (lpXform != null) {
 		OS.SetGraphicsMode(hdc, OS.GM_ADVANCED);
 		OS.SetWorldTransform(hdc, lpXform);
-	}
+						}
 	if (clipRgn != 0) {
 		OS.SelectClipRgn(hdc, clipRgn);
 		OS.DeleteObject(clipRgn);
-	}
+							}
 	if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {
 		OS.SetLayout(hdc, OS.GetLayout(hdc) | OS.LAYOUT_RTL);
-	}
+							}
 	OS.SetBkMode(hdc, OS.TRANSPARENT);
 	RECT pRect = drawRunText(hdc, run, rect, baseline, color, selectionColor, selectionStart, selectionEnd);
 	OS.RestoreDC(hdc, state);
@@ -1164,22 +1164,22 @@
 			left = line[i - 1].x;
 			start = Math.min(start, line[i - 1].start);
 			end = Math.max(end, line[i - 1].start + line[i - 1].length - 1);
-		}
+						}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
 		if (style.strikeoutColor != null) {
 			color = style.strikeoutColor.handle;
 			clipRect = null;
-		} else {
-			if (fullSelection) {
+					}  else {
+						if (fullSelection) {
 				color = selectionColor;
 				clipRect = null;
-			} else {
+						} else {
 				if (style.foreground != null) {
 					color = style.foreground.handle;
-				}
-			}
-		}
+						}
+						}
+					}
 		RECT rect = new RECT();
 		OS.SetRect(rect, x + left, baseline - run.strikeoutPos, x + run.x + run.width, baseline - run.strikeoutPos + run.strikeoutThickness);
 		long /*int*/ brush = OS.CreateSolidBrush(color);
@@ -1192,7 +1192,7 @@
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
 			OS.FillRect(hdc, clipRect, selBrush);
 			OS.DeleteObject(selBrush);
-		}
+				}
 		return null;
 	}
 	return clipRect;
@@ -1227,9 +1227,9 @@
 			} else {
 				if (style.foreground != null) {
 					brush = createGdipBrush(style.foreground, alpha);
-				}
 			}
 		}
+	}
 		if (clipRect != null) {
 			int gstate = Gdip.Graphics_Save(graphics);
 			if (clipRect.left == -1) clipRect.left = 0;
@@ -1246,7 +1246,7 @@
 			Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
 			Gdip.Graphics_FillRectangle(graphics, selectionColor, x + left, baseline - run.strikeoutPos, run.x + run.width - left, run.strikeoutThickness);
 			Gdip.Graphics_Restore(graphics, gstate);
-		} else {
+	} else {
 			Gdip.Graphics_FillRectangle(graphics, brush, x + left, baseline - run.strikeoutPos, run.x + run.width - left, run.strikeoutThickness);
 		}
 		if (brush != selectionColor && brush != color) Gdip.SolidBrush_delete(brush);
@@ -1266,11 +1266,11 @@
 		int left = run.x;
 		int start = run.start;
 		int end = run.start + run.length - 1;
-		for (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {
+					for (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {
 			left = line[i - 1].x;
 			start = Math.min(start, line[i - 1].start);
 			end = Math.max(end, line[i - 1].start + line[i - 1].length - 1);
-		}
+					}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
 		if (style.underlineColor != null) {
@@ -1292,12 +1292,12 @@
 			if (clipRect.left == -1) clipRect.left = 0;
 			if (clipRect.right == -1) clipRect.right = 0x7ffff;
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
-		}
-		switch (style.underlineStyle) {
-			case SWT.UNDERLINE_SQUIGGLE:
-			case SWT.UNDERLINE_ERROR: {
-				int squigglyThickness = 1;
-				int squigglyHeight = 2 * squigglyThickness;
+			}
+			switch (style.underlineStyle) {
+				case SWT.UNDERLINE_SQUIGGLE:
+				case SWT.UNDERLINE_ERROR: {
+					int squigglyThickness = 1;
+					int squigglyHeight = 2 * squigglyThickness;
 				int squigglyY = Math.min(rect.top - squigglyHeight / 2, lineBottom - squigglyHeight - 1);
 				int[] points = computePolyline(rect.left, squigglyY, rect.right, squigglyY + squigglyHeight);
 				long /*int*/ pen = OS.CreatePen(OS.PS_SOLID, squigglyThickness, color);
@@ -1308,11 +1308,11 @@
 				int length = points.length;
 				if (length >= 2 && squigglyThickness <= 1) {
 					OS.SetPixel (hdc, points[length - 2], points[length - 1], color);
-				}
+					}
 				OS.SelectObject(hdc, oldPen);
 				OS.DeleteObject(pen);
 				OS.RestoreDC(hdc, state);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					pen = OS.CreatePen(OS.PS_SOLID, squigglyThickness, selectionColor);
 					oldPen = OS.SelectObject(hdc, pen);
 					state = OS.SaveDC(hdc);
@@ -1325,10 +1325,10 @@
 					OS.DeleteObject(pen);
 					OS.RestoreDC(hdc, state);
 				}
-				break;
-			}
-			case SWT.UNDERLINE_SINGLE:
-			case SWT.UNDERLINE_DOUBLE:
+					break;
+				}
+				case SWT.UNDERLINE_SINGLE:
+				case SWT.UNDERLINE_DOUBLE:
 			case SWT.UNDERLINE_LINK:
 			case UNDERLINE_IME_THICK:
 				if (style.underlineStyle == UNDERLINE_IME_THICK) {
@@ -1345,9 +1345,9 @@
 				if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 					OS.SetRect(rect, rect.left, rect.top + run.underlineThickness * 2, rect.right, rect.bottom + run.underlineThickness * 2);
 					OS.FillRect(hdc, rect, brush);
-				}
+					}
 				OS.DeleteObject(brush);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					long /*int*/ selBrush = OS.CreateSolidBrush(selectionColor);
 					OS.FillRect(hdc, clipRect, selBrush);
 					if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
@@ -1355,11 +1355,11 @@
 						OS.FillRect(hdc, clipRect, selBrush);
 					}
 					OS.DeleteObject(selBrush);
-				}
-				break;
-			case UNDERLINE_IME_DASH:
-			case UNDERLINE_IME_DOT: {
-				int penStyle = style.underlineStyle == UNDERLINE_IME_DASH ? OS.PS_DASH : OS.PS_DOT;
+					}
+					break;
+				case UNDERLINE_IME_DASH:
+				case UNDERLINE_IME_DOT: {
+					int penStyle = style.underlineStyle == UNDERLINE_IME_DASH ? OS.PS_DASH : OS.PS_DOT;
 				long /*int*/ pen = OS.CreatePen(penStyle, 1, color);
 				long /*int*/ oldPen = OS.SelectObject(hdc, pen);
 				OS.SetRect(rect, rect.left, baseline + run.descent, rect.right, baseline + run.descent + run.underlineThickness);
@@ -1367,7 +1367,7 @@
 				OS.LineTo(hdc, rect.right, rect.top);
 				OS.SelectObject(hdc, oldPen);
 				OS.DeleteObject(pen);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					pen = OS.CreatePen(penStyle, 1, selectionColor);
 					oldPen = OS.SelectObject(hdc, pen);
 					OS.SetRect(clipRect, clipRect.left, rect.top, clipRect.right, rect.bottom);
@@ -1375,17 +1375,17 @@
 					OS.LineTo(hdc, clipRect.right, clipRect.top);
 					OS.SelectObject(hdc, oldPen);
 					OS.DeleteObject(pen);
+					}
+					break;
 				}
-				break;
 			}
+		return null;
 		}
-		return null;
-	}
 	return clipRect;
 }
 
 RECT drawUnderlineGDIP (long /*int*/ graphics, int x, int baseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, long /*int*/ color, long /*int*/ selectionColor, RECT clipRect, RECT pRect, int selectionStart, int selectionEnd, int alpha, Rectangle drawClip) {
-	StyleItem run = line[index];
+	StyleItem run = line[index]; 
 	TextStyle style = run.style;
 	if (style == null) return null;
 	if (!style.underline) return null;
@@ -1402,7 +1402,7 @@
 		}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
-		long /*int*/ brush = color;
+			long /*int*/ brush = color;
 		if (style.underlineColor != null) {
 			brush = createGdipBrush(style.underlineColor, alpha);
 			clipRect = null;
@@ -1414,20 +1414,20 @@
 				if (style.foreground != null) {
 					brush = createGdipBrush(style.foreground, alpha);
 				}
+				}
 			}
-		}
 		RECT rect = new RECT();
 		OS.SetRect(rect, x + left, baseline - lineUnderlinePos, x + run.x + run.width, baseline - lineUnderlinePos + run.underlineThickness);
 		Rect gdipRect = null;
 		if (clipRect != null) {
-			if (clipRect.left == -1) clipRect.left = 0;
-			if (clipRect.right == -1) clipRect.right = 0x7ffff;
+				if (clipRect.left == -1) clipRect.left = 0;
+				if (clipRect.right == -1) clipRect.right = 0x7ffff;
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
 			gdipRect = new Rect();
-			gdipRect.X = clipRect.left;
-			gdipRect.Y = clipRect.top;
-			gdipRect.Width = clipRect.right - clipRect.left;
-			gdipRect.Height = clipRect.bottom - clipRect.top;
+				gdipRect.X = clipRect.left;
+				gdipRect.Y = clipRect.top;
+				gdipRect.Width = clipRect.right - clipRect.left;
+				gdipRect.Height = clipRect.bottom - clipRect.top;
 		}
 		int gstate = 0;
 		Gdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeNone);
@@ -1443,7 +1443,7 @@
 				long /*int*/ pen = Gdip.Pen_new(brush, squigglyThickness);
 				gstate = Gdip.Graphics_Save(graphics);
 				if (gdipRect != null) {
-					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
+				Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
 				} else {
 					Rect r = new Rect();
 					r.X = rect.left;
@@ -1455,11 +1455,11 @@
 				Gdip.Graphics_DrawLines(graphics, pen, points, points.length / 2);
 				if (gdipRect != null) {
 					long /*int*/ selPen = Gdip.Pen_new(selectionColor, squigglyThickness);
-					Gdip.Graphics_Restore(graphics, gstate);
-					gstate = Gdip.Graphics_Save(graphics);
-					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
+				Gdip.Graphics_Restore(graphics, gstate);
+				gstate = Gdip.Graphics_Save(graphics);
+				Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
 					Gdip.Graphics_DrawLines(graphics, selPen, points, points.length / 2);
-					Gdip.Pen_delete(selPen);
+				Gdip.Pen_delete(selPen);
 				}
 				Gdip.Graphics_Restore(graphics, gstate);
 				Gdip.Pen_delete(pen);
@@ -1491,7 +1491,7 @@
 				Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 				if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 					Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);
-				}
+			}
 				if (gdipRect != null) {
 					Gdip.Graphics_Restore(graphics, gstate);
 					gstate = Gdip.Graphics_Save(graphics);
@@ -1499,7 +1499,7 @@
 					Gdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 					if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 						Gdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);
-					}
+				}
 					Gdip.Graphics_Restore(graphics, gstate);
 				}
 				break;
@@ -1511,7 +1511,7 @@
 				if (gdipRect != null) {
 					gstate = Gdip.Graphics_Save(graphics);
 					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
-				}
+			}
 				Gdip.Graphics_DrawLine(graphics, pen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);
 				if (gdipRect != null) {
 					Gdip.Graphics_Restore(graphics, gstate);
@@ -1522,7 +1522,7 @@
 					Gdip.Graphics_DrawLine(graphics, selPen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);
 					Gdip.Graphics_Restore(graphics, gstate);
 					Gdip.Pen_delete(selPen);
-				}
+			}
 				Gdip.Pen_delete(pen);
 				break;
 			}
@@ -2284,7 +2284,7 @@
 					}
 				}
 			} else {
-				if (trailing != null) trailing[0] = piTrailing[0];
+			if (trailing != null) trailing[0] = piTrailing[0];
 			}
 			return untranslateOffset(offset);
 		}
@@ -2422,10 +2422,10 @@
 	if (nSegments == 0) return text;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return text;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return text;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return text;
 	}
+	}
 	char[] oldChars = new char[length];
 	text.getChars(0, length, oldChars, 0);
 	char[] newChars = new char[length + nSegments];
@@ -3149,7 +3149,7 @@
  * returns without doing anything if the new text is the same as 
  * the current text.
  * </p>
- * 
+ *
  * @param text the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -3308,41 +3308,41 @@
 			}
 		}
 		if (count > 0) {
-			long /*int*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());
-			long /*int*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);
-			long /*int*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);
-			int flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;
+		long /*int*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());
+		long /*int*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);
+		long /*int*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);
+		int flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;
 			if (OS.ScriptStringAnalyse(metaFileDc, sampleChars, count, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {
-				OS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);
-				OS.ScriptStringFree(ssa);
-			}
-			OS.HeapFree(hHeap, 0, ssa);
-			OS.SelectObject(metaFileDc, oldMetaFont);
-			long /*int*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);
-			final EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();
-			class MetaFileEnumProc {
-				long /*int*/ metaFileEnumProc (long /*int*/ hDC, long /*int*/ table, long /*int*/ record, long /*int*/ nObj, long /*int*/ lpData) {
-					OS.MoveMemory(emr.emr, record, EMR.sizeof);
-					switch (emr.emr.iType) {
-						case OS.EMR_EXTCREATEFONTINDIRECTW:
-							OS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);
-							break;
-						case OS.EMR_EXTTEXTOUTW:
-							return 0;
-					}
-					return 1;
+			OS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);
+			OS.ScriptStringFree(ssa);
+		}
+		OS.HeapFree(hHeap, 0, ssa);
+		OS.SelectObject(metaFileDc, oldMetaFont);
+		long /*int*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);
+		final EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();
+		class MetaFileEnumProc {
+			long /*int*/ metaFileEnumProc (long /*int*/ hDC, long /*int*/ table, long /*int*/ record, long /*int*/ nObj, long /*int*/ lpData) {
+				OS.MoveMemory(emr.emr, record, EMR.sizeof);
+				switch (emr.emr.iType) {
+					case OS.EMR_EXTCREATEFONTINDIRECTW:
+						OS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);
+						break;
+					case OS.EMR_EXTTEXTOUTW:
+						return 0;
 				}
+				return 1;
 			}
-			MetaFileEnumProc object = new MetaFileEnumProc();
-			/* Avoid compiler warnings */
-			boolean compilerWarningWorkaround = false;
-			if (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);
-			Callback callback = new Callback(object, "metaFileEnumProc", 5);
-			long /*int*/ address = callback.getAddress();
-			if (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);
-			OS.EnumEnhMetaFile(0, metaFile, address, 0, null);
-			OS.DeleteEnhMetaFile(metaFile);
-			callback.dispose();
+			}
+		MetaFileEnumProc object = new MetaFileEnumProc();
+		/* Avoid compiler warnings */
+		boolean compilerWarningWorkaround = false;
+		if (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);
+		Callback callback = new Callback(object, "metaFileEnumProc", 5);
+		long /*int*/ address = callback.getAddress();
+		if (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);
+		OS.EnumEnhMetaFile(0, metaFile, address, 0, null);
+		OS.DeleteEnhMetaFile(metaFile);
+		callback.dispose();
 			newFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);
 		} else {
 			/*
@@ -3370,12 +3370,12 @@
 								OS.SelectObject(hdc, getItemFont(nRun));
 								shape(hdc, nRun);
 								long /*int*/ nFont = getItemFont(nRun);
-								LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();
+									LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();
 								OS.GetObject(nFont, LOGFONT.sizeof, logFont);
-								newFont = OS.CreateFontIndirect(logFont);
+									newFont = OS.CreateFontIndirect(logFont);
+								}
 							}
 						}
-					}
 					break;
 				}
 				index++;
@@ -3382,11 +3382,11 @@
 			}
 		}
 		if (newFont != 0) {
-			OS.SelectObject(hdc, newFont);
-			if (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {
-				run.fallbackFont = newFont;
-			}
+		OS.SelectObject(hdc, newFont);
+		if (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {
+			run.fallbackFont = newFont;
 		}
+		}
 		if (!shapeSucceed) {
 			if (!sp.fComplex) {
 				run.analysis.fNoGlyphIndex = true;
@@ -3518,10 +3518,10 @@
 	if (nSegments == 0) return offset;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return offset;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return offset;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return offset;
 	}
+	}
 	for (int i = 0; i < nSegments && offset - i >= segments[i]; i++) {
 		offset++;
 	}	
@@ -3536,10 +3536,10 @@
 	if (nSegments == 0) return offset;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return offset;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return offset;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return offset;
 	}
+	}
 	for (int i = 0; i < nSegments && offset > segments[i]; i++) {
 		offset--;
 	}
Index: org/eclipse/swt/graphics/GC.java
===================================================================
--- org/eclipse/swt/graphics/GC.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/graphics/GC.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -308,8 +308,8 @@
 			long /*int*/[] hFont = new long /*int*/[1];
 			long /*int*/ gdipFont = createGdipFont(handle, font.handle, gdipGraphics, device.fontCollection, null, hFont);
 			if (hFont[0] != 0) OS.SelectObject(handle, hFont[0]);
-			if (data.hGDIFont != 0) OS.DeleteObject(data.hGDIFont);
-			data.hGDIFont = hFont[0];
+				if (data.hGDIFont != 0) OS.DeleteObject(data.hGDIFont);
+				data.hGDIFont = hFont[0];
 			if (data.gdipFont != 0) Gdip.Font_delete(data.gdipFont);
 			data.gdipFont = gdipFont;
 		}
@@ -592,7 +592,7 @@
 		if (family != 0) {
 			font = Gdip.Font_new(family, size, style, Gdip.UnitPixel);
 		} else {
-			font = Gdip.Font_new(buffer, size, style, Gdip.UnitPixel, 0);
+		font = Gdip.Font_new(buffer, size, style, Gdip.UnitPixel, 0);
 		}
 		if (outFont != null && font != 0) {
 			long /*int*/ hHeap = OS.GetProcessHeap();
@@ -3399,7 +3399,7 @@
 				OS.GetWindowOrgEx (handle, pt);
 				OS.OffsetRgn (hRgn, pt.x, pt.y);
 			}
-			OS.CombineRgn(region.handle, hRgn, 0, OS.RGN_COPY);			
+			OS.CombineRgn(region.handle, hRgn, 0, OS.RGN_COPY);
 			OS.DeleteObject(hRgn);
 		}
 		Gdip.Region_delete(rgn);
Index: org/eclipse/swt/events/GestureEvent.java
===================================================================
--- org/eclipse/swt/events/GestureEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/events/GestureEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -23,7 +23,7 @@
  * @since 3.7
  */
 public class GestureEvent extends TypedEvent {
-
+	
 	/**
 	 * The state of the keyboard modifier keys and mouse masks
 	 * at the time the event was generated.
@@ -32,7 +32,7 @@
 	 * @see org.eclipse.swt.SWT#BUTTON_MASK
 	 */
 	public int stateMask;
-
+	
 	/**
 	 * The gesture type.
 	 * <p><ul>
@@ -55,13 +55,13 @@
 	 * gesture was performed. 
 	 */
 	public int x;
-
+	
 	/**
 	 * The meaning of this field is dependent on the value of the <code>detail</code> field
 	 * and the platform.  It can represent either the y coordinate of the centroid of the
 	 * touches that make up the gesture, or the y coordinate of the cursor at the time the
 	 * gesture was performed. 
-	 */
+	 */	
 	public int y;
 
 	/**
@@ -114,9 +114,9 @@
 	 * Setting it to <code>false</code> will cancel the operation.
 	 */
 	public boolean doit;
-
+	
 	static final long serialVersionUID = -8348741538373572182L;
-
+	
 /**
  * Constructs a new instance of this class based on the
  * information in the given untyped event.
Index: org/eclipse/swt/events/TouchEvent.java
===================================================================
--- org/eclipse/swt/events/TouchEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/events/TouchEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -23,7 +23,7 @@
  * @since 3.7
  */
 public class TouchEvent extends TypedEvent {
-
+	
 	/**
 	 * The set of touches representing the state of all contacts with touch input
 	 * device at the time the event was generated.
@@ -40,19 +40,19 @@
 	 * @see org.eclipse.swt.SWT#BUTTON_MASK
 	 */
 	public int stateMask;
-
+	
 	/**
 	 * The widget-relative x coordinate of the pointer
 	 * at the time the touch occurred.
 	 */
 	public int x;
-
+	
 	/**
 	 * The widget-relative y coordinate of the pointer
 	 * at the time the touch occurred.
 	 */	
 	public int y;
-
+	
 	static final long serialVersionUID = -8348741538373572182L;
 	
 /**
Index: org/eclipse/swt/dnd/Clipboard.java
===================================================================
--- org/eclipse/swt/dnd/Clipboard.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/Clipboard.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -650,9 +650,9 @@
 		this.transferAgents = new Transfer[0];
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 
Index: org/eclipse/swt/dnd/DND.java
===================================================================
--- org/eclipse/swt/dnd/DND.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DND.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -162,7 +162,7 @@
 	
 	/**
 	 * DropTarget drag under effect: The widget is scrolled up or down to allow the user to drop on items that 
-	 * are not currently visible; applies to tables and trees (value is 8).
+	 * are not currently visible;  applies to tables and trees (value is 8).
 	 */	
 	public static final int FEEDBACK_SCROLL = 8;
 	
Index: org/eclipse/swt/dnd/URLTransfer.java
===================================================================
--- org/eclipse/swt/dnd/URLTransfer.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/URLTransfer.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -77,24 +77,24 @@
 		transferData.stgmedium.pUnkForRelease = 0;
 		transferData.result = COM.S_OK;
 	} else if (transferData.type == CFSTR_INETURLID) {
-		int count = url.length();
-		char[] chars = new char[count + 1];
-		url.getChars(0, count, chars, 0);
-		int codePage = OS.GetACP();
-		int cchMultiByte = OS.WideCharToMultiByte(codePage, 0, chars, -1, null, 0, null, null);
-		if (cchMultiByte == 0) {
-			transferData.stgmedium = new STGMEDIUM();
-			transferData.result = COM.DV_E_STGMEDIUM;
-			return;
-		}
-		long /*int*/ lpMultiByteStr = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, cchMultiByte);
-		OS.WideCharToMultiByte(codePage, 0, chars, -1, lpMultiByteStr, cchMultiByte, null, null);
+	int count = url.length();
+	char[] chars = new char[count + 1];
+	url.getChars(0, count, chars, 0);
+	int codePage = OS.GetACP();
+	int cchMultiByte = OS.WideCharToMultiByte(codePage, 0, chars, -1, null, 0, null, null);
+	if (cchMultiByte == 0) {
 		transferData.stgmedium = new STGMEDIUM();
-		transferData.stgmedium.tymed = COM.TYMED_HGLOBAL;
-		transferData.stgmedium.unionField = lpMultiByteStr;
-		transferData.stgmedium.pUnkForRelease = 0;
-		transferData.result = COM.S_OK;
+		transferData.result = COM.DV_E_STGMEDIUM;
+		return;
 	}
+	long /*int*/ lpMultiByteStr = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, cchMultiByte);
+	OS.WideCharToMultiByte(codePage, 0, chars, -1, lpMultiByteStr, cchMultiByte, null, null);
+	transferData.stgmedium = new STGMEDIUM();
+	transferData.stgmedium.tymed = COM.TYMED_HGLOBAL;
+	transferData.stgmedium.unionField = lpMultiByteStr;
+	transferData.stgmedium.pUnkForRelease = 0;
+	transferData.result = COM.S_OK;
+	}
 }
 
 /**
@@ -140,19 +140,19 @@
 				OS.GlobalUnlock(hMem);	
 			}
 		} else if (transferData.type == CFSTR_INETURLID) {
-			long /*int*/ lpMultiByteStr = OS.GlobalLock(hMem);
-			if (lpMultiByteStr == 0) return null;
-			try {
-				int codePage = OS.GetACP();
-				int cchWideChar  = OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, null, 0);
-				if (cchWideChar == 0) return null;
-				char[] lpWideCharStr = new char [cchWideChar - 1];
-				OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, lpWideCharStr, lpWideCharStr.length);
-				return new String(lpWideCharStr);
-			} finally {
-				OS.GlobalUnlock(hMem);
-			}
+		long /*int*/ lpMultiByteStr = OS.GlobalLock(hMem);
+		if (lpMultiByteStr == 0) return null;
+		try {
+			int codePage = OS.GetACP();
+			int cchWideChar  = OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, null, 0);
+			if (cchWideChar == 0) return null;
+			char[] lpWideCharStr = new char [cchWideChar - 1];
+			OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, lpWideCharStr, lpWideCharStr.length);
+			return new String(lpWideCharStr);
+		} finally {
+			OS.GlobalUnlock(hMem);
 		}
+		}
 	} finally {
 		OS.GlobalFree(hMem);
 	}
Index: org/eclipse/swt/dnd/OleEnumFORMATETC.java
===================================================================
--- org/eclipse/swt/dnd/OleEnumFORMATETC.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/OleEnumFORMATETC.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -134,9 +134,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	
 	return refCount;
 }
Index: org/eclipse/swt/dnd/DropTarget.java
===================================================================
--- org/eclipse/swt/dnd/DropTarget.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DropTarget.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.dnd;
 
@@ -166,6 +167,9 @@
 	} else if (control instanceof Tree) {
 		dropEffect = new TreeDropTargetEffect((Tree) control);
 	}
+        // <QFS>
+        getDisplay().runDNDCreationHooks(this);
+        // </QFS>
 }
 
 static int checkStyle (int style) {
@@ -572,7 +576,7 @@
 	iDataObject = null;
 	
 	if (COM.FreeUnusedLibraries) {
-		COM.CoFreeUnusedLibraries();
+	COM.CoFreeUnusedLibraries();
 	}
 }
 
@@ -630,9 +634,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	
 	return refCount;
 }
Index: org/eclipse/swt/dnd/DragSource.java
===================================================================
--- org/eclipse/swt/dnd/DragSource.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DragSource.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.dnd;
 
@@ -191,6 +192,9 @@
 	} else if (control instanceof Table) {
 		dragEffect = new TableDragSourceEffect((Table) control);
 	}
+        // <QFS>
+        getDisplay().runDNDCreationHooks(this);
+        // </QFS>
 }
 
 static int checkStyle(int style) {
@@ -656,9 +660,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 
Index: org/eclipse/swt/widgets/Tree.java
===================================================================
--- org/eclipse/swt/widgets/Tree.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Tree.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -125,7 +125,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -162,7 +162,7 @@
 	* WS_VSCROLL is not specified, Windows creates
 	* trees and tables with scroll bars.  The fix
 	* is to set H_SCROLL and V_SCROLL.
-	* 
+	*
 	* NOTE: This code appears on all platforms so that
 	* applications have consistent scroll bar behavior.
 	*/
@@ -271,12 +271,12 @@
 
 		/* Set the background color */
 		OS.SendMessage (handle, OS.TVM_SETBKCOLOR, 0, newPixel);
-		
+
 		/*
 		* Feature in Windows.  When TVM_SETBKCOLOR is used to
 		* set the background color of a tree, the plus/minus
 		* animation draws badly.  The fix is to clear the effect.
-		*/	
+		*/
 		if (explorerTheme) {
 			int bits2 = (int)/*64*/OS.SendMessage (handle, OS.TVM_GETEXTENDEDSTYLE, 0, 0);
 			if (newPixel == -1 && findImageControl () == null) {
@@ -352,7 +352,7 @@
 	TypedListener typedListener = new TypedListener (listener);
 	addListener (SWT.Expand, typedListener);
 	addListener (SWT.Collapse, typedListener);
-} 
+}
 
 long /*int*/ borderHandle () {
 	return hwndParent != 0 ? hwndParent : handle;
@@ -364,7 +364,7 @@
 	long /*int*/ hDC = nmcd.hdc;
 	OS.RestoreDC (hDC, -1);
 	TreeItem item = getItem (nmcd);
-	
+
 	/*
 	* Feature in Windows.  When a new tree item is inserted
 	* using TVM_INSERTITEM and the tree is using custom draw,
@@ -371,7 +371,7 @@
 	* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns
 	* and before the item is added to the items array.  The
 	* fix is to check for null.
-	* 
+	*
 	* NOTE: This only happens on XP with the version 6.00 of
 	* COMCTL32.DLL,
 	*/
@@ -383,7 +383,7 @@
 	* not a problem providing that graphics do not occur outside
 	* the rectangle.  The fix is to test for the rectangle and
 	* draw nothing.
-	* 
+	*
 	* NOTE:  This seems to happen when both I_IMAGECALLBACK
 	* and LPSTR_TEXTCALLBACK are used at the same time with
 	* TVM_SETITEM.
@@ -479,7 +479,7 @@
 						long /*int*/ hTheme = OS.OpenThemeData (handle, Display.TREEVIEW);
 						int iStateId = selected ? OS.TREIS_SELECTED : OS.TREIS_HOT;
 						if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.TREIS_SELECTEDNOTFOCUS;
-						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);	
+						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);
 						OS.CloseThemeData (hTheme);
 					}
 					if (draw) fillBackground (hDC, OS.GetBkColor (hDC), pClipRect);
@@ -694,7 +694,7 @@
 										long /*int*/ hTheme = OS.OpenThemeData (handle, Display.TREEVIEW);
 										int iStateId = selected ? OS.TREIS_SELECTED : OS.TREIS_HOT;
 										if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.TREIS_SELECTEDNOTFOCUS;
-										OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, backgroundRect);	
+										OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, backgroundRect);
 										OS.CloseThemeData (hTheme);
 									}
 								}
@@ -841,7 +841,7 @@
 							}
 						}
 					}
-				}				
+				}
 				event.x = itemRect.left;
 				event.y = itemRect.top;
 				event.width = itemRect.right - itemRect.left;
@@ -921,7 +921,7 @@
 	* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns
 	* and before the item is added to the items array.  The
 	* fix is to check for null.
-	* 
+	*
 	* NOTE: This only happens on XP with the version 6.00 of
 	* COMCTL32.DLL,
 	*/
@@ -960,7 +960,7 @@
 			if (findImageControl () == null) {
 				if (indexOf (sortColumn) == index) {
 					clrSortBk = getSortColumnPixel ();
-					if (clrTextBk == -1) clrTextBk = clrSortBk; 
+					if (clrTextBk == -1) clrTextBk = clrSortBk;
 				}
 			}
 		}
@@ -1020,11 +1020,11 @@
 			if (clrTextBk != -1) event.detail |= SWT.BACKGROUND;
 			if (hot) event.detail |= SWT.HOT;
 			if (selected) event.detail |= SWT.SELECTED;
-			//if ((nmcd.uItemState & OS.CDIS_FOCUS) != 0) {
-			if (OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0) == nmcd.dwItemSpec) {
-				if (handle == OS.GetFocus ()) {
-					int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
-					if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
+				//if ((nmcd.uItemState & OS.CDIS_FOCUS) != 0) {
+				if (OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0) == nmcd.dwItemSpec) {
+					if (handle == OS.GetFocus ()) {
+						int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
+						if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
 						if (!explorerTheme || !selected) {
 							focused = true;
 							event.detail |= SWT.FOCUSED;
@@ -1092,7 +1092,7 @@
 						long /*int*/ hTheme = OS.OpenThemeData (handle, Display.TREEVIEW);
 						int iStateId = selected ? OS.TREIS_SELECTED : OS.TREIS_HOT;
 						if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.TREIS_SELECTEDNOTFOCUS;
-						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);	
+						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);
 						OS.CloseThemeData (hTheme);
 					}
 				} else {
@@ -1193,7 +1193,7 @@
 	}
 	LRESULT result = null;
 	if (clrText == -1 && clrTextBk == -1 && hFont == -1) {
-		result = new LRESULT (OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);	
+		result = new LRESULT (OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);
 	} else {
 		result = new LRESULT (OS.CDRF_NEWFONT | OS.CDRF_NOTIFYPOSTPAINT);
 		if (hFont != -1) OS.SelectObject (hDC, hFont);
@@ -1221,8 +1221,8 @@
 						if ((style & SWT.FULL_SELECTION) != 0) {
 							if (!selected) fillBackground (hDC, clrTextBk, rect);
 						} else {
-							fillBackground (hDC, clrTextBk, rect);
-						}
+								fillBackground (hDC, clrTextBk, rect);
+							}
 					} else {
 						if ((style & SWT.FULL_SELECTION) != 0) {
 							RECT rect = new RECT ();
@@ -1335,7 +1335,7 @@
 						* child.  The fix is to use the bottom partially
 						* visible item rather than the last possible item
 						* that could be visible.
-						* 
+						*
 						* NOTE: This problem only happens on Vista during
 						* WM_NOTIFY with NM_CUSTOMDRAW and CDDS_POSTPAINT.
 						*/
@@ -1391,7 +1391,7 @@
 			* child.  The fix is to use the bottom partially
 			* visible item rather than the last possible item
 			* that could be visible.
-			* 
+			*
 			* NOTE: This problem only happens on Vista during
 			* WM_NOTIFY with NM_CUSTOMDRAW and CDDS_POSTPAINT.
 			*/
@@ -1413,14 +1413,14 @@
 				OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
 			}
 			if (height != 0) {
-				while (rect.bottom < nmcd.bottom) {
-					int top = rect.top + height;
-					OS.SetRect (rect, rect.left, top, rect.right, top + height);
-					OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
-				}
+			while (rect.bottom < nmcd.bottom) {
+				int top = rect.top + height;
+				OS.SetRect (rect, rect.left, top, rect.right, top + height);
+				OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
 			}
 		}
 	}
+	}
 	return new LRESULT (OS.CDRF_DODEFAULT);
 }
 
@@ -1473,7 +1473,7 @@
 				}
 			}
 			break;
-		}	
+		}
 	}
 	long /*int*/ hItem = 0;
 	boolean redraw = false;
@@ -1489,18 +1489,18 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-			
+
 		/* Resize messages */
 		case OS.WM_SIZE:
 			redraw = findImageControl () != null && getDrawing () && OS.IsWindowVisible (handle);
 			if (redraw) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -1519,7 +1519,7 @@
 		case OS.WM_XBUTTONDOWN:
 		case OS.WM_XBUTTONUP:
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -1543,12 +1543,12 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-			
+
 		/* Resize messages */
 		case OS.WM_SIZE:
 			if (redraw) {
@@ -1557,7 +1557,7 @@
 				if (hwndHeader != 0) OS.InvalidateRect (hwndHeader, null, true);
 			}
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -1576,7 +1576,7 @@
 		case OS.WM_XBUTTONDOWN:
 		case OS.WM_XBUTTONUP:
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -1588,7 +1588,7 @@
 			updateScrollBar ();
 			break;
 		}
-		
+
 		case OS.WM_PAINT:
 			painted = true;
 			break;
@@ -1653,13 +1653,13 @@
 
 boolean checkScroll (long /*int*/ hItem) {
 	/*
-	* Feature in Windows.  If redraw is turned off using WM_SETREDRAW 
+	* Feature in Windows.  If redraw is turned off using WM_SETREDRAW
 	* and a tree item that is not a child of the first root is selected or
 	* scrolled using TVM_SELECTITEM or TVM_ENSUREVISIBLE, then scrolling
 	* does not occur.  The fix is to detect this case, and make sure
 	* that redraw is temporarily enabled.  To avoid flashing, DefWindowProc()
 	* is called to disable redrawing.
-	* 
+	*
 	* NOTE:  The code that actually works around the problem is in the
 	* callers of this method.
 	*/
@@ -1693,10 +1693,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.2
  */
 public void clear (int index, boolean all) {
@@ -1732,7 +1732,7 @@
  * attributes of the items are set to their default values. If the
  * tree was created with the <code>SWT.VIRTUAL</code> style, these
  * attributes are requested again as needed.
- * 
+ *
  * @param all <code>true</code> if all child items should be cleared
  * recursively, and <code>false</code> otherwise
  *
@@ -1740,10 +1740,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.2
  */
 public void clearAll (boolean all) {
@@ -1794,7 +1794,7 @@
 			OS.SendMessage (hwndHeader, OS.HDM_GETITEM, i, hdItem);
 			width += hdItem.cxy;
 		}
-		RECT rect = new RECT ();					
+		RECT rect = new RECT ();
 		OS.GetWindowRect (hwndHeader, rect);
 		height += rect.bottom - rect.top;
 	}
@@ -1872,10 +1872,10 @@
 			OS.SendMessage (handle, OS.CCM_SETVERSION, 5, 0);
 		}
 	}
-		
+
 	/* Set the checkbox image list */
 	if ((style & SWT.CHECK) != 0) setCheckboxImageList ();
-	
+
 	/*
 	* Feature in Windows.  When the control is created,
 	* it does not use the default system font.  A new HFONT
@@ -1988,7 +1988,7 @@
 	}
 	System.arraycopy (columns, index, columns, index + 1, columnCount++ - index);
 	columns [index] = column;
-	
+
 	/*
 	* Bug in Windows.  For some reason, when HDM_INSERTITEM
 	* is used to insert an item into a header without text,
@@ -2005,7 +2005,7 @@
 	if ((column.style & SWT.RIGHT) == SWT.RIGHT) hdItem.fmt = OS.HDF_RIGHT;
 	OS.SendMessage (hwndHeader, OS.HDM_INSERTITEM, index, hdItem);
 	if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
-	
+
 	/* When the first column is created, hide the horizontal scroll bar */
 	if (columnCount == 1) {
 		scrollWidth = 0;
@@ -2032,12 +2032,12 @@
 	setScrollWidth ();
 	updateImageList ();
 	updateScrollBar ();
-	
+
 	/* Redraw to hide the items when the first column is created */
 	if (columnCount == 1 && OS.SendMessage (handle, OS.TVM_GETCOUNT, 0, 0) != 0) {
 		OS.InvalidateRect (handle, null, true);
 	}
-	
+
 	/* Add the tool tip item for the header */
 	if (headerToolTipHandle != 0) {
 		RECT rect = new RECT ();
@@ -2196,7 +2196,7 @@
 	* is documented to affect painting, not hit testing.
 	*
 	* NOTE: Windows 2000 doesn't have the problem and
-	* setting WS_EX_TRANSPARENT causes pixel corruption. 
+	* setting WS_EX_TRANSPARENT causes pixel corruption.
 	*/
 	if (OS.COMCTL32_MAJOR >= 6) bits2 |= OS.WS_EX_TRANSPARENT;
 	itemToolTipHandle = OS.CreateWindowEx (
@@ -2234,9 +2234,9 @@
 		super.windowClass (),
 		null,
 		newStyle,
-		rect.left, 
-		rect.top, 
-		rect.right - rect.left, 
+		rect.left,
+		rect.top,
+		rect.right - rect.left,
 		rect.bottom - rect.top,
 		parent.handle,
 		0,
@@ -2264,7 +2264,7 @@
 	if (OS.IsDBLocale) {
 		long /*int*/ hIMC = OS.ImmGetContext (handle);
 		OS.ImmAssociateContext (hwndParent, hIMC);
-		OS.ImmAssociateContext (hwndHeader, hIMC);		
+		OS.ImmAssociateContext (hwndHeader, hIMC);
 		OS.ImmReleaseContext (handle, hIMC);
 	}
 	//This code is intentionally commented
@@ -2517,7 +2517,7 @@
 		for (int i=orderIndex; i<newOrder.length; i++) {
 			newColumns [i - orderIndex] = columns [newOrder [i]];
 			newColumns [i - orderIndex].updateToolTip (newOrder [i]);
-		}	
+		}
 		for (int i=0; i<newColumns.length; i++) {
 			if (!newColumns [i].isDisposed ()) {
 				newColumns [i].sendEvent (SWT.Move);
@@ -2546,7 +2546,7 @@
 	* force the widget to be fully painted, turn off redraw, remove
 	* the item and validate the damage caused by the removing of
 	* the item.
-	* 
+	*
 	* NOTE: This fix is not necessary when double buffering and
 	* can cause problems for virtual trees due to the call to
 	* UpdateWindow() that flushes outstanding WM_PAINT events,
@@ -2581,7 +2581,7 @@
 	* multiple items are deleted, the tool tip flashes, showing
 	* each new item in the tool tip as it is scrolled into view.
 	* The fix is to hide tool tips when any item is deleted.
-	* 
+	*
 	* NOTE:  This only happens on Vista.
 	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -2588,7 +2588,7 @@
 		long /*int*/ hwndToolTip = OS.SendMessage (handle, OS.TVM_GETTOOLTIPS, 0, 0);
 		if (hwndToolTip != 0) OS.SendMessage (hwndToolTip, OS.TTM_POP, 0 ,0);
 	}
-	
+
 	shrink = ignoreShrink = true;
 	OS.SendMessage (handle, OS.TVM_DELETEITEM, 0, hItem);
 	ignoreShrink = false;
@@ -2646,7 +2646,7 @@
 void enableDrag (boolean enabled) {
 	int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 	if (enabled && hooks (SWT.DragDetect)) {
-		bits &= ~OS.TVS_DISABLEDRAGDROP;		
+		bits &= ~OS.TVS_DISABLEDRAGDROP;
 	} else {
 		bits |= OS.TVS_DISABLEDRAGDROP;
 	}
@@ -2850,7 +2850,7 @@
 		}
 		return 0;
 	}
-	int nextIndex = 0; 
+	int nextIndex = 0;
 	long /*int*/ hNextItem = hFirstItem;
 	while (hNextItem != 0 && nextIndex < index) {
 		hNextItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hNextItem);
@@ -2875,12 +2875,12 @@
  * Returns the width in pixels of a grid line.
  *
  * @return the width of a grid line in pixels
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int getGridLineWidth () {
@@ -2889,7 +2889,7 @@
 }
 
 /**
- * Returns the height of the receiver's header 
+ * Returns the height of the receiver's header
  *
  * @return the height of the header or zero if the header is not visible
  *
@@ -2897,13 +2897,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
- * @since 3.1 
+ *
+ * @since 3.1
  */
 public int getHeaderHeight () {
 	checkWidget ();
 	if (hwndHeader == 0) return 0;
-	RECT rect = new RECT ();					
+	RECT rect = new RECT ();
 	OS.GetWindowRect (hwndHeader, rect);
 	return rect.bottom - rect.top;
 }
@@ -2924,7 +2924,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public boolean getHeaderVisible () {
@@ -2972,13 +2972,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public TreeColumn getColumn (int index) {
@@ -3000,7 +3000,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int getColumnCount () {
@@ -3019,7 +3019,7 @@
  * </p><p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the current visual order of the receiver's items
@@ -3028,12 +3028,12 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.2
  */
 public int[] getColumnOrder () {
@@ -3055,7 +3055,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -3064,13 +3064,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public TreeColumn [] getColumns () {
@@ -3094,7 +3094,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public TreeItem getItem (int index) {
@@ -3135,8 +3135,8 @@
  * coordinate system of the receiver.
  * <p>
  * The item that is returned represents an item that could be selected by the user.
- * For example, if selection only occurs in items in the first column, then null is 
- * returned if the point is outside of the item. 
+ * For example, if selection only occurs in items in the first column, then null is
+ * returned if the point is outside of the item.
  * Note that the SWT.FULL_SELECTION style hint, which specifies the selection policy,
  * determines the extent of the selection.
  * </p>
@@ -3235,7 +3235,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items
@@ -3253,7 +3253,7 @@
 }
 
 TreeItem [] getItems (long /*int*/ hTreeItem) {
-	int count = 0; 
+	int count = 0;
 	long /*int*/ hItem = hTreeItem;
 	while (hItem != 0) {
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
@@ -3302,7 +3302,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public boolean getLinesVisible () {
@@ -3385,11 +3385,11 @@
 /**
  * Returns an array of <code>TreeItem</code>s that are currently
  * selected in the receiver. The order of the items is unspecified.
- * An empty array indicates that no items are selected. 
+ * An empty array indicates that no items are selected.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return an array representing the selection
  *
@@ -3529,15 +3529,15 @@
  * the receiver. The value may be null if no column shows
  * the sort indicator.
  *
- * @return the sort indicator 
+ * @return the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortColumn(TreeColumn)
- * 
+ *
  * @since 3.2
  */
 public TreeColumn getSortColumn () {
@@ -3563,8 +3563,8 @@
 }
 
 /**
- * Returns the direction of the sort indicator for the receiver. 
- * The value will be one of <code>UP</code>, <code>DOWN</code> 
+ * Returns the direction of the sort indicator for the receiver.
+ * The value will be one of <code>UP</code>, <code>DOWN</code>
  * or <code>NONE</code>.
  *
  * @return the sort direction
@@ -3573,9 +3573,9 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortDirection(int)
- * 
+ *
  * @since 3.2
  */
 public int getSortDirection () {
@@ -3588,13 +3588,13 @@
  * This item can change when items are expanded, collapsed, scrolled
  * or new items are added or removed.
  *
- * @return the item at the top of the receiver 
- * 
+ * @return the item at the top of the receiver
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public TreeItem getTopItem () {
@@ -3609,11 +3609,11 @@
 	if (item == null) return false;
 	if (!hooks (SWT.MeasureItem)) return false;
 	boolean result = false;
-	
+
 	//BUG? - moved columns, only hittest first column
 	//BUG? - check drag detect
 	int [] order = new int [1], index = new int [1];
-	
+
 	long /*int*/ hDC = OS.GetDC (handle);
 	long /*int*/ oldFont = 0, newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
 	if (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);
@@ -3674,7 +3674,7 @@
 
 /**
  * Searches the receiver's list starting at the first column
- * (index 0) until a column is found that is equal to the 
+ * (index 0) until a column is found that is equal to the
  * argument, and returns the index of that column. If no column
  * is found, returns -1.
  *
@@ -3688,7 +3688,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int indexOf (TreeColumn column) {
@@ -3703,7 +3703,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -3718,7 +3718,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int indexOf (TreeItem item) {
@@ -3753,7 +3753,7 @@
 			* not draw with the correct background until the mouse is
 			* moved.  The fix is to test for the selection colors and
 			* guess that the item is not selected.
-			* 
+			*
 			* NOTE: This code does not work when the foreground and
 			* background of the tree are set to the selection colors
 			* but this does not happen in a regular application.
@@ -3781,7 +3781,7 @@
 				* will not draw the entire row selected until the user
 				* moves the mouse.  The fix is to test for the selection
 				* colors and guess that the item is selected.
-				* 
+				*
 				* NOTE: This code does not work when the foreground and
 				* background of the tree are set to the selection colors
 				* but this does not happen in a regular application.
@@ -3903,7 +3903,7 @@
 	* messages.  This behavior is unwanted when the tree is being
 	* disposed.  The fix is to ignore NM_CUSTOMDRAW messages by
 	* clearing the custom draw flag.
-	* 
+	*
 	* NOTE: This only happens on Windows XP.
 	*/
 	customDraw = false;
@@ -3928,7 +3928,7 @@
 
 /**
  * Removes all of the items from the receiver.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3951,7 +3951,7 @@
 	long /*int*/ result = OS.SendMessage (handle, OS.TVM_DELETEITEM, 0, OS.TVI_ROOT);
 	ignoreShrink = false;
 	if (redraw) {
-		OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);	
+		OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 		OS.InvalidateRect (handle, null, true);
 	}
 	ignoreDeselect = ignoreSelect = false;
@@ -3995,7 +3995,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection, listener);	
+	eventTable.unhook (SWT.DefaultSelection, listener);
 }
 
 /**
@@ -4042,11 +4042,11 @@
 
 /**
  * Display a mark indicating the point at which an item will be inserted.
- * The drop insert item has a visual hint to show where a dragged item 
+ * The drop insert item has a visual hint to show where a dragged item
  * will be inserted when dropped on the tree.
- * 
+ *
  * @param item the insert item.  Null will clear the insertion mark.
- * @param before true places the insert mark above 'item'. false places 
+ * @param before true places the insert mark above 'item'. false places
  *	the insert mark below 'item'.
  *
  * @exception IllegalArgumentException <ul>
@@ -4163,7 +4163,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 /*public*/ void setItemHeight (int itemHeight) {
@@ -4188,7 +4188,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setLinesVisible (boolean show) {
@@ -4210,8 +4210,8 @@
 		OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
 		int state = (int)/*64*/OS.SendMessage (handle, OS.TVM_GETITEMSTATE, hItem, OS.TVIS_EXPANDED);
 		if ((state & OS.TVIS_EXPANDED) != 0) {
-			long /*int*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
-			select (hFirstItem, tvItem);
+		long /*int*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
+		select (hFirstItem, tvItem);
 		}
 
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
@@ -4338,8 +4338,8 @@
 	tvItem.stateMask = OS.TVIS_SELECTED;
 	long /*int*/ oldProc = OS.GetWindowLongPtr (handle, OS.GWLP_WNDPROC);
 	OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, TreeProc);
-	long /*int*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);
-	select (hItem, tvItem);
+		long /*int*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);
+		select (hItem, tvItem);
 	OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, oldProc);
 }
 
@@ -4500,7 +4500,7 @@
 	* is sent from SendMessage(), Windows GP's in the window proc for
 	* the tree.  The fix is to avoid calling the tree window proc and
 	* set the cursor for the tree outside of WM_SETCURSOR.
-	* 
+	*
 	* NOTE:  This code assumes that the default cursor for the tree
 	* is IDC_ARROW.
 	*/
@@ -4510,7 +4510,7 @@
 }
 
 /**
- * Sets the order that the items in the receiver should 
+ * Sets the order that the items in the receiver should
  * be displayed in to the given argument which is described
  * in terms of the zero-relative ordering of when the items
  * were added.
@@ -4525,12 +4525,12 @@
  *    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>
  *    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.2
  */
 public void setColumnOrder (int [] order) {
@@ -4693,7 +4693,7 @@
 
 /**
  * Marks the receiver's header as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -4706,7 +4706,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setHeaderVisible (boolean show) {
@@ -4739,7 +4739,7 @@
 	* turn off redraw, the scroll bars are updated when
 	* items are added and removed.  The fix is to call
 	* the default window proc to stop all drawing.
-	* 
+	*
 	* Bug in Windows.  For some reason, when WM_SETREDRAW
 	* is used to turn redraw on for a tree and the tree
 	* contains no items, the last item in the tree does
@@ -4885,7 +4885,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSelection (TreeItem item) {
@@ -4924,7 +4924,7 @@
 		deselectAll();
 		return;
 	}
-		
+
 	/* Select/deselect the first item */
 	TreeItem item = items [0];
 	if (item != null) {
@@ -4931,7 +4931,7 @@
 		if (item.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
 		long /*int*/ hOldItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 		long /*int*/ hNewItem = hAnchor = item.handle;
-		
+
 		/*
 		* Bug in Windows.  When TVM_SELECTITEM is used to select and
 		* scroll an item to be visible and the client area of the tree
@@ -4940,7 +4940,7 @@
 		* instead of making the desired item visible.  The fix is to
 		* detect the case when the client area is too small and make
 		* the desired visible item be the top item in the tree.
-		* 
+		*
 		* Note that TVM_SELECTITEM when called with TVGN_FIRSTVISIBLE
 		* also requires the work around for scrolling.
 		*/
@@ -4961,7 +4961,7 @@
 			OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 			OS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);
 		}
-		
+
 		/*
 		* Feature in Windows.  When the old and new focused item
 		* are the same, Windows does not check to make sure that
@@ -5020,19 +5020,19 @@
 
 /**
  * Sets the column used by the sort indicator for the receiver. A null
- * value will clear the sort indicator.  The current sort column is cleared 
+ * value will clear the sort indicator.  The current sort column is cleared
  * before the new column is set.
  *
  * @param column the column used by the sort indicator or <code>null</code>
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortColumn (TreeColumn column) {
@@ -5048,16 +5048,16 @@
 }
 
 /**
- * Sets the direction of the sort indicator for the receiver. The value 
+ * Sets the direction of the sort indicator for the receiver. The value
  * can be one of <code>UP</code>, <code>DOWN</code> or <code>NONE</code>.
  *
- * @param direction the direction of the sort indicator 
+ * @param direction the direction of the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortDirection (int direction) {
@@ -5086,7 +5086,7 @@
  * </ul>
  *
  * @see Tree#getTopItem()
- * 
+ *
  * @since 2.1
  */
 public void setTopItem (TreeItem item) {
@@ -5301,7 +5301,7 @@
 public void showSelection () {
 	checkWidget ();
 	long /*int*/ hItem = 0;
-	if ((style & SWT.SINGLE) != 0) {	
+	if ((style & SWT.SINGLE) != 0) {
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 		if (hItem == 0) return;
 		int state = 0;
@@ -5701,7 +5701,7 @@
 				* the header not notified and NM_RELEASEDCAPTURE is not
 				* sent.  The fix is to redraw the header when the capture
 				* changes to another control.
-				* 
+				*
 				* This does not happen on XP.
 				*/
 				if (OS.COMCTL32_MAJOR < 6) {
@@ -5728,7 +5728,7 @@
 				OS.MoveMemory (hdr, lParam, NMHDR.sizeof);
 				switch (hdr.code) {
 					case OS.TTN_SHOW:
-					case OS.TTN_POP: 
+					case OS.TTN_POP:
 					case OS.TTN_GETDISPINFOA:
 					case OS.TTN_GETDISPINFOW:
 						return OS.SendMessage (handle, msg, wParam, lParam);
@@ -5819,7 +5819,7 @@
 				* Update the nPos field to match the nTrackPos field
 				* so that the tree scrolls when the scroll bar of the
 				* parent is dragged.
-				* 
+				*
 				* NOTE: For some reason, this code is only necessary
 				* on Windows Vista.
 				*/
@@ -5841,7 +5841,7 @@
 		/*
 		* When there is more than one item selected, DI_GETDRAGIMAGE
 		* returns the item under the cursor.  This happens because
-		* the tree does not have implement multi-select.  The fix 
+		* the tree does not have implement multi-select.  The fix
 		* is to disable DI_GETDRAGIMAGE when more than one item is
 		* selected.
 		*/
@@ -5887,10 +5887,10 @@
 				OS.CombineRgn (hRgn, hRgn, rectRgn, OS.RGN_OR);
 				OS.DeleteObject (rectRgn);
 				rect.bottom = itemRect.bottom;
-				
+
 			}
 			OS.GetRgnBox (hRgn, rect);
-			
+
 			/* Create resources */
 			long /*int*/ hdc = OS.GetDC (handle);
 			long /*int*/ memHdc = OS.CreateCompatibleDC (hdc);
@@ -5928,7 +5928,7 @@
 			shdi.ptOffset.x = mousePos.x - rect.left;
 			shdi.ptOffset.y = mousePos.y - rect.top;
 			if ((style & SWT.MIRRORED) != 0) {
-				shdi.ptOffset.x = shdi.sizeDragImage.cx - shdi.ptOffset.x; 
+				shdi.ptOffset.x = shdi.sizeDragImage.cx - shdi.ptOffset.x;
 			}
 			OS.MoveMemory (lParam, shdi, SHDRAGIMAGE.sizeof);
 			return 1;
@@ -5974,12 +5974,13 @@
 						if (OS.COMCTL32_MAJOR >= 6) {
 							id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, hItem, 0);
 						}
-						OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+						OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 					}
 				}
 				tvItem.stateMask = OS.TVIS_SELECTED;
 				OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
-				if ((style & SWT.MULTI) != 0 && OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                                // <QFS/> Changed to getDisplay().GetKeyState
+				if ((style & SWT.MULTI) != 0 && getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 					if ((tvItem.state & OS.TVIS_SELECTED) != 0) {
 						tvItem.state &= ~OS.TVIS_SELECTED;
 					} else {
@@ -6093,7 +6094,8 @@
 			*/
 			return LRESULT.ZERO;
 		case OS.VK_ADD:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				if (hwndHeader != 0) {
 					TreeColumn [] newColumns = new TreeColumn [columnCount];
 					System.arraycopy (columns, 0, newColumns, 0, columnCount);
@@ -6115,7 +6117,8 @@
 			OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
 			if (itemToolTipHandle != 0) OS.ShowWindow (itemToolTipHandle, OS.SW_HIDE);
 			if ((style & SWT.SINGLE) != 0) break;
-			if (OS.GetKeyState (OS.VK_SHIFT) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) {
 				long /*int*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 				if (hItem != 0) {
 					if (hAnchor == 0) hAnchor = hItem;
@@ -6126,7 +6129,7 @@
 					TVITEM tvItem = new TVITEM ();
 					tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_STATE;
 					tvItem.stateMask = OS.TVIS_SELECTED;
-					long /*int*/ hDeselectItem = hItem;					
+					long /*int*/ hDeselectItem = hItem;
 					RECT rect1 = new RECT ();
 					if (!OS.TreeView_GetItemRect (handle, hAnchor, rect1, false)) {
 						hAnchor = hItem;
@@ -6161,7 +6164,8 @@
 					return new LRESULT (code);
 				}
 			}
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				long /*int*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 				if (hItem != 0) {
 					TVITEM tvItem = new TVITEM ();
@@ -6188,7 +6192,7 @@
 								hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);
 							}
 							break;
-						case OS.VK_NEXT:			
+						case OS.VK_NEXT:
 							RECT rect = new RECT (), clientRect = new RECT ();
 							OS.GetClientRect (handle, clientRect);
 							hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);
@@ -6262,7 +6266,7 @@
 	* the image is drawn is not erased before it is drawn.
 	* This means that the image gets darker each time.
 	* The fix is to redraw the selection.
-	* 
+	*
 	* Feature in Windows.  When multiple item have
 	* the TVIS_SELECTED state, Windows redraws only
 	* the focused item in the color used to show the
@@ -6308,7 +6312,7 @@
 				OS.SetFocus (handle);
 				TVITEM tvItem = new TVITEM ();
 				tvItem.hItem = lpht.hItem;
-				tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;	
+				tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;
 				tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;
 				OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 				int state = tvItem.state >> 12;
@@ -6319,12 +6323,12 @@
 				}
 				tvItem.state = state << 12;
 				OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
-				if (!OS.IsWinCE) {	
+				if (!OS.IsWinCE) {
 					long /*int*/ id = tvItem.hItem;
 					if (OS.COMCTL32_MAJOR >= 6) {
 						id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);
 					}
-					OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+					OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 				}
 				Event event = new Event ();
 				event.item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -6451,7 +6455,7 @@
 		}
 		return new LRESULT (code);
 	}
-	
+
 	/* Look for check/uncheck */
 	if ((style & SWT.CHECK) != 0) {
 		if ((lpht.flags & OS.TVHT_ONITEMSTATEICON) != 0) {
@@ -6469,7 +6473,7 @@
 			OS.SetFocus (handle);
 			TVITEM tvItem = new TVITEM ();
 			tvItem.hItem = lpht.hItem;
-			tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;	
+			tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;
 			tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;
 			OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 			int state = tvItem.state >> 12;
@@ -6485,7 +6489,7 @@
 				if (OS.COMCTL32_MAJOR >= 6) {
 					id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);
 				}
-				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 			}
 			Event event = new Event ();
 			event.item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -6494,7 +6498,7 @@
 			return LRESULT.ZERO;
 		}
 	}
-	
+
 	/*
 	* Feature in Windows.  When the tree has the style
 	* TVS_FULLROWSELECT, the background color for the
@@ -6517,7 +6521,7 @@
 			}
 		}
 	}
-	
+
 	/* Process the mouse when an item is not selected */
 	if (!selected && (style & SWT.FULL_SELECTION) == 0) {
 		if ((lpht.flags & OS.TVHT_ONITEM) == 0) {
@@ -6550,7 +6554,7 @@
 		OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 		hittestSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;
 	}
-	
+
 	/* Get the selected state of the last selected item */
 	long /*int*/ hOldItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 	if ((style & SWT.MULTI) != 0) {
@@ -6575,7 +6579,7 @@
 			* focus from WM_MOUSEACTIVATE of the shell.  The fix is to
 			* force the WM_UPDATEUISTATE to be sent before disabling
 			* the drawing.
-			* 
+			*
 			* NOTE:  Any redraw of a parent (or sibling) will be dispatched
 			* during the modal drag detect loop.  This code only fixes the
 			* case where the tree causes a redraw from WM_UPDATEUISTATE.
@@ -6644,10 +6648,10 @@
 			OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
 		}
 	}
-	
+
 	/* Reselect the last item that was unselected */
 	if ((style & SWT.MULTI) != 0) {
-		
+
 		/* Check for CONTROL and reselect the last item */
 		if (hittestSelected || (wParam & OS.MK_CONTROL) != 0) {
 			if (hOldItem == hNewItem && hOldItem == lpht.hItem) {
@@ -6709,7 +6713,7 @@
 					if (OS.TreeView_GetItemRect (handle, hAnchor, rect1, false)) {
 						RECT rect2 = new RECT ();
 						if (OS.TreeView_GetItemRect (handle, hNewItem, rect2, false)) {
-							int flags = rect1.top < rect2.top ? OS.TVGN_NEXTVISIBLE : OS.TVGN_PREVIOUSVISIBLE;			
+							int flags = rect1.top < rect2.top ? OS.TVGN_NEXTVISIBLE : OS.TVGN_PREVIOUSVISIBLE;
 							tvItem.state = OS.TVIS_SELECTED;
 							long /*int*/ hItem = tvItem.hItem = hAnchor;
 							OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
@@ -6725,7 +6729,7 @@
 		}
 	}
 	if ((wParam & OS.MK_SHIFT) == 0) hAnchor = hNewItem;
-			
+
 	/* Issue notification */
 	if (!gestureCompleted) {
 		tvItem.hItem = hNewItem;
@@ -6736,7 +6740,7 @@
 		sendSelectionEvent (SWT.Selection, event, false);
 	}
 	gestureCompleted = false;
-	
+
 	/*
 	* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,
 	* the widget starts a modal loop to determine if the user wants
@@ -6840,7 +6844,7 @@
 	*/
 //	if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	if (OS.GetFocus () != handle) OS.SetFocus (handle);
-	
+
 	/*
 	* Feature in Windows.  When the user selects a tree item
 	* with the right mouse button, the item remains selected
@@ -7014,7 +7018,7 @@
 	* the image is drawn is not erased before it is drawn.
 	* This means that the image gets darker each time.
 	* The fix is to redraw the selection.
-	* 
+	*
 	* Feature in Windows.  When multiple item have
 	* the TVIS_SELECTED state, Windows redraws only
 	* the focused item in the color used to show the
@@ -7073,7 +7077,7 @@
 	* that is not inside the client area, Windows segment
 	* faults.  The fix is to call the default window proc
 	* rather than the default tree proc.
-	* 
+	*
 	* NOTE:  This problem is intermittent and happens on
 	* Windows Vista running under the theme manager.
 	*/
@@ -7235,7 +7239,7 @@
 				* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before
 				* TVM_INSERTITEM returns and before the item is added to
 				* the items array.  The fix is to check for null.
-				* 
+				*
 				* NOTE: This only happens on XP with the version 6.00 of
 				* COMCTL32.DLL.
 				*/
@@ -7296,10 +7300,10 @@
 			* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before
 			* TVM_INSERTITEM returns and before the item is added to
 			* the items array.  The fix is to check for null.
-			* 
+			*
 			* NOTE: This only happens on XP with the version 6.00 of
 			* COMCTL32.DLL.
-			* 
+			*
 			* Feature in Windows.  When TVM_DELETEITEM is called with
 			* TVI_ROOT to remove all items from a tree, under certain
 			* circumstances, the tree sends TVN_GETDISPINFO for items
@@ -7368,7 +7372,7 @@
 				}
 			}
 			NMTVCUSTOMDRAW nmcd = new NMTVCUSTOMDRAW ();
-			OS.MoveMemory (nmcd, lParam, NMTVCUSTOMDRAW.sizeof);		
+			OS.MoveMemory (nmcd, lParam, NMTVCUSTOMDRAW.sizeof);
 			switch (nmcd.dwDrawStage) {
 				case OS.CDDS_PREPAINT: return CDDS_PREPAINT (nmcd, wParam, lParam);
 				case OS.CDDS_ITEMPREPAINT: return CDDS_ITEMPREPAINT (nmcd, wParam, lParam);
@@ -7423,7 +7427,7 @@
 						return LRESULT.ONE;
 					}
 				}
-			}			
+			}
 			break;
 		}
 		case OS.TVN_SELCHANGINGA:
@@ -7517,7 +7521,7 @@
 				* is sent from within TVM_DELETEITEM for the tree item
 				* being destroyed.  By the time the message is sent,
 				* the item has already been removed from the list of
-				* items.  The fix is to check for null. 
+				* items.  The fix is to check for null.
 				*/
 				if (items == null) break;
 				TreeItem item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -7620,7 +7624,7 @@
 			break;
 		}
 		case OS.NM_RECOGNIZEGESTURE: {
-			/* 
+			/*
 			* Feature in Pocket PC.  The tree and table controls detect the tap
 			* and hold gesture by default. They send a GN_CONTEXTMENU message to show
 			* the popup menu.  This default behaviour is unwanted on Pocket PC 2002
@@ -7810,7 +7814,7 @@
 					if (column != null) {
 						column.updateToolTip (phdn.iItem);
 						column.sendEvent (SWT.Resize);
-						if (isDisposed ()) return LRESULT.ZERO;	
+						if (isDisposed ()) return LRESULT.ZERO;
 						TreeColumn [] newColumns = new TreeColumn [columnCount];
 						System.arraycopy (columns, 0, newColumns, 0, columnCount);
 						int [] order = new int [columnCount];
@@ -7840,7 +7844,7 @@
 			}
 			break;
 		}
-		case OS.HDN_ITEMDBLCLICKW:      
+		case OS.HDN_ITEMDBLCLICKW:
 		case OS.HDN_ITEMDBLCLICKA: {
 			NMHEADER phdn = new NMHEADER ();
 			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
Index: org/eclipse/swt/widgets/TableColumn.java
===================================================================
--- org/eclipse/swt/widgets/TableColumn.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TableColumn.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -830,7 +830,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -867,7 +867,7 @@
 	if (index == -1) return;
 	long /*int*/ hwnd = parent.handle;
 	if (width != (int)/*64*/OS.SendMessage (hwnd, OS.LVM_GETCOLUMNWIDTH, index, 0)) {
-		OS.SendMessage (hwnd, OS.LVM_SETCOLUMNWIDTH, index, width);
+	OS.SendMessage (hwnd, OS.LVM_SETCOLUMNWIDTH, index, width);
 	}
 }
 
Index: org/eclipse/swt/widgets/Shell.java
===================================================================
--- org/eclipse/swt/widgets/Shell.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Shell.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1046,7 +1046,7 @@
 	return new Point (width,  height);
 }
 
-/**
+/** 
  * Gets the receiver's modified state.
  *
  * @return <code>true</code> if the receiver is marked as modified, or <code>false</code> otherwise
@@ -2291,7 +2291,8 @@
 	* embedded widget's event loop.
 	*/
 	POINT pt = new POINT ();
-	if (!OS.GetCursorPos (pt)) {
+        // <QFS/> Get overridden cursor position
+	if (!OS._GetCursorPos (pt)) {
 		int pos = OS.GetMessagePos ();
 		OS.POINTSTOPOINT (pt, pos);
 	}
Index: org/eclipse/swt/widgets/List.java
===================================================================
--- org/eclipse/swt/widgets/List.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/List.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -782,7 +782,7 @@
 	if (topCount > 0) {
 		topIndex -= topCount;
 	}
-	OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
+		OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
 	if (i < newIndices.length) error (SWT.ERROR_ITEM_NOT_REMOVED);
 }
 
@@ -897,7 +897,7 @@
 	if (end < topIndex) {
 		topIndex -= end - start + 1;
 	}
-	OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
+		OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
 	if (index <= end) error (SWT.ERROR_ITEM_NOT_REMOVED);
 }
 
@@ -1535,7 +1535,8 @@
 	* it inaccessible from the keyboard.  The fix is to implement
 	* the key processing.
 	*/
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0 && getDisplay().GetKeyState (OS.VK_SHIFT) >= 0) {
 		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		if ((bits & OS.LBS_EXTENDEDSEL) != 0) {
 			switch ((int)/*64*/wParam) {
@@ -1563,7 +1564,8 @@
 	* it inaccessible from the keyboard.  The fix is to implement
 	* the key processing.
 	*/
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0 && getDisplay().GetKeyState (OS.VK_SHIFT) >= 0) {
 		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		if ((bits & OS.LBS_EXTENDEDSEL) != 0) {
 			int newIndex = -1;
@@ -1628,28 +1630,28 @@
 				}
 			}
 			if (newIndex != -1) {
-				/*
-				* Feature in Windows.  When the user changes focus using
-				* the keyboard, the focus indicator does not draw.  The
-				* fix is to update the UI state for the control whenever
-				* the focus indicator changes as a result of something
-				* the user types.
-				*/
-				int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
-				if ((uiState & OS.UISF_HIDEFOCUS) != 0) {
-					OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
-					/*
-					* Bug in Windows.  When the WM_CHANGEUISTATE is used
-					* to update the UI state for a list that has been
-					* selected using Shift+Arrow, the focus indicator
-					* has pixel corruption.  The fix is to redraw the
+	/*
+	* Feature in Windows.  When the user changes focus using
+	* the keyboard, the focus indicator does not draw.  The
+	* fix is to update the UI state for the control whenever
+	* the focus indicator changes as a result of something
+	* the user types.
+	*/
+	int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
+	if ((uiState & OS.UISF_HIDEFOCUS) != 0) {
+			OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
+			/*
+			* Bug in Windows.  When the WM_CHANGEUISTATE is used
+			* to update the UI state for a list that has been
+			* selected using Shift+Arrow, the focus indicator
+			* has pixel corruption.  The fix is to redraw the
 					* control.
-					*/
-					RECT itemRect = new RECT ();
+			*/
+			RECT itemRect = new RECT ();
 					int oldIndex = (int)/*64*/OS.SendMessage (handle, OS.LB_GETCARETINDEX, 0, 0);
 					OS.SendMessage (handle, OS.LB_GETITEMRECT, oldIndex, itemRect);
-					OS.InvalidateRect (handle, itemRect, true);
-				}
+			OS.InvalidateRect (handle, itemRect, true);
+		}
 				OS.SendMessage (handle, OS.LB_SETCARETINDEX, newIndex, 0);
 				return LRESULT.ZERO;
 			}
Index: org/eclipse/swt/widgets/Control.java
===================================================================
--- org/eclipse/swt/widgets/Control.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Control.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -19,6 +20,11 @@
 import org.eclipse.swt.events.*;
 import org.eclipse.swt.accessibility.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Control is the abstract superclass of all windowed user interface classes.
  * <p>
@@ -37,7 +43,7 @@
  * IMPORTANT: This class is intended to be subclassed <em>only</em>
  * within the SWT implementation.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/snippets/#control">Control snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
@@ -46,8 +52,15 @@
 
 public abstract class Control extends Widget implements Drawable {
 
+    // {{{ <QFS> Log
+
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Control");
+    private final static Logger suppresslogger = new Logger("suppress.aus.ab.DBG");
+
+    // }}} </QFS>
+
 	/**
-	 * the handle to the OS resource 
+	 * the handle to the OS resource
 	 * (Warning: This field is platform dependent)
 	 * <p>
 	 * <b>IMPORTANT:</b> This field is <em>not</em> part of the SWT
@@ -55,7 +68,7 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public long /*int*/ handle;
@@ -82,7 +95,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -157,7 +170,7 @@
  *
  * @see DragDetectListener
  * @see #removeDragDetectListener
- * 
+ *
  * @since 3.3
  */
 public void addDragDetectListener (DragDetectListener listener) {
@@ -205,7 +218,7 @@
  * must be invoked on it to specify that gesture events should be
  * sent instead of touch events.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified
  *
  * @exception IllegalArgumentException <ul>
@@ -219,7 +232,7 @@
  * @see GestureListener
  * @see #removeGestureListener
  * @see #setTouchEnabled
- * 
+ *
  * @since 3.7
  */
 public void addGestureListener (GestureListener listener) {
@@ -467,7 +480,7 @@
  * specify that touch events should be sent, which will cause gesture
  * events to not be sent.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified
  *
  * @exception IllegalArgumentException <ul>
@@ -557,7 +570,7 @@
 		}
 		if (composite == shell) break;
 		composite = composite.parent;
-	} while (true);	
+	} while (true);
 }
 
 void checkBorder () {
@@ -590,8 +603,8 @@
  * best be displayed at. The width hint and height hint arguments
  * allow the caller to ask a control questions such as "Given a particular
  * width, how high does the control need to be to show all of the contents?"
- * To indicate that the caller does not wish to constrain a particular 
- * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint. 
+ * To indicate that the caller does not wish to constrain a particular
+ * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.
  * </p>
  *
  * @param wHint the width hint (can be <code>SWT.DEFAULT</code>)
@@ -621,14 +634,14 @@
  * best be displayed at. The width hint and height hint arguments
  * allow the caller to ask a control questions such as "Given a particular
  * width, how high does the control need to be to show all of the contents?"
- * To indicate that the caller does not wish to constrain a particular 
- * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint. 
+ * To indicate that the caller does not wish to constrain a particular
+ * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.
  * </p><p>
  * If the changed flag is <code>true</code>, it indicates that the receiver's
  * <em>contents</em> have changed, therefore any caches that a layout manager
  * containing the control may have been keeping need to be flushed. When the
  * control is resized, the changed flag will be <code>false</code>, so layout
- * manager caches can be retained. 
+ * manager caches can be retained.
  * </p>
  *
  * @param wHint the width hint (can be <code>SWT.DEFAULT</code>)
@@ -711,7 +724,7 @@
 		OS.ImmAssociateContext (handle, hIMC);
 		OS.ImmReleaseContext (hwndParent, hIMC);
 	}
-	
+
 }
 
 void checkGesture () {
@@ -732,7 +745,7 @@
 				OS.MoveMemory (pConfigs, config, GESTURECONFIG.sizeof);
 				OS.SetGestureConfig (handle, 0, 1, pConfigs, GESTURECONFIG.sizeof);
 				OS.HeapFree (hHeap, 0, pConfigs);
-			}		
+			}
 		}
 	}
 }
@@ -785,7 +798,7 @@
  * Detects a drag and drop gesture.  This method is used
  * to detect a drag gesture when called from within a mouse
  * down listener.
- * 
+ *
  * <p>By default, a drag is detected when the gesture
  * occurs anywhere within the client area of a control.
  * Some controls, such as tables and trees, override this
@@ -798,7 +811,7 @@
  * </p>
  *
  * @param event the mouse down event
- * 
+ *
  * @return <code>true</code> if the gesture occurred, and <code>false</code> otherwise.
  *
  * @exception IllegalArgumentException <ul>
@@ -808,13 +821,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- *  
+ *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @see #getDragDetect
  * @see #setDragDetect
- * 
+ *
  * @since 3.3
  */
 public boolean dragDetect (Event event) {
@@ -827,7 +840,7 @@
  * Detects a drag and drop gesture.  This method is used
  * to detect a drag gesture when called from within a mouse
  * down listener.
- * 
+ *
  * <p>By default, a drag is detected when the gesture
  * occurs anywhere within the client area of a control.
  * Some controls, such as tables and trees, override this
@@ -840,7 +853,7 @@
  * </p>
  *
  * @param event the mouse down event
- * 
+ *
  * @return <code>true</code> if the gesture occurred, and <code>false</code> otherwise.
  *
  * @exception IllegalArgumentException <ul>
@@ -850,13 +863,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @see #getDragDetect
  * @see #setDragDetect
- * 
+ *
  * @since 3.3
  */
 public boolean dragDetect (MouseEvent event) {
@@ -868,7 +881,8 @@
 boolean dragDetect (int button, int count, int stateMask, int x, int y) {
 	if (button != 1 || count != 1) return false;
 	boolean dragging = dragDetect (handle, x, y, false, null, null);
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	}
 	if (!dragging) {
@@ -885,7 +899,7 @@
 		* mouse down/up pairs or looks for the ESC key will not
 		* function properly.  The fix is to send the missing
 		* events when the drag has not started.
-		* 
+		*
 		* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP
 		* events for the ESC key.  This would require computing
 		* wParam (the key) and lParam (the repeat count, scan code,
@@ -892,7 +906,8 @@
 		* extended-key flag, context code, previous key-state flag,
 		* and transition-state flag) which is non-trivial.
 		*/
-		if (button == 1 && OS.GetKeyState (OS.VK_ESCAPE) >= 0) {
+                // <QFS/> Changed to getDisplay().GetKeyState
+		if (button == 1 && getDisplay().GetKeyState (OS.VK_ESCAPE) >= 0) {
 			int wParam = 0;
 			if ((stateMask & SWT.CTRL) != 0) wParam |= OS.MK_CONTROL;
 			if ((stateMask & SWT.SHIFT) != 0) wParam |= OS.MK_SHIFT;
@@ -1049,7 +1064,7 @@
 	boolean oldFixFocus = display.fixFocus;
 	display.fixFocus = true;
 	try {
-		while (control != shell && (control = control.parent) != null) {
+	while (control != shell && (control = control.parent) != null) {
 				if (control.setFocus ()) return;
 		}
 	} finally {
@@ -1090,7 +1105,7 @@
 	* control will no longer have the focus
 	* and the call to setFocus() will return
 	* false indicating failure.
-	* 
+	*
 	* We are still working on a solution at
 	* this time.
 	*/
@@ -1112,7 +1127,7 @@
 			* This code is intentionally commented.  All widgets that
 			* are created by SWT have WS_CLIPSIBLINGS to ensure that
 			* application code does not draw outside of the control.
-			*/	
+			*/
 //			int count = parent.getChildrenCount ();
 //			if (count > 1) {
 //				int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
@@ -1121,7 +1136,7 @@
 			SetWindowPos (wp.hwnd, 0, wp.x, wp.y, wp.cx, wp.cy, wp.flags);
 			lpwp [i] = null;
 			return;
-		}	
+		}
 	}
 }
 
@@ -1139,10 +1154,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Accessible#addAccessibleListener
  * @see Accessible#addAccessibleControlListener
- * 
+ *
  * @since 2.0
  */
 public Accessible getAccessible () {
@@ -1181,7 +1196,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public Image getBackgroundImage () {
@@ -1288,7 +1303,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public Cursor getCursor () {
@@ -1298,15 +1313,15 @@
 
 /**
  * Returns <code>true</code> if the receiver is detecting
- * drag gestures, and  <code>false</code> otherwise. 
+ * drag gestures, and  <code>false</code> otherwise.
  *
  * @return the receiver's drag detect state
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public boolean getDragDetect () {
@@ -1330,7 +1345,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -1393,8 +1408,8 @@
 /**
  * Returns a point describing the receiver's location relative
  * to its parent (or its display if its parent is null), unless
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @return the receiver's location
  *
@@ -1435,14 +1450,14 @@
 
 /**
  * Returns the receiver's monitor.
- * 
+ *
  * @return the receiver's monitor
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public Monitor getMonitor () {
@@ -1472,12 +1487,12 @@
  * constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public int getOrientation () {
@@ -1519,12 +1534,12 @@
 	return result;
 }
 
-/** 
+/**
  * Returns the region that defines the shape of the control,
  * or null if the control has the default shape.
  *
  * @return the region that defines the shape of the shell (or null)
- *	
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1650,7 +1665,8 @@
 	if (!OS.GetClientRect (handle, rect)) return false;
 	OS.MapWindowPoints (handle, 0, rect, 2);
 	POINT pt = new POINT ();
-	return OS.GetCursorPos (pt) && OS.PtInRect (rect, pt);
+        // <QFS/> Get overridden cursor position
+	return OS._GetCursorPos (pt) && OS.PtInRect (rect, pt);
 }
 
 boolean hasFocus () {
@@ -1670,7 +1686,7 @@
 	return false;
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to allocate a new GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -1680,9 +1696,9 @@
  * application code.
  * </p>
  *
- * @param data the platform specific GC data 
+ * @param data the platform specific GC data
  * @return the platform specific GC handle
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public long /*int*/ internal_new_GC (GCData data) {
@@ -1726,7 +1742,7 @@
 	return hDC;
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to dispose a GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -1737,8 +1753,8 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data 
- * 
+ * @param data the platform specific GC data
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public void internal_dispose_GC (long /*int*/ hDC, GCData data) {
@@ -1803,7 +1819,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -1965,13 +1981,13 @@
  * @param control the sibling control (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Control#moveBelow
  * @see Composite#getChildren
  */
@@ -1995,7 +2011,7 @@
 			hwndAbove = OS.HWND_TOP;
 		}
 	}
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, hwndAbove, 0, 0, 0, 0, flags);
 }
 
@@ -2009,13 +2025,13 @@
  * @param control the sibling control (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Control#moveAbove
  * @see Composite#getChildren
  */
@@ -2037,7 +2053,7 @@
 		*/
 		Shell shell = getShell ();
 		if (this == shell && parent != null) {
-			/* 
+			/*
 			* Bug in Windows.  For some reason, when GetWindow ()
 			* with GW_HWNDPREV is used to query the previous window
 			* in the z-order with the first child, Windows returns
@@ -2055,7 +2071,7 @@
 		}
 	}
 	if (hwndAbove == 0 || hwndAbove == topHandle) return;
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, hwndAbove, 0, 0, 0, 0, flags);
 }
 
@@ -2093,11 +2109,11 @@
  * <em>contents</em> have changed, therefore any caches that a layout manager
  * containing the control may have been keeping need to be flushed. When the
  * control is resized, the changed flag will be <code>false</code>, so layout
- * manager caches can be retained. 
+ * manager caches can be retained.
  * </p>
  *
  * @param changed whether or not the receiver's contents have changed
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -2112,7 +2128,7 @@
 
 /**
  * Prints the receiver and all children.
- * 
+ *
  * @param gc the gc where the drawing occurs
  * @return <code>true</code> if the operation was successful and <code>false</code> otherwise
  *
@@ -2124,7 +2140,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public boolean print (GC gc) {
@@ -2208,9 +2224,9 @@
 		OS.GetWindowRect (hwnd, rect1);
 		boolean fixPrintWindow = !OS.IsWindowVisible(hwnd);
 		if (!fixPrintWindow) {
-			RECT rect2 = new RECT ();
-			OS.GetWindowRect (hwndShell, rect2);
-			OS.IntersectRect (rect2, rect1, rect2);
+		RECT rect2 = new RECT ();
+		OS.GetWindowRect (hwndShell, rect2);
+		OS.IntersectRect (rect2, rect1, rect2);
 			fixPrintWindow = !OS.EqualRect (rect2, rect1);
 		}
 		/*
@@ -2246,12 +2262,12 @@
 		}
 		if (fixPrintWindow) {
 			int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-			int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+			int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 			int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 			int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 			int flags = OS.SWP_NOSIZE | OS.SWP_NOZORDER | OS.SWP_NOACTIVATE | OS.SWP_DRAWFRAME;
 			if ((bits1 & OS.WS_VISIBLE) != 0) {
-				OS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);
+			OS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);
 			}
 			SetWindowPos (hwnd, 0, x + width, y + height, 0, 0, flags);
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -2290,7 +2306,7 @@
 			}
 		}
 	}
-	
+
 	/*
 	* Bug in Windows.  For some reason, PrintWindow() fails
 	* when it is called on a push button.  The fix is to
@@ -2341,7 +2357,7 @@
 }
 /**
  * Causes the rectangular area of the receiver specified by
- * the arguments to be marked as needing to be redrawn. 
+ * the arguments to be marked as needing to be redrawn.
  * The next time a paint request is processed, that area of
  * the receiver will be painted, including the background.
  * If the <code>all</code> flag is <code>true</code>, any
@@ -2484,7 +2500,7 @@
  *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @since 3.3
  */
 public void removeDragDetectListener(DragDetectListener listener) {
@@ -2535,7 +2551,7 @@
  *
  * @see GestureListener
  * @see #addGestureListener
- * 
+ *
  * @since 3.7
  */
 public void removeGestureListener (GestureListener listener) {
@@ -2805,7 +2821,7 @@
 
 boolean sendFocusEvent (int type) {
 	Shell shell = getShell ();
-	
+
 	/*
 	* Feature in Windows.  During the processing of WM_KILLFOCUS,
 	* when the focus window is queried using GetFocus(), it has
@@ -2829,7 +2845,7 @@
 	* disposed at this point.  If this happens
 	* don't send the activate and deactivate
 	* events.
-	*/	
+	*/
 	if (!shell.isDisposed ()) {
 		switch (type) {
 			case SWT.FocusIn:
@@ -2870,10 +2886,10 @@
 			}
 
 			/*
-			* The gi.ullArguments is the distance between the fingers. 
+			* The gi.ullArguments is the distance between the fingers.
 			* Scale factor is relative to that original value.
 			*/
-			if (fingerDistance == display.lastDistance && event.detail == SWT.GESTURE_MAGNIFY) return true;			
+			if (fingerDistance == display.lastDistance && event.detail == SWT.GESTURE_MAGNIFY) return true;
 			if (fingerDistance != 0) event.magnification = fingerDistance / display.magStartDistance;
 			display.lastDistance = fingerDistance;
 			break;
@@ -2891,10 +2907,10 @@
 			event.xDirection = point.x - display.lastX;
 			event.yDirection = point.y - display.lastY;
 			display.lastX = point.x;
-			display.lastY = point.y;			
+			display.lastY = point.y;
 			break;
 		case OS.GID_ROTATE:
-			type = SWT.Gesture;			
+			type = SWT.Gesture;
 			event.detail = SWT.GESTURE_ROTATE;
 			double rotationInRadians = OS.GID_ROTATE_ANGLE_FROM_ARGUMENT (OS.LODWORD (gi.ullArguments));
 			if ((gi.dwFlags & OS.GF_BEGIN) != 0) {
@@ -2919,7 +2935,7 @@
 
     if (type == 0) return true;
 	setInputState (event, type);
-	sendEvent (type, event);	
+	sendEvent (type, event);
 	return event.doit;
 }
 
@@ -2980,7 +2996,7 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3011,14 +3027,14 @@
  * @param image the new image (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setBackgroundImage (Image image) {
@@ -3054,9 +3070,9 @@
 
 /**
  * Sets the receiver's size and location to the rectangular
- * area specified by the arguments. The <code>x</code> and 
+ * area specified by the arguments. The <code>x</code> and
  * <code>y</code> arguments are relative to the receiver's
- * parent (or its display if its parent is null), unless 
+ * parent (or its display if its parent is null), unless
  * the receiver is a shell. In this case, the <code>x</code>
  * and <code>y</code> arguments are relative to the display.
  * <p>
@@ -3126,7 +3142,7 @@
 
 /**
  * Sets the receiver's size and location to the rectangular
- * area specified by the argument. The <code>x</code> and 
+ * area specified by the argument. The <code>x</code> and
  * <code>y</code> fields of the rectangle are relative to
  * the receiver's parent (or its display if its parent is null).
  * <p>
@@ -3189,7 +3205,7 @@
  * @param cursor the new cursor (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3208,7 +3224,8 @@
 	long /*int*/ hwndCursor = OS.GetCapture ();
 	if (hwndCursor == 0) {
 		POINT pt = new POINT ();
-		if (!OS.GetCursorPos (pt)) return;
+                // <QFS/> Get overridden cursor position
+		if (!OS._GetCursorPos (pt)) return;
 		long /*int*/ hwnd = hwndCursor = OS.WindowFromPoint (pt);
 		while (hwnd != 0 && hwnd != handle) {
 			hwnd = OS.GetParent (hwnd);
@@ -3236,7 +3253,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public void setDragDetect (boolean dragDetect) {
@@ -3284,7 +3301,7 @@
 }
 
 /**
- * Causes the receiver to have the <em>keyboard focus</em>, 
+ * Causes the receiver to have the <em>keyboard focus</em>,
  * such that all keyboard events will be delivered to it.  Focus
  * reassignment will respect applicable platform constraints.
  *
@@ -3311,7 +3328,7 @@
  * @param font the new font (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3321,7 +3338,7 @@
 public void setFont (Font font) {
 	checkWidget ();
 	long /*int*/ hFont = 0;
-	if (font != null) { 
+	if (font != null) {
 		if (font.isDisposed()) SWT.error(SWT.ERROR_INVALID_ARGUMENT);
 		hFont = font.handle;
 	}
@@ -3340,7 +3357,7 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3365,9 +3382,9 @@
 
 /**
  * Sets the layout data associated with the receiver to the argument.
- * 
+ *
  * @param layoutData the new layout data for the receiver.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3381,9 +3398,9 @@
 /**
  * Sets the receiver's location to the point specified by
  * the arguments which are relative to the receiver's
- * parent (or its display if its parent is null), unless 
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * parent (or its display if its parent is null), unless
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @param x the new x coordinate for the receiver
  * @param y the new y coordinate for the receiver
@@ -3409,9 +3426,9 @@
 /**
  * Sets the receiver's location to the point specified by
  * the arguments which are relative to the receiver's
- * parent (or its display if its parent is null), unless 
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * parent (or its display if its parent is null), unless
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @param location the new location for the receiver
  *
@@ -3444,7 +3461,7 @@
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_MENU_NOT_POP_UP - the menu is not a pop up menu</li>
  *    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3471,12 +3488,12 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public void setOrientation (int orientation) {
@@ -3519,7 +3536,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #redraw(int, int, int, int, boolean)
  * @see #update()
  */
@@ -3575,7 +3592,7 @@
  *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the region has been disposed</li>
- * </ul>  
+ * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3652,7 +3669,7 @@
 
 /**
  * Sets the receiver's tool tip text to the argument, which
- * may be null indicating that the default tool tip for the 
+ * may be null indicating that the default tool tip for the
  * control will be shown. For a control that has a default
  * tool tip, such as the Tree control on Windows, setting
  * the tool tip text to an empty string replaces the default,
@@ -3659,10 +3676,10 @@
  * causing no tool tip text to be shown.
  * <p>
  * The mnemonic indicator (character '&amp;') is not displayed in a tool tip.
- * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
+ * To display a single '&amp;' in the tool tip, the character '&amp;' can be
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -3685,9 +3702,9 @@
  * Setting this to <code>false</code> causes the receiver to send gesture events
  * instead.  No exception is thrown if a touch-based input device is not
  * detected (this can be determined with <code>Display#getTouchEnabled()</code>).
- * 
+ *
  * @param enabled the new touch-enabled state
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3707,7 +3724,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -3733,7 +3750,7 @@
 		sendEvent (SWT.Show);
 		if (isDisposed ()) return;
 	}
-	
+
 	/*
 	* Feature in Windows.  If the receiver has focus, hiding
 	* the receiver causes no window to have focus.  The fix is
@@ -3798,13 +3815,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public Point toControl (int x, int y) {
 	checkWidget ();
 	POINT pt = new POINT ();
-	pt.x = x;  pt.y = y; 
+	pt.x = x;  pt.y = y;
 	OS.ScreenToClient (handle, pt);
 	return new Point (pt.x, pt.y);
 }
@@ -3844,13 +3861,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public Point toDisplay (int x, int y) {
 	checkWidget ();
 	POINT pt = new POINT ();
-	pt.x = x;  pt.y = y; 
+	pt.x = x;  pt.y = y;
 	OS.ClientToScreen (handle, pt);
 	return new Point (pt.x, pt.y);
 }
@@ -3895,7 +3912,8 @@
 boolean translateMnemonic (MSG msg) {
 	if (msg.wParam < 0x20) return false;
 	long /*int*/ hwnd = msg.hwnd;
-	if (OS.GetKeyState (OS.VK_MENU) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_MENU) >= 0) {
 		long /*int*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 		if ((code & OS.DLGC_WANTALLKEYS) != 0) return false;
 		if ((code & OS.DLGC_BUTTON) == 0) return false;
@@ -3914,11 +3932,18 @@
 }
 
 boolean translateTraversal (MSG msg) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("translateTraversal(MSG)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(msg)).log(Log.MTD);
+    }
+    // </QFS>
 	long /*int*/ hwnd = msg.hwnd;
 	int key = (int)/*64*/msg.wParam;
 	if (key == OS.VK_MENU) {
 		if ((msg.lParam & 0x40000000) == 0) {
-			OS.SendMessage (hwnd, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
+		OS.SendMessage (hwnd, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
 		}
 		return false;
 	}
@@ -3954,7 +3979,8 @@
 		}
 		case OS.VK_TAB: {
 			lastAscii = '\t';
-			boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 			long /*int*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 			if ((code & (OS.DLGC_WANTTAB | OS.DLGC_WANTALLKEYS)) != 0) {
 				/*
@@ -3966,7 +3992,8 @@
 				* Shift+Tab to the control.
 				*/
 				if ((code & OS.DLGC_HASSETSEL) != 0) {
-					if (next && OS.GetKeyState (OS.VK_CONTROL) >= 0) {
+                                        // <QFS/> Changed to getDisplay().GetKeyState
+					if (next && getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) {
 						doit = false;
 					}
 				} else {
@@ -4002,7 +4029,8 @@
 		case OS.VK_NEXT: {
 			all = true;
 			lastVirtual = true;
-			if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return false;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return false;
 			long /*int*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 			if ((code & OS.DLGC_WANTALLKEYS) != 0) {
 				/*
@@ -4025,7 +4053,15 @@
 	display.lastAscii = lastAscii;
 	display.lastVirtual = lastVirtual;
 	display.lastNull = display.lastDead = false;
-	if (!setKeyState (event, SWT.Traverse, msg.wParam, msg.lParam)) return false;
+	if (!setKeyState (event, SWT.Traverse, msg.wParam, msg.lParam)) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "translateTraversal(MSG)",
+                           "setKeyState returned false");
+            }
+            // </QFS>
+            return false;
+        }
 	Shell shell = getShell ();
 	Control control = this;
 	do {
@@ -4046,7 +4082,7 @@
 	* code could have disposed the widget in the traverse
 	* event.  If this happens, return true to stop further
 	* event processing.
-	*/	
+	*/
 	sendEvent (SWT.Traverse, event);
 	if (isDisposed ()) return true;
 	if (!event.doit) return false;
@@ -4058,7 +4094,7 @@
 		case SWT.TRAVERSE_TAB_PREVIOUS:	return traverseGroup (false);
 		case SWT.TRAVERSE_ARROW_NEXT:		return traverseItem (true);
 		case SWT.TRAVERSE_ARROW_PREVIOUS:	return traverseItem (false);
-		case SWT.TRAVERSE_MNEMONIC:		return traverseMnemonic (event.character);	
+		case SWT.TRAVERSE_MNEMONIC:		return traverseMnemonic (event.character);
 		case SWT.TRAVERSE_PAGE_NEXT:		return traversePage (true);
 		case SWT.TRAVERSE_PAGE_PREVIOUS:	return traversePage (false);
 	}
@@ -4068,8 +4104,8 @@
 /**
  * Based on the argument, perform one of the expected platform
  * traversal action. The argument should be one of the constants:
- * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>, 
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  *
@@ -4091,11 +4127,11 @@
 
 /**
  * Performs a platform traversal action corresponding to a <code>KeyDown</code> event.
- * 
+ *
  * <p>Valid traversal values are
  * <code>SWT.TRAVERSE_NONE</code>, <code>SWT.TRAVERSE_MNEMONIC</code>,
  * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  * If <code>traversal</code> is <code>SWT.TRAVERSE_NONE</code> then the Traverse
@@ -4102,13 +4138,13 @@
  * event is created with standard values based on the KeyDown event.  If
  * <code>traversal</code> is one of the other traversal constants then the Traverse
  * event is created with this detail, and its <code>doit</code> is taken from the
- * KeyDown event. 
+ * KeyDown event.
  * </p>
  *
  * @param traversal the type of traversal, or <code>SWT.TRAVERSE_NONE</code> to compute
  * this from <code>event</code>
  * @param event the KeyDown event
- * 
+ *
  * @return <code>true</code> if the traversal succeeded
  *
  * @exception IllegalArgumentException <ul>
@@ -4129,11 +4165,11 @@
 
 /**
  * Performs a platform traversal action corresponding to a <code>KeyDown</code> event.
- * 
+ *
  * <p>Valid traversal values are
  * <code>SWT.TRAVERSE_NONE</code>, <code>SWT.TRAVERSE_MNEMONIC</code>,
  * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  * If <code>traversal</code> is <code>SWT.TRAVERSE_NONE</code> then the Traverse
@@ -4140,13 +4176,13 @@
  * event is created with standard values based on the KeyDown event.  If
  * <code>traversal</code> is one of the other traversal constants then the Traverse
  * event is created with this detail, and its <code>doit</code> is taken from the
- * KeyDown event. 
+ * KeyDown event.
  * </p>
  *
  * @param traversal the type of traversal, or <code>SWT.TRAVERSE_NONE</code> to compute
  * this from <code>event</code>
  * @param event the KeyDown event
- * 
+ *
  * @return <code>true</code> if the traversal succeeded
  *
  * @exception IllegalArgumentException <ul>
@@ -4443,7 +4479,7 @@
 	*/
 	if (OS.WIN32_VERSION < OS.VERSION (4, 10)) {
 		return bits;
-	} 
+	}
 	bits |= OS.WS_EX_NOINHERITLAYOUT;
 	if ((style & SWT.RIGHT_TO_LEFT) != 0) bits |= OS.WS_EX_LAYOUTRTL;
 	return bits;
@@ -4463,7 +4499,7 @@
 		if ((style & SWT.BORDER) != 0) bits |= OS.WS_BORDER;
 	}
 	return bits;
-	
+
 	/*
 	* This code is intentionally commented.  When clipping
 	* of both siblings and children is not enforced, it is
@@ -4486,7 +4522,7 @@
  *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
- *    <li>ERROR_NULL_ARGUMENT - if the parent is <code>null</code></li> 
+ *    <li>ERROR_NULL_ARGUMENT - if the parent is <code>null</code></li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -4509,7 +4545,7 @@
 	long /*int*/ topHandle = topHandle ();
 	if (OS.SetParent (topHandle, parent.handle) == 0) return false;
 	this.parent = parent;
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, OS.HWND_BOTTOM, 0, 0, 0, 0, flags);
 	reskin (SWT.ALL);
 	return true;
@@ -4520,6 +4556,19 @@
 abstract long /*int*/ windowProc ();
 
 long /*int*/ windowProc (long /*int*/ hwnd, int msg, long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("windowProc(long,int,long,long)");
+        boolean[] hasMatch = new boolean[1];
+        String msgtype = OS.getWinMsgType(msg, hasMatch);
+        (logger.level < Log.MTD ? lb : lb
+         .add("hwnd: ").addHex(hwnd)
+         .add(", class=").add(this.getClass().getName())
+         .add(", msg: ").add(OS.getWinMsgType(msg, null))
+         .add(", wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	LRESULT result = null;
 	switch (msg) {
 		case OS.WM_ACTIVATE:			result = WM_ACTIVATE (wParam, lParam); break;
@@ -4556,7 +4605,7 @@
 		case OS.WM_IME_ENDCOMPOSITION:	result = WM_IME_ENDCOMPOSITION (wParam, lParam); break;
 		case OS.WM_INITMENUPOPUP:		result = WM_INITMENUPOPUP (wParam, lParam); break;
 		case OS.WM_INPUTLANGCHANGE:		result = WM_INPUTLANGCHANGE (wParam, lParam); break;
-		case OS.WM_HOTKEY:				result = WM_HOTKEY (wParam, lParam); break;		
+		case OS.WM_HOTKEY:				result = WM_HOTKEY (wParam, lParam); break;
 		case OS.WM_KEYDOWN:				result = WM_KEYDOWN (wParam, lParam); break;
 		case OS.WM_KEYUP:				result = WM_KEYUP (wParam, lParam); break;
 		case OS.WM_KILLFOCUS:			result = WM_KILLFOCUS (wParam, lParam); break;
@@ -4649,6 +4698,14 @@
 }
 
 LRESULT WM_COMMAND (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_COMMAND(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	/*
 	* When the WM_COMMAND message is sent from a
 	* menu, the HWND parameter in LPARAM is zero.
@@ -4658,6 +4715,12 @@
 		if (shell.isEnabled ()) {
 			int id = OS.LOWORD (wParam);
 			MenuItem item = display.getMenuItem (id);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("WM_COMMAND(long,long)")
+                                .add("item: ").add(item).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (item != null && item.isEnabled ()) {
 				return item.wmCommandChild (wParam, lParam);
 			}
@@ -4732,7 +4795,7 @@
 		if (OS.GetGestureInfo (lParam, gi)) {
 			if (!sendGestureEvent (gi)) {
 				OS.CloseGestureInfoHandle (lParam);
-				return LRESULT.ZERO; 
+				return LRESULT.ZERO;
 			}
 		}
 	}
@@ -4796,6 +4859,14 @@
 }
 
 LRESULT WM_HSCROLL (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_HSCROLL(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	Control control = display.getControl (lParam);
 	if (control == null) return null;
 	return control.wmScrollChild (wParam, lParam);
@@ -4828,7 +4899,15 @@
 }
 
 LRESULT WM_INITMENUPOPUP (long /*int*/ wParam, long /*int*/ lParam) {
-	
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_INITMENUPOPUP(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+
 	/* Ignore WM_INITMENUPOPUP for an accelerator */
 	if (display.accelKeyHit) return null;
 
@@ -4839,10 +4918,22 @@
 	*/
 	Shell shell = getShell ();
 	Menu oldMenu = shell.activeMenu, newMenu = null;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(long,long)")
+                .add("oldMenu: ").add(oldMenu).log(Log.DBG);
+        }
+        // </QFS>
 	if (OS.HIWORD (lParam) == 0) {
 		newMenu = menuShell ().findMenu (wParam);
 		if (newMenu != null) newMenu.update ();
-	}	
+	}
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(long,long)")
+                .add("newMenu: ").add(newMenu).log(Log.DBG);
+        }
+        // </QFS>
 	Menu menu = newMenu;
 	while (menu != null && menu != oldMenu) {
 		menu = menu.getParentMenu ();
@@ -4867,7 +4958,7 @@
 			if (ancestor != null) break;
 		}
 	}
-	
+
 	/*
 	* The shell and the new menu may be disposed because of
 	* sending the hide event to the ancestor menus but setting
@@ -4875,9 +4966,21 @@
 	*/
 	if (newMenu != null && newMenu.isDisposed ()) newMenu = null;
 	shell.activeMenu = newMenu;
-	
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(long,long)")
+                .add("shell.activeMenu: ").add(shell.activeMenu).log(Log.DBG);
+        }
+        // </QFS>
+
 	/* Send the show event */
 	if (newMenu != null && newMenu != oldMenu) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.build("WM_INITMENUPOPUP(long,long)")
+                    .add("show newMenu: ").add(newMenu).log(Log.DBG);
+            }
+            // </QFS>
 		newMenu.sendEvent (SWT.Show);
 		// widget could be disposed at this point
 	}
@@ -4889,11 +4992,43 @@
 }
 
 LRESULT WM_KEYDOWN (long /*int*/ wParam, long /*int*/ lParam) {
-	return wmKeyDown (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_KEYDOWN(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT lresult = wmKeyDown (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTDDETAIL) {
+        logger.log(Log.MTDDETAIL, "WM_KEYDOWN(long,long)",
+                   "lresult="+(lresult == null ? "null" : ""+lresult.value));
+    }
+    // </QFS>
+
+    return lresult;
 }
 
 LRESULT WM_KEYUP (long /*int*/ wParam, long /*int*/ lParam) {
-	return wmKeyUp (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_KEYUP(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT lresult = wmKeyUp (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTDDETAIL) {
+        logger.log(Log.MTDDETAIL, "WM_KEYUP(long,long)",
+                   "lresult="+(lresult == null ? "null" : ""+lresult.value));
+    }
+    // </QFS>
+
+    return lresult;
 }
 
 LRESULT WM_KILLFOCUS (long /*int*/ wParam, long /*int*/ lParam) {
@@ -4956,6 +5091,14 @@
 }
 
 LRESULT WM_MENUSELECT (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_MENUSELECT(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	int code = OS.HIWORD (wParam);
 	Shell shell = getShell ();
 	if (code == 0xFFFF && lParam == 0) {
@@ -4988,6 +5131,12 @@
 		* to null in a destroyed widget is not harmful.
 		*/
 		shell.activeMenu = null;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("WM_MENUSELECT(long,long)")
+                        .add("shell.activeMenu: ").add(shell.activeMenu).log(Log.DBG);
+                }
+                // </QFS>
 		return null;
 	}
 	if ((code & OS.MF_SYSMENU) != 0) return null;
@@ -5002,7 +5151,7 @@
 			if (OS.GetMenuItemInfo (lParam, index, true, info)) {
 				Menu newMenu = menuShell.findMenu (info.hSubMenu);
 				if (newMenu != null) item = newMenu.cascade;
-			}	
+			}
 		} else {
 			Menu newMenu = menuShell.findMenu (lParam);
 			if (newMenu != null) {
@@ -5189,7 +5338,7 @@
 	* a user menu item that was added to the System menu.
 	* When a user item is added to the System menu,
 	* WM_SYSCOMMAND must always return zero.
-	* 
+	*
 	* NOTE: This is undocumented.
 	*/
 	if ((wParam & 0xF000) == 0) {
@@ -5218,7 +5367,7 @@
 			* moves focus to the System menu but this can be achieved
 			* using Alt+Space.  To allow the application to see F10,
 			* avoid running the default window proc.
-			* 
+			*
 			* NOTE:  When F10 is pressed, WM_SYSCOMMAND is sent to the
 			* shell, not the focus control.  This is undocumented Windows
 			* behavior.
@@ -5245,7 +5394,7 @@
 				* matching the mnemonic character.  To allow the application
 				* to see the keystrokes in this case, avoid running the default
 				* window proc.
-				* 
+				*
 				* NOTE: When the user types Alt+Space, the System menu is
 				* activated.  In this case the application should not see
 				* the keystroke.
@@ -5351,7 +5500,7 @@
 			event.yDirection = 1;
 			break;
 	}
-	
+
 	event.x = fPoint.x;
 	event.y = fPoint.y;
 	event.type = SWT.Gesture;
@@ -5375,7 +5524,7 @@
 					OS.MoveMemory (ti [i], pInputs + i * TOUCHINPUT.sizeof, TOUCHINPUT.sizeof);
 				}
 				sendTouchEvent (ti);
-				OS.CloseTouchInputHandle (lParam); 
+				OS.CloseTouchInputHandle (lParam);
 				result = LRESULT.ZERO;
 			}
 			OS.HeapFree (hHeap, 0, pInputs);
@@ -5397,6 +5546,14 @@
 }
 
 LRESULT WM_VSCROLL (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_VSCROLL(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	Control control = display.getControl (lParam);
 	if (control == null) return null;
 	return control.wmScrollChild (wParam, lParam);
Index: org/eclipse/swt/widgets/MenuItem.java
===================================================================
--- org/eclipse/swt/widgets/MenuItem.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/MenuItem.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,18 +7,24 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class represent a selectable user interface object
- * that issues notification when pressed and released. 
+ * that issues notification when pressed and released.
  * <dl>
  * <dt><b>Styles:</b></dt>
  * <dd>CHECK, CASCADE, PUSH, RADIO, SEPARATOR</dd>
@@ -50,6 +56,13 @@
 	*/
 	final static int MARGIN_WIDTH = OS.IsWin95 ? 2 : 1;
 	final static int MARGIN_HEIGHT = OS.IsWin95 ? 2 : 1;
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.MenuItem");
+    // </QFS>
 
 /**
  * Constructs a new instance of this class given its parent
@@ -59,7 +72,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -99,7 +112,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -136,7 +149,7 @@
 MenuItem (Menu parent, Menu menu, int style, int index) {
 	super (parent, checkStyle (style));
 	this.parent = parent;
-	this.menu = menu;	
+	this.menu = menu;
 	if (menu != null) menu.cascade = this;
 	display.addMenuItem (this);
 }
@@ -208,7 +221,7 @@
  * was selected by the user. During <code>widgetSelected</code> the application can use
  * <code>getSelection()</code> to determine the current selected state of the receiver.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified when the menu item is selected by the user
  *
  * @exception IllegalArgumentException <ul>
@@ -252,7 +265,7 @@
 	int key = accelerator & SWT.KEY_MASK;
 	int vKey = Display.untranslateKey (key);
 	if (vKey != 0) {
-		key = vKey;	
+		key = vKey;
 	} else {
 		switch (key) {
 			/*
@@ -322,10 +335,11 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
-/*public*/ Rectangle getBounds () {
+// <QFS/> Made public.
+public Rectangle getBounds () {
 	checkWidget ();
 	if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
 	int index = parent.indexOf (this);
@@ -354,10 +368,16 @@
 	} else {
 		long /*int*/ hMenu = parent.handle;
 		RECT rect1 = new RECT ();
+                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                // Leave unchanged for now
+                // if (!OS.GetMenuItemRect (parent.getShell().handle, hMenu, 0, rect1)) {
 		if (!OS.GetMenuItemRect (0, hMenu, 0, rect1)) {
 			return new Rectangle (0, 0, 0, 0);
 		}
 		RECT rect2 = new RECT ();
+                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                // Leave unchanged for now
+                // if (!OS.GetMenuItemRect (parent.getShell().handle, hMenu, index, rect2)) {
 		if (!OS.GetMenuItemRect (0, hMenu, index, rect2)) {
 			return new Rectangle (0, 0, 0, 0);
 		}
@@ -381,7 +401,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -439,7 +459,7 @@
 /**
  * Returns the receiver's cascade menu if it has one or null
  * if it does not. Only <code>CASCADE</code> menu items can have
- * a pull down menu. The sequence of key strokes, button presses 
+ * a pull down menu. The sequence of key strokes, button presses
  * and/or button releases that are used to request a pull down
  * menu is platform specific.
  *
@@ -514,7 +534,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -620,7 +640,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 
@@ -688,7 +708,7 @@
 		OS.SendMessage (hwndCB, OS.TB_GETBUTTONINFO, id, info);
 		info.fsState &= ~OS.TBSTATE_ENABLED;
 		if (enabled) info.fsState |= OS.TBSTATE_ENABLED;
-		OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, id, info);		
+		OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, id, info);
 	} else {
 		/*
 		* Feature in Windows.  For some reason, when the menu item
@@ -730,7 +750,7 @@
 				* returns a fail code when setting the enabled or
 				* selected state of a default item, but sets the
 				* state anyway.  The fix is to ignore the error.
-				* 
+				*
 				* NOTE:  This only happens on Vista.
 				*/
 				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -866,7 +886,7 @@
 	if (oldMenu != null) oldMenu.cascade = null;
 	this.menu = menu;
 
-	/* Assign the new menu in the OS */		
+	/* Assign the new menu in the OS */
 	if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {
 		if (OS.IsPPC) {
 			long /*int*/ hwndCB = parent.hwndCB;
@@ -906,7 +926,7 @@
 		info.cch = cch;
 		boolean success = OS.GetMenuItemInfo (hMenu, index, true, info);
 		if (menu != null) {
-			menu.cascade = this; 
+			menu.cascade = this;
 			info.fMask |= OS.MIIM_SUBMENU;
 			info.hSubMenu = menu.handle;
 		}
@@ -1016,7 +1036,7 @@
 			* returns a fail code when setting the enabled or
 			* selected state of a default item, but sets the
 			* state anyway.  The fix is to ignore the error.
-			* 
+			*
 			* NOTE:  This only happens on Vista.
 			*/
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -1051,7 +1071,7 @@
  * accelerator key sequence. The accelerator key sequence
  * is installed using #setAccelerator.
  * </p>
- * 
+ *
  * @param string the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -1061,7 +1081,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setAccelerator
  */
 public void setText (String string) {
@@ -1078,7 +1098,7 @@
 		* Bug in WinCE PPC.  Tool items on the menubar don't resize
 		* correctly when the character '&' is used (even when it
 		* is a sequence '&&').  The fix is to remove all '&' from
-		* the string. 
+		* the string.
 		*/
 		if (string.indexOf ('&') != -1) {
 			int length = string.length ();
@@ -1094,7 +1114,7 @@
 		TCHAR buffer = new TCHAR (0, string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount);	
+		OS.MoveMemory (pszText, buffer, byteCount);
 		long /*int*/ hwndCB = parent.hwndCB;
 		TBBUTTONINFO info2 = new TBBUTTONINFO ();
 		info2.cbSize = TBBUTTONINFO.sizeof;
@@ -1105,12 +1125,12 @@
 		MENUITEMINFO info = new MENUITEMINFO ();
 		info.cbSize = MENUITEMINFO.sizeof;
 		long /*int*/ hMenu = parent.handle;
-		
+
 		/* Use the character encoding for the default locale */
 		TCHAR buffer = new TCHAR (0, string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount);	
+		OS.MoveMemory (pszText, buffer, byteCount);
 		/*
 		* Bug in Windows 2000.  For some reason, when MIIM_TYPE is set
 		* on a menu item that also has MIIM_BITMAP, the MIIM_TYPE clears
@@ -1148,6 +1168,14 @@
 }
 
 LRESULT wmCommandChild (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmCommandChild(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	if ((style & SWT.CHECK) != 0) {
 		setSelection (!getSelection ());
 	} else {
@@ -1216,7 +1244,7 @@
 				MenuItem item = items [i];
 				if (item.image != null) {
 					Rectangle rect = item.image.getBounds ();
-					width = Math.max (width, rect.width); 
+					width = Math.max (width, rect.width);
 				}
 			}
 		}
Index: org/eclipse/swt/widgets/Text.java
===================================================================
--- org/eclipse/swt/widgets/Text.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Text.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -191,13 +191,13 @@
 						hDC = OS.CreateCompatibleDC (paintDC);
 						lpPoint1 = new POINT ();
 						lpPoint2 = new POINT ();
-						OS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);
-						OS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);
+					OS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);
+					OS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);
 						hBitmap = OS.CreateCompatibleBitmap (paintDC, width, height);
 						hOldBitmap = OS.SelectObject (hDC, hBitmap);
-						RECT rect = new RECT ();
-						OS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);
-						drawBackground (hDC, rect);
+					RECT rect = new RECT ();
+					OS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);
+					drawBackground (hDC, rect);
 					}
 					
 					OS.CallWindowProc (EditProc, hwnd, OS.WM_PAINT, hDC, lParam);
@@ -238,14 +238,14 @@
 					}
 					
 					if (doubleBuffer) {
-						OS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);
-						OS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);
-						OS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);
-						OS.SelectObject (hDC, hOldBitmap);
-						OS.DeleteObject (hBitmap);
-						OS.DeleteObject (hDC);
-					}
+					OS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);
+					OS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);
+					OS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);
+					OS.SelectObject (hDC, hOldBitmap);
+					OS.DeleteObject (hBitmap);
+					OS.DeleteObject (hDC);
 				}
+				}
 				OS.EndPaint (handle, ps);
 				return 0;
 			}
@@ -1486,7 +1486,8 @@
 	* is to detect this case and avoid sending a verify
 	* event.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (handle == OS.GetCapture()) return true;
 	}
 
@@ -1596,7 +1597,7 @@
 				return;
 			}
 		}
-	}
+	}	
 	super.setBounds (x, y, width, height, flags);
 	
 	/*
@@ -1727,7 +1728,7 @@
 	* margins, causing the first character to be clipped.  The
 	* fix is to set the margins to zero.
 	*/
-	if ((style & SWT.SEARCH) != 0) {
+		if ((style & SWT.SEARCH) != 0) {
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 			OS.SendMessage (handle, OS.EM_SETMARGINS, OS.EC_LEFTMARGIN | OS.EC_RIGHTMARGIN, 0);
 		}
@@ -2268,7 +2269,8 @@
 	*/
 	switch ((int)/*64*/wParam) {
 		case SWT.DEL:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				return LRESULT.ZERO;
 			}
 	}
@@ -2617,8 +2619,8 @@
 				style &= ~SWT.LEFT_TO_RIGHT;
 				style |= SWT.RIGHT_TO_LEFT;
 			} else {
-				style &= ~SWT.RIGHT_TO_LEFT;
-				style |= SWT.LEFT_TO_RIGHT;
+			style &= ~SWT.RIGHT_TO_LEFT;
+			style |= SWT.LEFT_TO_RIGHT;
 			}
 			Event event = new Event();
 			event.doit = true;
@@ -2626,8 +2628,8 @@
 			if (!event.doit) {
 				if (code == OS.EN_ALIGN_LTR_EC) {
 					bits |= (OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR);
-					style &= ~SWT.LEFT_TO_RIGHT;
-					style |= SWT.RIGHT_TO_LEFT;
+			style &= ~SWT.LEFT_TO_RIGHT;
+			style |= SWT.RIGHT_TO_LEFT;
 				} else {
 					bits &= ~(OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR);
 					style &= ~SWT.RIGHT_TO_LEFT;
Index: org/eclipse/swt/widgets/TabItem.java
===================================================================
--- org/eclipse/swt/widgets/TabItem.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TabItem.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -276,9 +276,9 @@
 				if (selectedControl == newControl) return;
 			}
 			newControl.setVisible(false);
-			return;
-		}
+		return;
 	}
+	}
 	if (newControl != null) {
 		newControl.setBounds (parent.getClientArea ());
 		newControl.setVisible (true);
@@ -356,7 +356,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/widgets/FontDialog.java
===================================================================
--- org/eclipse/swt/widgets/FontDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/FontDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -15,6 +16,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to select a font
  * from all available fonts in the system.
@@ -33,6 +39,13 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public class FontDialog extends Dialog {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.ColorDialog");
+    // </QFS>
 	FontData fontData;
 	RGB rgb;
 	
@@ -203,6 +216,22 @@
 		display.setModalDialog (this);
 	}
 
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/* Open the dialog */
 	boolean success = OS.ChooseFont (lpcf);
 	
@@ -270,6 +299,15 @@
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
 	
+        // <QFS>
+        Object[] replaced = (Object[]) _qfGetDisplay().runDialogClosedHooks
+            (this, success ? new Object[] {fontData, rgb} : null);
+        if (replaced != null) {
+            fontData = (FontData) replaced[0];
+            rgb = (RGB) replaced[1];
+            success = true;
+        }
+        // </QFS>
 	if (!success) return null;
 	return fontData;
 }
Index: org/eclipse/swt/widgets/TaskBar.java
===================================================================
--- org/eclipse/swt/widgets/TaskBar.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TaskBar.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -189,18 +189,18 @@
 			text = (String)item.getData (ICON_INDEX_KEY);
 			if (text != null) index = Integer.parseInt (text);
 		} else {
-			Image image = item.getImage ();
-			if (image != null && directory != null) {
+		Image image = item.getImage ();
+		if (image != null && directory != null) {
 				icon = directory + "\\menu" + item.id + ".ico" ;
-				ImageData data;
-				if (item.hBitmap != 0) {
-					Image image2 = Image.win32_new (display, SWT.BITMAP, item.hBitmap);
-					data = image2.getImageData ();
-				} else {
-					data = image.getImageData ();
-				}
-				ImageLoader loader = new ImageLoader ();
-				loader.data = new ImageData [] {data};
+			ImageData data;
+			if (item.hBitmap != 0) {
+				Image image2 = Image.win32_new (display, SWT.BITMAP, item.hBitmap);
+				data = image2.getImageData ();
+			} else {
+				data = image.getImageData ();
+			}
+			ImageLoader loader = new ImageLoader ();
+			loader.data = new ImageData [] {data};
 				loader.save (icon, SWT.IMAGE_ICO);
 			}
 		}
Index: org/eclipse/swt/widgets/Table.java
===================================================================
--- org/eclipse/swt/widgets/Table.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Table.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -271,8 +271,8 @@
         	}
         	//TODO - _checkGrow() doesn't return a value, check keys == null instead
 	        if (_checkGrow (count)) {
-	    		if (items [index] != null) return items [index];
-	    		return items [index] = new TableItem (this, SWT.NONE, -1, false);
+	if (items [index] != null) return items [index];
+	return items [index] = new TableItem (this, SWT.NONE, -1, false);
 	        }
 	        keyIndex = -keyIndex - 1;
 	        if (keyIndex < keyCount) { 
@@ -2995,20 +2995,20 @@
 	if (item == null) error (SWT.ERROR_NULL_ARGUMENT);
 	//TODO - find other loops that can be optimized
 	if (keys == null) {
-		int count = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETITEMCOUNT, 0, 0);
-		if (1 <= lastIndexOf && lastIndexOf < count - 1) {
+	int count = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETITEMCOUNT, 0, 0);
+	if (1 <= lastIndexOf && lastIndexOf < count - 1) {
 			if (_getItem (lastIndexOf, false) == item) return lastIndexOf;
 			if (_getItem (lastIndexOf + 1, false) == item) return ++lastIndexOf;
 			if (_getItem (lastIndexOf - 1, false) == item) return --lastIndexOf;
+	}
+	if (lastIndexOf < count / 2) {
+		for (int i=0; i<count; i++) {
+				if (_getItem (i, false) == item) return lastIndexOf = i;
 		}
-		if (lastIndexOf < count / 2) {
-			for (int i=0; i<count; i++) {
+	} else {
+		for (int i=count - 1; i>=0; --i) {
 				if (_getItem (i, false) == item) return lastIndexOf = i;
 			}
-		} else {
-			for (int i=count - 1; i>=0; --i) {
-				if (_getItem (i, false) == item) return lastIndexOf = i;
-			}
 		}
 	} else {
 		for (int i=0; i<keyCount; i++) {
@@ -3086,17 +3086,17 @@
 			}
 		} else {
 			if (keys == null) {
-				for (int i=0; i<itemCount; i++) {
+			for (int i=0; i<itemCount; i++) {
 					TableItem item = _getItem (i, false);
 					if (item != null && !item.isDisposed ()) item.release (false);
 				}
 			} else {
 				for (int i=0; i<keyCount; i++) {
-					TableItem item = items [i];
-					if (item != null && !item.isDisposed ()) item.release (false);
-				}
+				TableItem item = items [i];
+				if (item != null && !item.isDisposed ()) item.release (false);
 			}
 		}
+		}
 		_clearItems ();
 	}
 	if (columns != null) {
@@ -5989,7 +5989,8 @@
 			*/
 			return LRESULT.ZERO;
 		case OS.VK_ADD:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+                        if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				int index = 0;
 				while (index < columnCount) {
 					if (!columns [index].getResizable ()) break;
@@ -6701,7 +6702,7 @@
 				* to be sent before the method returns. For this reason, LVM_REDRAWITEMS
 				* can never be used from a LVN_GETDISPINFO handler. The fix is to 
 				* InvalidateRect() passing the bounds for the entire item.
-				*/
+			*/
 				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 					RECT rect = new RECT ();
 					rect.left = OS.LVIR_BOUNDS;
@@ -6711,13 +6712,13 @@
 					if (code != 0) OS.InvalidateRect (handle, rect, true);
 					break;
 				} else {
-					if ((style & SWT.VIRTUAL) != 0 && !item.cached) {
-						OS.SendMessage (handle, OS.LVM_REDRAWITEMS, plvfi.iItem, plvfi.iItem);
-						break;
-					}
+			if ((style & SWT.VIRTUAL) != 0 && !item.cached) {
+					OS.SendMessage (handle, OS.LVM_REDRAWITEMS, plvfi.iItem, plvfi.iItem);
+					break;
 				}
 			}
-			
+			}
+
 			/*
 			* The cached flag is used by both virtual and non-virtual
 			* tables to indicate that Windows has asked at least once
@@ -7172,7 +7173,7 @@
 				OS.POINTSTOPOINT (pt, pos);
 				OS.ScreenToClient (handle, pt);
 				pinfo.x = pt.x;
-				pinfo.y = pt.y;	
+				pinfo.y = pt.y;
 				/*
 				*  Bug in Windows.  When LVM_SUBITEMHITTEST is used to hittest
 				*  a point that is above the table, instead of returning -1 to
Index: org/eclipse/swt/widgets/EventTable.java
===================================================================
--- org/eclipse/swt/widgets/EventTable.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/EventTable.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -14,6 +15,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.internal.SWTEventListener;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class implement a simple
  * look up mechanism that maps an event type
@@ -22,6 +28,12 @@
  */
 
 class EventTable {
+    // <QFS>
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.EventTable");
+    // </QFS>
+
+
 	int [] types;
 	Listener [] listeners;
 	int level;
@@ -74,6 +86,14 @@
 }
 
 public void sendEvent (Event event) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.build("sendEvent(Event)")
+            .add("eventtype=").add(Display.getEventName(event.type))
+            .add(", widget.class: ").add(event.widget == null ? "null" : event.widget.getClass().getName())
+            .log(Log.MTD);
+    }
+    // </QFS>
 	if (types == null) return;
 	level += level >= 0 ? 1 : -1;
 	try {
Index: org/eclipse/swt/widgets/Tracker.java
===================================================================
--- org/eclipse/swt/widgets/Tracker.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Tracker.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.graphics.*;
@@ -23,7 +24,7 @@
  *  These rectangles can be specified to respond to mouse and key events
  *  by either moving or resizing themselves accordingly.  Trackers are
  *  typically used to represent window geometries in a lightweight manner.
- *  
+ *
  * <dl>
  * <dt><b>Styles:</b></dt>
  * <dd>LEFT, RIGHT, UP, DOWN, RESIZE</dd>
@@ -51,7 +52,7 @@
 	boolean inEvent = false;
 	long /*int*/ hwndTransparent, hwndOpaque, oldTransparentProc, oldOpaqueProc;
 	int oldX, oldY;
-	
+
 	static boolean IsVista = !OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0);
 
 	/*
@@ -66,7 +67,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -104,7 +105,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -112,7 +113,7 @@
  * </p><p>
  * Note: Currently, null can be passed in for the display argument.
  * This has the effect of creating the tracker on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * tracker is created on a "default" display. <b>Passing in null as
  * the display argument is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -125,7 +126,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#LEFT
  * @see SWT#RIGHT
  * @see SWT#UP
@@ -284,7 +285,7 @@
 		}
 		resizeCursor = newCursor;
 	}
-		
+
 	return new Point (pt.x, pt.y);
 }
 
@@ -315,16 +316,16 @@
 	int yMin = rectangles [0].y;
 	int xMax = rectangles [0].x + rectangles [0].width;
 	int yMax = rectangles [0].y + rectangles [0].height;
-	
+
 	for (int i = 1; i < rectangles.length; i++) {
 		if (rectangles [i].x < xMin) xMin = rectangles [i].x;
 		if (rectangles [i].y < yMin) yMin = rectangles [i].y;
 		int rectRight = rectangles [i].x + rectangles [i].width;
-		if (rectRight > xMax) xMax = rectRight;		
+		if (rectRight > xMax) xMax = rectRight;
 		int rectBottom = rectangles [i].y + rectangles [i].height;
 		if (rectBottom > yMax) yMax = rectBottom;
 	}
-	
+
 	return new Rectangle (xMin, yMin, xMax - xMin, yMax - yMin);
 }
 
@@ -346,7 +347,7 @@
 			} else {
 				height = 100;
 			}
-			result [i] = new Rectangle (x, y, width, height);			
+			result [i] = new Rectangle (x, y, width, height);
 		}
 	}
 	return result;
@@ -402,7 +403,7 @@
  * coordinates.
  *
  * @return the bounds of the Rectangles being drawn
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -451,9 +452,9 @@
  * Displays the Tracker rectangles for manipulation by the user.  Returns when
  * the user has either finished manipulating the rectangles or has cancelled the
  * Tracker.
- * 
+ *
  * @return <code>true</code> if the user did not cancel the Tracker, <code>false</code> otherwise
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -463,6 +464,22 @@
 	checkWidget ();
 	cancelled = false;
 	tracking = true;
+        // <QFS>
+        // Check if we're running a eclipse.ui DnD loop and inform the display if necessary.
+        java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream();
+        java.io.PrintWriter pw = new java.io.PrintWriter (os);
+        try {
+            throw new Exception();
+        } catch (Exception ex) {
+            ex.printStackTrace(pw);
+        }
+        pw.close();
+        String dump = os.toString();
+        boolean insideDnD = dump.indexOf("org.eclipse.ui.internal.dnd.DragUtil.performDrag") > 0;
+        if (insideDnD) {
+            display.runDNDTrackerHooks(true, false);
+        }
+        // </QFS>
 
 	/*
 	* If exactly one of UP/DOWN is specified as a style then set the cursor
@@ -478,13 +495,14 @@
 	}
 
 	Callback newProc = null;
-	boolean mouseDown = OS.GetKeyState(OS.VK_LBUTTON) < 0;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	boolean mouseDown = getDisplay().GetKeyState(OS.VK_LBUTTON) < 0;
 	/*
 	* Bug in Vista. Drawing directly to the screen with XOR does not
 	* perform well. The fix is to draw on layered window instead.
-	* 
+	*
 	* Note that one window (almost opaque) is used for catching all events and a
-	* second window is used for drawing the rectangles. 
+	* second window is used for drawing the rectangles.
 	*/
 	if (IsVista && parent == null) {
 		Rectangle bounds = display.getBounds();
@@ -500,28 +518,28 @@
 			OS.GetModuleHandle (null),
 			null);
 		OS.SetLayeredWindowAttributes (hwndTransparent, 0, (byte)0x01, OS.LWA_ALPHA);
-		hwndOpaque = OS.CreateWindowEx (
-			OS.WS_EX_LAYERED | OS.WS_EX_NOACTIVATE,
-			display.windowClass,
-			null,
-			OS.WS_POPUP,
+			hwndOpaque = OS.CreateWindowEx (
+				OS.WS_EX_LAYERED | OS.WS_EX_NOACTIVATE,
+				display.windowClass,
+				null,
+				OS.WS_POPUP,
 			bounds.x, bounds.y,
 			bounds.width, bounds.height,
-			hwndTransparent,
-			0,
-			OS.GetModuleHandle (null),
-			null);
-		OS.SetLayeredWindowAttributes (hwndOpaque, 0xFFFFFF, (byte)0xFF, OS.LWA_COLORKEY | OS.LWA_ALPHA);		
+				hwndTransparent,
+				0,
+				OS.GetModuleHandle (null),
+				null);
+		OS.SetLayeredWindowAttributes (hwndOpaque, 0xFFFFFF, (byte)0xFF, OS.LWA_COLORKEY | OS.LWA_ALPHA);
 		newProc = new Callback (this, "transparentProc", 4); //$NON-NLS-1$
 		long /*int*/ newProcAddress = newProc.getAddress ();
 		if (newProcAddress == 0) SWT.error (SWT.ERROR_NO_MORE_CALLBACKS);
 		oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
 		OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
-		oldOpaqueProc = OS.GetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC);
-		OS.SetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC, newProcAddress);
+			oldOpaqueProc = OS.GetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC);
+			OS.SetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC, newProcAddress);
 		OS.ShowWindow (hwndTransparent, OS.SW_SHOWNOACTIVATE);
 		OS.ShowWindow (hwndOpaque, OS.SW_SHOWNOACTIVATE);
-	} else {
+		} else {
 		/*
 		* If this tracker is being created without a mouse drag then
 		* we need to create a transparent window that fills the screen
@@ -544,8 +562,8 @@
 			newProc = new Callback (this, "transparentProc", 4); //$NON-NLS-1$
 			long /*int*/ newProcAddress = newProc.getAddress ();
 			if (newProcAddress == 0) SWT.error (SWT.ERROR_NO_MORE_CALLBACKS);
-			oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
-			OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
+		oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
+		OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
 			OS.ShowWindow (hwndTransparent, OS.SW_SHOWNOACTIVATE);
 		}
 	}
@@ -555,7 +573,8 @@
 	Point cursorPos = null;
 	if (mouseDown) {
 		POINT pt = new POINT ();
-		OS.GetCursorPos (pt);
+                // <QFS/> Get overridden cursor position
+		OS._GetCursorPos (pt);
 		cursorPos = new Point (pt.x, pt.y);
 	} else {
 		if ((style & SWT.RESIZE) != 0) {
@@ -633,6 +652,11 @@
 		}
 	}
 	tracking = false;
+        // <QFS>
+        if (insideDnD) {
+            display.runDNDTrackerHooks(false, cancelled);
+        }
+        // </QFS>
 	return !cancelled;
 }
 
@@ -711,12 +735,12 @@
 	if (yChange > 0 && ((style & SWT.DOWN) != 0) && ((cursorOrientation & SWT.UP) == 0)) {
 		cursorOrientation |= SWT.DOWN;
 	}
-	
+
 	/*
 	 * If the bounds will flip about the x or y axis then apply the adjustment
 	 * up to the axis (ie.- where bounds width/height becomes 0), change the
 	 * cursor's orientation accordingly, and flip each Rectangle's origin (only
-	 * necessary for > 1 Rectangles) 
+	 * necessary for > 1 Rectangles)
 	 */
 	if ((cursorOrientation & SWT.LEFT) != 0) {
 		if (xChange > bounds.width) {
@@ -778,7 +802,7 @@
 			}
 		}
 	}
-	
+
 	// apply the bounds adjustment
 	if ((cursorOrientation & SWT.LEFT) != 0) {
 		bounds.x += xChange;
@@ -792,7 +816,7 @@
 	} else if ((cursorOrientation & SWT.DOWN) != 0) {
 		bounds.height += yChange;
 	}
-	
+
 	Rectangle [] newRects = new Rectangle [rectangles.length];
 	for (int i = 0; i < rectangles.length; i++) {
 		Rectangle proportion = proportions[i];
@@ -802,7 +826,7 @@
 			proportion.width * bounds.width / 100,
 			proportion.height * bounds.height / 100);
 	}
-	rectangles = newRects;	
+	rectangles = newRects;
 }
 
 /**
@@ -810,7 +834,7 @@
  * then the cursor reverts to the default.
  *
  * @param newCursor the new <code>Cursor</code> to display
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -893,7 +917,7 @@
 			if (hwndOpaque == hwnd) {
 				PAINTSTRUCT ps = new PAINTSTRUCT();
 				long /*int*/ hDC = OS.BeginPaint (hwnd, ps);
-				long /*int*/ hBitmap = 0, hBrush = 0, oldBrush = 0;			
+				long /*int*/ hBitmap = 0, hBrush = 0, oldBrush = 0;
 				long /*int*/ transparentBrush = OS.CreateSolidBrush(0xFFFFFF);
 				oldBrush = OS.SelectObject (hDC, transparentBrush);
 				OS.PatBlt (hDC, ps.left, ps.top, ps.right - ps.left, ps.bottom - ps.top, OS.PATCOPY);
@@ -953,7 +977,8 @@
 	LRESULT result = super.wmKeyDown (hwnd, wParam, lParam);
 	if (result != null) return result;
 	boolean isMirrored = parent != null && (parent.style & SWT.MIRRORED) != 0;
-	int stepSize = OS.GetKeyState (OS.VK_CONTROL) < 0 ? STEPSIZE_SMALL : STEPSIZE_LARGE;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	int stepSize = getDisplay().GetKeyState (OS.VK_CONTROL) < 0 ? STEPSIZE_SMALL : STEPSIZE_LARGE;
 	int xChange = 0, yChange = 0;
 	switch ((int)/*64*/wParam) {
 		case OS.VK_ESCAPE:
@@ -1086,7 +1111,7 @@
 LRESULT wmSysKeyDown (long /*int*/ hwnd, long /*int*/ wParam, long /*int*/ lParam) {
 	LRESULT result = super.wmSysKeyDown (hwnd, wParam, lParam);
 	if (result != null) return result;
-	cancelled = true;			
+	cancelled = true;
 	tracking = false;
 	return result;
 }
@@ -1161,8 +1186,8 @@
 			}
 		} else {
 			if (isMirrored) {
-				moveRectangles (oldX - newX, newY - oldY); 
-			} else { 
+				moveRectangles (oldX - newX, newY - oldY);
+			} else {
 				moveRectangles (newX - oldX, newY - oldY);
 			}
 			inEvent = true;
Index: org/eclipse/swt/widgets/DateTime.java
===================================================================
--- org/eclipse/swt/widgets/DateTime.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/DateTime.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -263,12 +263,12 @@
 				width = size.cx;
 				height = size.cy;
 			} else {
-				long /*int*/ newFont, oldFont = 0;
-				long /*int*/ hDC = OS.GetDC (handle);
-				newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
-				if (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);
-				RECT rect = new RECT ();
-				if ((style & SWT.DATE) != 0) {
+			long /*int*/ newFont, oldFont = 0;
+			long /*int*/ hDC = OS.GetDC (handle);
+			newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
+			if (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);
+			RECT rect = new RECT ();
+			if ((style & SWT.DATE) != 0) {
 					int dwFlags = 0;
 					TCHAR lpFormat = null;
 					if ((style & SWT.SHORT) != 0) {
@@ -281,8 +281,8 @@
 						TCHAR buffer = new TCHAR (getCodePage (), size);
 						OS.GetDateFormat(OS.LOCALE_USER_DEFAULT, dwFlags, null, lpFormat, buffer, buffer.length ());
 						OS.DrawText (hDC, buffer, size, rect, OS.DT_CALCRECT | OS.DT_EDITCONTROL);
-					}
-				} else if ((style & SWT.TIME) != 0) {
+				}
+			} else if ((style & SWT.TIME) != 0) {
 					int dwFlags = 0;
 					TCHAR lpFormat = null;
 					if ((style & SWT.SHORT) != 0) {
@@ -294,13 +294,13 @@
 						TCHAR buffer = new TCHAR (getCodePage (), size);
 						OS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, null, lpFormat, buffer, buffer.length ());
 						OS.DrawText (hDC, buffer, size, rect, OS.DT_CALCRECT | OS.DT_EDITCONTROL);
-					}
 				}
+				}
 				width = rect.right - rect.left;
 				height = rect.bottom - rect.top;
-				if (newFont != 0) OS.SelectObject (hDC, oldFont);
-				OS.ReleaseDC (handle, hDC);
-				int upDownWidth = OS.GetSystemMetrics (OS.SM_CXVSCROLL);
+			if (newFont != 0) OS.SelectObject (hDC, oldFont);
+			OS.ReleaseDC (handle, hDC);
+			int upDownWidth = OS.GetSystemMetrics (OS.SM_CXVSCROLL);
 				width += upDownWidth + MARGIN;
 			}
 			int upDownHeight = OS.GetSystemMetrics (OS.SM_CYVSCROLL);
@@ -337,9 +337,9 @@
 }
 
 String getCustomShortDateFormat () {
-	TCHAR tchar = new TCHAR (getCodePage (), 80);
-	int size = OS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, OS.LOCALE_SYEARMONTH, tchar, 80);
-	return size != 0 ? tchar.toString (0, size - 1) : "M/yyyy"; //$NON-NLS-1$
+		TCHAR tchar = new TCHAR (getCodePage (), 80);
+		int size = OS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, OS.LOCALE_SYEARMONTH, tchar, 80);
+		return size != 0 ? tchar.toString (0, size - 1) : "M/yyyy"; //$NON-NLS-1$
 }
 
 String getCustomShortTimeFormat () {
@@ -817,8 +817,8 @@
 				if ((style & SWT.TIME) == 0) lastSystemTime = systime;
 			}
 			break;
-		}
 	}
+	}
 	return super.wmNotifyChild (hdr, wParam, lParam);
 }
 
Index: org/eclipse/swt/widgets/Group.java
===================================================================
--- org/eclipse/swt/widgets/Group.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Group.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -342,7 +342,7 @@
 			long /*int*/ topHandle = children [i].topHandle();
 			int bits = OS.GetWindowLong (topHandle, OS.GWL_STYLE);
 			if ((bits & OS.WS_VISIBLE) != 0) {
-				children [i].printWidget (topHandle, hdc, gc);
+			children [i].printWidget (topHandle, hdc, gc);
 			}
 			if (graphicsMode == OS.GM_ADVANCED) {
 				float [] lpXform = {1, 0, 0, 1, -location.x, -location.y};
Index: org/eclipse/swt/widgets/Synchronizer.java
===================================================================
--- org/eclipse/swt/widgets/Synchronizer.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Synchronizer.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -15,6 +16,11 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.internal.Compatibility;
  
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class provide synchronization support
  * for displays. A default instance is created automatically
@@ -39,6 +45,12 @@
 	RunnableLock [] messages;
 	Object messageLock = new Object ();
 	Thread syncThread;
+    // <QFS>
+    /**
+     * The logger used for logging.
+     */
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Synchronizer");
+    // </QFS>
 	static final int GROW_SIZE = 4;
 	static final int MESSAGE_LIMIT = 64;
 
@@ -53,7 +65,17 @@
  * @param display the display to create the synchronizer on
  */
 public Synchronizer (Display display) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("Synchronizer(Display)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", display: ").add(display)).log(Log.MTD);
+    }
+    // </QFS>
+
 	this.display = display;
+
 }
 	
 void addLast (RunnableLock lock) {
@@ -71,6 +93,58 @@
 	if (wake) display.wakeThread ();
 }
 
+    // <QFS> Delegate to asyncExec except for special cases where QF-Test calls must not be
+    // blocked in a derived class.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The caller of this method continues
+     * to run in parallel, and is not notified when the
+     * runnable has completed.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @see #syncExec
+     */
+    protected void internalAsyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("internalAsyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        if (runnable != null
+            && "org.eclipse.ui.internal.UISynchronizer".equals(getClass().getName())
+            && runnable.getClass().getName().startsWith("de.qfs.")) {
+            trueAsyncExec(runnable);
+        } else {
+            asyncExec(runnable);
+        }
+    }
+    // </QFS>
+
+    // <QFS> Delegate to trueAsyncExec.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The caller of this method continues
+     * to run in parallel, and is not notified when the
+     * runnable has completed.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @see #syncExec
+     */
+    protected void asyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("asyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        trueAsyncExec(runnable);
+    }
+    // </QFS>
+
+    // <QFS/> Copy of original asyncExec.
 /**
  * Causes the <code>run()</code> method of the runnable to
  * be invoked by the user-interface thread at the next 
@@ -82,7 +156,15 @@
  *
  * @see #syncExec
  */
-protected void asyncExec (Runnable runnable) {
+void trueAsyncExec (Runnable runnable) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("trueAsyncExec(Runnable)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", runnable: ").add(runnable)).log(Log.MTD);
+    }
+    // </QFS>
 	if (runnable == null) {
 		//TEMPORARY CODE
 		if (!(IS_CARBON || IS_GTK || IS_COCOA)) {
@@ -124,15 +206,41 @@
 }
 
 boolean runAsyncMessages (boolean all) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runAsyncMessages(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", all: ").add(all)).log(Log.MTD);
+    }
+    // </QFS>
 	boolean run = false;
 	do {
 		RunnableLock lock = removeFirst ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("runAsyncMessages(boolean)")
+                        .add("lock: ").add(lock).log(Log.DBG);
+                }
+                // </QFS>
 		if (lock == null) return run;
 		run = true;
 		synchronized (lock) {
 			syncThread = lock.thread;
 			try {
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.log(Log.DBG, "runAsyncMessages(boolean)",
+                                           "Executing lock");
+                            }
+                            // </QFS>
 				lock.run ();
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.log(Log.DBG, "runAsyncMessages(boolean)",
+                                           "Executing lock... done");
+                            }
+                            // </QFS>
 			} catch (Throwable t) {
 				lock.throwable = t;
 				SWT.error (SWT.ERROR_FAILED_EXEC, t);
@@ -145,6 +253,64 @@
 	return run;
 }
 
+    // <QFS> Delegate to syncExec except for special cases where QF-Test calls must not be
+    // blocked in a derived class.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The thread which calls this method
+     * is suspended until the runnable completes.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @exception SWTException <ul>
+     *    <li>ERROR_FAILED_EXEC - if an exception occurred when executing the runnable</li>
+     * </ul>
+     *
+     * @see #asyncExec
+     */
+    protected void internalSyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("internalSyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        if (runnable != null
+            && "org.eclipse.ui.internal.UISynchronizer".equals(getClass().getName())
+            && runnable.getClass().getName().startsWith("de.qfs.")) {
+            trueSyncExec(runnable);
+        } else {
+            syncExec(runnable);
+        }
+    }
+    // </QFS>
+
+    // <QFS> Delegate to trueSyncExec.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The thread which calls this method
+     * is suspended until the runnable completes.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @exception SWTException <ul>
+     *    <li>ERROR_FAILED_EXEC - if an exception occurred when executing the runnable</li>
+     * </ul>
+     *
+     * @see #asyncExec
+     */
+    protected void syncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("syncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        trueSyncExec(runnable);
+    }
+    // </QFS>
+
+    // <QFS/> Copy of original syncExec.
 /**
  * Causes the <code>run()</code> method of the runnable to
  * be invoked by the user-interface thread at the next 
@@ -159,7 +325,15 @@
  *
  * @see #asyncExec
  */
-protected void syncExec (Runnable runnable) {
+protected void trueSyncExec (Runnable runnable) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("trueSyncExec(Runnable)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", runnable: ").add(runnable)).log(Log.MTD);
+    }
+    // </QFS>
 	RunnableLock lock = null;
 	synchronized (Device.class) {
 		if (display == null || display.isDisposed ()) SWT.error (SWT.ERROR_DEVICE_DISPOSED);
Index: org/eclipse/swt/widgets/Link.java
===================================================================
--- org/eclipse/swt/widgets/Link.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Link.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -764,7 +765,8 @@
 				sendSelectionEvent (SWT.Selection, event, true);
 				break;
 			case SWT.TAB:
-				boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+                                // <QFS/> Changed to getDisplay().GetKeyState
+				boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 				if (next) {
 					if (focusIndex < offsets.length - 1) {
 						focusIndex++;
@@ -822,7 +824,8 @@
 	if (count == 0) {
 		return new LRESULT (code | OS.DLGC_STATIC);
 	}
-	boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 	if (next && index < count - 1) {
 		return new LRESULT (code | OS.DLGC_WANTTAB);
 	}
@@ -946,7 +949,8 @@
 	if (OS.COMCTL32_MAJOR < 6) {
 		int x = OS.GET_X_LPARAM (lParam);
 		int y = OS.GET_Y_LPARAM (lParam);
-		if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+                // <QFS/> Changed to getDisplay().GetKeyState
+		if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 			int oldSelection = selection.y;
 			selection.y = layout.getOffset (x, y, null);
 			if (selection.y != oldSelection) {
Index: org/eclipse/swt/widgets/MessageBox.java
===================================================================
--- org/eclipse/swt/widgets/MessageBox.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/MessageBox.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -13,6 +14,10 @@
 
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
 /**
  * Instances of this class are used to inform or warn the user.
@@ -38,6 +43,15 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public  class MessageBox extends Dialog {
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.MessageBox");
+    // </QFS>
+
 	String message = "";
 	
 /**
@@ -203,8 +217,24 @@
 	/* Use the character encoding for the default locale */
 	TCHAR buffer1 = new TCHAR (0, message, true);
 	TCHAR buffer2 = new TCHAR (0, title, true);
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	int code = OS.MessageBox (hwndOwner, buffer1, buffer2, bits);
-	
 	/* Clear the temporarily dialog modal parent */
 	if ((bits & OS.MB_TASKMODAL) != 0) {
 		display.setModalDialog (oldModal);
@@ -218,31 +248,53 @@
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
 	
+        // <QFS/> Don't return immediately so result can be overridden.
+        int ret;
 	/* Compute and return the result */
 	if (code != 0) {
 		int type = bits & 0x0F;
-		if (type == OS.MB_OK) return SWT.OK;
-		if (type == OS.MB_OKCANCEL) {
-			return (code == OS.IDOK) ? SWT.OK : SWT.CANCEL;
+            if (type == OS.MB_OK) {
+                ret = SWT.OK;
+            } else if (type == OS.MB_OKCANCEL) {
+                ret = (code == OS.IDOK) ? SWT.OK : SWT.CANCEL;
+            } else if (type == OS.MB_YESNO) {
+                ret = (code == OS.IDYES) ? SWT.YES : SWT.NO;
+            } else if (type == OS.MB_YESNOCANCEL) {
+                if (code == OS.IDYES) {
+                    ret = SWT.YES;
+                } else if (code == OS.IDNO) {
+                    ret = SWT.NO;
+                } else {
+                    ret = SWT.CANCEL;
 		}
-		if (type == OS.MB_YESNO) {
-			return (code == OS.IDYES) ? SWT.YES : SWT.NO;
+            } else if (type == OS.MB_RETRYCANCEL) {
+                ret = (code == OS.IDRETRY) ? SWT.RETRY : SWT.CANCEL;
+            } else if (type == OS.MB_ABORTRETRYIGNORE) {
+                if (code == OS.IDRETRY) {
+                    ret = SWT.RETRY;
+                } else if (code == OS.IDABORT) {
+                    ret = SWT.ABORT;
+                } else {
+                    ret = SWT.IGNORE;
 		}
-		if (type == OS.MB_YESNOCANCEL) {
-			if (code == OS.IDYES) return SWT.YES;
-			if (code == OS.IDNO) return SWT.NO;
-			return SWT.CANCEL;
+            } else {
+                ret = SWT.CANCEL;
 		}
-		if (type == OS.MB_RETRYCANCEL) {
-			return (code == OS.IDRETRY) ? SWT.RETRY : SWT.CANCEL;
+        } else {
+                ret = SWT.CANCEL;
 		}
-		if (type == OS.MB_ABORTRETRYIGNORE) {
-			if (code == OS.IDRETRY) return SWT.RETRY;
-			if (code == OS.IDABORT) return SWT.ABORT;
-			return SWT.IGNORE;
+
+        // <QFS>
+        Object result = new Integer (ret);
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+        if (logger.level >= Log.DBG) {
+            logger.build("open()").add("result: ").add(result).log(Log.DBG);
 		}
+        if (result instanceof Integer) {
+            ret = ((Integer) result).intValue();
 	}
-	return SWT.CANCEL;
+        // </QFS>
+        return ret;
 }
 
 /**
Index: org/eclipse/swt/widgets/Dialog.java
===================================================================
--- org/eclipse/swt/widgets/Dialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Dialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,12 +7,18 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
 
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
+
 /**
  * This class is the abstract superclass of the classes
  * that represent the built in platform dialogs.
@@ -76,6 +82,34 @@
  */
 
 public abstract class Dialog {
+    // <QFS>
+
+    // {{{ Logging
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Dialog");
+
+    // }}}
+
+    // {{{ runDialogShownHooks
+
+    void runDialogShownHooks()
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogShownHooks()");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("this: ").add(this)).log(Log.MTD);
+        }
+        _qfGetDisplay().runDialogShownHooks(this, null);
+    }
+
+    // }}}
+
+    // </QFS>
+
 	int style;
 	Shell parent;
 	String title;
@@ -128,6 +162,9 @@
 	this.parent = parent;
 	this.style = style;
 	title = "";
+        // <QFS>
+        _qfGetDisplay().runDialogCreationHooks(this);
+        // </QFS>
 }
 
 /**
@@ -198,6 +235,17 @@
 	SWT.error(code);
 }
 
+    // <QFS>
+    /**
+     * Get the display of the dialog.
+     *
+     * @return  The display of the dialog.
+     */
+    protected final Display _qfGetDisplay() {
+        return parent != null ? parent.display : Display.getCurrent ();
+    }
+    // </QFS>
+
 /**
  * Returns the receiver's parent, which must be a <code>Shell</code>
  * or null.
Index: org/eclipse/swt/widgets/Combo.java
===================================================================
--- org/eclipse/swt/widgets/Combo.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Combo.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -17,9 +18,14 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are controls that allow the user
- * to choose an item from a list of items, or optionally 
+ * to choose an item from a list of items, or optionally
  * enter a new value by typing it into an editable text
  * field. Often, <code>Combo</code>s are used in the same place
  * where a single selection <code>List</code> widget could
@@ -32,7 +38,7 @@
  * which access one versus the other (compare for example,
  * <code>clearSelection()</code> and <code>deselectAll()</code>).
  * The API documentation is careful to indicate either "the
- * receiver's list" or the "the receiver's text field" to 
+ * receiver's list" or the "the receiver's text field" to
  * distinguish between the two cases.
  * </p><p>
  * Note that although this class is a subclass of <code>Composite</code>,
@@ -58,6 +64,13 @@
  */
 
 public class Combo extends Composite {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Combo");
+    // </QFS>
 	boolean noSelection, ignoreDefaultSelection, ignoreCharacter, ignoreModify, ignoreResize, lockText;
 	int scrollWidth, visibleCount;
 	long /*int*/ cbtHook;
@@ -69,7 +82,7 @@
 	 * that the text field in an instance of this class can hold
 	 */
 	public static final int LIMIT;
-	
+
 	/*
 	 * These values can be different on different platforms.
 	 * Therefore they are not initialized in the declaration
@@ -76,9 +89,9 @@
 	 * to stop the compiler from inlining.
 	 */
 	static {
-		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;	
+		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;
 	}
-	
+
 	/*
 	 * These are the undocumented control id's for the children of
 	 * a combo box.  Since there are no constants for these values,
@@ -88,7 +101,7 @@
 	static final int CBID_LIST = 1000;
 	static final int CBID_EDIT = 1001;
 	static /*final*/ long /*int*/ EditProc, ListProc;
-	
+
 	static final long /*int*/ ComboProc;
 	static final TCHAR ComboClass = new TCHAR (0, "COMBOBOX", true);
 	static {
@@ -96,7 +109,7 @@
 		OS.GetClassInfo (0, ComboClass, lpWndClass);
 		ComboProc = lpWndClass.lpfnWndProc;
 	}
-	
+
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -103,7 +116,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -273,7 +286,7 @@
  *
  * @see VerifyListener
  * @see #removeVerifyListener
- * 
+ *
  * @since 3.1
  */
 public void addVerifyListener (VerifyListener listener) {
@@ -357,7 +370,7 @@
 	 * all platforms.
 	 */
 	style &= ~SWT.BORDER;
-	
+
 	/*
 	 * Even though it is legal to create this widget
 	 * with scroll bars, they serve no useful purpose
@@ -377,7 +390,7 @@
  * text field is editable, this has the effect of placing the
  * i-beam at the start of the text.
  * <p>
- * Note: To clear the selected items in the receiver's list, 
+ * Note: To clear the selected items in the receiver's list,
  * use <code>deselectAll()</code>.
  * </p>
  *
@@ -454,10 +467,10 @@
 	pcbi.cbSize = COMBOBOXINFO.sizeof;
 	if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo (handle, pcbi)) {
 		width += pcbi.itemLeft + (pcbi.buttonRight - pcbi.buttonLeft);
-		height = (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2; 
+		height = (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;
 	} else {
 		int border = OS.GetSystemMetrics (OS.SM_CXEDGE);
-		width += OS.GetSystemMetrics (OS.SM_CXVSCROLL) + border * 2;		
+		width += OS.GetSystemMetrics (OS.SM_CXVSCROLL) + border * 2;
 		int textHeight = (int)/*64*/OS.SendMessage (handle, OS.CB_GETITEMHEIGHT, -1, 0);
 		if ((style & SWT.DROP_DOWN) != 0) {
 			height = textHeight + 6;
@@ -481,7 +494,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void copy () {
@@ -572,7 +585,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void cut () {
@@ -594,7 +607,7 @@
 }
 
 /**
- * Deselects the item at the given zero-relative index in the receiver's 
+ * Deselects the item at the given zero-relative index in the receiver's
  * list.  If the item at the index was already deselected, it remains
  * deselected. Indices that are out of range are ignored.
  *
@@ -724,11 +737,11 @@
 
 /**
  * Returns a (possibly empty) array of <code>String</code>s which are
- * the items in the receiver's list. 
+ * the items in the receiver's list.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver's list
@@ -762,7 +775,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public boolean getListVisible () {
@@ -792,7 +805,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public void setListVisible (boolean visible) {
@@ -804,12 +817,12 @@
  * Returns the orientation of the receiver.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public int getOrientation () {
@@ -902,7 +915,7 @@
 	COMBOBOXINFO pcbi = new COMBOBOXINFO ();
 	pcbi.cbSize = COMBOBOXINFO.sizeof;
 	if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo (handle, pcbi)) {
-		return (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2; 
+		return (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;
 	}
 	int result = (int)/*64*/OS.SendMessage (handle, OS.CB_GETITEMHEIGHT, -1, 0);
 	if (result == OS.CB_ERR) error (SWT.ERROR_CANNOT_GET_ITEM_HEIGHT);
@@ -914,9 +927,9 @@
  * text field is capable of holding. If this has not been changed
  * by <code>setTextLimit()</code>, it will be the constant
  * <code>Combo.LIMIT</code>.
- * 
+ *
  * @return the text limit
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -945,7 +958,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public int getVisibleItemCount () {
@@ -966,7 +979,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -986,7 +999,7 @@
 }
 
 /**
- * Searches the receiver's list starting at the given, 
+ * Searches the receiver's list starting at the given,
  * zero-relative index until an item is found that is equal
  * to the argument, and returns the index of that item. If
  * no item is found or the starting index is out of range,
@@ -1007,7 +1020,7 @@
 public int indexOf (String string, int start) {
 	checkWidget ();
 	if (string == null) error (SWT.ERROR_NULL_ARGUMENT);
-	
+
 	/*
 	* Bug in Windows.  For some reason, CB_FINDSTRINGEXACT
 	* will not find empty strings even though it is legal
@@ -1022,7 +1035,7 @@
 		return -1;
 	}
 
-	/* Use CB_FINDSTRINGEXACT to search for the item */	
+	/* Use CB_FINDSTRINGEXACT to search for the item */
 	int count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 	if (!(0 <= start && start < count)) return -1;
 	int index = start - 1, last = 0;
@@ -1058,7 +1071,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void paste () {
@@ -1130,7 +1143,7 @@
 	* redraw to clear the text area.  The fix is to
 	* force a redraw.
 	*/
-	if ((style & SWT.READ_ONLY) != 0) {		
+	if ((style & SWT.READ_ONLY) != 0) {
 		int count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 		if (count == 0) OS.InvalidateRect (handle, null, true);
 	}
@@ -1138,7 +1151,7 @@
 
 /**
  * Removes the items from the receiver's list which are
- * between the given zero-relative start and end 
+ * between the given zero-relative start and end
  * indices (inclusive).
  *
  * @param start the start of the range
@@ -1203,7 +1216,7 @@
 	* redraw to clear the text area.  The fix is to
 	* force a redraw.
 	*/
-	if ((style & SWT.READ_ONLY) != 0) {		
+	if ((style & SWT.READ_ONLY) != 0) {
 		count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 		if (count == 0) OS.InvalidateRect (handle, null, true);
 	}
@@ -1211,7 +1224,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * until an item is found that is equal to the argument, 
+ * until an item is found that is equal to the argument,
  * and removes that item from the list.
  *
  * @param string the item to remove
@@ -1271,7 +1284,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Modify, listener);	
+	eventTable.unhook (SWT.Modify, listener);
 }
 
 /**
@@ -1296,7 +1309,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -1315,7 +1328,7 @@
  *
  * @see VerifyListener
  * @see #addVerifyListener
- * 
+ *
  * @since 3.1
  */
 public void removeVerifyListener (VerifyListener listener) {
@@ -1322,7 +1335,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Verify, listener);	
+	eventTable.unhook (SWT.Verify, listener);
 }
 
 boolean sendKeyEvent (int type, int msg, long /*int*/ wParam, long /*int*/ lParam, Event event) {
@@ -1338,7 +1351,7 @@
 	if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;
 	char key = event.character;
 	int stateMask = event.stateMask;
-	
+
 	/*
 	* Disable all magic keys that could modify the text
 	* and don't send events when Alt, Shift or Ctrl is
@@ -1359,7 +1372,8 @@
 	* is to detect this case and avoid sending a verify
 	* event.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (OS.GetDlgItem (handle, CBID_EDIT) == OS.GetCapture()) return true;
 	}
 
@@ -1414,7 +1428,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver's 
+ * Selects the item at the given zero-relative index in the receiver's
  * list.  If the item at the index was already selected, it remains
  * selected. Indices that are out of range are ignored.
  *
@@ -1483,7 +1497,7 @@
 		* the whole area, not just the text field.  The fix is to set the
 		* SWP_NOSIZE bits when the height of text field and the drop down
 		* list is the same as the requested height.
-		* 
+		*
 		* NOTE:  Setting the width of a combo box to zero does not update
 		* the width of the drop down control rect.  If the width of the
 		* combo box is zero, then do not set SWP_NOSIZE.
@@ -1614,12 +1628,12 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public void setOrientation (int orientation) {
@@ -1724,7 +1738,7 @@
  * Sets the selection in the receiver's text field to the
  * range specified by the argument whose x coordinate is the
  * start of the selection and whose y coordinate is the end
- * of the selection. 
+ * of the selection.
  *
  * @param selection a point representing the new selection start and end
  *
@@ -1752,7 +1766,7 @@
  * Sets the contents of the receiver's text field to the
  * given string.
  * <p>
- * This call is ignored when the receiver is read only and 
+ * This call is ignored when the receiver is read only and
  * the given string is not in the receiver's list.
  * </p>
  * <p>
@@ -1759,7 +1773,7 @@
  * Note: The text field in a <code>Combo</code> is typically
  * only capable of displaying a single line of text. Thus,
  * setting the text to a string containing line breaks or
- * other special characters will probably cause it to 
+ * other special characters will probably cause it to
  * display incorrectly.
  * </p>
  *
@@ -1811,7 +1825,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #LIMIT
  */
 public void setTextLimit (int limit) {
@@ -1842,7 +1856,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public void setVisibleItemCount (int count) {
@@ -1860,7 +1874,7 @@
 		OS.SetWindowLongPtr (hwndText, OS.GWLP_WNDPROC, newProc);
 	}
 	long /*int*/ hwndList = OS.GetDlgItem (handle, CBID_LIST);
-	if (hwndList != 0) {	
+	if (hwndList != 0) {
 		OS.SetWindowLongPtr (hwndList, OS.GWLP_WNDPROC, newProc);
 	}
 }
@@ -2096,7 +2110,7 @@
 
 				/* Menu messages */
 				case OS.WM_CONTEXTMENU:		result = wmContextMenu (hwnd, wParam, lParam); break;
-					
+
 				/* Clipboard messages */
 				case OS.WM_CLEAR:
 				case OS.WM_CUT:
@@ -2114,6 +2128,16 @@
 		}
 	}
 	if (msg == OS.CB_SETCURSEL) {
+            // <QFS>
+            if (logger.level >= Log.MTD) {
+                Logger.Builder lb = logger.build("windowProc(long,int,long,long)");
+                (logger.level < Log.MTDDETAIL ? lb : lb
+                 .add("CB_SETCURSEL - hwnd: ").addHex(hwnd)
+                 .add(", msg: ").add(msg)
+                 .add(", wParam: ").addHex(wParam)
+                 .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+            }
+            // </QFS>
 		if ((style & SWT.READ_ONLY) != 0) {
 			if (hooks (SWT.Verify) || filters (SWT.Verify)) {
 				String oldText = getText (), newText = null;
@@ -2157,13 +2181,13 @@
 	* is disposed in CBN_KILLFOCUS, Windows segment faults.
 	* The fix is to send focus from WM_KILLFOCUS instead
 	* of CBN_KILLFOCUS.
-	* 
+	*
 	* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.
 	*/
 	if ((style & SWT.READ_ONLY) != 0) {
 		return super.WM_KILLFOCUS (wParam, lParam);
 	}
-	
+
 	/*
 	* Return NULL - Focus notification is
 	* done in WM_COMMAND by CBN_KILLFOCUS.
@@ -2222,7 +2246,7 @@
 	if ((style & SWT.SIMPLE) != 0) {
 		LRESULT result = super.WM_SIZE (wParam, lParam);
 		if (OS.IsWindowVisible (handle)) {
-			if (OS.IsWinCE) {	
+			if (OS.IsWinCE) {
 				long /*int*/ hwndText = OS.GetDlgItem (handle, CBID_EDIT);
 				if (hwndText != 0) OS.InvalidateRect (hwndText, null, true);
 				long /*int*/ hwndList = OS.GetDlgItem (handle, CBID_LIST);
@@ -2234,7 +2258,7 @@
 		}
 		return result;
 	}
-	
+
 	/*
 	* Feature in Windows.  When an editable drop down combo box
 	* contains text that does not correspond to an item in the
@@ -2254,7 +2278,7 @@
 	* the combo box has been resized.
 	*/
 	if ((style & SWT.H_SCROLL) != 0) setScrollWidth (scrollWidth);
-	return result; 
+	return result;
 }
 
 LRESULT WM_WINDOWPOSCHANGING (long /*int*/ wParam, long /*int*/ lParam) {
@@ -2319,7 +2343,7 @@
 	* user presses tab, return or escape, Windows beeps.
 	* The fix is to look for these keys and not call
 	* the window proc.
-	* 
+	*
 	* NOTE: This only happens when the drop down list
 	* is not visible.
 	*/
@@ -2401,7 +2425,7 @@
 				long /*int*/ hHeap = OS.GetProcessHeap ();
 				int byteCount = buffer.length () * TCHAR.sizeof;
 				long /*int*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-				OS.MoveMemory (pszText, buffer, byteCount); 
+				OS.MoveMemory (pszText, buffer, byteCount);
 				long /*int*/ code = OS.CallWindowProc (EditProc, hwndText, msg, wParam, pszText);
 				OS.HeapFree (hHeap, 0, pszText);
 				return new LRESULT (code);
@@ -2415,6 +2439,14 @@
 }
 
 LRESULT wmCommandChild (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmCommandChild(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	int code = OS.HIWORD (wParam);
 	switch (code) {
 		case OS.CBN_EDITCHANGE:
@@ -2444,6 +2476,12 @@
 			* to match the list selection by re-selecting the list item.
 			*/
 			int index = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCURSEL, 0, 0);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("wmCommandChild(long,long)")
+                                .add("index: ").add(index).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (index != OS.CB_ERR) {
 				OS.SendMessage (handle, OS.CB_SETCURSEL, index, 0);
 			}
@@ -2472,7 +2510,7 @@
 			* is disposed in CBN_KILLFOCUS, Windows segment faults.
 			* The fix is to send focus from WM_KILLFOCUS instead
 			* of CBN_KILLFOCUS.
-			* 
+			*
 			* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.
 			*/
 			if ((style & SWT.READ_ONLY) != 0) break;
@@ -2530,7 +2568,7 @@
 		OS.DispatchMessage (msg);
 	}
 	ignoreCharacter = false;
-	
+
 	sendKeyEvent (SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);
 	// widget could be disposed at this point
 	display.lastKey = display.lastAscii = 0;
Index: org/eclipse/swt/widgets/FileDialog.java
===================================================================
--- org/eclipse/swt/widgets/FileDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/FileDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -15,6 +16,13 @@
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
 
+// <QFS>
+import java.io.File;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to navigate
  * the file system and select or enter a file name.
@@ -36,6 +44,15 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public class FileDialog extends Dialog {
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.FileDialog");
+    // </QFS>
+
 	String [] filterNames = new String [0];
 	String [] filterExtensions = new String [0];
 	String [] fileNames = new String [0];
@@ -370,6 +387,22 @@
 		display.setModalDialog (this);
 	}
 	
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/*
 	* Feature in Windows.  For some reason, the WH_MSGFILTER filter
 	* does not run for GetSaveFileName() or GetOpenFileName().  The
@@ -507,7 +540,13 @@
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
 	
 	/* Answer the full path or null */
-	return fullPath;
+        // <QFS>
+        Object result = fullPath;
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+	return (result instanceof String) || result == null
+            ? (String) result
+            : fullPath;
+        // </QFS>
 }
 
 /**
Index: org/eclipse/swt/widgets/Composite.java
===================================================================
--- org/eclipse/swt/widgets/Composite.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Composite.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -236,8 +236,8 @@
 		}
 	} else {
 		size = minimumSize (wHint, hHint, changed);
-		if (size.x == 0) size.x = DEFAULT_WIDTH;
-		if (size.y == 0) size.y = DEFAULT_HEIGHT;
+	if (size.x == 0) size.x = DEFAULT_WIDTH;
+	if (size.y == 0) size.y = DEFAULT_HEIGHT;
 	}
 	if (wHint != SWT.DEFAULT) size.x = wHint;
 	if (hHint != SWT.DEFAULT) size.y = hHint;
@@ -759,45 +759,45 @@
 public void layout (Control [] changed, int flags) {
 	checkWidget ();
 	if (changed != null) {
-		for (int i=0; i<changed.length; i++) {
-			Control control = changed [i];
-			if (control == null) error (SWT.ERROR_INVALID_ARGUMENT);
-			if (control.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
-			boolean ancestor = false;
-			Composite composite = control.parent;
-			while (composite != null) {
-				ancestor = composite == this;
-				if (ancestor) break;
-				composite = composite.parent;
-			}
-			if (!ancestor) error (SWT.ERROR_INVALID_PARENT);
+	for (int i=0; i<changed.length; i++) {
+		Control control = changed [i];
+		if (control == null) error (SWT.ERROR_INVALID_ARGUMENT);
+		if (control.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
+		boolean ancestor = false;
+		Composite composite = control.parent;
+		while (composite != null) {
+			ancestor = composite == this;
+			if (ancestor) break;
+			composite = composite.parent;
 		}
-		int updateCount = 0;
-		Composite [] update = new Composite [16];
-		for (int i=0; i<changed.length; i++) {
-			Control child = changed [i];
-			Composite composite = child.parent;
-			while (child != this) {
-				if (composite.layout != null) {
-					composite.state |= LAYOUT_NEEDED;
-					if (!composite.layout.flushCache (child)) {
-						composite.state |= LAYOUT_CHANGED;
-					}
+		if (!ancestor) error (SWT.ERROR_INVALID_PARENT);
+	}
+	int updateCount = 0;
+	Composite [] update = new Composite [16];
+	for (int i=0; i<changed.length; i++) {
+		Control child = changed [i];
+		Composite composite = child.parent;
+		while (child != this) {
+			if (composite.layout != null) {
+				composite.state |= LAYOUT_NEEDED;
+				if (!composite.layout.flushCache (child)) {
+					composite.state |= LAYOUT_CHANGED;
 				}
-				if (updateCount == update.length) {
-					Composite [] newUpdate = new Composite [update.length + 16];
-					System.arraycopy (update, 0, newUpdate, 0, update.length);
-					update = newUpdate;
-				}
-				child = update [updateCount++] = composite;
-				composite = child.parent;
 			}
+			if (updateCount == update.length) {
+				Composite [] newUpdate = new Composite [update.length + 16];
+				System.arraycopy (update, 0, newUpdate, 0, update.length);
+				update = newUpdate;
+			}
+			child = update [updateCount++] = composite;
+			composite = child.parent;
 		}
+	}
 		if ((flags & SWT.DEFER) != 0) {
 			setLayoutDeferred (true);
 			display.addLayoutDeferred (this);
 		}
-		for (int i=updateCount-1; i>=0; i--) {
+	for (int i=updateCount-1; i>=0; i--) {
 			update [i].updateLayout (false);
 		}
 	} else {
Index: org/eclipse/swt/widgets/ToolBar.java
===================================================================
--- org/eclipse/swt/widgets/ToolBar.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ToolBar.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -712,29 +712,29 @@
 	if ((style & SWT.VERTICAL) != 0) {
 		int itemCount = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
 		if (itemCount > 1) {
-			TBBUTTONINFO info = new TBBUTTONINFO ();
-			info.cbSize = TBBUTTONINFO.sizeof;
-			info.dwMask = OS.TBIF_SIZE;
-			long /*int*/ size = OS.SendMessage (handle, OS.TB_GETBUTTONSIZE, 0, 0);
-			info.cx = (short) OS.LOWORD (size);
-			int index = 0;
-			while (index < items.length) {
-				ToolItem item = items [index];
-				if (item != null && (item.style & SWT.DROP_DOWN) != 0) break;
-				index++;
+		TBBUTTONINFO info = new TBBUTTONINFO ();
+		info.cbSize = TBBUTTONINFO.sizeof;
+		info.dwMask = OS.TBIF_SIZE;
+		long /*int*/ size = OS.SendMessage (handle, OS.TB_GETBUTTONSIZE, 0, 0);
+		info.cx = (short) OS.LOWORD (size);
+		int index = 0;
+		while (index < items.length) {
+			ToolItem item = items [index];
+			if (item != null && (item.style & SWT.DROP_DOWN) != 0) break;
+			index++;
+		}
+		if (index < items.length) {
+			long /*int*/ padding = OS.SendMessage (handle, OS.TB_GETPADDING, 0, 0);
+			info.cx += OS.LOWORD (padding) * 2;
+		}
+		for (int i=0; i<items.length; i++) {
+			ToolItem item = items [i];
+			if (item != null && (item.style & SWT.SEPARATOR) == 0) {
+				OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
 			}
-			if (index < items.length) {
-				long /*int*/ padding = OS.SendMessage (handle, OS.TB_GETPADDING, 0, 0);
-				info.cx += OS.LOWORD (padding) * 2;
-			}
-			for (int i=0; i<items.length; i++) {
-				ToolItem item = items [i];
-				if (item != null && (item.style & SWT.SEPARATOR) == 0) {
-					OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
-				}
-			}
 		}
 	}
+	}
 
 	/*
 	* Feature on Windows. When SWT.WRAP or SWT.VERTICAL are set
@@ -1151,9 +1151,9 @@
 		ImageList newImageList = display.getImageListToolBar (style & SWT.RIGHT_TO_LEFT, size.x, size.y);
 		ImageList newHotImageList = display.getImageListToolBarHot (style & SWT.RIGHT_TO_LEFT, size.x, size.y);
 		ImageList newDisabledImageList = display.getImageListToolBarDisabled (style & SWT.RIGHT_TO_LEFT, size.x, size.y);	
-		TBBUTTONINFO info = new TBBUTTONINFO ();
-		info.cbSize = TBBUTTONINFO.sizeof;
-		info.dwMask = OS.TBIF_IMAGE;
+					TBBUTTONINFO info = new TBBUTTONINFO ();
+					info.cbSize = TBBUTTONINFO.sizeof;
+					info.dwMask = OS.TBIF_IMAGE;
 		int count = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
 		for (int i=0; i<count; i++) {
 			ToolItem item = items [i];
@@ -1170,9 +1170,9 @@
 				info.iImage = newImageList.add(image);
 				newHotImageList.add(hot);
 				newDisabledImageList.add(disabled);
-				OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
+					OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
+				}
 			}
-		}
 		display.releaseToolImageList (imageList);
 		display.releaseToolHotImageList (hotImageList);
 		display.releaseToolDisabledImageList (disabledImageList);
@@ -1183,7 +1183,7 @@
 		hotImageList = newHotImageList;
 		disabledImageList = newDisabledImageList;
 		OS.InvalidateRect (handle, null, true);
-	}
+		}
 }
 
 int widgetStyle () {
@@ -1577,7 +1577,7 @@
 						}
 						lastArrowId = lpnmhi.idNew;
 						break;
-					}
+				}
 					default:
 						lastArrowId = -1;
 				}
Index: org/eclipse/swt/widgets/Menu.java
===================================================================
--- org/eclipse/swt/widgets/Menu.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Menu.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
@@ -17,6 +18,11 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are user interface objects that contain
  * menu items.
@@ -41,8 +47,15 @@
  */
 
 public class Menu extends Widget {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Menu");
+    // </QFS>
 	/**
-	 * the handle to the OS resource 
+	 * the handle to the OS resource
 	 * (Warning: This field is platform dependent)
 	 * <p>
 	 * <b>IMPORTANT:</b> This field is <em>not</em> part of the SWT
@@ -50,30 +63,31 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public long /*int*/ handle;
-	
-	int x, y; 
+
+	int x, y;
 	long /*int*/ hBrush, hwndCB;
 	int id0, id1;
 	int foreground = -1, background = -1;
-	Image backgroundImage;	
+	Image backgroundImage;
 	boolean hasLocation;
 	MenuItem cascade;
+    public // <QFS/> temporarily made public
 	Decorations parent;
 	ImageList imageList;
-	
+
 	/* Resource ID for SHMENUBARINFO */
 	static final int ID_PPC = 100;
-	
+
 	/* SmartPhone SoftKeyBar resource ids */
 	static final int ID_SPMM = 102;
 	static final int ID_SPBM = 103;
 	static final int ID_SPMB = 104;
 	static final int ID_SPBB = 105;
-	static final int ID_SPSOFTKEY0 = 106; 
+	static final int ID_SPSOFTKEY0 = 106;
 	static final int ID_SPSOFTKEY1 = 107;
 
 /**
@@ -111,7 +125,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -210,13 +224,13 @@
 	* called from createWidget(), the JVM issues this error:
 	*
 	* JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
-	* 
+	*
 	* In addition, on Windows XP, a dialog appears with following error message,
 	* indicating that the problem may be in the JIT:
-	* 
+	*
 	* AppName: java.exe	 AppVer: 0.0.0.0	 ModName: jitc.dll
 	* ModVer: 0.0.0.0	 Offset: 000b6912
-	* 
+	*
 	* The fix is to call checkOrientation() from here.
 	*/
 	checkOrientation (parent);
@@ -223,12 +237,22 @@
 	createWidget ();
 }
 
-void _setVisible (boolean visible) {
+// <QFS/> made public
+public void _setVisible (boolean visible) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("_setVisible(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add("visible: ").add(visible)).log(Log.MTD);
+    }
+    // </QFS>
 	if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
 	long /*int*/ hwndParent = parent.handle;
 	if (visible) {
 		int flags = OS.TPM_LEFTBUTTON;
-		if (OS.GetKeyState (OS.VK_LBUTTON) >= 0) flags |= OS.TPM_RIGHTBUTTON;
+        // <QFS/> Changed to getDisplay().GetKeyState
+        if (getDisplay().GetKeyState (OS.VK_LBUTTON) >= 0) flags |= OS.TPM_RIGHTBUTTON;
 		if ((style & SWT.RIGHT_TO_LEFT) != 0) flags |= OS.TPM_RIGHTALIGN;
 		if ((parent.style & SWT.MIRRORED) != 0) {
 			flags &= ~OS.TPM_RIGHTALIGN;
@@ -253,13 +277,124 @@
 		* the case when TrackPopupMenu() fails and the number of items in
 		* the menu is zero and issue a fake WM_MENUSELECT.
 		*/
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("_setVisible(boolean)")
+                .add("calling OS.TrackPopupMenu on this: ").add(this)
+                .add(", flags: ").addHex(flags)
+                .add(", handle: ").addHex(handle)
+                .add(", hwndParent: ").addHex(hwndParent)
+                .log(Log.DBG);
+        }
+        // Force pseudo-visibility while TrackPopupMenu is active. Otherwise a call to
+        // Display.readAndDispatch() can cause Display.popups to become null and thus the Menu to
+        // return visible false.
+        Object visCount = getData("qfs:popupvisible");
+        if (visCount instanceof Integer) {
+            setData("qfs:popupvisible", new Integer (((Integer) visCount).intValue() + 1));
+        } else {
+            setData("qfs:popupvisible", new Integer (1));
+        }
+        // </QFS>
 		boolean success = OS.TrackPopupMenu (handle, flags, nX, nY, 0, hwndParent, null);
+        // <QFS>
+        visCount = getData("qfs:popupvisible");
+        if (visCount instanceof Integer) {
+            int count = ((Integer) visCount).intValue() - 1;
+            setData("qfs:popupvisible", count <= 0 ? null : new Integer (count));
+        }
+        int err = -1;
+        if (! success) {
+            err = OS.GetLastError();
+        }
+        if (logger.level >= Log.DBG) {
+            logger.build("_setVisible(boolean)")
+                .add("OS.TrackPopupMenu returned success: ").add(success)
+                .add(", this: ").add(this)
+                .add(", err: ").add(err)
+                .log(Log.DBG);
+        }
+        // Display.(a)syncExec can lead to WM_NULL messages being posted through
+        // Display.wakeThread which in turn can confuse a certain type of modal popup menu because
+        // they turn up just after OS.TrackPopupMenu but before the WM_COMMAND resulting from a
+        // MenuItem selection. Removing all pending WM_NULL messages that come before a pending
+        // WM_COMMAND here prevents that and is safe since we're already on the dispatch thread
+        // anyway.
+        MSG msg = new MSG ();
+        if (OS.PeekMessage(msg, 0, OS.WM_COMMAND, OS.WM_COMMAND,
+                              OS.PM_NOREMOVE | OS.PM_NOYIELD)) {
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "_setVisible(boolean)",
+                           "WM_COMMAND pending");
+            }
+            while (OS.PeekMessage(msg, 0, 0, 0, OS.PM_NOREMOVE | OS.PM_NOYIELD)) {
+                if (msg.message == OS.WM_NULL) {
+                    OS.PeekMessage(msg, 0, OS.WM_NULL, OS.WM_NULL, OS.PM_REMOVE | OS.PM_NOYIELD);
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("removed WM_NULL").log(Log.MSG);
+                    }
+                } else if (msg.message == OS.WM_APP + 89) {
+                    // qftest callback - _very_ special case
+                    OS.PeekMessage(msg, 0, OS.WM_APP + 89, OS.WM_NULL,
+                                   OS.PM_REMOVE | OS.PM_NOYIELD);
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)")
+                            .add("removed qftest callback").log(Log.MSG);
+                    }
+                    if (logger.level >= Log.DBGDETAIL) {
+                        logger.log(Log.DBGDETAIL, "_setVisible(boolean)",
+                                   "now calling OS.TranslateMessage");
+                    }
+                    OS.TranslateMessage (msg);
+                    if (logger.level >= Log.DBGDETAIL) {
+                        logger.log(Log.DBGDETAIL, "_setVisible(boolean)",
+                                   "now calling OS.DispatchMessage");
+                    }
+                    try {
+                        getDisplay().eventProcessedByReadAndDispatch++;
+                        OS.DispatchMessage (msg);
+                    } finally {
+                        getDisplay().eventProcessedByReadAndDispatch--;
+                    }
+                } else if (msg.message == OS.WM_COMMAND) {
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("success, WM_COMMAND now first")
+                            .log(Log.MSG);
+                    }
+                    break;
+                } else {
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("oops, unexpected message: ")
+                            .add(msg.message).log(Log.MSG);
+                    }
+                    break;
+                }
+            }
+        }
+        // </QFS>
 		if (!success && GetMenuItemCount (handle) == 0) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "_setVisible(boolean)",
+                           "now SendMessage WM_MENUSELECT");
+            }
+            // </QFS>
 			OS.SendMessage (hwndParent, OS.WM_MENUSELECT, OS.MAKEWPARAM (0, 0xFFFF), 0);
 		}
 	} else {
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "_setVisible(boolean)",
+                       "now SendMessage WM_CANCELMODE");
+        }
+        // </QFS>
 		OS.SendMessage (hwndParent, OS.WM_CANCELMODE, 0, 0);
 	}
+    // <QFS>
+    if (logger.level >= Log.DBG) {
+        logger.build("_setVisible(boolean)").add("done. this: ").add(this).log(Log.DBG);
+    }
+    // </QFS>
 }
 
 /**
@@ -335,6 +470,11 @@
 }
 
 void createHandle () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "createHandle()", "");
+    }
+    // </QFS>
 	if (handle != 0) return;
 	if ((style & SWT.BAR) != 0) {
 		if (OS.IsPPC) {
@@ -354,7 +494,7 @@
 		}
 		/*
 		* Note in WinCE SmartPhone.  The SoftBar contains only 2 items.
-		* An item can either be a menu or a button. 
+		* An item can either be a menu or a button.
 		* SWT.BAR: creates a SoftBar with 2 menus
 		* SWT.BAR | SWT.BUTTON1: creates a SoftBar with 1 button
 		*    for button1, and a menu for button2
@@ -369,7 +509,7 @@
 			} else {
 				nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPMB : ID_SPMM;
 			}
-			
+
 			/* Create SHMENUBAR */
 			SHMENUBARINFO mbi = new SHMENUBARINFO ();
 			mbi.cbSize = SHMENUBARINFO.sizeof;
@@ -379,7 +519,7 @@
 			mbi.hInstRes = OS.GetLibraryHandle ();
 			if (!OS.SHCreateMenuBar (mbi)) error (SWT.ERROR_NO_HANDLES);
 			hwndCB = mbi.hwndMB;
-			
+
 			/*
 			* Feature on WinCE SmartPhone.  The SHCMBF_HIDDEN flag causes the
 			* SHMENUBAR to not be drawn. However the keyboard events still go
@@ -387,12 +527,12 @@
 			* ShowWindow ().
 			*/
 			OS.ShowWindow (hwndCB, OS.SW_HIDE);
-			
+
 			TBBUTTONINFO info = new TBBUTTONINFO ();
 			info.cbSize = TBBUTTONINFO.sizeof;
 			info.dwMask = OS.TBIF_COMMAND;
 			MenuItem item;
-			
+
 			/* Set first item */
 			if (nToolBarId == ID_SPMM || nToolBarId == ID_SPMB) {
 				long /*int*/ hMenu = OS.SendMessage (hwndCB, OS.SHCMBM_GETSUBMENU, 0, ID_SPSOFTKEY0);
@@ -404,7 +544,7 @@
 				item = new MenuItem (this, null, SWT.PUSH, 0);
 			}
 			info.idCommand = id0 = item.id;
-			OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY0, info);	
+			OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY0, info);
 
 			/* Set second item */
 			if (nToolBarId == ID_SPMM || nToolBarId == ID_SPBM) {
@@ -488,7 +628,7 @@
 			* is used to insert an item without text, it is not possible
 			* to use SetMenuItemInfo() to set the text at a later time.
 			* The fix is to insert the item with some text.
-			* 
+			*
 			* Feature in Windows.  When an empty string is used instead
 			* of a space and InsertMenuItem() is used to set a submenu
 			* before setting text to a non-empty string, the menu item
@@ -499,7 +639,7 @@
 			TCHAR buffer = new TCHAR (0, " ", true);
 			int byteCount = buffer.length () * TCHAR.sizeof;
 			long /*int*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-			OS.MoveMemory (pszText, buffer, byteCount);	
+			OS.MoveMemory (pszText, buffer, byteCount);
 			MENUITEMINFO info = new MENUITEMINFO ();
 			info.cbSize = MENUITEMINFO.sizeof;
 			info.fMask = OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_DATA;
@@ -517,7 +657,7 @@
 	}
 	redraw ();
 }
-	
+
 void createWidget () {
 	/*
 	* Bug in IBM JVM 1.3.1.  For some reason, when the following code is called
@@ -524,13 +664,13 @@
 	* from this method, the JVM issues this error:
 	*
 	* JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
-	* 
+	*
 	* In addition, on Windows XP, a dialog appears with following error message,
 	* indicating that the problem may be in the JIT:
-	* 
+	*
 	* AppName: java.exe	 AppVer: 0.0.0.0	 ModName: jitc.dll
 	* ModVer: 0.0.0.0	 Offset: 000b6912
-	* 
+	*
 	* The fix is to move the code to the caller of this method.
 	*/
 //	checkOrientation (parent);
@@ -580,7 +720,7 @@
 			}
 			if (info.dwItemData != item.id) {
 				error (SWT.ERROR_ITEM_NOT_REMOVED);
-			}	
+			}
 			if (!OS.DeleteMenu (handle, index, OS.MF_BYPOSITION)) {
 				error (SWT.ERROR_ITEM_NOT_REMOVED);
 			}
@@ -627,7 +767,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ Color getBackground () {
@@ -644,7 +784,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ Image getBackgroundImage () {
@@ -669,10 +809,16 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
-/*public*/ Rectangle getBounds () {
+// <QFS/> Made public.
+public Rectangle getBounds () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "getBounds()", "");
+    }
+    // </QFS>
 	checkWidget ();
 	if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
 	if ((style & SWT.BAR) != 0) {
@@ -691,9 +837,27 @@
 		int count = GetMenuItemCount (handle);
 		if (count != 0) {
 			RECT rect1 = new RECT ();
+                        // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                        // Leave unchanged for now
+                        // if (OS.GetMenuItemRect (getShell().handle, handle, 0, rect1)) {
 			if (OS.GetMenuItemRect (0, handle, 0, rect1)) {
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.build("getBounds()")
+                                    .add("rect1: ").add(rect1).log(Log.DBG);
+                            }
+                            // </QFS>
 				RECT rect2 = new RECT ();
+                                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                                // Leave unchanged for now
+                                // if (OS.GetMenuItemRect (getShell().handle, handle, count - 1, rect2)) {
 				if (OS.GetMenuItemRect (0, handle, count - 1, rect2)) {
+                                    // <QFS>
+                                    if (logger.level >= Log.DBG) {
+                                        logger.build("getBounds()")
+                                            .add("rect2: ").add(rect2).log(Log.DBG);
+                                    }
+                                    // </QFS>
 					int x = rect1.left - 2, y = rect1.top - 2;
 					int width = (rect2.right - rect2.left) + 4;
 					int height = (rect2.bottom - rect1.top) + 4;
@@ -743,7 +907,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -824,11 +988,11 @@
 
 /**
  * Returns a (possibly empty) array of <code>MenuItem</code>s which
- * are the items in the receiver. 
+ * are the items in the receiver.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -910,12 +1074,12 @@
  * constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public int getOrientation () {
@@ -1011,6 +1175,11 @@
  * </ul>
  */
 public boolean getVisible () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "getVisible()", "");
+    }
+    // </QFS>
 	checkWidget ();
 	if ((style & SWT.BAR) != 0) {
 		return this == parent.menuShell ().menuBar;
@@ -1017,15 +1186,39 @@
 	}
 	if ((style & SWT.POP_UP) != 0) {
 		Menu [] popups = display.popups;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("getVisible()").add("popups: ").addAll(popups).log(Log.DBG);
+                }
+                // </QFS>
 		if (popups == null) return false;
 		for (int i=0; i<popups.length; i++) {
+                    // <QFS>
+                    if (logger.level >= Log.DBG && popups [i] == this) {
+                        logger.log(Log.DBG, "getVisible()",
+                                   "Found me");
+                    }
+                    // </QFS>
 			if (popups [i] == this) return true;
 		}
 	}
 	Shell shell = getShell ();
 	Menu menu = shell.activeMenu;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("getVisible()").add("shell: ").add(shell)
+                .add(", menu: ").add(menu)
+                .add(", is me: ").add(menu == this).log(Log.DBG);
+        }
+        // </QFS>
 	while (menu != null && menu != this) {
 		menu = menu.getParentMenu ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("getVisible()").add("parent menu: ").add(menu)
+                        .add(", is me: ").add(menu == this).log(Log.DBG);
+                }
+                // </QFS>
 	}
 	return this == menu;
 }
@@ -1051,7 +1244,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -1104,7 +1297,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -1131,6 +1324,11 @@
  * @see #getVisible
  */
 public boolean isVisible () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "isVisible()", "");
+    }
+    // </QFS>
 	checkWidget ();
 	return getVisible ();
 }
@@ -1261,13 +1459,13 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setBackground (Color color) {
@@ -1291,14 +1489,14 @@
  * @param image the new image (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setBackgroundImage (Image image) {
@@ -1320,13 +1518,13 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setForeground (Color color) {
@@ -1344,11 +1542,11 @@
 /**
  * Sets the default menu item to the argument or removes
  * the default emphasis when the argument is <code>null</code>.
- * 
+ *
  * @param item the default menu item or null
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the menu item has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the menu item has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -1438,7 +1636,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void setLocation (Point location) {
@@ -1453,15 +1651,15 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
- * @since 3.7  
+ *
+ * @since 3.7
  */
-public void setOrientation (int orientation) { 
+public void setOrientation (int orientation) {
     checkWidget ();
     if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
     _setOrientation (orientation);
@@ -1482,7 +1680,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -1497,7 +1695,20 @@
  * </ul>
  */
 public void setVisible (boolean visible) {
-	checkWidget ();
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("setVisible(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add("visible: ").add(visible)).log(Log.MTD);
+    }
+    // </QFS>
+        checkWidget ();
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("setVisible(boolean)").add("style: ").addHex(style).log(Log.DBG);
+        }
+        // </QFS>
 	if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
 	if (visible) {
 		display.addPopup (this);
@@ -1505,6 +1716,12 @@
 		display.removePopup (this);
 		_setVisible (false);
 	}
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "setVisible(boolean)",
+                       "done");
+        }
+        // </QFS>
 }
 
 void update () {
@@ -1547,7 +1764,7 @@
 			if ((hasCheck = true) && hasImage) break;
 		}
 	}
-	
+
 	/*
 	* Bug in Windows.  If a menu contains items that have
 	* images and can be checked, Windows does not include
@@ -1557,16 +1774,16 @@
 	* text can overlap.  The fix is to use SetMenuItemInfo()
 	* to indicate that all items have a bitmap and then include
 	* the width of the widest bitmap in WM_MEASURECHILD.
-	* 
+	*
 	* NOTE:  This work around causes problems on Windows 98.
 	* Under certain circumstances that have yet to be isolated,
 	* some menus can become huge and blank.  For now, do not
 	* run the code on Windows 98.
-	* 
+	*
 	* NOTE:  This work around doesn't run on Vista because
 	* WM_MEASURECHILD and WM_DRAWITEM cause Vista to lose
 	* the menu theme.
-	*/	
+	*/
 	if (!OS.IsWin95) {
 		if (OS.WIN32_VERSION < OS.VERSION (6, 0)) {
 			MENUITEMINFO info = new MENUITEMINFO ();
@@ -1584,6 +1801,36 @@
 		}
 	}
 
+        /*
+        * Bug in Windows.  If a menu contains items that have
+        * images and can be checked, Windows does not include
+        * the width of the image and the width of the check when
+        * computing the width of the menu.  When the longest item
+        * does not have an image, the label and the accelerator
+        * text can overlap.  The fix is to use SetMenuItemInfo()
+        * to indicate that all items have a bitmap and then include
+        * the width of the widest bitmap in WM_MEASURECHILD.
+        *
+        * NOTE:  This work around causes problems on Windows 98.
+        * Under certain circumstances that have yet to be isolated,
+        * some menus can become huge and blank.  For now, do not
+        * run the code on Windows 98.
+        */
+        if (!OS.IsWin95) {
+                MENUITEMINFO info = new MENUITEMINFO ();
+                info.cbSize = MENUITEMINFO.sizeof;
+                info.fMask = OS.MIIM_BITMAP;
+                for (int i=0; i<items.length; i++) {
+                        MenuItem item = items [i];
+                        if ((style & SWT.SEPARATOR) == 0) {
+                                if (item.image == null) {
+                                        info.hbmpItem = hasImage ? OS.HBMMENU_CALLBACK : 0;
+                                        OS.SetMenuItemInfo (handle, item.id, false, info);
+                                }
+                        }
+                }
+        }
+
 	/* Update the menu to hide or show the space for bitmaps */
 	MENUINFO lpcmi = new MENUINFO ();
 	lpcmi.cbSize = MENUINFO.sizeof;
Index: org/eclipse/swt/widgets/Display.java
===================================================================
--- org/eclipse/swt/widgets/Display.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Display.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -16,6 +17,21 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import org.eclipse.swt.dnd.DragSource;
+import org.eclipse.swt.dnd.DropTarget;
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are responsible for managing the
  * connection between SWT and the underlying operating
@@ -47,12 +63,12 @@
  * <code>Widget</code> and its subclasses), may only be called
  * from the thread. (To support multi-threaded user-interface
  * applications, class <code>Display</code> provides inter-thread
- * communication methods which allow threads other than the 
+ * communication methods which allow threads other than the
  * user-interface thread to request that it perform operations
  * on their behalf.)
  * </li>
  * <li>
- * The thread is not allowed to construct other 
+ * The thread is not allowed to construct other
  * <code>Display</code>s until that display has been disposed.
  * (Note that, this is in addition to the restriction mentioned
  * above concerning platform support for multiple displays. Thus,
@@ -61,8 +77,8 @@
  * </li>
  * </ul>
  * Enforcing these attributes allows SWT to be implemented directly
- * on the underlying operating system's event model. This has 
- * numerous benefits including smaller footprint, better use of 
+ * on the underlying operating system's event model. This has
+ * numerous benefits including smaller footprint, better use of
  * resources, safer memory management, clearer program logic,
  * better performance, and fewer overall operating system threads
  * required. The down side however, is that care must be taken
@@ -97,6 +113,1409 @@
 
 public class Display extends Device {
 
+    // <QFS>
+    // {{{ Logging
+
+    /**
+     * The logger used for logging.
+     */
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Display");
+
+    // }}}
+
+    /**
+     * Monitor for class level synchronization.
+     */
+    final static Object classLock = new Object ();
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for display creation notification
+    //------------------------------------------------------------------------------------------
+
+    // {{{ interface IDisplayCreationHook
+
+    public interface IDisplayCreationHook {
+        /**
+         * Notify the hook that a new display was created.
+         *
+         * @param       display The newly created Display.
+         */
+        public void displayCreated(Display display);
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    static IDisplayCreationHook[] creationHooks;
+
+    // {{{ addDisplayCreationHook
+
+    public static void addDisplayCreationHook(IDisplayCreationHook hook)
+    {
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                creationHooks = new IDisplayCreationHook[] {hook};
+                return;
+            }
+            // Prevent double registration. If the hook is already registered, move it to the
+            // front.
+            for (int i = 0; i < creationHooks.length; i++) {
+                if (creationHooks[i] == hook) {
+                    if (i == 0) {
+                        return;
+                    }
+                    System.arraycopy(creationHooks, 0, creationHooks, 1, i);
+                    creationHooks[0] = hook;
+                }
+            }
+            // Insert new hook at front
+            IDisplayCreationHook[] tmp = new IDisplayCreationHook[creationHooks.length + 1];
+            tmp[0] = hook;
+            System.arraycopy(creationHooks, 0, tmp, 1, creationHooks.length);
+            creationHooks = tmp;
+        }
+    }
+
+    // }}}
+    // {{{ removeDisplayCreationHook
+
+    public static void removeDisplayCreationHook(IDisplayCreationHook hook)
+    {
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                return;
+            }
+
+            for (int i = 0; i < creationHooks.length; i++) {
+                if (creationHooks[i] == hook) {
+                    if (creationHooks.length == 1) {
+                        creationHooks = null;
+                        return;
+                    }
+                    // Insert new hook at front
+                    IDisplayCreationHook[] tmp =
+                        new IDisplayCreationHook[creationHooks.length - 1];
+                    if (i > 0) {
+                        System.arraycopy(creationHooks, 0, tmp, 0, i - 1);
+                    }
+                    if (i < creationHooks.length - 1) {
+                        System.arraycopy(creationHooks, i + 1, tmp, i,
+                                         creationHooks.length - i - 1);
+                    }
+                    creationHooks = tmp;
+                }
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDisplayCreationHooks
+
+    static void runDisplayCreationHooks(Display display)
+    {
+        IDisplayCreationHook[] tmp;
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                return;
+            }
+            tmp = (IDisplayCreationHook[]) creationHooks.clone();
+        }
+        if (tmp != null) {
+            for (int i = 0; i < tmp.length; i++) {
+                try {
+                    tmp[i].displayCreated(display);
+                } catch (Throwable ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for Dialog creation and showing
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IDialogHook
+
+    public interface IDialogHook {
+        // {{{ dialogCreated
+
+        /**
+         * Notify the hook that a new display was created.
+         *
+         * @param       dialog The dialog that was created.
+         */
+        public void dialogCreated(Dialog dialog);
+
+        // }}}
+        // {{{ dialogShown
+
+        /**
+         * Notify the hook that a dialog is about to be shown.
+         *
+         * @param       dialog The dialog that is about to be shown.
+         * @param       handle System specific handle for the dialog.
+         */
+        public void dialogShown(Dialog dialog, Object handle);
+
+        // }}}
+        // {{{ dialogClosed
+
+        /**
+         * Notify the hook that a dialog was closed.
+         *
+         * @param       dialog The dialog that was closed.
+         * @param       result The result representing the user's choice.
+         *
+         * @return  Optional replacement for the original result.
+         */
+        public Object dialogClosed(Dialog dialog, Object result);
+
+        // }}}
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    private IDialogHook[] dialogHooks;
+
+    // {{{ addDialogHook
+
+    /**
+     * Add a dialog hook.
+     *
+     * @param   hook    The hook to add.
+     */
+    public void addDialogHook(IDialogHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("addDialogHook(IDialogHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            dialogHooks = new IDialogHook[] {hook};
+            return;
+        }
+        // Prevent double registration. If the hook is already registered, move it to the
+        // front.
+        for (int i = 0; i < dialogHooks.length; i++) {
+            if (dialogHooks[i] == hook) {
+                if (i == 0) {
+                    return;
+                }
+                System.arraycopy(dialogHooks, 0, dialogHooks, 1, i);
+                dialogHooks[0] = hook;
+            }
+        }
+        // Insert new hook at front
+        IDialogHook[] tmp = new IDialogHook[dialogHooks.length + 1];
+        tmp[0] = hook;
+        System.arraycopy(dialogHooks, 0, tmp, 1, dialogHooks.length);
+        dialogHooks = tmp;
+    }
+
+    // }}}
+    // {{{ removeDialogHook
+
+    /**
+     * Remove a dialog hook.
+     *
+     * @param   hook    The hook to remove.
+     */
+    public void removeDialogHook(IDialogHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("removeDialogHook(IDialogHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+
+        for (int i = 0; i < dialogHooks.length; i++) {
+            if (dialogHooks[i] == hook) {
+                if (dialogHooks.length == 1) {
+                    dialogHooks = null;
+                    return;
+                }
+                // Insert new hook at front
+                IDialogHook[] tmp = new IDialogHook[dialogHooks.length - 1];
+                if (i > 0) {
+                    System.arraycopy(dialogHooks, 0, tmp, 0, i - 1);
+                }
+                if (i < dialogHooks.length - 1) {
+                    System.arraycopy(dialogHooks, i + 1, tmp, i,
+                                     dialogHooks.length - i - 1);
+                }
+                dialogHooks = tmp;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogCreationHooks
+
+    /**
+     * Notify all hooks about a newly created dialog.
+     *
+     * @param   dialog  The new dialog.
+     */
+    public void runDialogCreationHooks(Dialog dialog)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogCreationHooks(Dialog)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dialogCreated(dialog);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogShownHooks
+
+    /**
+     * Notify all hooks about a dialog being shown.
+     *
+     * @param   dialog  The shown dialog.
+     * @param   handle  The handle for the dialog.
+     */
+    public void runDialogShownHooks(Dialog dialog, Object handle)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogShownHooks(Dialog,Object)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)
+             .add(", handle: ").add(handle)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dialogShown(dialog, handle);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogClosedHooks
+
+    /**
+     * Notify all hooks about a dialog being closed.
+     *
+     * @param   dialog  The closed dialog.
+     * @param   result  The result of the operation (depends on the type of dialog).
+     *
+     * @return  Optional replacement for the original result.
+     */
+    public Object runDialogClosedHooks(Dialog dialog, Object result)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogClosedHooks(Dialog,Object)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)
+             .add(", result: ").add(result)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return result;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                result = tmp[i].dialogClosed(dialog, result);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+        return result;
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for DND creation
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IDNDHook
+
+    public interface IDNDHook {
+        // {{{ dragSourceCreated
+
+        /**
+         * Notify the hook that a new DragSource was created.
+         *
+         * @param       dragSource The DragSource that was created.
+         */
+        public void dragSourceCreated(DragSource dragSource);
+
+        // }}}
+        // {{{ dropTargetCreated
+
+        /**
+         * Notify the hook that a new DropTarget was created.
+         *
+         * @param       dropTarget The DropTarget that was created.
+         */
+        public void dropTargetCreated(DropTarget dropTarget);
+
+        // }}}
+        // {{{ trackerDragStarted
+
+        /**
+         * Notify the listener that a Drag involving a Tracker was started.
+         */
+        public void trackerDragStarted();
+
+        // }}}
+        // {{{ trackerDragFinished
+
+        /**
+         * Notify the listener that a Drag involving a Tracker was finished.
+         *
+         * @param   cancelled       Whether the drag was cancelled.
+         */
+        public void trackerDragFinished(boolean cancelled);
+
+        // }}}
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    private IDNDHook[] dndHooks;
+
+    // {{{ addDNDHook
+
+    /**
+     * Add a dnd hook.
+     *
+     * @param   hook    The hook to add.
+     */
+    public void addDNDHook(IDNDHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("addDNDHook(IDNDHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            dndHooks = new IDNDHook[] {hook};
+            return;
+        }
+        // Prevent double registration. If the hook is already registered, move it to the
+        // front.
+        for (int i = 0; i < dndHooks.length; i++) {
+            if (dndHooks[i] == hook) {
+                if (i == 0) {
+                    return;
+                }
+                System.arraycopy(dndHooks, 0, dndHooks, 1, i);
+                dndHooks[0] = hook;
+            }
+        }
+        // Insert new hook at front
+        IDNDHook[] tmp = new IDNDHook[dndHooks.length + 1];
+        tmp[0] = hook;
+        System.arraycopy(dndHooks, 0, tmp, 1, dndHooks.length);
+        dndHooks = tmp;
+    }
+
+    // }}}
+    // {{{ removeDNDHook
+
+    /**
+     * Remove a dnd hook.
+     *
+     * @param   hook    The hook to remove.
+     */
+    public void removeDNDHook(IDNDHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("removeDNDHook(IDNDHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+
+        for (int i = 0; i < dndHooks.length; i++) {
+            if (dndHooks[i] == hook) {
+                if (dndHooks.length == 1) {
+                    dndHooks = null;
+                    return;
+                }
+                // Insert new hook at front
+                IDNDHook[] tmp = new IDNDHook[dndHooks.length - 1];
+                if (i > 0) {
+                    System.arraycopy(dndHooks, 0, tmp, 0, i - 1);
+                }
+                if (i < dndHooks.length - 1) {
+                    System.arraycopy(dndHooks, i + 1, tmp, i,
+                                     dndHooks.length - i - 1);
+                }
+                dndHooks = tmp;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDCreationHooks
+
+    /**
+     * Notify all hooks about a newly created DragSource or DropTarget.
+     *
+     * @param   dragSource     The new DragSource.
+     */
+    public void runDNDCreationHooks(DragSource dragSource)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDCreationHooks(DragSource)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dragSource: ").add(dragSource)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dragSourceCreated(dragSource);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDCreationHooks
+
+    /**
+     * Notify all hooks about a newly created DropTarget or DropTarget.
+     *
+     * @param   dropTarget     The new DropTarget.
+     */
+    public void runDNDCreationHooks(DropTarget dropTarget)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDCreationHooks(DropTarget)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dropTarget: ").add(dropTarget)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dropTargetCreated(dropTarget);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDTrackerHooks
+
+    /**
+     * Notify all hooks about DnD performed through a Tracker.
+     *
+     * @param   start   True if the DnD is started, false if finished.
+     * @param   cancelled True if the DnD was cancelled.
+     */
+    public void runDNDTrackerHooks(boolean start, boolean cancelled)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDTrackerHooks(boolean,boolean)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("start: ").add(start)
+             .add(", cancelled: ").add(cancelled)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                if (start) {
+                    tmp[i].trackerDragStarted();
+                } else {
+                    tmp[i].trackerDragFinished(cancelled);
+                }
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Event filter at Win32 level
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IWin32EventFilter
+
+    public interface IWin32EventFilter {
+        /**
+         * Possibly filter a Win32 message.
+         *
+         * @param       hwnd        The window handle.
+         * @param       msg         The message type.
+         * @param       wParam      win32 wParam.
+         * @param       lParam      win32 lParam.
+         *
+         * @return      True to process the event normally, false to filter it. (i.e. "keep it?")
+         */
+        public boolean filterWin32Event(long /*int*/ hwnd, long /*int*/ msg,
+                                        long /*int*/ wParam, long /*int*/ lParam);
+    }
+
+    // }}}
+
+    /**
+     * Registered Win32 event filters.
+     */
+    IWin32EventFilter[] win32EventFilters;
+    public int eventProcessedByReadAndDispatch = 0;
+
+    // {{{ addWin32EventFilter
+
+    public void addWin32EventFilter(IWin32EventFilter hook)
+    {
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                win32EventFilters = new IWin32EventFilter[] {hook};
+                return;
+            }
+            // Prevent double registration. If the hook is already registered, move it to the
+            // front.
+            for (int i = 0; i < win32EventFilters.length; i++) {
+                if (win32EventFilters[i] == hook) {
+                    if (i == 0) {
+                        return;
+                    }
+                    System.arraycopy(win32EventFilters, 0, win32EventFilters, 1, i);
+                    win32EventFilters[0] = hook;
+                }
+            }
+            // Insert new hook at front
+            IWin32EventFilter[] tmp = new IWin32EventFilter[win32EventFilters.length + 1];
+            tmp[0] = hook;
+            System.arraycopy(win32EventFilters, 0, tmp, 1, win32EventFilters.length);
+            win32EventFilters = tmp;
+        }
+    }
+
+    // }}}
+    // {{{ removeWin32EventFilter
+
+    public void removeWin32EventFilter(IWin32EventFilter hook)
+    {
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                return;
+            }
+
+            for (int i = 0; i < win32EventFilters.length; i++) {
+                if (win32EventFilters[i] == hook) {
+                    if (win32EventFilters.length == 1) {
+                        win32EventFilters = null;
+                        return;
+                    }
+                    // Insert new hook at front
+                    IWin32EventFilter[] tmp =
+                        new IWin32EventFilter[win32EventFilters.length - 1];
+                    if (i > 0) {
+                        System.arraycopy(win32EventFilters, 0, tmp, 0, i - 1);
+                    }
+                    if (i < win32EventFilters.length - 1) {
+                        System.arraycopy(win32EventFilters, i + 1, tmp, i,
+                                         win32EventFilters.length - i - 1);
+                    }
+                    win32EventFilters = tmp;
+                }
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runWin32EventFilters
+
+    /**
+     * Run all registered filters and possibly filter a Win32 message.
+     * Filters are only run until the first one wants to filter it (returns false);
+     *
+     * @param       hwnd        The window handle.
+     * @param       msg         The message type.
+     * @param       wParam      win32 wParam.
+     * @param       lParam      win32 lParam.
+     *
+     * @return      True to process the event normally, false to filter it. (i.e. "keep it?")
+     */
+    protected boolean runWin32EventFilters(long /*int*/ hwnd, long /*int*/ msg,
+                                           long /*int*/ wParam, long /*int*/ lParam)
+    {
+        // <QFS>
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runWin32EventFilters(long,long,long,long)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hwnd: ").addHex(hwnd)
+             .add(", msg: ").add(msg)
+             .add(", wParam: ").addHex(wParam)
+             .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+        }
+        // </QFS>
+        IWin32EventFilter[] tmp;
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                return true;
+            }
+            tmp = (IWin32EventFilter[]) win32EventFilters.clone();
+        }
+        if (tmp != null) {
+            for (int i = 0; i < tmp.length; i++) {
+                try {
+                    if (! tmp[i].filterWin32Event(hwnd, msg, wParam, lParam)) {
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.log(Log.DBG, "runWin32EventFilters(long,long,long,long)",
+                                       "filterWin32Event returned false");
+                        }
+                        // </QFS>
+                        return false;
+                    }
+                } catch (Throwable ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+        return true;
+    }
+
+    // }}}
+
+    /**
+     * Misc
+     */
+    // {{{ logMessage
+
+    public void logMessage(String method,
+                           long /*int*/ hwnd, long /*int*/ msg,
+                           long /*int*/ wParam, long /*int*/ lParam,
+                           String preText,
+                           Logger logger,
+                           int fixedloglevel)
+    {
+        // get name of control
+        Control control = getControl(hwnd);
+        String controlClassName = control != null ? control.getClass().getName() : "(unknown control)";
+
+        // determine loglevel
+        int loglevel = Log.MTD;
+        String msgtype = null;
+
+        if (logger.level >= Log.MTD) {
+            boolean[] hasMatch = new boolean[1];
+            msgtype = OS.getWinMsgType(msg, hasMatch);
+            loglevel = OS.isMessageImportant(msg)
+                ? Log.MTD
+                : (OS.isMessageUnimportant(msg) || ! hasMatch[0])
+                ? Log.DBGDETAIL
+                : Log.DBG;
+        }
+        if (fixedloglevel >= 0)
+            loglevel = fixedloglevel;
+
+        // now do the real logging
+        if (logger.level >= loglevel) {
+            Logger.Builder lb = logger.build(method)
+                .add(preText != null ? preText : "")
+                .add("msg: ").add(msgtype)
+                .add(", hwnd: ").addHex(hwnd)
+                .add(", controlclass=").add(controlClassName);
+            switch ((int) msg) {
+            case OS.WM_LBUTTONDOWN:
+            case OS.WM_LBUTTONUP:
+                lb  .add(", keyflags=").addHex(wParam)
+                    .add(", x=").add(lParam & 0xffff)
+                    .add(", y=").add(lParam >> 16)
+                    .log(loglevel);
+                break;
+            default:
+                lb  .add(", wParam: ").addHex(wParam)
+                    .add(", lParam: ").addHex(lParam)
+                    .log(loglevel);
+                break;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ getLastMouse
+
+    public int getLastMouse()
+    {
+        return lastMouse;
+    }
+
+    // }}}
+
+    // {{{ variables
+
+    public final static String[] EVENTS = new String[] {
+        "None", "KeyDown", "KeyUp", "MouseDown", "MouseUp", "MouseMove", "MouseEnter", "MouseExit",
+        "MouseDoubleClick", "Paint", "Move", "Resize", "Dispose", "Selection", "DefaultSelection",
+        "FocusIn", "FocusOut", "Expand", "Collapse", "Iconify", "Deiconify", "Close", "Show",
+        "Hide", "Modify", "Verify", "Activate", "Deactivate", "Help", "DragDetect", "Arm",
+        "Traverse", "MouseHover", "HardKeyDown", "HardKeyUp", "MenuDetect", "SetData"};
+
+    // }}}
+    // {{{ getEventName
+
+    public final static String getEventName(int event)
+    {
+        if (event >= 0 && event <= 36) {
+            return EVENTS[event];
+        }
+        return "Unknown";
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // KeyState override during replay
+    //------------------------------------------------------------------------------------------
+    // {{{ variables
+
+    protected boolean replaying;
+    protected Widget replayTarget;
+    private long replayingUntil;
+    private int replayPos;
+    private int replayFwKeys;
+
+    // }}}
+    // {{{ GetKeyState
+
+    /**
+     * The GetKeyState function retrieves the status of the specified virtual key.
+     * If replaying is false, this is just OS.GetKeyState().
+     * If replaying is true, it returns the replayed keyState.
+     *
+     * @param   nVirtKey
+     *
+     * @return  -1 if key is pressed, 0 if not.
+     */
+    public short GetKeyState(int nVirtKey)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("GetKeyState(int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("nVirtKey: ").add(nVirtKey)).log(Log.MTD);
+        }
+        if (logger.level >= Log.DBG) {
+            logger.dumpStack(Log.DBG, "GetKeyState(int)",
+                       "");
+        }
+
+        if (replaying) {
+            int mask;
+            switch (nVirtKey) {
+            case OS.VK_SHIFT:
+                mask = SWT.SHIFT;
+                break;
+            case OS.VK_CONTROL:
+                mask = SWT.CONTROL;
+                break;
+            case OS.VK_MENU:
+                mask = SWT.ALT;
+                break;
+            case OS.VK_LBUTTON:
+                mask = SWT.BUTTON1;
+                break;
+            case OS.VK_MBUTTON:
+                mask = SWT.BUTTON2;
+                break;
+            case OS.VK_RBUTTON:
+                mask = SWT.BUTTON3;
+                break;
+            default:
+                mask = 0;
+            }
+
+            if (logger.level >= Log.DBG) {
+                logger.build("GetKeyState(int)").add("mask: ").addHex(mask)
+                    .add(", replayFwKeys").addHex(replayFwKeys).log(Log.DBG);
+            }
+            return ((replayFwKeys & mask) != 0) ? (short)-1 : 0;
+        } else {
+            return OS.GetKeyState(nVirtKey);
+        }
+    }
+
+    // }}}
+    // {{{ GetMessagePos
+
+    /**
+     * The GetMessagePos function returns a long value that gives the cursor position in
+     * screen coordinates.
+     *
+     * If replaying is false, this is just OS.GetMessagePos().
+     * If replaying is true, it returns the replayed position.
+     *
+     * @return The return value specifies the x- and y-coordinates of the cursor position.
+     *           The x-coordinate is the low order int and the y-coordinate is the high-order int.
+     *
+     */
+    int GetMessagePos()
+    {
+        if (isReplaying()) {
+            return replayPos;
+        } else {
+            return OS.GetMessagePos();
+        }
+    }
+
+    // }}}
+    // {{{ setReplayState
+
+    public void setReplayState(boolean replaying, long until, int pos, Widget target)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayState(boolean,long,int,Widget)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", until: ").add(until)
+             .add(", pos: ").add(pos)
+             .add(", target: ").add(target)).log(Log.MTD);
+        }
+        this.replaying = replaying;
+        replayingUntil = until;
+        if (replaying) {
+            replayPos = pos;
+            replayTarget = target;
+        }
+    }
+
+    // }}}
+    // {{{ setReplayKeyState
+
+    public void setReplayKeyState(boolean replaying, long until, int keyState)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayKeyState(boolean,long,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", until: ").add(until)
+             .add(", keyState: ").addHex(keyState)).log(Log.MTD);
+        }
+        this.replaying = replaying;
+        replayingUntil = until;
+        if (replaying) {
+            replayFwKeys = keyState;
+        }
+    }
+
+    // }}}
+    // {{{ setReplayKeyStateWnd
+
+    public void setReplayKeyStateWnd(int keyState)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayKeyStateWnd(int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("keyState: ").add(keyState)).log(Log.MTD);
+        }
+        replayFwKeys = 0;
+        if ((keyState & OS.MK_SHIFT) != 0) {
+            replayFwKeys |= SWT.SHIFT;
+        }
+        if ((keyState & OS.MK_CONTROL) != 0) {
+            replayFwKeys |= SWT.CONTROL;
+        }
+        if ((keyState & OS.MK_LBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON1;
+        }
+        if ((keyState & OS.MK_MBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON2;
+        }
+        if ((keyState & OS.MK_RBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON3;
+        }
+    }
+
+    // }}}
+    // {{{ isReplaying
+
+    protected boolean isReplaying()
+    {
+        return replaying
+            || (replayingUntil != 0 && replayingUntil > System.currentTimeMillis());
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Helper class for accessing environment variables
+    //
+    // Doesn't belong here.
+    //------------------------------------------------------------------------------------------
+    // {{{ class Environment
+
+    private static class Environment
+    {
+        // {{{ variables
+
+        /**
+         * Names used by DOS/Windows 95 variants.
+         */
+        private final String[] dosNames = {
+            "Windows 95", "Windows 98", "Windows ME"
+        };
+
+        /**
+         * Whether the JDK is at least version 1.5 so we can use System.getenv.
+         */
+        private final boolean is15 = "1.5".compareTo(System.getProperty("java.version")) <= 0;
+
+        /**
+         * Unknown os.
+         */
+        private final int OS_OTHER = 0;
+
+        /**
+         * Posix variants.
+         */
+        private final int OS_POSIX = 1;
+
+        /**
+         * Windows NT variants.
+         */
+        private final int OS_NT = 2;
+
+        /**
+         * DOS/Windows 95 variants.
+         */
+        private final int OS_DOS = 3;
+
+        /**
+         * MacOS variants < Mac OS-X
+         */
+        private final int OS_MAC = 4;
+
+        /**
+         * The os type.
+         */
+        private int os = OS_OTHER;
+
+        /**
+         * The actual environment.
+         */
+        private Properties environment;
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Constructor
+        //--------------------------------------------------------------------------------------
+        // {{{ Environment
+
+        /**
+         * Create a new Environment.
+         */
+        public Environment ()
+        {
+            determineOS();
+            if (os != OS_OTHER) {
+                initEnvironment();
+            }
+        }
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Public methods
+        //--------------------------------------------------------------------------------------
+        // {{{ isAvaliable
+
+        /**
+         * Test whether the Environment is available.
+         *
+         * @return      Whether the Environment is available.
+         */
+        public boolean isAvaliable()
+        {
+            return os != OS_OTHER;
+        }
+
+        // }}}
+        // {{{ getEnvironment
+
+        /**
+         * Get the whole set of environment variables.
+         *
+         * @return  The environment variables.
+         */
+        public final Properties getEnvironment()
+        {
+            if (os == OS_OTHER) {
+                return null;
+            }
+            synchronized (this) {
+                if (environment == null) {
+                    initEnvironment();
+                }
+            }
+            return environment;
+        }
+
+        // }}}
+        // {{{ setEnvironment
+
+        /**
+         * Set the whole set of environment variables.
+         *
+         * @param   environment     The environment to set.
+         */
+        public final void setEnvironment(Properties environment)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            this.environment = environment;
+        }
+
+
+
+        // }}}
+        // {{{ getEnv
+
+        /**
+         * Get one environment variable.
+         *
+         * @param   name    The name of the environment variable.
+         *
+         * @return  The respective environment value or null if undefined.
+         */
+        public String getEnv(String name)
+        {
+            if (os == OS_OTHER) {
+                return null;
+            }
+            return getEnvironment().getProperty(transformName(name));
+        }
+
+        // }}}
+        // {{{ setEnv
+
+        /**
+         * Set an environment variable value.
+         *
+         * @param   name    The name of the environment variable.
+         * @param   value   The value of the environment variable.
+         */
+        public void setEnv(String name, String value)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            getEnvironment().put(transformName(name), value);
+        }
+
+        // }}}
+        // {{{ unsetEnv
+        /**
+         * Delete an environment variable.
+         *
+         * @param   name    The name of the environment variable.
+         */
+        public void unsetEnv(String name)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            getEnvironment().remove(transformName(name));
+        }
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Helper methods
+        //--------------------------------------------------------------------------------------
+        // {{{ determineOS
+
+        /**
+         * Determine the type of the underlying operating system.
+         */
+        private void determineOS()
+        {
+            String osname = System.getProperty("os.name");
+            // debug("osname: " + osname);
+            if (osname == null) {
+                if (is15) {
+                    os = OS_POSIX;
+                    return;
+                }
+                return;
+            }
+
+            if (osname.startsWith("Windows")) {
+                int i;
+                for (i = 0; i < dosNames.length; i++) {
+                    if (dosNames[i].equalsIgnoreCase(osname)) {
+                        os = OS_DOS;
+                    }
+                }
+                if (i == dosNames.length) {
+                    os = OS_NT;
+                }
+            } else if (osname.startsWith("MacOS")) {
+                os = OS_MAC;
+            } else {
+                os = OS_POSIX;
+            }
+            // debug("os: " + os);
+        }
+
+        // }}}
+        // {{{ initEnvironment
+
+        /**
+         * Initialize the environment by executing a subshell.
+         */
+        private void initEnvironment()
+        {
+            environment = new Properties();
+
+            if (is15) {
+                try {
+                    Map env = (Map) System.class.getMethod("getenv", new Class[0])
+                        .invoke(null, new Object[0]);
+                    for (Iterator i = env.entrySet().iterator(); i.hasNext(); ) {
+                        Map.Entry entry = (Map.Entry) i.next();
+                        environment.put(transformName((String) entry.getKey()), entry.getValue());
+                    }
+                    return;
+                } catch (Throwable ex) {
+                    // debug(ex);
+                }
+            }
+            String[] envCommand = null;
+            switch(os) {
+            case OS_POSIX:
+                envCommand = new String[] {"sh", "-c", "env"};
+                break;
+            case OS_NT:
+                envCommand = new String[] {"cmd", "/c", "set"};
+                break;
+            case OS_DOS:
+                envCommand = new String[] {"command.com", "/c", "set"};
+                break;
+            }
+
+            if (envCommand != null) {
+                try {
+                    Process process = Runtime.getRuntime().exec(envCommand);
+                    BufferedReader in = new BufferedReader
+                        (new InputStreamReader(process.getInputStream()));
+                    String line = in.readLine();
+                    if (line.indexOf('=') <= 0) {
+                        terminateProcess(process);
+                        return;
+                    }
+                    StringBuffer sb = new StringBuffer ();
+                    String key = "";
+                    int lines = 0;
+                    while (line != null) {
+                        lines++;
+                        int idx = line.indexOf('=');
+                        if (idx < 0) {
+                            // Belongs to previous line
+                            sb.append("\n");
+                            sb.append(line);
+                        } else {
+                            environment.put(key, sb.toString());
+                            sb.setLength(0);
+                            key = transformName(line.substring(0, idx));
+                            sb.append(line.substring(idx + 1));
+                        }
+                        line = in.readLine();
+                    }
+                    environment.put(key, sb.toString());
+                    terminateProcess(process);
+                    // debug("lines: " + lines);
+                    // debug("environment: " + environment);
+                } catch (Throwable ex) {
+                    // debug(ex);
+                    os = OS_OTHER;
+                }
+            }
+        }
+
+        // }}}
+        // {{{ terminateProcess
+
+        /**
+         * Terminate a process cleanly and make sure its output and error streams are read to
+         * prevent it from blocking.
+         *
+         * @param   process The process to terminate.
+         */
+        private void terminateProcess(final Process process)
+        {
+            final byte[] buf = new byte[32768];
+            // Make sure output stream gets cleared.
+            new Thread() {
+                public void run() {
+                    try {
+                        InputStream in = process.getInputStream();
+                        while (in.read(buf) >= 0) {
+                        }
+                    } catch (Throwable ex) {
+                        // debug(ex);
+                    }
+                }
+            }.start();
+            // Make sure error stream gets cleared.
+            new Thread() {
+                public void run() {
+                    try {
+                        InputStream in = process.getErrorStream();
+                        while (in.read(buf) >= 0) {
+                        }
+                    } catch (Throwable ex) {
+                        // debug(ex);
+                    }
+                }
+            }.start();
+            process.destroy();
+        }
+
+        // }}}
+        // {{{ transformName
+
+        /**
+         * Transform the name of an envrionment variable: On Windows Systems the name is converted
+         * to upper case.
+         *
+         * @param   name    The name of the envrionment variable.
+         *
+         * @return  The transformed name.
+         */
+        private String transformName(String name)
+        {
+            return (os == OS_DOS || os == OS_NT) ? name.toUpperCase() : name;
+        }
+
+        // }}}
+    }
+    // }}}
+
+    /**
+     * Static initialization: Check system properties and environment variables for display
+     * creation hooks.
+     */
+    static {
+        try {
+            String hookClasses = System.getProperty("eclipse.swt.DisplayCreationHooks");
+            String envHooks = new Environment ().getEnv("SWT_DISPLAY_CREATION_HOOKS");
+            if (envHooks != null) {
+                hookClasses = hookClasses == null ? envHooks : (hookClasses + ":" + envHooks);
+            }
+            if (hookClasses != null) {
+                for (StringTokenizer st = new StringTokenizer(hookClasses, ":;, \t\r\n");
+                     st.hasMoreTokens(); ) {
+                    String clName = st.nextToken();
+                    try {
+                        Class cl;
+                        try {
+                            // First try to fall back to the system ClassLoader
+                            cl = ClassLoader.getSystemClassLoader().loadClass(clName);
+                        } catch (Throwable th) {
+                            // Then try the ClassLoader for this code
+                            cl = Display.class.getClassLoader().loadClass(clName);
+                        }
+                        Object o = cl.getConstructor(new Class[] {Class.class})
+                            .newInstance(new Object[] {Display.class});
+                        String buildnumber = null;
+                        try {
+                            java.io.InputStream in = Display.class.getResourceAsStream
+                                ("/org/eclipse/swt/widgets/qfsbuild.properties");
+                            Properties build = new Properties ();
+                            build.load(in);
+                            buildnumber = build.getProperty("buildnumber");
+                        } catch (Throwable th) {
+                            if (logger.level >= Log.WRN) {
+                                logger.log(Log.WRN, "run()", th);
+                            }
+                        }
+                        System.out.println("SWT " + SWT.getVersion() + " build qftest." +
+                                           (buildnumber == null ? "?" : buildnumber));
+                    } catch (Throwable th) {
+                        if (logger.level >= Log.WRN) {
+                            logger.log(Log.WRN, "run()", th);
+                        }
+                        System.err.println("Could not load class " + clName);
+                    }
+                }
+            }
+        } catch (Throwable th) {
+            th.printStackTrace();
+        }
+    }
+// </QFS>
+
 	/**
 	 * the handle to the OS message queue
 	 * (Warning: This field is platform dependent)
@@ -106,7 +1525,7 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public MSG msg = new MSG ();
@@ -113,7 +1532,7 @@
 
 	static String APP_NAME = "SWT"; //$NON-NLS-1$
 	static String APP_VERSION = ""; //$NON-NLS-1$
-	
+
 	/* Windows and Events */
 	Event [] eventQueue;
 	Callback windowCallback;
@@ -143,7 +1562,7 @@
 			SWT_OBJECT_INDEX = 0;
 		}
 	}
-	
+
 	/* Startup info */
 	static STARTUPINFO lpStartupInfo;
 	static {
@@ -153,7 +1572,7 @@
 			OS.GetStartupInfo (lpStartupInfo);
 		}
 	}
-	
+
 	/* XP Themes */
 	long /*int*/ hButtonTheme, hEditTheme, hExplorerBarTheme, hScrollBarTheme, hTabTheme;
 	static final char [] BUTTON = new char [] {'B', 'U', 'T', 'T', 'O', 'N', 0};
@@ -164,35 +1583,35 @@
 	static final char [] LISTVIEW = new char [] {'L', 'I', 'S', 'T', 'V', 'I', 'E', 'W', 0};
 	static final char [] TAB = new char [] {'T', 'A', 'B', 0};
 	static final char [] TREEVIEW = new char [] {'T', 'R', 'E', 'E', 'V', 'I', 'E', 'W', 0};
-	
+
 	/* Focus */
 	int focusEvent;
 	Control focusControl;
 	boolean fixFocus;
-	
+
 	/* Menus */
 	Menu [] bars, popups;
 	MenuItem [] items;
-	
+
 	/*
 	* The start value for WM_COMMAND id's.
 	* Windows reserves the values 0..100.
-	* 
+	*
 	* The SmartPhone SWT resource file reserves
 	* the values 101..107.
 	*/
 	static final int ID_START = 108;
-	
+
 	/* Filter Hook */
 	Callback msgFilterCallback;
 	long /*int*/ msgFilterProc, filterHook;
 	MSG hookMsg = new MSG ();
 	boolean runDragDrop = true, dragCancelled = false;
-	
+
 	/* Idle Hook */
 	Callback foregroundIdleCallback;
 	long /*int*/ foregroundIdleProc, idleHook;
-	
+
 	/* Message Hook and Embedding */
 	boolean ignoreNextKey;
 	Callback getMsgCallback, embeddedCallback;
@@ -211,7 +1630,7 @@
 
 	/* Display Shutdown */
 	Runnable [] disposeList;
-	
+
 	/* Deferred Layout list */
 	Composite[] layoutDeferred;
 	int layoutDeferredCount;
@@ -219,33 +1638,35 @@
 	/* System Tray */
 	Tray tray;
 	int nextTrayId;
-	
+
 	/* TaskBar */
 	TaskBar taskBar;
 	static final String TASKBAR_EVENT = "/SWTINTERNAL_ID"; //$NON-NLS-1$
 	static final String LAUNCHER_PREFIX = "--launcher.openFile "; //$NON-NLS-1$
-	
+
 	/* Timers */
 	long /*int*/ [] timerIds;
 	Runnable [] timerList;
 	long /*int*/ nextTimerId = SETTINGS_ID + 1;
-	
+
 	/* Settings */
 	static final long /*int*/ SETTINGS_ID = 100;
 	static final int SETTINGS_DELAY = 2000;
 	boolean lastHighContrast, sendSettings;
-	
+
 	/* Keyboard and Mouse */
 	RECT clickRect;
 	int clickCount, lastTime, lastButton;
 	long /*int*/ lastClickHwnd;
 	int scrollRemainder, scrollHRemainder;
-	int lastKey, lastMouse, lastAscii;
-	boolean lastVirtual, lastNull, lastDead;
+        // <QFS/> public - TODO provide get-functions instead
+	public int lastKey, lastMouse, lastAscii;
+        // <QFS/> public - TODO provide get-functions instead
+	public boolean lastVirtual, lastNull, lastDead;
 	byte [] keyboard = new byte [256];
 	boolean accelKeyHit, mnemonicKeyHit;
 	boolean lockActiveWindow, captureChanged, xMouse;
-	
+
 	/* Gesture state */
 	double magStartDistance, lastDistance;
 	double rotationAngle;
@@ -256,16 +1677,16 @@
 	
 	/* Tool Tips */
 	int nextToolTipId;
-	
+
 	/* MDI */
 	boolean ignoreRestoreFocus;
 	Control lastHittestControl;
 	int lastHittest;
-	
+
 	/* Message Only Window */
 	Callback messageCallback;
 	long /*int*/ hwndMessage, messageProc;
-	
+
 	/* System Resources */
 	LOGFONT lfSystemFont;
 	Font systemFont;
@@ -274,7 +1695,7 @@
 	Resource [] resources;
 	static final int RESOURCE_SIZE = 1 + 4 + SWT.CURSOR_HAND + 1;
 
-	/* ImageList Cache */	
+	/* ImageList Cache */
 	ImageList[] imageList, toolImageList, toolHotImageList, toolDisabledImageList;
 
 	/* Custom Colors for ChooseColor */
@@ -282,7 +1703,7 @@
 
 	/* Sort Indicators */
 	Image upArrow, downArrow;
-	
+
 	/* Table */
 	char [] tableBuffer;
 	NMHDR hdr = new NMHDR ();
@@ -290,19 +1711,19 @@
 	long /*int*/ hwndParent;
 	int columnCount;
 	boolean [] columnVisible;
-	
+
 	/* Resize and move recursion */
 	int resizeCount;
 	static final int RESIZE_LIMIT = 4;
-	
+
 	/* Display Data */
 	Object data;
 	String [] keys;
 	Object [] values;
-	
+
 	/* Key Mappings */
 	static final int [] [] KeyTable = {
-		
+
 		/* Keyboard and Mouse Masks */
 		{OS.VK_MENU,	SWT.ALT},
 		{OS.VK_SHIFT,	SWT.SHIFT},
@@ -309,11 +1730,11 @@
 		{OS.VK_CONTROL,	SWT.CONTROL},
 //		{OS.VK_????,	SWT.COMMAND},
 
-		/* NOT CURRENTLY USED */		
+		/* NOT CURRENTLY USED */
 //		{OS.VK_LBUTTON, SWT.BUTTON1},
 //		{OS.VK_MBUTTON, SWT.BUTTON3},
 //		{OS.VK_RBUTTON, SWT.BUTTON2},
-		
+
 		/* Non-Numeric Keypad Keys */
 		{OS.VK_UP,		SWT.ARROW_UP},
 		{OS.VK_DOWN,	SWT.ARROW_DOWN},
@@ -332,7 +1753,7 @@
 		{OS.VK_ESCAPE,	SWT.ESC},
 		{OS.VK_RETURN,	SWT.LF},
 		{OS.VK_TAB,		SWT.TAB},
-	
+
 		/* Functions Keys */
 		{OS.VK_F1,	SWT.F1},
 		{OS.VK_F2,	SWT.F2},
@@ -354,7 +1775,7 @@
 		{OS.VK_F18,	SWT.F18},
 		{OS.VK_F19,	SWT.F19},
 		{OS.VK_F20,	SWT.F20},
-		
+
 		/* Numeric Keypad Keys */
 		{OS.VK_MULTIPLY,	SWT.KEYPAD_MULTIPLY},
 		{OS.VK_ADD,			SWT.KEYPAD_ADD},
@@ -382,7 +1803,7 @@
 		{OS.VK_CANCEL,		SWT.BREAK},
 		{OS.VK_SNAPSHOT,	SWT.PRINT_SCREEN},
 //		{OS.VK_????,		SWT.HELP},
-		
+
 	};
 
 	/* Multiple Displays */
@@ -392,7 +1813,7 @@
 	/* Multiple Monitors */
 	Monitor[] monitors = null;
 	int monitorCount = 0;
-	
+
 	/* Modality */
 	Shell [] modalShells;
 	Dialog modalDialog;
@@ -411,14 +1832,14 @@
 	static int SWT_RESTORECARET;
 	static int DI_GETDRAGIMAGE;
 	static int SWT_OPENDOC;
-	
+
 	/* Workaround for Adobe Reader 7.0 */
 	int hitCount;
-	
+
 	/* Skinning support */
 	Widget [] skinList = new Widget [GROW_SIZE];
 	int skinCount;
-	
+
 	/* Package Name */
 	static final String PACKAGE_PREFIX = "org.eclipse.swt.widgets."; //$NON-NLS-1$
 	/*
@@ -448,7 +1869,7 @@
 				setDevice (device);
 			}
 		};
-	}	
+	}
 
 /*
 * TEMPORARY CODE.
@@ -456,12 +1877,12 @@
 static void setDevice (Device device) {
 	CurrentDevice = device;
 }
-	
+
 /**
  * Constructs a new instance of this class.
  * <p>
  * Note: The resulting display is marked as the <em>current</em>
- * display. If this is the first display which has been 
+ * display. If this is the first display which has been
  * constructed since the application started, it is also
  * marked as the <em>default</em> display.
  * </p>
@@ -482,11 +1903,14 @@
 
 /**
  * Constructs a new instance of this class using the parameter.
- * 
+ *
  * @param data the device data
  */
 public Display (DeviceData data) {
 	super (data);
+        // <QFS> Execute display creation hooks
+        runDisplayCreationHooks(this);
+        // </QFS>
 }
 
 Control _getFocusControl () {
@@ -562,7 +1986,7 @@
  * powerful and dangerous. They should generally be avoided for
  * performance, debugging and code maintenance reasons.
  * </p>
- * 
+ *
  * @param eventType the type of event to listen for
  * @param listener the listener which should be notified when the event occurs
  *
@@ -578,8 +2002,8 @@
  * @see SWT
  * @see #removeFilter
  * @see #removeListener
- * 
- * @since 3.0 
+ *
+ * @since 3.0
  */
 public void addFilter (int eventType, Listener listener) {
 	checkDevice ();
@@ -619,8 +2043,8 @@
  * @see Listener
  * @see SWT
  * @see #removeListener
- * 
- * @since 2.0 
+ *
+ * @since 2.0
  */
 public void addListener (int eventType, Listener listener) {
 	checkDevice ();
@@ -646,6 +2070,13 @@
 }
 
 void addPopup (Menu menu) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("addPopup(Menu)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("menu: ").add(menu)).log(Log.MTD);
+    }
+    // </QFS>
 	if (popups == null) popups = new Menu [4];
 	int length = popups.length;
 	for (int i=0; i<length; i++) {
@@ -664,13 +2095,14 @@
 	popups [index] = menu;
 }
 
-int asciiKey (int key) {
+// <QFS/> made public
+public int asciiKey (int key) {
 	if (OS.IsWinCE) return 0;
-	
+
 	/* Get the current keyboard. */
 	for (int i=0; i<keyboard.length; i++) keyboard [i] = 0;
 	if (!OS.GetKeyboardState (keyboard)) return 0;
-		
+
 	/* Translate the key to ASCII or UNICODE using the virtual keyboard */
 	if (OS.IsUnicode) {
 		char [] result = new char [1];
@@ -684,13 +2116,13 @@
 
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
- * reasonable opportunity. The caller of this method continues 
+ * be invoked by the user-interface thread at the next
+ * reasonable opportunity. The caller of this method continues
  * to run in parallel, and is not notified when the
  * runnable has completed.  Specifying <code>null</code> as the
  * runnable simply wakes the user-interface thread when run.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
@@ -701,13 +2133,14 @@
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see #syncExec
  */
 public void asyncExec (Runnable runnable) {
 	synchronized (Device.class) {
 		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		synchronizer.asyncExec (runnable);
+                // <QFS/> Redirected to internalAsyncExec.
+                synchronizer.internalAsyncExec (runnable);
 	}
 }
 
@@ -714,7 +2147,7 @@
 /**
  * Causes the system hardware to emit a short sound
  * (if it supports this capability).
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
@@ -755,10 +2188,10 @@
 		* error happens seems to fix the problem.  The
 		* fix is to use operating system calls to verify
 		* that the current thread is not the Display thread.
-		* 
+		*
 		* NOTE: Despite the fact that Thread.currentThread()
 		* is used in other places, the failure has not been
-		* observed in all places where it is called. 
+		* observed in all places where it is called.
 		*/
 		if (threadId != OS.GetCurrentThreadId ()) {
 			error (SWT.ERROR_THREAD_INVALID_ACCESS);
@@ -794,7 +2227,8 @@
 	for (int i=0; i<shells.length; i++) shells [i].updateModal ();
 }
 
-int controlKey (int key) {
+// <QFS/> made public
+public int controlKey (int key) {
 	int upper = (int)/*64*/OS.CharUpper ((short) key);
 	if (64 <= upper && upper <= 95) return upper & 0xBF;
 	return key;
@@ -810,7 +2244,7 @@
  * </ul>
  *
  * @see Device#dispose
- * 
+ *
  * @since 2.0
  */
 public void close () {
@@ -1193,7 +2627,7 @@
  * is ignored.
  *
  * @param runnable code to run at dispose time.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
@@ -1263,17 +2697,31 @@
 	return false;
 }
 
-boolean filters (int eventType) {
+// <QFS/> make public
+public boolean filters (int eventType) {
 	if (filterTable == null) return false;
 	return filterTable.hooks (eventType);
 }
 
 boolean filterMessage (MSG msg) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("filterMessage(MSG)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(OS.getWinMsgType(msg.message, null))).log(Log.MTD);
+    }
+    // </QFS>
 	int message = msg.message;
 	if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {
 		Control control = findControl (msg.hwnd);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("filterMessage(MSG)")
+                        .add("control: ").add(control).log(Log.DBG);
+                }
+                // </QFS>
 		if (control != null) {
-			if (translateAccelerator (msg, control) || translateMnemonic (msg, control) || translateTraversal (msg, control)) {	
+			if (translateAccelerator (msg, control) || translateMnemonic (msg, control) || translateTraversal (msg, control)) {
 				lastAscii = lastKey = 0;
 				lastVirtual = lastNull = lastDead = false;
 				return true;
@@ -1312,7 +2760,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public Widget findWidget (long /*int*/ handle) {
@@ -1339,9 +2787,9 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
- * 
+ *
  * @since 3.1
  */
 public Widget findWidget (long /*int*/ handle, long /*int*/ id) {
@@ -1365,7 +2813,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public Widget findWidget (Widget widget, long /*int*/ id) {
@@ -1392,7 +2840,7 @@
 			* when a message is posted to the queue from a foreground idle
 			* hook.  The fix is to detect that there are outstanding input
 			* events and avoid posting the wake event.
-			* 
+			*
 			* Note that PeekMessage() changes the state of events on the
 			* queue to no longer be considered new. If we peek for input
 			* events and posted messages (PM_QS_INPUT | PM_QS_POSTMESSAGE),
@@ -1413,7 +2861,7 @@
  * user-interface thread for, or null if the given thread
  * is not a user-interface thread for any display.  Specifying
  * <code>null</code> as the thread will return <code>null</code>
- * for the display. 
+ * for the display.
  *
  * @param thread the user-interface thread
  * @return the display for the given thread
@@ -1505,7 +2953,7 @@
 		return new Rectangle (0, 0, width, height);
 	}
 	int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 	int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 	int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 	return new Rectangle (x, y, width, height);
@@ -1554,7 +3002,7 @@
 /**
  * Returns a rectangle which describes the area of the
  * receiver which is capable of displaying data.
- * 
+ *
  * @return the client area
  *
  * @exception SWTException <ul>
@@ -1574,13 +3022,14 @@
 		return new Rectangle (rect.left, rect.top, width, height);
 	}
 	int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 	int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 	int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 	return new Rectangle (x, y, width, height);
 }
 
-Control getControl (long /*int*/ handle) {
+// <QFS/> made public
+public Control getControl (long /*int*/ handle) {
 	if (handle == 0) return null;
 	if (lastControl != null && lastHwnd == handle) {
 		return lastControl;
@@ -1628,7 +3077,8 @@
 public Control getCursorControl () {
 	checkDevice ();
 	POINT pt = new POINT ();
-	if (!OS.GetCursorPos (pt)) return null;
+        // <QFS/> Get overridden cursor position
+	if (!OS._GetCursorPos (pt)) return null;
 	return findControl (OS.WindowFromPoint (pt));
 }
 
@@ -1646,8 +3096,15 @@
 public Point getCursorLocation () {
 	checkDevice ();
 	POINT pt = new POINT ();
-	OS.GetCursorPos (pt);
-	return new Point (pt.x, pt.y);
+        // <QFS/> Get overridden cursor position
+        OS._GetCursorPos (pt);
+        // <QFS> Log result
+        Point ret = new Point (pt.x, pt.y);
+        if (logger.level >= Log.DBG) {
+            logger.build("getCursorLocation()").add("ret: ").add(ret).log(Log.DBG);
+        }
+        return ret;
+        // </QFS>
 }
 
 /**
@@ -1659,7 +3116,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public Point [] getCursorSizes () {
@@ -1739,7 +3196,7 @@
  * Returns the application defined, display specific data
  * associated with the receiver, or null if it has not been
  * set. The <em>display specific data</em> is a single,
- * unnamed field that is stored with every display. 
+ * unnamed field that is stored with every display.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the display specific data needs to
@@ -1777,7 +3234,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public int getDismissalAlignment () {
@@ -1855,7 +3312,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public boolean getHighContrast () {
@@ -1877,7 +3334,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Device#getDepth
  */
 public int getIconDepth () {
@@ -1894,7 +3351,7 @@
 	if (result != 0) return 4;
 	int depth = 4;
 	int [] lpcbData = new int [1];
-	
+
 	/* Use the character encoding for the default locale */
 	TCHAR buffer2 = new TCHAR (0, "Shell Icon BPP", true); //$NON-NLS-1$
 	result = OS.RegQueryValueEx (phkResult [0], buffer2, 0, null, (TCHAR) null, lpcbData);
@@ -1920,9 +3377,9 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Decorations#setImages(Image[])
- * 
+ *
  * @since 3.0
  */
 public Point [] getIconSizes () {
@@ -1930,14 +3387,14 @@
 	return new Point [] {
 		new Point (OS.GetSystemMetrics (OS.SM_CXSMICON), OS.GetSystemMetrics (OS.SM_CYSMICON)),
 		new Point (OS.GetSystemMetrics (OS.SM_CXICON), OS.GetSystemMetrics (OS.SM_CYICON)),
-	};	
+	};
 }
 
 ImageList getImageList (int style, int width, int height) {
 	if (imageList == null) imageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = imageList.length; 
+	int length = imageList.length;
 	while (i < length) {
 		ImageList list = imageList [i];
 		if (list == null) break;
@@ -1950,13 +3407,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (imageList, 0, newList, 0, length);
 		imageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	imageList [i] = list;
 	list.addRef();
@@ -1965,9 +3422,9 @@
 
 ImageList getImageListToolBar (int style, int width, int height) {
 	if (toolImageList == null) toolImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolImageList.length; 
+	int length = toolImageList.length;
 	while (i < length) {
 		ImageList list = toolImageList [i];
 		if (list == null) break;
@@ -1980,13 +3437,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolImageList, 0, newList, 0, length);
 		toolImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolImageList [i] = list;
 	list.addRef();
@@ -1995,9 +3452,9 @@
 
 ImageList getImageListToolBarDisabled (int style, int width, int height) {
 	if (toolDisabledImageList == null) toolDisabledImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolDisabledImageList.length; 
+	int length = toolDisabledImageList.length;
 	while (i < length) {
 		ImageList list = toolDisabledImageList [i];
 		if (list == null) break;
@@ -2010,13 +3467,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolDisabledImageList, 0, newList, 0, length);
 		toolDisabledImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolDisabledImageList [i] = list;
 	list.addRef();
@@ -2025,9 +3482,9 @@
 
 ImageList getImageListToolBarHot (int style, int width, int height) {
 	if (toolHotImageList == null) toolHotImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolHotImageList.length; 
+	int length = toolHotImageList.length;
 	while (i < length) {
 		ImageList list = toolHotImageList [i];
 		if (list == null) break;
@@ -2040,13 +3497,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolHotImageList, 0, newList, 0, length);
 		toolHotImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolHotImageList [i] = list;
 	list.addRef();
@@ -2053,7 +3510,8 @@
 	return list;
 }
 
-int getLastEventTime () {
+// <QFS/> made public
+public int getLastEventTime () {
 	return OS.IsWinCE ? OS.GetTickCount () : OS.GetMessageTime ();
 }
 
@@ -2085,9 +3543,9 @@
 
 /**
  * Returns an array of monitors attached to the device.
- * 
+ *
  * @return the array of monitors
- * 
+ *
  * @since 3.0
  */
 public Monitor [] getMonitors () {
@@ -2160,9 +3618,9 @@
 
 /**
  * Returns the primary monitor for that device.
- * 
+ *
  * @return the primary monitor
- * 
+ *
  * @since 3.0
  */
 public Monitor getPrimaryMonitor () {
@@ -2196,11 +3654,11 @@
 		if ((lpmi.dwFlags & OS.MONITORINFOF_PRIMARY) != 0) {
 			result = monitor;
 			break;
-		} 			
+		}
 	}
 	monitors = null;
 	monitorCount = 0;
-	return result;		
+	return result;
 }
 
 /**
@@ -2232,7 +3690,7 @@
 					System.arraycopy (result, 0, newResult, 0, index);
 					result = newResult;
 				}
-				result [index++] = (Shell) control;	
+				result [index++] = (Shell) control;
 			}
 		}
 	}
@@ -2294,12 +3752,12 @@
  * Gets the synchronizer used by the display.
  *
  * @return the receiver's synchronizer
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public Synchronizer getSynchronizer () {
@@ -2317,7 +3775,7 @@
  * </p>
  *
  * @return the receiver's sync-interface thread
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2367,13 +3825,13 @@
 		case SWT.COLOR_INFO_BACKGROUND:		pixel = OS.GetSysColor (OS.COLOR_INFOBK);		break;
 		case SWT.COLOR_TITLE_FOREGROUND: 		pixel = OS.GetSysColor (OS.COLOR_CAPTIONTEXT);	break;
 		case SWT.COLOR_TITLE_BACKGROUND:		pixel = OS.GetSysColor (OS.COLOR_ACTIVECAPTION);		break;
-		case SWT.COLOR_TITLE_BACKGROUND_GRADIENT: 
+		case SWT.COLOR_TITLE_BACKGROUND_GRADIENT:
 			pixel = OS.GetSysColor (OS.COLOR_GRADIENTACTIVECAPTION);
 			if (pixel == 0) pixel = OS.GetSysColor (OS.COLOR_ACTIVECAPTION);
 			break;
 		case SWT.COLOR_TITLE_INACTIVE_FOREGROUND: 		pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTIONTEXT);	break;
 		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND:			pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTION);		break;
-		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT:	
+		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT:
 			pixel = OS.GetSysColor (OS.COLOR_GRADIENTINACTIVECAPTION);
 			if (pixel == 0) pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTION);
 			break;
@@ -2390,7 +3848,7 @@
  * not be free'd because it was allocated by the system,
  * not the application.  A value of <code>null</code> will
  * be returned if the supplied constant is not an SWT cursor
- * constant. 
+ * constant.
  *
  * @param id the SWT cursor constant
  * @return the corresponding cursor or <code>null</code>
@@ -2422,7 +3880,7 @@
  * @see SWT#CURSOR_IBEAM
  * @see SWT#CURSOR_NO
  * @see SWT#CURSOR_HAND
- * 
+ *
  * @since 3.0
  */
 public Cursor getSystemCursor (int id) {
@@ -2481,7 +3939,7 @@
  * not the application.  A value of <code>null</code> will
  * be returned either if the supplied constant is not an
  * SWT icon constant or if the platform does not define an
- * image that corresponds to the constant. 
+ * image that corresponds to the constant.
  *
  * @param id the SWT icon constant
  * @return the corresponding image or <code>null</code>
@@ -2496,7 +3954,7 @@
  * @see SWT#ICON_QUESTION
  * @see SWT#ICON_WARNING
  * @see SWT#ICON_WORKING
- * 
+ *
  * @since 3.0
  */
 public Image getSystemImage (int id) {
@@ -2550,7 +4008,7 @@
  * when there is no system taskBar available for the platform.
  *
  * @return the system taskBar or <code>null</code>
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2571,7 +4029,7 @@
  * when there is no system tray available for the platform.
  *
  * @return the system tray or <code>null</code>
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2589,7 +4047,7 @@
  * Returns the user-interface thread for the receiver.
  *
  * @return the receiver's user-interface thread
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2645,7 +4103,7 @@
 	return hTabTheme = OS.OpenThemeData (hwndMessage, TAB);
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to allocate a new GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -2655,9 +4113,9 @@
  * application code.
  * </p>
  *
- * @param data the platform specific GC data 
+ * @param data the platform specific GC data
  * @return the platform specific GC handle
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2664,7 +4122,7 @@
  * @exception SWTError <ul>
  *    <li>ERROR_NO_HANDLES if a handle could not be obtained for gc creation</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public long /*int*/ internal_new_GC (GCData data) {
@@ -2690,12 +4148,12 @@
  * <p>
  * This method is called after <code>create</code>.
  * </p>
- * 
+ *
  * @see #create
  */
 protected void init () {
 	super.init ();
-	
+
 	/* Set the application user model ID */
 	char [] appName = null;
 	if (APP_NAME != null) {
@@ -2706,21 +4164,21 @@
 			OS.SetCurrentProcessExplicitAppUserModelID (appName);
 		}
 	}
-	
+
 	/* Create the callbacks */
 	windowCallback = new Callback (this, "windowProc", 4); //$NON-NLS-1$
 	windowProc = windowCallback.getAddress ();
 	if (windowProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
-	
+
 	/* Remember the current thread id */
 	threadId = OS.GetCurrentThreadId ();
-	
+
 	/* Use the character encoding for the default locale */
 	windowClass = new TCHAR (0, WindowName + WindowClassCount, true);
 	windowShadowClass = new TCHAR (0, WindowShadowName + WindowClassCount, true);
 	windowOwnDCClass = new TCHAR (0, WindowOwnDCName + WindowClassCount, true);
 	WindowClassCount++;
-	
+
 	/* Register the SWT window class */
 	long /*int*/ hHeap = OS.GetProcessHeap ();
 	long /*int*/ hInstance = OS.GetModuleHandle (null);
@@ -2762,7 +4220,7 @@
 	OS.MoveMemory (lpWndClass.lpszClassName, windowShadowClass, byteCount);
 	OS.RegisterClass (lpWndClass);
 	OS.HeapFree (hHeap, 0, lpWndClass.lpszClassName);
-	
+
 	/* Register the CS_OWNDC window class */
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (5, 1)) {
 		lpWndClass.style |= OS.CS_OWNDC;
@@ -2772,7 +4230,7 @@
 	OS.MoveMemory (lpWndClass.lpszClassName, windowOwnDCClass, byteCount);
 	OS.RegisterClass (lpWndClass);
 	OS.HeapFree (hHeap, 0, lpWndClass.lpszClassName);
-	
+
 	/* Create the message only HWND */
 	hwndMessage = OS.CreateWindowEx (0,
 		windowClass,
@@ -2797,7 +4255,7 @@
 		if (msgFilterProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
 		filterHook = OS.SetWindowsHookEx (OS.WH_MSGFILTER, msgFilterProc, 0, threadId);
 	}
-	
+
 	/* Create the idle hook */
 	if (!OS.IsWinCE) {
 		foregroundIdleCallback = new Callback (this, "foregroundIdleProc", 3); //$NON-NLS-1$
@@ -2805,7 +4263,7 @@
 		if (foregroundIdleProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
 		idleHook = OS.SetWindowsHookEx (OS.WH_FOREGROUNDIDLE, foregroundIdleProc, 0, threadId);
 	}
-	
+
 	/* Register window messages */
 	TASKBARCREATED = OS.RegisterWindowMessage (new TCHAR (0, "TaskbarCreated", true)); //$NON-NLS-1$
 	TASKBARBUTTONCREATED = OS.RegisterWindowMessage (new TCHAR (0, "TaskbarButtonCreated", true)); //$NON-NLS-1$
@@ -2815,7 +4273,7 @@
 
 	/* Initialize OLE */
 	if (!OS.IsWinCE) OS.OleInitialize (0);
-	
+
 	if (appName != null) {
 		/* Delete any old jump list set for the ID */
 		long /*int*/ [] ppv = new long /*int*/ [1];
@@ -2832,18 +4290,18 @@
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)){
 		OS.BufferedPaintInit ();
 	}
-	
+
 	/* Initialize the Widget Table */
 	indexTable = new int [GROW_SIZE];
 	controlTable = new Control [GROW_SIZE];
 	for (int i=0; i<GROW_SIZE-1; i++) indexTable [i] = i + 1;
 	indexTable [GROW_SIZE - 1] = -1;
-	
+
 	/* Remember the last high contrast state */
 	lastHighContrast = getHighContrast ();
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to dispose a GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -2854,8 +4312,8 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data 
- * 
+ * @param data the platform specific GC data
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public void internal_dispose_GC (long /*int*/ hDC, GCData data) {
@@ -2893,7 +4351,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2903,26 +4361,26 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
- * @param point to be mapped 
- * @return point with mapped coordinates 
- * 
+ * @param point to be mapped
+ * @return point with mapped coordinates
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the point is null</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Point map (Control from, Control to, Point point) {
 	checkDevice ();
-	if (point == null) error (SWT.ERROR_NULL_ARGUMENT);	
+	if (point == null) error (SWT.ERROR_NULL_ARGUMENT);
 	return map (from, to, point.x, point.y);
 }
 
@@ -2935,7 +4393,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2945,21 +4403,21 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param x coordinates to be mapped
  * @param y coordinates to be mapped
  * @return point with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Point map (Control from, Control to, int x, int y) {
@@ -2985,7 +4443,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2995,26 +4453,26 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param rectangle to be mapped
  * @return rectangle with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the rectangle is null</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Rectangle map (Control from, Control to, Rectangle rectangle) {
 	checkDevice ();
-	if (rectangle == null) error (SWT.ERROR_NULL_ARGUMENT);	
+	if (rectangle == null) error (SWT.ERROR_NULL_ARGUMENT);
 	return map (from, to, rectangle.x, rectangle.y, rectangle.width, rectangle.height);
 }
 
@@ -3027,7 +4485,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -3037,7 +4495,7 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param x coordinates to be mapped
@@ -3045,15 +4503,15 @@
  * @param width coordinates to be mapped
  * @param height coordinates to be mapped
  * @return rectangle with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Rectangle map (Control from, Control to, int x, int y, int width, int height) {
@@ -3060,7 +4518,7 @@
 	checkDevice ();
 	if (from != null && from.isDisposed()) error (SWT.ERROR_INVALID_ARGUMENT);
 	if (to != null && to.isDisposed()) error (SWT.ERROR_INVALID_ARGUMENT);
-	if (from == to) return new Rectangle (x, y, width, height); 
+	if (from == to) return new Rectangle (x, y, width, height);
 	long /*int*/ hwndFrom = from != null ? from.handle : 0;
 	long /*int*/ hwndTo = to != null ? to.handle : 0;
 	RECT rect = new RECT ();
@@ -3080,7 +4538,8 @@
  * @param ch the MBCS character
  * @return the WCS character
  */
-static char mbcsToWcs (int ch) {
+// <QFS/> made public
+public static char mbcsToWcs (int ch) {
 	return mbcsToWcs (ch, 0);
 }
 
@@ -3114,6 +4573,16 @@
 }
 
 long /*int*/ messageProc (long /*int*/ hwnd, long /*int*/ msg, long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("messageProc(long,long,long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").addHex(hwnd)
+         .add(", msg: ").add(OS.getWinMsgType(msg, null))
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	switch ((int)/*64*/msg) {
 		case SWT_RUNASYNC: {
 			if (runMessagesInIdle) runAsyncMessages (false);
@@ -3124,6 +4593,12 @@
 			MSG keyMsg = new MSG ();
 			OS.MoveMemory (keyMsg, lParam, MSG.sizeof);
 			Control control = findControl (keyMsg.hwnd);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("messageProc(long,long,long,long)")
+                                .add("control: ").add(control).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (control != null) {
 				/*
 				* Feature in Windows.  When the user types an accent key such
@@ -3148,7 +4623,7 @@
 								case OS.VK_SCROLL:
 									break;
 								default: {
-									/* 
+									/*
 									* Bug in Windows. The high bit in the result of MapVirtualKey() on
 									* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
 									* They should both be bit 32.  The fix is to test the right bit.
@@ -3161,9 +4636,10 @@
 												int value = OS.VkKeyScan (ACCENTS [i]);
 												if (value != -1 && (value & 0xFF) == keyMsg.wParam) {
 													int state = value >> 8;
-													if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
-														(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
-														(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
+                                                                                                        // <QFS/> changed to GetKeyState
+													if ((GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
+														(GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
+														(GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
 															if ((state & 0x7) != 0) accentKey = true;
 															break;
 													}
@@ -3184,7 +4660,7 @@
 					do {
 						if (!(consumed |= filterMessage (keyMsg))) {
 							OS.TranslateMessage (keyMsg);
-							consumed |= OS.DispatchMessage (keyMsg) == 1;	
+							consumed |= OS.DispatchMessage (keyMsg) == 1;
 						}
 					} while (OS.PeekMessage (keyMsg, keyMsg.hwnd, OS.WM_KEYFIRST, OS.WM_KEYLAST, flags));
 				}
@@ -3252,7 +4728,7 @@
 			* the mouse.  The fix is to look for WM_ACTIVATEAPP
 			* and force the enabled dialog child to the front.
 			* This is typically what the user is expecting.
-			* 
+			*
 			* NOTE: If the modal shell is disabled for any
 			* reason, it should not be brought to the front.
 			*/
@@ -3318,7 +4794,7 @@
 			}
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 				sendSettings = true;
-			} 
+			}
 			switch ((int)/*64*/wParam) {
 				case 0:
 				case 1:
@@ -3329,7 +4805,7 @@
 			}
 			/* Set the initial timer or push the time out period forward */
 			if (sendSettings) {
-				OS.SetTimer (hwndMessage, SETTINGS_ID, SETTINGS_DELAY, 0);
+					OS.SetTimer (hwndMessage, SETTINGS_ID, SETTINGS_DELAY, 0);
 			}
 			break;
 		}
@@ -3375,8 +4851,8 @@
 							item.sendSelectionEvent (SWT.Selection);
 						}
 					} else {
-						Event event = new Event();
-						event.text = filename;
+					Event event = new Event();
+					event.text = filename;
 						sendEvent(SWT.OpenDocument, event);
 					}
 					wakeThread ();
@@ -3398,7 +4874,7 @@
 		OS.DuplicateHandle(processHandle, handle, OS.GetCurrentProcess(), mapHandle, OS.DUPLICATE_SAME_ACCESS, false, OS.DUPLICATE_SAME_ACCESS);
 		OS.CloseHandle(processHandle);
 	}
-	
+
 	long /*int*/ sharedData = OS.MapViewOfFile(mapHandle[0], OS.FILE_MAP_READ, 0, 0, 0);
 	if (sharedData == 0) return null;
 	int length = OS.IsUnicode ? OS.wcslen (sharedData) : OS.strlen (sharedData);
@@ -3465,6 +4941,14 @@
 		case OS.MSGF_SIZE: {
 			if (runMessages) {
 				OS.MoveMemory (hookMsg, lParam, MSG.sizeof);
+                                // <QFS>
+                                boolean filterit = filterMessage (hookMsg); // SWT/Display
+                                logMessage("msgFilterProc(int,int,int)",
+                                           hookMsg.hwnd, hookMsg.message, hookMsg.wParam,
+                                           hookMsg.lParam,
+                                           (filterit ? "would be filtered by SWT/Display: " : ""),
+                                           logger, -1);
+                                // </QFS>
 				if (hookMsg.message == OS.WM_NULL) {
 					MSG msg = new MSG ();
 					int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;
@@ -3479,7 +4963,8 @@
 	return OS.CallNextHookEx (filterHook, (int)/*64*/code, wParam, lParam);
 }
 
-int numpadKey (int key) {
+// <QFS/> made public
+public int numpadKey (int key) {
 	switch (key) {
 		case OS.VK_NUMPAD0:	return '0';
 		case OS.VK_NUMPAD1:	return '1';
@@ -3503,7 +4988,7 @@
 
 /**
  * Generate a low level system event.
- * 
+ *
  * <code>post</code> is used to generate low level keyboard
  * and mouse events. The intent is to enable automated UI
  * testing by simulating the input from the user.  Most
@@ -3546,11 +5031,11 @@
  * <li>(in) count the number of lines or pages to scroll
  * </ul>
  * </dl>
- * 
+ *
  * @param event the event to be generated
- * 
+ *
  * @return true if the event was generated or false otherwise
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the event is null</li>
  * </ul>
@@ -3559,7 +5044,7 @@
  * </ul>
  *
  * @since 3.0
- * 
+ *
  */
 public boolean post (Event event) {
 	synchronized (Device.class) {
@@ -3634,7 +5119,7 @@
 					if (OS.WIN32_VERSION >= OS.VERSION (5, 0)) {
 						inputs.dwFlags |= OS.MOUSEEVENTF_VIRTUALDESK;
 						x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-						y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+						y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 						width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 						height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 					} else {
@@ -3688,7 +5173,7 @@
 				OS.HeapFree (hHeap, 0, pInputs);
 				return result;
 			}
-		} 
+		}
 		return false;
 	}
 }
@@ -3740,6 +5225,12 @@
  * @see #wake
  */
 public boolean readAndDispatch () {
+    // <QFS>
+    if (logger.level >= Log.DBGDETAIL) {
+        logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                   "");
+    }
+    // </QFS>
 	checkDevice ();
 	lpStartupInfo = null;
 	drawMenuBars ();
@@ -3747,10 +5238,45 @@
 	runDeferredLayouts ();
 	runPopups ();
 	if (OS.PeekMessage (msg, 0, 0, 0, OS.PM_REMOVE)) {
-		if (!filterMessage (msg)) {
+        // <QFS>
+        boolean filterit = filterMessage (msg); // SWT/Display
+        this.logMessage("readAndDispatch()",
+                        msg.hwnd, msg.message, msg.wParam, msg.lParam,
+                        (filterit ? "filtered by SWT/Display: " : ""),
+                        logger, -1);
+
+        // ??? runWin32EventFilters only if ( ! filterMessage  ) ???
+        boolean keepit = runWin32EventFilters(msg.hwnd, msg.message,
+                                              msg.wParam, msg.lParam); // filtered by qftest?
+        eventProcessedByReadAndDispatch++;
+        if (logger.level >= Log.DBG) {
+            logger.build("readAndDispatch()")
+                .add("eventProcessedByReadAndDispatch increased to ")
+                .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+        }
+        try {
+
+            if ( keepit && ! filterit ) {
+                if (logger.level >= Log.DBGDETAIL) {
+                    logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                               "now calling OS.TranslateMessage");
+                }
 			OS.TranslateMessage (msg);
+                if (logger.level >= Log.DBGDETAIL) {
+                    logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                               "now calling OS.DispatchMessage");
+                }
 			OS.DispatchMessage (msg);
 		}
+        } finally {
+            eventProcessedByReadAndDispatch--;
+            if (logger.level >= Log.DBG) {
+                logger.build("readAndDispatch()")
+                    .add("eventProcessedByReadAndDispatch decreased to ")
+                    .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+            }
+        }
+        // </QFS>
 		runDeferredEvents ();
 		return true;
 	}
@@ -3776,7 +5302,7 @@
  * Releases any internal resources back to the operating
  * system and clears all fields except the device handle.
  * <p>
- * Disposes all shells which are currently open on the display. 
+ * Disposes all shells which are currently open on the display.
  * After this method has been invoked, all related related shells
  * will answer <code>true</code> when sent the message
  * <code>isDisposed()</code>.
@@ -3792,7 +5318,7 @@
  * The handle is needed by <code>destroy</code>.
  * </p>
  * This method is called before <code>destroy</code>.
- * 
+ *
  * @see Device#dispose
  * @see #destroy
  */
@@ -3824,7 +5350,7 @@
 	if (embeddedHwnd != 0) {
 		OS.PostMessage (embeddedHwnd, SWT_DESTROY, 0, 0);
 	}
-	
+
 	/* Release XP Themes */
 	if (OS.COMCTL32_MAJOR >= 6) {
 		if (hButtonTheme != 0) OS.CloseThemeData (hButtonTheme);
@@ -3834,7 +5360,7 @@
 		if (hTabTheme != 0) OS.CloseThemeData (hTabTheme);
 		hButtonTheme = hEditTheme = hExplorerBarTheme = hScrollBarTheme = hTabTheme = 0;
 	}
-	
+
 	/* Unhook the message hook */
 	if (!OS.IsWinCE) {
 		if (msgHook != 0) OS.UnhookWindowsHookEx (msgHook);
@@ -3849,7 +5375,7 @@
 		msgFilterCallback = null;
 		msgFilterProc = 0;
 	}
-	
+
 	/* Unhook the idle hook */
 	if (!OS.IsWinCE) {
 		if (idleHook != 0) OS.UnhookWindowsHookEx (idleHook);
@@ -3858,10 +5384,10 @@
 		foregroundIdleCallback = null;
 		foregroundIdleProc = 0;
 	}
-	
+
 	/* Stop the settings timer */
 	OS.KillTimer (hwndMessage, SETTINGS_ID);
-	
+
 	/* Destroy the message only HWND */
 	if (hwndMessage != 0) OS.DestroyWindow (hwndMessage);
 	hwndMessage = 0;
@@ -3868,12 +5394,12 @@
 	messageCallback.dispose ();
 	messageCallback = null;
 	messageProc = 0;
-	
+
 	/* Unregister the SWT window class */
 	long /*int*/ hHeap = OS.GetProcessHeap ();
 	long /*int*/ hInstance = OS.GetModuleHandle (null);
 	OS.UnregisterClass (windowClass, hInstance);
-	
+
 	/* Unregister the SWT drop shadow and CS_OWNDC window class */
 	OS.UnregisterClass (windowShadowClass, hInstance);
 	OS.UnregisterClass (windowOwnDCClass, hInstance);
@@ -3881,12 +5407,12 @@
 	windowCallback.dispose ();
 	windowCallback = null;
 	windowProc = 0;
-	
+
 	/* Release the System fonts */
 	if (systemFont != null) systemFont.dispose ();
 	systemFont = null;
 	lfSystemFont = null;
-	
+
 	/* Release the System Images */
 	if (errorImage != null) errorImage.dispose ();
 	if (infoImage != null) infoImage.dispose ();
@@ -3893,12 +5419,12 @@
 	if (questionImage != null) questionImage.dispose ();
 	if (warningIcon != null) warningIcon.dispose ();
 	errorImage = infoImage = questionImage = warningIcon = null;
-	
+
 	/* Release Sort Indicators */
 	if (upArrow != null) upArrow.dispose ();
 	if (downArrow != null) downArrow.dispose ();
 	upArrow = downArrow = null;
-	
+
 	/* Release the System Cursors */
 	for (int i = 0; i < cursors.length; i++) {
 		if (cursors [i] != null) cursors [i].dispose ();
@@ -3916,7 +5442,7 @@
 	/* Release Custom Colors for ChooseColor */
 	if (lpCustColors != 0) OS.HeapFree (hHeap, 0, lpCustColors);
 	lpCustColors = 0;
-	
+
 	/* Uninitialize OLE */
 	if (!OS.IsWinCE) OS.OleUninitialize ();
 
@@ -3924,7 +5450,7 @@
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 		OS.BufferedPaintUnInit ();
 	}
-	
+
 	/* Release references */
 	thread = null;
 	msg = hookMsg = null;
@@ -3935,7 +5461,7 @@
 	keys = null;
 	values = null;
 	bars = popups = null;
-	indexTable = null; 
+	indexTable = null;
 	timerIds = null;
 	controlTable = null;
 	lastControl = lastGetControl = lastHittestControl = null;
@@ -3950,7 +5476,7 @@
 	plvfi = null;
 	monitors = null;
 	touchSources = null;
-	
+
 	/* Release handles */
 	threadId = 0;
 }
@@ -3957,7 +5483,7 @@
 
 void releaseImageList (ImageList list) {
 	int i = 0;
-	int length = imageList.length; 
+	int length = imageList.length;
 	while (i < length) {
 		if (imageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -3976,7 +5502,7 @@
 
 void releaseToolImageList (ImageList list) {
 	int i = 0;
-	int length = toolImageList.length; 
+	int length = toolImageList.length;
 	while (i < length) {
 		if (toolImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -3995,7 +5521,7 @@
 
 void releaseToolHotImageList (ImageList list) {
 	int i = 0;
-	int length = toolHotImageList.length; 
+	int length = toolHotImageList.length;
 	while (i < length) {
 		if (toolHotImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -4014,7 +5540,7 @@
 
 void releaseToolDisabledImageList (ImageList list) {
 	int i = 0;
-	int length = toolDisabledImageList.length; 
+	int length = toolDisabledImageList.length;
 	while (i < length) {
 		if (toolDisabledImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -4051,7 +5577,7 @@
  * @see SWT
  * @see #addFilter
  * @see #addListener
- * 
+ *
  * @since 3.0
  */
 public void removeFilter (int eventType, Listener listener) {
@@ -4081,8 +5607,8 @@
  * @see Listener
  * @see SWT
  * @see #addListener
- * 
- * @since 2.0 
+ *
+ * @since 2.0
  */
 public void removeListener (int eventType, Listener listener) {
 	checkDevice ();
@@ -4127,6 +5653,13 @@
 }
 
 void removePopup (Menu menu) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("removePopup(Menu)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("menu: ").add(menu)).log(Log.MTD);
+    }
+    // </QFS>
 	if (popups == null) return;
 	for (int i=0; i<popups.length; i++) {
 		if (popups [i] == menu) {
@@ -4137,6 +5670,13 @@
 }
 
 boolean runAsyncMessages (boolean all) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runAsyncMessages(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("all: ").add(all)).log(Log.MTD);
+    }
+    // </QFS>
 	return synchronizer.runAsyncMessages (all);
 }
 
@@ -4148,7 +5688,7 @@
 	* be re-enterant but need not be synchronized.
 	*/
 	while (eventQueue != null) {
-		
+
 		/* Take an event off the queue */
 		Event event = eventQueue [0];
 		if (event == null) break;
@@ -4189,24 +5729,54 @@
 			if (!comp.isDisposed()) comp.setLayoutDeferred (false);
 		}
 		return true;
-	}	
+	}
 	return false;
 }
 
 boolean runPopups () {
-	if (popups == null) return false;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runPopups()");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("popups: ").addAll(popups)).log(Log.MTD);
+    }
+    // </QFS>
+    if (popups == null) return false;
 	boolean result = false;
 	while (popups != null) {
 		Menu menu = popups [0];
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("runPopups()").add("menu: ").add(menu).log(Log.DBG);
+                }
+                // </QFS>
 		if (menu == null) break;
 		int length = popups.length;
 		System.arraycopy (popups, 1, popups, 0, --length);
 		popups [length] = null;
 		runDeferredEvents ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "runPopups()",
+                               "runDeferredEvents done");
+                }
+                // </QFS>
 		if (!menu.isDisposed ()) menu._setVisible (true);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "runPopups()",
+                               "menu._setVisible done");
+                }
+                // </QFS>
 		result = true;
 	}
 	popups = null;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "runPopups()",
+                       "all done");
+        }
+        // </QFS>
 	return result;
 }
 
@@ -4233,8 +5803,8 @@
 
 boolean runSkin () {
 	if (skinCount > 0) {
-		Widget [] oldSkinWidgets = skinList;	
-		int count = skinCount;	
+		Widget [] oldSkinWidgets = skinList;
+		int count = skinCount;
 		skinList = new Widget[GROW_SIZE];
 		skinCount = 0;
 		if (eventTable != null && eventTable.hooks(SWT.Skin)) {
@@ -4250,11 +5820,18 @@
 			}
 		}
 		return true;
-	}	
+	}
 	return false;
 }
-	
+
 boolean runTimer (long /*int*/ id) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runTimer(long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("id: ").add(id)).log(Log.MTD);
+    }
+    // </QFS>
 	if (timerList != null && timerIds != null) {
 		int index = 0;
 		while (index <timerIds.length) {
@@ -4262,6 +5839,12 @@
 				OS.KillTimer (hwndMessage, timerIds [index]);
 				timerIds [index] = 0;
 				Runnable runnable = timerList [index];
+                                // <QFS>
+                                if (logger.level >= Log.MSG) {
+                                    logger.build("runTimer(long)")
+                                        .add("runnable: ").add(runnable).log(Log.MSG);
+                                }
+                                // </QFS>
 				timerList [index] = null;
 				if (runnable != null) runnable.run ();
 				return true;
@@ -4269,6 +5852,12 @@
 			index++;
 		}
 	}
+    // <QFS>
+    if (logger.level >= Log.MSG) {
+        logger.log(Log.MSG, "runTimer(long)",
+                   "No timer for id " + id);
+    }
+    // </QFS>
 	return false;
 }
 
@@ -4347,12 +5936,12 @@
  *
  * @param x the new x coordinate for the cursor
  * @param y the new y coordinate for the cursor
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void setCursorLocation (int x, int y) {
@@ -4366,13 +5955,13 @@
  * program to move the on-screen pointer location.</b>
  *
  * @param point new position
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_NULL_ARGUMENT - if the point is null
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.0
  */
 public void setCursorLocation (Point point) {
@@ -4451,7 +6040,7 @@
 		}
 		return;
 	}
-	
+
 	/* Add the key/value pair */
 	if (keys == null) {
 		keys = new String [] {key};
@@ -4478,7 +6067,7 @@
  * Sets the application defined, display specific data
  * associated with the receiver, to the argument.
  * The <em>display specific data</em> is a single,
- * unnamed field that is stored with every display. 
+ * unnamed field that is stored with every display.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the display specific data needs to
@@ -4506,9 +6095,9 @@
  * Returns the application name.
  *
  * @return the application name
- * 
+ *
  * @see #setAppName(String)
- * 
+ *
  * @since 3.6
  */
 public static String getAppName () {
@@ -4519,9 +6108,9 @@
  * Returns the application version.
  *
  * @return the application version
- * 
+ *
  * @see #setAppVersion(String)
- * 
+ *
  * @since 3.6
  */
 public static String getAppVersion () {
@@ -4550,7 +6139,7 @@
  * Sets the application version to the argument.
  *
  * @param version the new app version
- * 
+ *
  * @since 3.6
  */
 public static void setAppVersion (String version) {
@@ -4610,9 +6199,10 @@
 	}
 }
 
-int shiftedKey (int key) {
+// <QFS/> made public
+public int shiftedKey (int key) {
 	if (OS.IsWinCE) return 0;
-	
+
 	/* Clear the virtual keyboard and press the shift key */
 	for (int i=0; i<keyboard.length; i++) keyboard [i] = 0;
 	keyboard [OS.VK_SHIFT] |= 0x80;
@@ -4654,17 +6244,17 @@
 
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
+ * be invoked by the user-interface thread at the next
  * reasonable opportunity. The thread which calls this method
  * is suspended until the runnable completes.  Specifying <code>null</code>
  * as the runnable simply wakes the user-interface thread.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
  * </p>
- * 
+ *
  * @param runnable code to run on the user-interface thread or <code>null</code>
  *
  * @exception SWTException <ul>
@@ -4680,7 +6270,8 @@
 		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
 		synchronizer = this.synchronizer;
 	}
-	synchronizer.syncExec (runnable);
+        // <QFS/> Redirected to internalSyncExec.
+        synchronizer.internalSyncExec (runnable);
 }
 
 /**
@@ -4689,7 +6280,7 @@
  * number of milliseconds have elapsed. If milliseconds is less
  * than zero, the runnable is not executed.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
@@ -4721,7 +6312,7 @@
 	long /*int*/ timerId = 0;
 	if (index != timerList.length) {
 		timerId = timerIds [index];
-		if (milliseconds < 0) {			
+		if (milliseconds < 0) {
 			OS.KillTimer (hwndMessage, timerId);
 			timerList [index] = null;
 			timerIds [index] = 0;
@@ -4758,7 +6349,8 @@
 	return result;
 }
 
-static int translateKey (int key) {
+// <QFS/> Made public.
+public static int translateKey (int key) {
 	for (int i=0; i<KeyTable.length; i++) {
 		if (KeyTable [i] [0] == key) return KeyTable [i] [1];
 	}
@@ -4775,6 +6367,14 @@
 }
 
 boolean translateTraversal (MSG msg, Control control) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("translateTraversal(MSG,Control)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(OS.getWinMsgType(msg.message, null))
+         .add(", control: ").add(control)).log(Log.MTD);
+    }
+    // </QFS>
 	switch (msg.message) {
 		case OS.WM_KEYDOWN:
 			switch ((int)/*64*/msg.wParam) {
@@ -4800,7 +6400,8 @@
 	return false;
 }
 
-static int untranslateKey (int key) {
+// <QFS/> Made public.
+public static int untranslateKey (int key) {
 	for (int i=0; i<KeyTable.length; i++) {
 		if (KeyTable [i] [1] == key) return KeyTable [i] [0];
 	}
@@ -4815,7 +6416,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Control#update()
  */
 public void update() {
@@ -4829,10 +6430,10 @@
 	* PM_REMOVE to tell Windows that the application is ready
 	* to dispatch events.  Note that the message does not have
 	* to be found or dispatched in order to wake Windows up.
-	* 
+	*
 	* NOTE: This allows other cross thread messages to be delivered,
 	* most notably WM_ACTIVATE.
-	*/	
+	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (4, 10)) {
 		if (OS.IsHungAppWindow (hwndMessage)) {
 			MSG msg = new MSG ();
@@ -4858,14 +6459,14 @@
 }
 
 /**
- * If the receiver's user-interface thread was <code>sleep</code>ing, 
+ * If the receiver's user-interface thread was <code>sleep</code>ing,
  * causes it to be awakened and start running again. Note that this
  * method may be called from any thread.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see #sleep
  */
 public void wake () {
@@ -4877,7 +6478,12 @@
 }
 
 void wakeThread () {
-	if (OS.IsWinCE) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.dumpStack(Log.MTD, "wakeThread()", "");
+    }
+    // </QFS>
+        if (OS.IsWinCE) {
 		OS.PostMessage (hwndMessage, OS.WM_NULL, 0, 0);
 	} else {
 		OS.PostThreadMessage (threadId, OS.WM_NULL, 0, 0);
@@ -4894,7 +6500,8 @@
  * @param codePage the code page used to convert the character
  * @return the MBCS character
  */
-static int wcsToMbcs (char ch, int codePage) {
+// <QFS/> made public
+public static int wcsToMbcs (char ch, int codePage) {
 	if (OS.IsUnicode) return ch;
 	if (ch <= 0x7F) return ch;
 	TCHAR buffer = new TCHAR (codePage, ch, false);
@@ -4915,6 +6522,16 @@
 }
 
 long /*int*/ windowProc (long /*int*/ hwnd, long /*int*/ msg, long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.build("windowProc(long,long,long,long)")
+            .add("hwnd: ").addHex(hwnd)
+            .add(", msg: ").add(OS.getWinMsgType(msg, null))
+            .add(", wParam: ").addHex(wParam)
+            .add(", lParam: ").addHex(lParam)
+            .log(Log.MTD);
+    }
+    // </QFS>
 	/*
 	* Feature in Windows.  On Vista only, it is faster to
 	* compute and answer the data for the visible columns
@@ -4956,7 +6573,7 @@
 	* if the control takes some time to respond to the message,
 	* Adobe stops sending them.  The fix is to detect this case
 	* and sleep.
-	* 
+	*
 	* NOTE: Under normal circumstances, Windows will never send
 	* consecutive WM_NCHITTEST messages to the same control without
 	* another message (normally WM_SETCURSOR) in between.
@@ -4968,8 +6585,45 @@
 	} else {
 		hitCount = 0;
 	}
+        // <QFS>
+        boolean keepit = true;
+        eventProcessedByReadAndDispatch--;
+        if (logger.level >= Log.DBG) {
+            logger.build("windowProc(long,long,long,long)")
+                .add("eventProcessedByReadAndDispatch decreased to ")
+                .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+        }
+        try {
+            // Run filter only if eventProcessedByReadAndDispatch was not > 0 before decrementing.
+            if (eventProcessedByReadAndDispatch < 0) {
+                keepit = runWin32EventFilters(hwnd, msg, wParam, lParam);
+            }
+            if (msg == OS.WM_MOUSEMOVE
+                || msg == OS.WM_LBUTTONDOWN
+                || msg == OS.WM_LBUTTONUP
+                || msg == OS.WM_MBUTTONDOWN
+                || msg == OS.WM_MBUTTONUP
+                || msg == OS.WM_RBUTTONDOWN
+                || msg == OS.WM_RBUTTONUP) {
+                // Save the state of the modifier keys and mouse buttons so that GetKeyState
+                // overriding works.
+                setReplayKeyStateWnd((int) wParam);
+            }
+            // </QFS>
 	if (lastControl != null && lastHwnd == hwnd) {
-		return lastControl.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                // <QFS>
+                if (keepit) {
+                // </QFS>
+                    long /*int*/ ret = lastControl.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "windowProc(long,long,long,long)",
+                                   "Control.windowProc returned "+ret
+                                   +" - this will now be returned by this Display.windowProc");
+                    }
+                    return ret;
+                }
+                // </QFS>
 	}
 	int index;
 	if (USE_PROPERTY) {
@@ -4978,14 +6632,60 @@
 		index = (int)/*64*/OS.GetWindowLongPtr (hwnd, OS.GWLP_USERDATA) - 1;
 	}
 	if (0 <= index && index < controlTable.length) {
+                if (keepit) {
 		Control control = controlTable [index];
 		if (control != null) {
 			lastHwnd = hwnd;
 			lastControl = control;
-			return control.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                        long /*int*/ ret = control.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                        // <QFS>
+                        if (logger.level >= Log.MTDDETAIL) {
+                            logger.log(Log.MTDDETAIL, "windowProc(long,long,long,long)",
+                                       "Control.windowProc returned "+ret
+                                       +" - this will now be returned by this Display.windowProc");
+                        }
+                        // Need to run async messages while modal dialogs (e.g. file dialog) are
+                        // displayed.
+                        // if (synchronizer != null) {
+                            // runAsyncMessages(false);
+                        // }
+                        // </QFS>
+                        return ret;
+                    }
+                }
+            }
+            // <QFS>
+            if ( ! keepit) {
+                // Need to run async messages while modal dialogs (e.g. file dialog) are displayed.
+                // if (synchronizer != null) {
+                    // runAsyncMessages(false);
+                // }
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "windowProc(long,long,long,long)",
+                               "keepit == false ie. return 0");
+                }
+                return 0;
+            }
+            // </QFS>
+            long /*int*/ ret = OS.DefWindowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.build("windowProc(long,long,long,long)").add("ret: ").add(ret).log(Log.DBG);
+            }
+            // Need to run async messages while modal dialogs (e.g. file dialog) are displayed.
+            // if (synchronizer != null) {
+                // runAsyncMessages(false);
+            // }
+            // </QFS>
+            return ret;
+        } finally {
+            eventProcessedByReadAndDispatch++;
+            if (logger.level >= Log.DBG) {
+                logger.build("windowProc(long,long,long,long)")
+                    .add("eventProcessedByReadAndDispatch increased to ")
+                    .add(eventProcessedByReadAndDispatch).log(Log.DBG);
 		}
 	}
-	return OS.DefWindowProc (hwnd, (int)/*64*/msg, wParam, lParam);
 }
 
 static String withCrLf (String string) {
@@ -4993,7 +6693,7 @@
 	/* If the string is empty, return the string. */
 	int length = string.length ();
 	if (length == 0) return string;
-	
+
 	/*
 	* Check for an LF or CR/LF and assume the rest of
 	* the string is formated that way.  This will not
@@ -5010,7 +6710,7 @@
 	* number of lines and the size of the buffer
 	* needed to hold the result
 	*/
-	i++;	
+	i++;
 	int count = 1;
 	while (i < length) {
 		if ((i = string.indexOf ('\n', i)) == -1) break;
Index: org/eclipse/swt/widgets/Decorations.java
===================================================================
--- org/eclipse/swt/widgets/Decorations.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Decorations.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1480,7 +1480,8 @@
 			return true;
 		}
 		if (msg.message == OS.WM_KEYDOWN) {
-			if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return false;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return false;
 			switch ((int)/*64*/(msg.wParam)) {
 				case OS.VK_F4:
 					OS.PostMessage (handle, OS.WM_CLOSE, 0, 0);
Index: org/eclipse/swt/widgets/TreeColumn.java
===================================================================
--- org/eclipse/swt/widgets/TreeColumn.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TreeColumn.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -687,7 +687,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/widgets/Spinner.java
===================================================================
--- org/eclipse/swt/widgets/Spinner.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Spinner.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -761,7 +762,8 @@
 	/*
 	* If the left button is down, the text widget refuses the character.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		return true;
 	}
 
Index: org/eclipse/swt/widgets/Scrollable.java
===================================================================
--- org/eclipse/swt/widgets/Scrollable.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Scrollable.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -15,6 +15,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * This class is the abstract superclass of all classes which
  * represent controls that have standard scroll bars.
@@ -34,6 +39,17 @@
  */
 
 public abstract class Scrollable extends Control {
+
+    // {{{ <QFS> Log
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Scrollable");
+
+    // }}} </QFS>
+
 	ScrollBar horizontalBar, verticalBar;
 
 /**
@@ -48,7 +64,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -93,7 +109,7 @@
  * rectangle described by the arguments (relative to the
  * receiver's parent).
  * </p>
- * 
+ *
  * @param x the desired x coordinate of the client area
  * @param y the desired y coordinate of the client area
  * @param width the desired width of the client area
@@ -154,7 +170,7 @@
  * Returns a rectangle which describes the area of the
  * receiver which is capable of displaying data (that is,
  * not covered by the "trimmings").
- * 
+ *
  * @return the client area
  *
  * @exception SWTException <ul>
@@ -266,9 +282,20 @@
 }
 
 LRESULT WM_HSCROLL (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_HSCROLL(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.build("WM_HSCROLL(long,long)").add("state: ").add(state).log(Log.DBG);
+    }
+    // </QFS>
 	LRESULT result = super.WM_HSCROLL (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Bug on WinCE.  lParam should be NULL when the message is not sent
 	* by a scroll bar control, but it contains the handle to the window.
@@ -295,6 +322,17 @@
 }
 
 LRESULT WM_VSCROLL (long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_VSCROLL(long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.build("WM_VSCROLL(long,long)").add("state: ").add(state).log(Log.DBG);
+    }
+    // </QFS>
 	LRESULT result = super.WM_VSCROLL (wParam, lParam);
 	if (result != null) return result;
 	/*
@@ -344,8 +382,8 @@
 					cornerRect.left = trimRect.left;
 					cornerRect.right = cornerRect.left + (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
 				} else {
-					cornerRect.right = windowRect.right - windowRect.left - trimRect.right;
-					cornerRect.left = cornerRect.right - (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
+				cornerRect.right = windowRect.right - windowRect.left - trimRect.right;
+				cornerRect.left = cornerRect.right - (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
 				}
 				if (cornerRect.left != cornerRect.right && cornerRect.top != cornerRect.bottom) {
 					long /*int*/ hDC = OS.GetWindowDC (hwnd);
@@ -452,6 +490,18 @@
 }
 
 LRESULT wmScroll (ScrollBar bar, boolean update, long /*int*/ hwnd, int msg, long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmScroll(ScrollBar,boolean,long,int,long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("bar: ").add(bar)
+         .add(", update: ").add(update)
+         .add(", hwnd: ").addHex(hwnd)
+         .add(", msg: ").add(msg)
+         .add(", wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	LRESULT result = null;
 	if (update) {
 		int type = msg == OS.WM_HSCROLL ? OS.SB_HORZ : OS.SB_VERT;
@@ -459,6 +509,13 @@
 		info.cbSize = SCROLLINFO.sizeof;
 		info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;
 		OS.GetScrollInfo (hwnd, type, info);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmScroll(ScrollBar,boolean,long,int,long,long)")
+                        .add("at method begin: info.nPos: ").add(info.nPos)
+                        .add(", info.nTrackPos: ").add(info.nTrackPos).log(Log.DBG);
+                }
+                // </QFS>
 		info.fMask = OS.SIF_POS;
 		int code = OS.LOWORD (wParam);
 		switch (code) {
@@ -465,7 +522,7 @@
 			case OS.SB_ENDSCROLL:  return null;
 			case OS.SB_THUMBPOSITION:
 			case OS.SB_THUMBTRACK:
-				/* 
+				/*
 				* Note: On WinCE, the value in SB_THUMBPOSITION is relative to nMin.
 				* Same for SB_THUMBPOSITION 'except' for the very first thumb track
 				* message which has the actual value of nMin. This is a problem when
@@ -500,6 +557,18 @@
 		result = code == 0 ? LRESULT.ZERO : new LRESULT (code);
 	}
 	bar.wmScrollChild (wParam, lParam);
+        // <QFS>
+        SCROLLINFO info = new SCROLLINFO ();
+        info.cbSize = org.eclipse.swt.internal.win32.SCROLLINFO.sizeof;
+        info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;
+        OS.GetScrollInfo (hwnd, OS.SB_HORZ, info);
+        if (logger.level >= Log.DBG) {
+            logger.build("wmScroll(ScrollBar,boolean,long,int,long,long)")
+                .add("at method end: info.nPos: ").add(info.nPos)
+                .add(", info.nTrackPos: ").add(info.nTrackPos).log(Log.DBG);
+        }
+
+        // </QFS>
 	return result;
 }
 
Index: org/eclipse/swt/widgets/Touch.java
===================================================================
--- org/eclipse/swt/widgets/Touch.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Touch.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -21,7 +21,7 @@
  * @since 3.7
  */
 public final class Touch {
-
+	
 	/**
 	 * The unique identity of the touch. Use this value to track changes to a touch
 	 * during the touch's life. Two touches may have the same identity even if they
@@ -28,12 +28,12 @@
 	 * come from different sources.
 	 */
 	public long id;
-
+	
 	/**
 	 * The object representing the input source that generated the touch.
 	 */
 	public TouchSource source;
-
+	
 	/**
 	 * The state of this touch at the time it was generated. If this field is 0
 	 * then the finger is still touching the device but has not moved
@@ -44,7 +44,7 @@
 	 * @see org.eclipse.swt.SWT#TOUCHSTATE_UP
 	 */
 	public int state;
-
+	
 	/**
 	 * A flag indicating that the touch is the first touch from a previous
 	 * state of no touch points. Once designated as such, the touch remains
Index: org/eclipse/swt/widgets/ScrollBar.java
===================================================================
--- org/eclipse/swt/widgets/ScrollBar.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ScrollBar.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -18,9 +18,9 @@
 
 /**
  * Instances of this class are selectable user interface
- * objects that represent a range of positive, numeric values. 
+ * objects that represent a range of positive, numeric values.
  * <p>
- * At any given moment, a given scroll bar will have a 
+ * At any given moment, a given scroll bar will have a
  * single 'selection' that is considered to be its
  * value, which is constrained to be within the range of
  * values the scroll bar represents (that is, between its
@@ -60,7 +60,7 @@
  * have no operating system resources and are not children of the control.
  * For this reason, scroll bars are treated specially.  To create a control
  * that looks like a scroll bar but has operating system resources, use
- * <code>Slider</code>. 
+ * <code>Slider</code>.
  * </p>
  * <dl>
  * <dt><b>Styles:</b></dt>
@@ -83,7 +83,7 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 
-public class ScrollBar extends Widget {	
+public class ScrollBar extends Widget {
 	Scrollable parent;
 	int increment, pageIncrement;
 
@@ -93,7 +93,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -231,7 +231,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -530,6 +530,9 @@
 	return (state & HIDDEN) == 0;
 }
 
+    // <QFS>
+    public
+    // </QFS>
 long /*int*/ hwndScrollBar () {
 	return parent.scrolledHandle ();
 }
@@ -546,7 +549,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -606,7 +609,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 int scrollBarType () {
@@ -649,7 +652,7 @@
 /**
  * Sets the amount that the receiver's value will be
  * modified by when the up/down (or right/left) arrows
- * are pressed to the argument, which must be at least 
+ * are pressed to the argument, which must be at least
  * one.
  *
  * @param value the new increment (must be greater than zero)
@@ -749,7 +752,7 @@
 	*/
 	boolean barVisible = false;
 	boolean visible = getVisible ();
-	
+
 	/*
 	* This line is intentionally commented.  Currently
 	* always show scrollbar as being enabled and visible.
@@ -769,7 +772,7 @@
 	}
 	if (!visible || (state & DISABLED) != 0) fRedraw = false;
 	boolean result = OS.SetScrollInfo (hwnd, flags, info, fRedraw);
-	
+
 	/*
 	* Bug in Windows.  For some reason, when the widget
 	* is a standard scroll bar, and SetScrollInfo() is
@@ -789,7 +792,7 @@
 			OS.ShowScrollBar (hwnd, !barVisible ? OS.SB_BOTH : flags, false);
 		}
 	}
-	
+
 	/*
 	* Bug in Windows.  When only one scroll bar is visible,
 	* and the thumb changes using SIF_RANGE or SIF_PAGE
@@ -797,8 +800,8 @@
 	* bar is incorrectly made visible.  The next time the
 	* parent is resized (or another scroll bar operation
 	* is performed), the opposite scroll bar draws.  The
-	* fix is to hide the opposite scroll bar again. 
-	*  
+	* fix is to hide the opposite scroll bar again.
+	*
 	* NOTE: This problem only happens on Vista
 	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -806,7 +809,7 @@
 			OS.ShowScrollBar (hwnd, flags == OS.SB_HORZ ? OS.SB_VERT : OS.SB_HORZ, false);
 		}
 	}
-		
+
 	/*
 	* Feature in Windows.  Using SIF_DISABLENOSCROLL,
 	* SetScrollInfo () can change enabled and disabled
@@ -887,7 +890,7 @@
  * value, thumb, increment and page increment all at once.
  * <p>
  * Note: This is similar to setting the values individually
- * using the appropriate methods, but may be implemented in a 
+ * using the appropriate methods, but may be implemented in a
  * more efficient fashion on some platforms.
  * </p>
  *
@@ -910,7 +913,7 @@
 	if (thumb < 1) return;
 	if (increment < 1) return;
 	if (pageIncrement < 1) return;
-	this.increment = increment;	
+	this.increment = increment;
 	this.pageIncrement = pageIncrement;
 	SCROLLINFO info = new SCROLLINFO ();
 	info.cbSize = SCROLLINFO.sizeof;
@@ -927,7 +930,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -944,7 +947,7 @@
 public void setVisible (boolean visible) {
 	checkWidget();
 	if (visible == getVisible ()) return;
-	
+
 	/*
 	* On Windows CE, use SIF_DISABLENOSCROLL to show and
 	* hide the scroll bar when the page size is equal to
@@ -961,11 +964,11 @@
 		if (info.nPage == info.nMax - info.nMin + 1) {
 			/*
 			* Bug in Windows.  When the only changed flag to
-			* SetScrollInfo () is OS.SIF_DISABLENOSCROLL, 
+			* SetScrollInfo () is OS.SIF_DISABLENOSCROLL,
 			* Windows does not update the scroll bar state.
 			* The fix is to increase and then decrease the
 			* maximum, causing Windows to honour the flag.
-			*/  
+			*/
 			int max = info.nMax;
 			info.nMax++;
 			OS.SetScrollInfo (hwnd, type, info, false);
@@ -980,7 +983,7 @@
 		}
 		return;
 	}
-	
+
 	/*
 	* Set the state bits before calling ShowScrollBar ()
 	* because hiding and showing the scroll bar can cause
Index: org/eclipse/swt/widgets/Widget.java
===================================================================
--- org/eclipse/swt/widgets/Widget.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Widget.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -17,8 +18,13 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
- * This class is the abstract superclass of all user interface objects.  
+ * This class is the abstract superclass of all user interface objects.
  * Widgets are created, disposed and issue notification to listeners
  * when events occur which affect them.
  * <dl>
@@ -46,6 +52,11 @@
  */
 
 public abstract class Widget {
+    // <QFS>
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Widget");
+    private final static Logger suppresslogger = new Logger("suppress.aus.ab.DBG");
+    // </QFS>
+
 	int style, state;
 	Display display;
 	EventTable eventTable;
@@ -57,13 +68,13 @@
 	static final int KEYED_DATA		= 1<<2;
 	static final int DISABLED		= 1<<3;
 	static final int HIDDEN			= 1<<4;
-	
+
 	/* A layout was requested on this widget */
 	static final int LAYOUT_NEEDED	= 1<<5;
-	
+
 	/* The preferred size of a child has changed */
 	static final int LAYOUT_CHANGED = 1<<6;
-	
+
 	/* A layout was requested in this widget hierarchy */
 	static final int LAYOUT_CHILD = 1<<7;
 
@@ -71,11 +82,11 @@
 	static final int THEME_BACKGROUND = 1<<8;
 	static final int DRAW_BACKGROUND = 1<<9;
 	static final int PARENT_BACKGROUND = 1<<10;
-	
+
 	/* Dispose and release flags */
 	static final int RELEASED		= 1<<11;
 	static final int DISPOSE_SENT	= 1<<12;
-	
+
 	/* More global widget state flags */
 	static final int TRACK_MOUSE	= 1<<13;
 	static final int FOREIGN_HANDLE	= 1<<14;
@@ -86,10 +97,10 @@
 	static final int MOVE_DEFERRED		= 1<<17;
 	static final int RESIZE_OCCURRED	= 1<<18;
 	static final int RESIZE_DEFERRED	= 1<<19;
-	
+
 	/* Ignore WM_CHANGEUISTATE */
 	static final int IGNORE_WM_CHANGEUISTATE = 1<<20;
-	
+
 	/* Notify of the opportunity to skin this widget */
 	static final int SKIN_NEEDED = 1<<21;
 	
@@ -108,7 +119,7 @@
 		}
 		OS.InitCommonControls ();
 	}
-	
+
 /**
  * Prevents uninitialized instances from being created outside the package.
  */
@@ -121,7 +132,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -283,14 +294,14 @@
 /**
  * Checks that this class can be subclassed.
  * <p>
- * The SWT class library is intended to be subclassed 
- * only at specific, controlled points (most notably, 
+ * The SWT class library is intended to be subclassed
+ * only at specific, controlled points (most notably,
  * <code>Composite</code> and <code>Canvas</code> when
  * implementing new widgets). This method enforces this
  * rule unless it is overridden.
  * </p><p>
  * <em>IMPORTANT:</em> By providing an implementation of this
- * method that allows a subclass of a class which does not 
+ * method that allows a subclass of a class which does not
  * normally allow subclassing to be created, the implementer
  * agrees to be fully responsible for the fact that any such
  * subclass will likely fail between SWT releases and will be
@@ -321,7 +332,7 @@
  * widget implementors to enforce the standard SWT invariants.
  * <p>
  * Currently, it is an error to invoke any method (other than
- * <code>isDisposed()</code>) on a widget that has had its 
+ * <code>isDisposed()</code>) on a widget that has had its
  * <code>dispose()</code> method called. It is also an error
  * to call widget methods from any thread that is different
  * from the thread that created the widget.
@@ -350,10 +361,10 @@
 		* error happens seems to fix the problem.  The
 		* fix is to use operating system calls to verify
 		* that the current thread is not the Display thread.
-		* 
+		*
 		* NOTE: Despite the fact that Thread.currentThread()
 		* is used in other places, the failure has not been
-		* observed in all places where it is called. 
+		* observed in all places where it is called.
 		*/
 		if (display.threadId != OS.GetCurrentThreadId ()) {
 			error (SWT.ERROR_THREAD_INVALID_ACCESS);
@@ -378,7 +389,7 @@
  * See also <code>releaseChild()</code>, <code>releaseWidget()</code>
  * and <code>releaseHandle()</code>.
  * </p>
- * 
+ *
  * @see #dispose
  */
 void destroyWidget () {
@@ -503,7 +514,7 @@
  * Returns the application defined widget data associated
  * with the receiver, or null if it has not been set. The
  * <em>widget data</em> is a single, unnamed field that is
- * stored with every widget. 
+ * stored with every widget.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the widget data needs to be notified
@@ -584,8 +595,8 @@
 }
 
 /**
- * Returns an array of listeners who will be notified when an event 
- * of the given type occurs. The event type is one of the event constants 
+ * Returns an array of listeners who will be notified when an event
+ * of the given type occurs. The event type is one of the event constants
  * defined in class <code>SWT</code>.
  *
  * @param eventType the type of event to listen for
@@ -601,7 +612,7 @@
  * @see #addListener(int, Listener)
  * @see #removeListener(int, Listener)
  * @see #notifyListeners
- * 
+ *
  * @since 3.4
  */
 public Listener[] getListeners (int eventType) {
@@ -679,7 +690,8 @@
  *
  * @see #isListening
  */
-boolean hooks (int eventType) {
+// <QFS/> made public
+public boolean hooks (int eventType) {
 	if (eventTable == null) return false;
 	return eventTable.hooks (eventType);
 }
@@ -762,7 +774,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT
  * @see #addListener
  * @see #getListeners(int)
@@ -794,9 +806,9 @@
  * this scenario, the children are actually destroyed later,
  * when the operating system destroys the widget tree.
  * </p>
- * 
+ *
  * @param destroy indicates that the receiver should be destroyed
- * 
+ *
  * @see #dispose
  * @see #releaseHandle
  * @see #releaseParent
@@ -861,7 +873,7 @@
  * bar requires that the menu bar first be released from the
  * shell when the menu bar is active.
  * </p>
- * 
+ *
  * @see #dispose
  * @see #releaseChildren
  * @see #releaseWidget
@@ -884,7 +896,7 @@
  * a reference to a disposed widget, all fields except the
  * handle are zero'd.  The handle is needed by <code>destroyWidget</code>.
  * </p>
- * 
+ *
  * @see #dispose
  * @see #releaseChildren
  * @see #releaseHandle
@@ -1058,7 +1070,8 @@
 	sendEvent (eventType, null, true);
 }
 
-void sendEvent (int eventType, Event event) {
+// <QFS/> Made public.
+public void sendEvent (int eventType, Event event) {
 	sendEvent (eventType, event, true);
 }
 
@@ -1165,7 +1178,7 @@
  * Sets the application defined widget data associated
  * with the receiver to be the argument. The <em>widget
  * data</em> is a single, unnamed field that is stored
- * with every widget. 
+ * with every widget.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the widget data needs to be notified
@@ -1180,7 +1193,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - when the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - when called from the wrong thread</li>
  * </ul>
- * 
+ *
  * @see #getData()
  */
 public void setData (Object data) {
@@ -1269,12 +1282,13 @@
 }
 
 boolean setInputState (Event event, int type) {
-	if (OS.GetKeyState (OS.VK_MENU) < 0) event.stateMask |= SWT.ALT;
-	if (OS.GetKeyState (OS.VK_SHIFT) < 0) event.stateMask |= SWT.SHIFT;
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0) event.stateMask |= SWT.CONTROL;
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) event.stateMask |= SWT.BUTTON1;
-	if (OS.GetKeyState (OS.VK_MBUTTON) < 0) event.stateMask |= SWT.BUTTON2;
-	if (OS.GetKeyState (OS.VK_RBUTTON) < 0) event.stateMask |= SWT.BUTTON3;
+        // <QFS/> changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_MENU) < 0) event.stateMask |= SWT.ALT;
+	if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) event.stateMask |= SWT.SHIFT;
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) event.stateMask |= SWT.CONTROL;
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) event.stateMask |= SWT.BUTTON1;
+	if (getDisplay().GetKeyState (OS.VK_MBUTTON) < 0) event.stateMask |= SWT.BUTTON2;
+	if (getDisplay().GetKeyState (OS.VK_RBUTTON) < 0) event.stateMask |= SWT.BUTTON3;
 	/*
 	* Bug in Windows.  On some machines that do not have XBUTTONs,
 	* the MK_XBUTTON1 and OS.MK_XBUTTON2 bits are sometimes set,
@@ -1282,8 +1296,8 @@
 	* for the extra buttons only when they exist.
 	*/
 	if (display.xMouse) {
-		if (OS.GetKeyState (OS.VK_XBUTTON1) < 0) event.stateMask |= SWT.BUTTON4;
-		if (OS.GetKeyState (OS.VK_XBUTTON2) < 0) event.stateMask |= SWT.BUTTON5;
+	if (getDisplay().GetKeyState (OS.VK_XBUTTON1) < 0) event.stateMask |= SWT.BUTTON4;
+	if (getDisplay().GetKeyState (OS.VK_XBUTTON2) < 0) event.stateMask |= SWT.BUTTON5;
 	}
 	switch (type) {
 		case SWT.MouseDown:
@@ -1312,12 +1326,12 @@
 			if (event.keyCode == SWT.SHIFT) event.stateMask |= SWT.SHIFT;
 			if (event.keyCode == SWT.CONTROL) event.stateMask |= SWT.CONTROL;
 			break;
-	}		
+	}
 	return true;
 }
 
 boolean setKeyState (Event event, int type, long /*int*/ wParam, long /*int*/ lParam) {
-	
+
 	/*
 	* Feature in Windows.  When the user presses Ctrl+Backspace
 	* or Ctrl+Enter, Windows sends a WM_CHAR with Delete (0x7F)
@@ -1333,13 +1347,13 @@
 			if (display.lastKey == SWT.CR) display.lastAscii = SWT.CR;
 			break;
 	}
-	
+
 	/*
 	* Feature in Windows.  When the user presses either the Enter
 	* key or the numeric keypad Enter key, Windows sends a WM_KEYDOWN
 	* with wParam=VK_RETURN in both cases.  In order to distinguish
 	* between the keys, the extended key bit is tested. If the bit
-	* is set, assume that the numeric keypad Enter was pressed. 
+	* is set, assume that the numeric keypad Enter was pressed.
 	*/
 	if (display.lastKey == SWT.CR && display.lastAscii == SWT.CR) {
 		if ((lParam & 0x1000000) != 0) display.lastKey = SWT.KEYPAD_CR;
@@ -1356,7 +1370,7 @@
 		* the ASCII value explicitly (Delete is 0x7F).
 		*/
 		if (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;
-		
+
 		/*
 		* Feature in Windows.  When the user presses Ctrl+Pause, the
 		* VK_CANCEL key is generated and a WM_CHAR is sent with 0x03,
@@ -1363,10 +1377,10 @@
 		* possibly to allow an application to look for Ctrl+C and the
 		* the Break key at the same time.  This is unexpected and
 		* unwanted.  The fix is to detect the case and set the character
-		* to zero. 
+		* to zero.
 		*/
 		if (display.lastKey == OS.VK_CANCEL) display.lastAscii = 0x0;
-		
+
 		event.keyCode = Display.translateKey (display.lastKey);
 	} else {
 		event.keyCode = display.lastKey;
@@ -1457,7 +1471,20 @@
 	return OS.SetWindowPos (hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
 }
 
+public // <QFS/> temporarily made public
 boolean showMenu (int x, int y) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("showMenu(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", x: ").add(x)
+         .add(", y: ").add(y)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.dumpStack(Log.DBG, "showMenu(int,int)", "");
+    }
+    // </QFS>
 	Event event = new Event ();
 	event.x = x;
 	event.y = y;
@@ -1467,9 +1494,12 @@
 	if (!event.doit) return true;
 	Menu menu = getMenu ();
 	if (menu != null && !menu.isDisposed ()) {
-		if (x != event.x || y != event.y) {
+                // <QFS> Always force desired location, otherwise the popup will always
+                // appear at the location of the mouse cursor
+                // if (event.x != x || event.y != y) {
 			menu.setLocation (event.x, event.y);
-		}
+                // }
+                // </QFS>
 		menu.setVisible (true);
 		return true;
 	}
@@ -1514,8 +1544,17 @@
 }
 
 LRESULT wmContextMenu (long /*int*/ hwnd, long /*int*/ wParam, long /*int*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmContextMenu(long,long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").add(hwnd)
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	if (wParam != hwnd) return null;
-	
+
 	/*
 	* Feature in Windows.  SHRecognizeGesture() sends an undocumented
 	* WM_CONTEXTMENU notification when the flag SHRG_NOTIFY_PARENT is
@@ -1523,12 +1562,12 @@
 	* once by the caller of SHRecognizeGesture() and once from this
 	* method.  The fix is to ignore WM_CONTEXTMENU notifications on
 	* all WinCE platforms.
-	* 
+	*
 	* NOTE: This only happens on WM2003.  Previous WinCE versions did
 	* not support WM_CONTEXTMENU.
 	*/
 	if (OS.IsWinCE) return null;
-	
+
 	/*
 	* Feature in Windows.  When the user presses  WM_NCRBUTTONUP,
 	* a WM_CONTEXTMENU message is generated.  This happens when
@@ -1546,8 +1585,26 @@
 		OS.POINTSTOPOINT (pt, lParam);
 		x = pt.x;
 		y = pt.y;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(long,long,long)")
+                        .add("pt1: ").add(pt).log(Log.DBG);
+                }
+                // </QFS>
 		OS.ScreenToClient (hwnd, pt);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(long,long,long)")
+                        .add("pt2: ").add(pt).log(Log.DBG);
+                }
+                // </QFS>
 		RECT rect = new RECT ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(long,long,long)")
+                        .add("rect: ").add(rect).log(Log.DBG);
+                }
+                // </QFS>
 		OS.GetClientRect (hwnd, rect);
 		if (!OS.PtInRect (rect, pt)) return null;
 	} else {
@@ -1575,7 +1632,16 @@
 }
 
 LRESULT wmKeyDown (long /*int*/ hwnd, long /*int*/ wParam, long /*int*/ lParam) {
-	
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmKeyDown(long,long,long)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").add(hwnd)
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+
 	/* Ignore repeating modifier keys by testing key down state */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_SHIFT:
@@ -1586,11 +1652,11 @@
 		case OS.VK_SCROLL:
 			if ((lParam & 0x40000000) != 0) return null;
 	}
-	
+
 	/* Clear last key and last ascii because a new key has been typed */
 	display.lastAscii = display.lastKey = 0;
 	display.lastVirtual = display.lastNull = display.lastDead = false;
-	
+
 	/*
 	* Do not report a lead byte as a key pressed.
 	*/
@@ -1598,7 +1664,7 @@
 		byte lead = (byte) (wParam & 0xFF);
 		if (OS.IsDBCSLeadByte (lead)) return null;
 	}
-	
+
 	/* Map the virtual key */
 	/*
 	* Bug in WinCE.  MapVirtualKey() returns incorrect values.
@@ -1622,13 +1688,13 @@
 		mapKey = OS.MapVirtualKey ((int)/*64*/wParam, 2);
 		/*
 		* Feature in Windows.  For Devanagari and Bengali numbers,
-		* MapVirtualKey() returns the localized number instead of 
+		* MapVirtualKey() returns the localized number instead of
 		* the ASCII equivalent.  For example, MapVirtualKey()
 		* maps VK_1 on the numbers keyboard to \u0967, which is
 		* the Devanagari digit '1', but not ASCII.
 		* The fix is to test for Devanagari and Bengali digits and 
 		* map these explicitly.
-		* 
+		*
 		* NOTE: VK_0 to VK_9 are the same as ASCII.
 		*/
 		if (('\u09e6' <= mapKey && mapKey <= '\u09ef') || ('\u0966' <= mapKey && mapKey <= '\u096f')) {
@@ -1651,7 +1717,7 @@
 	* a dead key.  This happens when an accent key, such as '^' is the
 	* result of a modifier such as Shift key and MapVirtualKey() always
 	* returns the unshifted key.  The fix is to peek for a WM_DEADCHAR
-	* and avoid issuing the event. 
+	* and avoid issuing the event.
 	*/
 	if (OS.IsWinNT) {
 		if ((mapKey & 0x80000000) != 0) return null;
@@ -1666,10 +1732,10 @@
 		display.lastKey = display.lastVirtual ? (int)/*64*/wParam : mapKey;
 		return null;
 	}
-	
+
 	/*
 	*  Bug in Windows.  Somehow, the widget is becoming disposed after
-	*  calling PeekMessage().  In rare circumstances, it seems that
+        *  calling PeekMessage().  In rare cirucmstances, it seems that
 	*  PeekMessage() can allow SWT listeners to run that might contain
 	*  application code that disposes the widget.  It is not exactly
 	*  clear how this can happen.  PeekMessage() is only looking for
@@ -1679,7 +1745,7 @@
 	*  return without calling the window proc.
 	*/
 	if (isDisposed ()) return LRESULT.ONE;
-	
+
 	/*
 	* If we are going to get a WM_CHAR, ensure that last key has
 	* the correct character value for the key down and key up
@@ -1687,14 +1753,14 @@
 	* (when we know we are going to get a WM_CHAR) and compute
 	* the key in WM_CHAR because there is not enough information
 	* by the time we get the WM_CHAR.  For example, when the user
-	* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with 
-	* wParam=30.  When the user types Ctrl+Shift+6 on a German 
+	* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with
+	* wParam=30.  When the user types Ctrl+Shift+6 on a German
 	* keyboard, we also get a WM_CHAR with wParam=30.  On the US
 	* keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.
 	* There is no way to map wParam=30 in WM_CHAR to the correct
 	* value.  Also, on international keyboards, the control key
 	* may be down when the user has not entered a control character.
-	* 
+	*
 	* NOTE: On Windows 98, keypad keys are virtual despite the
 	* fact that a WM_CHAR is issued.  On Windows 2000 and XP,
 	* they are not virtual.  Therefore it is necessary to force
@@ -1708,13 +1774,13 @@
 		* treated as both a virtual key and an ASCII key by Windows.
 		* Therefore, we will not receive a WM_CHAR for this key.
 		* The fix is to treat VK_DELETE as a special case and map
-		* the ASCII value explicitly (Delete is 0x7F).
+                * the ASCII value explictly (Delete is 0x7F).
 		*/
 		if (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;
 
 		/*
 		* It is possible to get a WM_CHAR for a virtual key when
-		* Num Lock is on.  If the user types Home while Num Lock 
+		* Num Lock is on.  If the user types Home while Num Lock
 		* is down, a WM_CHAR is issued with WPARM=55 (for the
 		* character 7).  If we are going to get a WM_CHAR we need
 		* to ensure that the last key has the correct value.  Note
@@ -1727,9 +1793,16 @@
 			* the accented state such that the next WM_CHAR loses the accent.
 			* This makes is critical that the accent key is detected.  Also,
 			* these functions clear the character that is entered using the
-			* special Windows keypad sequence when NumLock is down (ie. typing 
+			* special Windows keypad sequence when NumLock is down (ie. typing
 			* ALT+0231 should gives 'c' with a cedilla when NumLock is down).
 			*/
+                    // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                                   "lastKey-test");
+                    }
+                    // </QFS>
+
 			if (display.asciiKey (display.lastKey) != 0) return null;
 			display.lastAscii = display.numpadKey (display.lastKey);
 		}
@@ -1737,7 +1810,7 @@
 		/*
 		* Convert LastKey to lower case because Windows non-virtual
 		* keys that are also ASCII keys, such as like VK_A, are have
-		* upper case values in WM_KEYDOWN despite the fact that the 
+		* upper case values in WM_KEYDOWN despite the fact that the
 		* Shift was not pressed.
 		*/
 	 	display.lastKey = (int)/*64*/OS.CharLower ((short) mapKey);
@@ -1750,7 +1823,7 @@
 		* Ctrl+C, mark the key as virtual.
 		*/
 		if (wParam == OS.VK_CANCEL) display.lastVirtual = true;
-		
+
 		/*
 		* Some key combinations map to Windows ASCII keys depending
 		* on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a
@@ -1768,7 +1841,22 @@
 			* To avoid the extra SWT.KeyDown, look for a space and
 			* issue the event from WM_CHAR.
 			*/
+                    // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                                   "asciiKey test1");
+                    }
+                    // </QFS>
+
 			if (asciiKey == ' ') return null;
+                    // <QFS>
+                    if (logger.level >= Log.DBG) {
+                        logger.build("wmKeyDown(long,long,long)")
+                            .add("asciiKey test2: asciiKey=").add(asciiKey)
+                            .add(" ==? wParam=").addHex(wParam).log(Log.DBG);
+                    }
+                    // </QFS>
+
 			if (asciiKey != (int)/*64*/wParam) return null;
 			/*
 			* Feature in Windows. The virtual key VK_CANCEL is treated
@@ -1777,9 +1865,16 @@
 			* this key. To avoid the extra SWT.KeyDown, look for
 			* VK_CANCEL and issue the event from WM_CHAR.
 			*/
+                        // <QFS>
+                        if (logger.level >= Log.MTDDETAIL) {
+                            logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                                       "cancel test");
+                        }
+                        // </QFS>
+
 			if (wParam == OS.VK_CANCEL) return null;
 		}
-		
+
 		/*
 		* If the control key is not down at this point, then
 		* the key that was pressed was an accent key or a regular
@@ -1786,29 +1881,56 @@
 		* key such as 'A' or Shift+A.  In that case, issue the
 		* key event from WM_CHAR.
 		*/
-		if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return null;
-		
+                // <QFS>
+                if (logger.level >= Log.MTDDETAIL) {
+                    logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                               "control test");
+                }
+                // </QFS>
+
+                // <QFS/> changed to getDisplay().GetKeyState
+                if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return null;
+
 		/*
 		* Get the shifted state or convert to lower case if necessary.
-		* If the user types Ctrl+A, LastAscii should be 'a', not 'A'. 
+		* If the user types Ctrl+A, LastAscii should be 'a', not 'A'.
 		* If the user types Ctrl+Shift+A, LastAscii should be 'A'.
 		* If the user types Ctrl+Shift+6, the value of LastAscii will
 		* depend on the international keyboard.
 		*/
-	 	if (OS.GetKeyState (OS.VK_SHIFT) < 0) {
+                // <QFS/> changed to getDisplay().GetKeyState
+                if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) {
 			display.lastAscii = display.shiftedKey ((int)/*64*/wParam);
 			if (display.lastAscii == 0) display.lastAscii = mapKey;
 	 	} else {
 	 		display.lastAscii = (int)/*64*/OS.CharLower ((short) mapKey);
 	 	}
-	 			
+                // <QFS>
+                if (logger.level >= Log.MTDDETAIL) {
+                    logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                               "@-test");
+                }
+                // </QFS>
+
 		/* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */
 		if (display.lastAscii == '@') return null;
 		display.lastAscii = display.controlKey (display.lastAscii);
 	}
+        // <QFS>
+        if (logger.level >= Log.MTDDETAIL) {
+            logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                       "doing sendKeyEvent now");
+        }
+        // </QFS>
 	if (!sendKeyEvent (SWT.KeyDown, OS.WM_KEYDOWN, wParam, lParam)) {
 		return LRESULT.ONE;
 	}
+        // <QFS>
+        if (logger.level >= Log.MTDDETAIL) {
+            logger.log(Log.MTDDETAIL, "wmKeyDown(long,long,long)",
+                       "sendKeyEvent failed");
+        }
+        // </QFS>
 	// widget could be disposed at this point
 	return null;
 }
@@ -1815,7 +1937,7 @@
 
 LRESULT wmKeyUp (long /*int*/ hwnd, long /*int*/ wParam, long /*int*/ lParam) {
 	Display display = this.display;
-	
+
 	/* Check for hardware keys */
 	if (OS.IsWinCE) {
 		if (OS.VK_APP1 <= wParam && wParam <= OS.VK_APP6) {
@@ -1830,7 +1952,7 @@
 			return null;
 		}
 	}
-	
+
 	/*
 	* If the key up is not hooked, reset last key
 	* and last ascii in case the key down is hooked.
@@ -1840,7 +1962,7 @@
 		display.lastVirtual = display.lastNull = display.lastDead = false;
 		return null;
 	}
-	
+
 	/* Map the virtual key. */
 	/*
 	* Bug in WinCE.  MapVirtualKey() returns incorrect values.
@@ -1920,7 +2042,7 @@
 	long /*int*/ code = callWindowProc (hwnd, OS.WM_KILLFOCUS, wParam, lParam);
 	sendFocusEvent (SWT.FocusOut);
 	// widget could be disposed at this point
-	
+
 	/*
 	* It is possible (but unlikely), that application
 	* code could have disposed the widget in the focus
@@ -1984,13 +2106,14 @@
 			consume = new boolean [1];
 			dragging = dragDetect (hwnd, x, y, true, detect, consume);
 			if (isDisposed ()) return LRESULT.ZERO;
-			mouseDown = OS.GetKeyState (OS.VK_LBUTTON) < 0;
+                        // <QFS/> changed to getDisplay().GetKeyState
+			mouseDown = getDisplay().GetKeyState (OS.VK_LBUTTON) < 0;
 		}
 	}
 	display.captureChanged = false;
 	boolean dispatch = sendMouseEvent (SWT.MouseDown, 1, count, 0, false, hwnd, OS.WM_LBUTTONDOWN, wParam, lParam);
 	if (dispatch && (consume == null || !consume [0])) {
-		result = new LRESULT (callWindowProc (hwnd, OS.WM_LBUTTONDOWN, wParam, lParam));	
+		result = new LRESULT (callWindowProc (hwnd, OS.WM_LBUTTONDOWN, wParam, lParam));
 	} else {
 		result = LRESULT.ZERO;
 	}
@@ -2007,7 +2130,7 @@
 			shrg.cbSize = SHRGINFO.sizeof;
 			shrg.hwndClient = hwnd;
 			shrg.ptDown_x = x;
-			shrg.ptDown_y = y; 
+			shrg.ptDown_y = y;
 			shrg.dwFlags = OS.SHRG_RETURNCMD;
 			int type = OS.SHRecognizeGesture (shrg);
 			if (type == OS.GN_CONTEXTMENU) showMenu (x, y);
@@ -2035,7 +2158,7 @@
 			* mouse down/up pairs or looks for the ESC key will not
 			* function properly.  The fix is to send the missing
 			* events when the drag has not started.
-			* 
+			*
 			* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP
 			* events for the ESC key.  This would require computing
 			* wParam (the key) and lParam (the repeat count, scan code,
@@ -2042,7 +2165,8 @@
 			* extended-key flag, context code, previous key-state flag,
 			* and transition-state flag) which is non-trivial.
 			*/
-			if (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {
+                        // <QFS/> changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_ESCAPE) >= 0) {
 				OS.SendMessage (hwnd, OS.WM_LBUTTONUP, wParam, lParam);
 			}
 		}
@@ -2161,8 +2285,13 @@
 LRESULT wmMouseMove (long /*int*/ hwnd, long /*int*/ wParam, long /*int*/ lParam) {
 	LRESULT result = null;
 	Display display = this.display;
-	int pos = OS.GetMessagePos ();
-	if (pos != display.lastMouse || display.captureChanged) {
+    // <QFS> changed "OS.GetMessagePos" to "getDisplay().GetMessagePos" and test for overridden
+    // position and target
+    int pos = display.GetMessagePos ();
+    if ((! display.isReplaying()
+         || display.replayTarget == this)
+    // </QFS>
+	&& (pos != display.lastMouse || display.captureChanged)) {
 		if (!OS.IsWinCE) {
 			boolean trackMouse = (state & TRACK_MOUSE) != 0;
 			boolean mouseEnter = hooks (SWT.MouseEnter) || display.filters (SWT.MouseEnter);
@@ -2205,7 +2334,7 @@
 				result = LRESULT.ZERO;
 			}
 		}
-	} 
+	}
 	display.captureChanged = false;
 	return result;
 }
@@ -2228,7 +2357,7 @@
 	if (!hooks (SWT.Paint) && !filters (SWT.Paint)) {
 		return null;
 	}
-	
+
 	/* Issue a paint event */
 	long /*int*/ result = 0;
 	if (OS.IsWinCE) {
@@ -2424,7 +2553,7 @@
 	if (!hooks (SWT.KeyDown) && !display.filters (SWT.KeyDown)) {
 		return null;
 	}
-	
+
 	/* Call the window proc to determine whether it is a system key or mnemonic */
 	boolean oldKeyHit = display.mnemonicKeyHit;
 	display.mnemonicKeyHit = true;
@@ -2452,7 +2581,7 @@
 		/* Make sure WM_SYSKEYDOWN was sent by ALT-<aKey>. */
 		if ((lParam & 0x20000000) == 0) return null;
 	}
-	
+
 	/* Ignore well known system keys */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_F4: {
@@ -2465,7 +2594,7 @@
 			if ((bits & OS.WS_SYSMENU) != 0) return null;
 		}
 	}
-	
+
 	/* Ignore repeating modifier keys by testing key down state */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_SHIFT:
@@ -2476,7 +2605,7 @@
 		case OS.VK_SCROLL:
 			if ((lParam & 0x40000000) != 0) return null;
 	}
-	
+
 	/* Clear last key and last ascii because a new key has been typed */
 	display.lastAscii = display.lastKey = 0;
 	display.lastVirtual = display.lastNull = display.lastDead = false;
@@ -2539,7 +2668,7 @@
 		/*
 		* Convert LastKey to lower case because Windows non-virtual
 		* keys that are also ASCII keys, such as like VK_A, are have
-		* upper case values in WM_SYSKEYDOWN despite the fact that the 
+		* upper case values in WM_SYSKEYDOWN despite the fact that the
 		* Shift was not pressed.
 		*/
 	 	display.lastKey = (int)/*64*/OS.CharLower ((short) mapKey);
Index: org/eclipse/swt/widgets/DirectoryDialog.java
===================================================================
--- org/eclipse/swt/widgets/DirectoryDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/DirectoryDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -14,6 +15,10 @@
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
 /**
  * Instances of this class allow the user to navigate
@@ -35,6 +40,15 @@
  */
 
 public class DirectoryDialog extends Dialog {
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.DirectoryDialog");
+    // </QFS>
+
 	String message = "", filterPath = "";  //$NON-NLS-1$//$NON-NLS-2$
 	String directoryPath;
 	
@@ -215,6 +229,23 @@
 	*/
 	int oldErrorMode = OS.SetErrorMode (OS.SEM_FAILCRITICALERRORS);
 	
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
+
 	/*
 	* Bug in Windows.  When a WH_MSGFILTER hook is used to run code
 	* during the message loop for SHBrowseForFolder(), running code
@@ -268,9 +299,13 @@
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
 	
-	/* Return the directory path */
-	if (!success) return null;
-	return directoryPath;
+        // <QFS>
+        Object result = success ? directoryPath : null;
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+	return (result instanceof String) || result == null
+            ? (String) result
+            : success ? directoryPath : null;
+        // </QFS>
 }
 
 /**
Index: org/eclipse/swt/widgets/ToolItem.java
===================================================================
--- org/eclipse/swt/widgets/ToolItem.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ToolItem.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -10,7 +10,7 @@
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
@@ -27,7 +27,7 @@
  * <dd>Selection</dd>
  * </dl>
  * <p>
- * Note: Only one of the styles CHECK, PUSH, RADIO, SEPARATOR and DROP_DOWN 
+ * Note: Only one of the styles CHECK, PUSH, RADIO, SEPARATOR and DROP_DOWN
  * may be specified.
  * </p><p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
@@ -54,7 +54,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -94,7 +94,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -175,14 +175,15 @@
 	if (!isValidSubclass ()) error (SWT.ERROR_INVALID_SUBCLASS);
 }
 
-void click (boolean dropDown) {	
+void click (boolean dropDown) {
 	long /*int*/ hwnd = parent.handle;
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) return;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) return;
 	int index = (int)/*64*/OS.SendMessage (hwnd, OS.TB_COMMANDTOINDEX, id, 0);
 	RECT rect = new RECT ();
 	OS.SendMessage (hwnd, OS.TB_GETITEMRECT, index, rect);
 	int hotIndex = (int)/*64*/OS.SendMessage (hwnd, OS.TB_GETHOTITEM, 0, 0);
-	
+
 	/*
 	* In order to emulate all the processing that
 	* happens when a mnemonic key is pressed, fake
@@ -196,7 +197,7 @@
 	OS.SendMessage (hwnd, OS.WM_LBUTTONDOWN, 0, lParam);
 	OS.SendMessage (hwnd, OS.WM_LBUTTONUP, 0, lParam);
 	parent.ignoreMouse = false;
-	
+
 	if (hotIndex != -1) {
 		OS.SendMessage (hwnd, OS.TB_SETHOTITEM, hotIndex, 0);
 	}
@@ -289,7 +290,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -407,7 +408,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -456,7 +457,7 @@
 	* the style BTNS_SEP does not return I_IMAGENONE when queried
 	* for an image index, despite the fact that no attempt has been
 	* made to assign an image to the item.  As a result, operations
-	* on an image list that use the wrong index cause random results.	
+	* on an image list that use the wrong index cause random results.
 	* The fix is to ensure that the tool item is not a separator
 	* before using the image index.  Since separators cannot have
 	* an image and one is never assigned, this is not a problem.
@@ -493,7 +494,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 void resizeControl () {
@@ -533,7 +534,7 @@
  * @param control the new control
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  *    <li>ERROR_INVALID_PARENT - if the control is not in the same widget tree</li>
  * </ul>
  * @exception SWTException <ul>
@@ -634,7 +635,7 @@
 	* Feature in Windows.  When TB_SETSTATE is used to set the
 	* state of a tool item, the item redraws even when the state
 	* has not changed.  The fix is to detect this case and avoid
-	* setting the state. 
+	* setting the state.
 	*/
 	if (((fsState & OS.TBSTATE_ENABLED) != 0) == enabled) return;
 	if (enabled) {
@@ -660,7 +661,7 @@
  * @param image the disabled image to display on the receiver (may be null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -685,7 +686,7 @@
  * @param image the hot image to display on the receiver (may be null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -741,7 +742,7 @@
 	* Feature in Windows.  When TB_SETSTATE is used to set the
 	* state of a tool item, the item redraws even when the state
 	* has not changed.  The fix is to detect this case and avoid
-	* setting the state. 
+	* setting the state.
 	*/
 	if (((fsState & OS.TBSTATE_CHECKED) != 0) == selected) return;
 	if (selected) {
@@ -750,7 +751,7 @@
 		fsState &= ~OS.TBSTATE_CHECKED;
 	}
 	OS.SendMessage (hwnd, OS.TB_SETSTATE, id, fsState);
-	
+
 	/*
 	* Bug in Windows.  When a tool item with the style
 	* BTNS_CHECK or BTNS_CHECKGROUP is selected and then
@@ -757,7 +758,7 @@
 	* disabled, the item does not draw using the disabled
 	* image.  The fix is to use the disabled image in all
 	* image lists for the item.
-	* 
+	*
 	* NOTE: This means that the image list must be updated
 	* when the selection changes in a disabled tool item.
 	*/
@@ -792,7 +793,7 @@
  * escaped by doubling it in the string, causing a single
  * '&amp;' to be displayed.
  * </p>
- * 
+ *
  * @param string the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -820,12 +821,12 @@
 		TCHAR buffer = new TCHAR (parent.getCodePage (), string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount); 
+		OS.MoveMemory (pszText, buffer, byteCount);
 		info.pszText = pszText;
 	}
 	OS.SendMessage (hwnd, OS.TB_SETBUTTONINFO, id, info);
 	if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
-	
+
 	/*
 	* Bug in Windows.  For some reason, when the font is set
 	* before any tool item has text, the tool items resize to
@@ -853,7 +854,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -981,12 +982,12 @@
 
 	/*
 	* Bug in Windows.  If the width of an item has already been
-	* calculated, the tool bar control will not recalculate it to 
+	* calculated, the tool bar control will not recalculate it to
 	* include the space for the image.  The fix is to set the width
 	* to zero, forcing the control recalculate the width for the item.
 	*/
 	info.dwMask |= OS.TBIF_SIZE;
-	info.cx = 0;	
+	info.cx = 0;
 	OS.SendMessage (hwnd, OS.TB_SETBUTTONINFO, id, info);
 	long /*int*/ hFont = OS.SendMessage (hwnd, OS.WM_GETFONT, 0, 0);
 	OS.SendMessage (hwnd, OS.WM_SETFONT, hFont, 0);
Index: org/eclipse/swt/widgets/ColorDialog.java
===================================================================
--- org/eclipse/swt/widgets/ColorDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ColorDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -16,6 +17,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to select a color
  * from a predefined set of available colors.
@@ -35,6 +41,14 @@
  */
 
 public class ColorDialog extends Dialog {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.ColorDialog");
+    // </QFS>
+
 	Display display;
 	int width, height;
 	RGB rgb;
@@ -218,6 +232,22 @@
 		display.setModalDialog (this);
 	}
 	
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/* Open the dialog */
 	boolean success = OS.ChooseColor (lpcc);
 	
@@ -260,6 +290,12 @@
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
 	
+        // <QFS>
+        rgb = (RGB) _qfGetDisplay().runDialogClosedHooks(this, success ? rgb : null);
+        if (rgb != null) {
+            success = true;
+        }
+        // </QFS>
 	display = null;
 	if (!success) return null;
 	return rgb;
Index: org/eclipse/swt/widgets/Sash.java
===================================================================
--- org/eclipse/swt/widgets/Sash.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Sash.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -202,8 +202,10 @@
 		case OS.VK_DOWN:
 			
 			/* Calculate the new x or y position */
-			if (OS.GetKeyState (OS.VK_LBUTTON) < 0) return result;
-			int step = OS.GetKeyState (OS.VK_CONTROL) < 0 ? INCREMENT : PAGE_INCREMENT;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) return result;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			int step = getDisplay().GetKeyState (OS.VK_CONTROL) < 0 ? INCREMENT : PAGE_INCREMENT;
 			POINT pt = new POINT ();
 			if ((style & SWT.VERTICAL) != 0) {
 				if (wParam == OS.VK_UP || wParam == OS.VK_DOWN) break;
Index: org/eclipse/swt/widgets/TrayItem.java
===================================================================
--- org/eclipse/swt/widgets/TrayItem.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TrayItem.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -454,7 +454,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/custom/StyledText.java
===================================================================
--- org/eclipse/swt/custom/StyledText.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/StyledText.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -167,7 +167,7 @@
 	int alignmentMargin;
 	int newOrientation = SWT.NONE;
 	int accCaretOffset;
-	
+
 	//block selection
 	boolean blockSelection;
 	int blockXAnchor = -1, blockYAnchor = -1;
@@ -274,7 +274,7 @@
 						printerRenderer.setLineSegments(i, 1, event.segments);
 						printerRenderer.setLineSegmentChars(i, 1, event.segmentsChars);
 					}
-				}
+				}			
 				event = styledText.getLineStyleData(lineOffset, line);
 				if (event != null) {
 					printerRenderer.setLineIndent(i, 1, event.indent);
@@ -1011,11 +1011,11 @@
 				fontStyle = fontData.getStyle();
 			}
 			if ((fontStyle & SWT.BOLD) != 0) {
-				write("\\b");
-			}
+					write("\\b"); 
+				}
 			if ((fontStyle & SWT.ITALIC) != 0) {
-				write("\\i");
-			}
+					write("\\i"); 
+				}
 			if (style.underline) {
 				write("\\ul");
 			}
@@ -1029,11 +1029,11 @@
 			copyEnd = Math.max(copyEnd, lineIndex);
 			write(line, lineIndex, copyEnd);
 			if ((fontStyle & SWT.BOLD) != 0) {
-				write("\\b0");
-			}
-			if ((style.fontStyle & SWT.ITALIC) != 0) {
-				write("\\i0");
-			}
+					write("\\b0"); 
+				}
+				if ((style.fontStyle & SWT.ITALIC) != 0) {
+					write("\\i0"); 
+				}
 			if (style.underline) {
 				write("\\ul0");
 			}
@@ -1671,7 +1671,7 @@
  */
 void claimRightFreeSpace() {
 	int newHorizontalOffset = Math.max(0, renderer.getWidth() - clientAreaWidth);
-	if (newHorizontalOffset < horizontalScrollOffset) {
+	if (newHorizontalOffset < horizontalScrollOffset) {			
 		// item is no longer drawn past the right border of the client area
 		// align the right end of the item with the right border of the 
 		// client area (window is scrolled right).
@@ -1801,20 +1801,20 @@
 				return true;
 			}
 		} else {
-			int length = selection.y - selection.x;
-			if (length > 0) {
+	int length = selection.y - selection.x;
+	if (length > 0) {
 				setClipboardContent(selection.x, length, type);
 				return true;
 			}
 		}
-	} catch (SWTError error) {
-		// Copy to clipboard failed. This happens when another application 
-		// is accessing the clipboard while we copy. Ignore the error.
-		// Rethrow all other errors. Fixes bug 17578.
-		if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
-			throw error;
+		} catch (SWTError error) {
+			// Copy to clipboard failed. This happens when another application 
+			// is accessing the clipboard while we copy. Ignore the error.
+			// Rethrow all other errors. Fixes bug 17578.
+			if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
+				throw error;
+			}
 		}
-	}
 	return false;
 }
 /**
@@ -1865,7 +1865,7 @@
 	}
 	return Math.min(height, availableHeight);
 }
-/** 
+/**
  * Returns the color of the margins.
  * 
  * @return the color of the margins.
@@ -1949,12 +1949,12 @@
 			return dragDetect(event);
 		}
 	} else {
-		if (selection.x == selection.y) return false;
-		int offset = getOffsetAtPoint(event.x, event.y, null, true);
-		if (selection.x <= offset && offset < selection.y) {
-			return dragDetect(event);
-		}
+	if (selection.x == selection.y) return false;
+	int offset = getOffsetAtPoint(event.x, event.y, null, true);
+	if (selection.x <= offset && offset < selection.y) {
+		return dragDetect(event);
 	}
+	}
 	return false;
 }
 /**
@@ -2094,8 +2094,8 @@
  */
 public void cut() {
 	checkWidget();
-	// Abort cut operation if copy to clipboard fails.
-	// Fixes bug 21030.
+			// Abort cut operation if copy to clipboard fails.
+			// Fixes bug 21030.
 	if (copySelection(DND.CLIPBOARD)) {
 		if (blockSelection && blockXLocation != -1) {
 			insertBlockSelectionText((char)0, SWT.NULL);
@@ -2152,7 +2152,7 @@
 							scrollVertical(pixels, true);
 						}
 					} else {
-						doSelectionPageUp(autoScrollDistance);
+					doSelectionPageUp(autoScrollDistance);
 					}
 					display.timerExec(V_SCROLL_RATE, this);
 				}
@@ -2174,7 +2174,7 @@
 							scrollVertical(pixels, true);
 						}
 					} else {
-						doSelectionPageDown(autoScrollDistance);
+					doSelectionPageDown(autoScrollDistance);
 					}
 					display.timerExec(V_SCROLL_RATE, this);
 				}
@@ -2195,9 +2195,9 @@
 							scrollHorizontal(pixels, true);
 						}
 					} else {
-						doVisualNext();
-						setMouseWordSelectionAnchor();
-						doMouseSelection();
+					doVisualNext();
+					setMouseWordSelectionAnchor();
+					doMouseSelection();
 					}
 					display.timerExec(H_SCROLL_RATE, this);
 				}
@@ -2217,9 +2217,9 @@
 							scrollHorizontal(pixels, true);
 						}
 					} else {
-						doVisualPrevious();
-						setMouseWordSelectionAnchor();
-						doMouseSelection();
+					doVisualPrevious();
+					setMouseWordSelectionAnchor();
+					doMouseSelection();
 					}
 					display.timerExec(H_SCROLL_RATE, this);
 				}
@@ -2259,7 +2259,7 @@
 			}
 			TextLayout layout = renderer.getTextLayout(lineIndex);
 			int start = layout.getPreviousOffset(caretOffset - lineOffset, isSurrogate ? SWT.MOVEMENT_CLUSTER : SWT.MOVEMENT_CHAR);
-			renderer.disposeTextLayout(layout);
+			renderer.disposeTextLayout(layout); 
 			event.start = start + lineOffset;
 			event.end = caretOffset;
 		}
@@ -2466,16 +2466,16 @@
 		doLineEnd();
 	} else {
 		int length = content.getCharCount();		
-		setCaretOffset(length, SWT.DEFAULT);
-		showCaret();
-	}
+			setCaretOffset(length, SWT.DEFAULT);
+			showCaret();
+		}
 }
 /**
  * Moves the caret in front of the first character of the widget content.
  */
 void doContentStart() {
-	setCaretOffset(0, SWT.DEFAULT);
-	showCaret();
+		setCaretOffset(0, SWT.DEFAULT);
+		showCaret();
 }
 /**
  * Moves the caret to the start of the selection if a selection exists.
@@ -2629,8 +2629,8 @@
 		int lineLength = content.getLine(caretLine).length();
 		lineEndOffset = lineOffset + lineLength;
 	}
-	setCaretOffset(lineEndOffset, PREVIOUS_OFFSET_TRAILING);
-	showCaret();
+		setCaretOffset(lineEndOffset, PREVIOUS_OFFSET_TRAILING);
+		showCaret();
 }
 /**
  * Moves the caret to the beginning of the line.
@@ -2646,8 +2646,8 @@
 		lineOffset += offsets[lineIndex];
 		renderer.disposeTextLayout(layout);
 	}
-	setCaretOffset(lineOffset, OFFSET_LEADING);
-	showCaret();
+		setCaretOffset(lineOffset, OFFSET_LEADING);
+		showCaret();
 }
 /**
  * Moves the caret one line up and to the same character offset relative 
@@ -2802,10 +2802,10 @@
 	boolean vchange = 0 <= y && y < clientAreaHeight || newCaretLine == 0 || newCaretLine == content.getLineCount() - 1;
 	boolean hchange = 0 <= x && x < clientAreaWidth || wordWrap || newCaretLine != content.getLineAtOffset(caretOffset); 
 	if (vchange && hchange && (newCaretOffset != caretOffset || newCaretAlignemnt != caretAlignment)) {
-		setCaretOffset(newCaretOffset, newCaretAlignemnt);
-		if (select) doMouseSelection();
-		showCaret();
-	}
+			setCaretOffset(newCaretOffset, newCaretAlignemnt);
+			if (select) doMouseSelection();
+			showCaret();
+		}
 	if (!select) {
 		setCaretOffset(newCaretOffset, newCaretAlignemnt);
 		clearSelection(true);
@@ -3475,7 +3475,7 @@
 	checkWidget();
 	return bidiColoring;
 }
-/**
+/** 
  * Returns whether the widget is in block selection mode.
  *
  * @return true if widget is in block selection mode, false otherwise
@@ -4400,23 +4400,23 @@
 			offsetInLine += trailing[0];
 			if (alignment != null) alignment[0] = PREVIOUS_OFFSET_TRAILING;
 		} else {
-			String line = content.getLine(lineIndex);
+			String line = content.getLine(lineIndex);			
 			int level = 0;
 			if (alignment != null) {
-				int offset = offsetInLine;
-				while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;
-				if (offset == 0 && Character.isDigit(line.charAt(offset))) {
-					level = isMirrored() ? 1 : 0;
-				} else {
-					level = layout.getLevel(offset) & 0x1;
-				}
+			int offset = offsetInLine;
+			while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;
+			if (offset == 0 && Character.isDigit(line.charAt(offset))) {
+				level = isMirrored() ? 1 : 0;
+			} else {
+				level = layout.getLevel(offset) & 0x1;
 			}
+			}
 			offsetInLine += trailing[0];
 			if (alignment != null) {
-				int trailingLevel = layout.getLevel(offsetInLine) & 0x1;
-				if ((level ^ trailingLevel) != 0) {
+			int trailingLevel = layout.getLevel(offsetInLine) & 0x1;
+			if ((level ^ trailingLevel) != 0) {
 					alignment[0] = PREVIOUS_OFFSET_TRAILING;
-				} else {
+			} else {
 					alignment[0] = OFFSET_LEADING;
 				}
 			}
@@ -4587,7 +4587,7 @@
 	}
 	return new int[0];
 }
-/** 
+/**
  * Returns the right margin.
  *
  * @return the right margin.
@@ -4770,11 +4770,11 @@
 		// test segment index consistency
 		if (segments[0] != 0) {
 			SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-		}
+		} 	
 		for (int i = 1; i < segmentCount; i++) {
 			if (segments[i] <= segments[i - 1] || segments[i] > lineLength) {
 				SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-			}
+			} 	
 		}
 		// ensure that last segment index is line end offset
 		if (segments[segmentCount - 1] != lineLength) {
@@ -4783,13 +4783,13 @@
 			segments[segmentCount] = lineLength;
 		}
 		event.segments = segments;
-	} else {
+		} else {
 		for (int i = 1; i < segmentCount; i++) {
 			if (event.segments[i] < event.segments[i - 1] || event.segments[i] > lineLength) {
 				SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-			}
 		}
 	}
+	}
 	return event;
 }
 /**
@@ -5210,7 +5210,7 @@
 	checkWidget();
 	return topIndex;
 }
-/** 
+/**
  * Returns the top margin.
  *
  * @return the top margin.
@@ -5377,7 +5377,7 @@
 	checkWidget();
 	return wordWrap;
 }
-/**
+/** 
  * Returns the wrap indentation of the widget.
  * 
  * @return the wrap indentation
@@ -5466,8 +5466,8 @@
 	if (blockSelection) {
 		insertBlockSelectionText(string, false); 
 	} else {
-		Point sel = getSelectionRange();
-		replaceTextRange(sel.x, sel.y, string);
+	Point sel = getSelectionRange();
+	replaceTextRange(sel.x, sel.y, string);
 	}
 }
 int insertBlockSelectionText(String text, boolean fillWithSpaces) {
@@ -6017,10 +6017,10 @@
 				if (blockSelection) {
 					setBlockSelectionLocation(leftMargin, event.y, clientAreaWidth - rightMargin, event.y, true);
 				} else {
-					int lineEnd = content.getCharCount();
-					if (lineIndex + 1 < content.getLineCount()) {
-						lineEnd = content.getOffsetAtLine(lineIndex + 1);
-					}
+			int lineEnd = content.getCharCount();
+			if (lineIndex + 1 < content.getLineCount()) {
+				lineEnd = content.getOffsetAtLine(lineIndex + 1);
+			}
 					setSelection(lineOffset, lineEnd - lineOffset, false, false);
 					sendSelectionEvent();
 				}
@@ -6036,8 +6036,8 @@
  */
 void handleMouseMove(Event event) {
 	if (clickCount > 0) {
-		update();
-		doAutoScroll(event);
+	update();
+	doAutoScroll(event);
 		doMouseLocationChange(event.x, event.y, true);
 	} 
 	if (renderer.hasLinks) {
@@ -6203,7 +6203,7 @@
 	// in some cases new text would be drawn in scroll source area even 
 	// though the intent is to scroll it.
 	if (!(blockSelection && blockXLocation != -1)) {
-		updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);
+	updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);
 	}
 	if (lastTextChangeReplaceLineCount > 0 || wordWrap) {
 		claimBottomFreeSpace();
@@ -6330,12 +6330,12 @@
 		public void getKeyboardShortcut(AccessibleEvent e) {
 			String shortcut = null;
 			String text = getAssociatedLabel ();
-			if (text != null) {
-				char mnemonic = _findMnemonic (text);
-				if (mnemonic != '\0') {
-					shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+				if (text != null) {
+					char mnemonic = _findMnemonic (text);
+					if (mnemonic != '\0') {
+						shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+					}
 				}
-			}
 			e.result = shortcut;
 		}
 	});
@@ -7073,7 +7073,7 @@
 			if (blockXLocation != -1) {
 				insertBlockSelectionText((char)0, action);
 				return true;
-			}
+	}
 			return false;
 		case ST.DELETE_WORD_PREVIOUS:
 		case ST.DELETE_WORD_NEXT:
@@ -7380,7 +7380,7 @@
 	}
 }
 void redrawLines(int startLine, int lineCount, boolean bottomChanged) {
-	// do nothing if redraw range is completely invisible
+	// do nothing if redraw range is completely invisible	
 	int endLine = startLine + lineCount - 1;
 	int partialBottomIndex = getPartialBottomIndex();
 	int partialTopIndex = getPartialTopIndex();
@@ -7772,7 +7772,7 @@
 	topIndex = 0;
 	topIndexY = 0;
 	verticalScrollOffset = 0;
-	horizontalScrollOffset = 0;
+	horizontalScrollOffset = 0;	
 	resetSelection();
 	renderer.setContent(content);
 	if (verticalBar != null) {
@@ -8335,7 +8335,7 @@
 	checkWidget();
 	bidiColoring = mode;
 }
-/** 
+/**
  * Sets the bottom margin.
  * 
  * @param bottomMargin the bottom margin.
@@ -8440,11 +8440,11 @@
 		if (blockSelection) {
 			clearBlockSelection(true, false);
 		} else {
-			clearSelection(false);
-		}
+		clearSelection(false);
 	}
+	}
 	setCaretLocation();
-}
+}	
 void setCaretOffset(int offset, int alignment) {
 	if (caretOffset != offset) {
 		caretOffset = offset;
@@ -8781,7 +8781,7 @@
 		}
 	}		
 }
-/** 
+/**
  * Sets the left margin.
  * 
  * @param leftMargin the left margin.
@@ -9065,7 +9065,7 @@
 	setCaretLocation();
 	super.redraw();
 }
-/**
+/** 
  * Sets the tab stops of the specified lines.
  * <p>
  * Should not be called if a <code>LineStyleListener</code> has been set since the listener 
@@ -9248,15 +9248,15 @@
 	super.setOrientation(orientation);
 	int newOrientation = getOrientation();
 	if (oldOrientation != newOrientation) {
-		caretDirection = SWT.NULL;
-		resetCache(0, content.getLineCount());
-		setCaretLocation();
-		keyActionMap.clear();
-		createKeyBindings();
-		super.redraw();
+	caretDirection = SWT.NULL;
+	resetCache(0, content.getLineCount());
+	setCaretLocation();
+	keyActionMap.clear();
+	createKeyBindings();
+	super.redraw();
 	}
 }
-/** 
+/**
  * Sets the right margin.
  * 
  * @param rightMargin the right margin.
@@ -9475,20 +9475,20 @@
 		if (blockSelection && doBlock) {
 			setBlockSelectionOffset(start, end, sendEvent);
 		} else {
-			clearSelection(sendEvent);
-			if (length < 0) {
-				selectionAnchor = selection.y = end;
+		clearSelection(sendEvent);
+		if (length < 0) {
+			selectionAnchor = selection.y = end;
 				selection.x = start;
 				setCaretOffset(start, PREVIOUS_OFFSET_TRAILING);
-			} else {
-				selectionAnchor = selection.x = start;
+		} else {
+			selectionAnchor = selection.x = start;
 				selection.y = end;
 				setCaretOffset(end, PREVIOUS_OFFSET_TRAILING);
-			}
-			internalRedrawRange(selection.x, selection.y - selection.x);
+		}
+		internalRedrawRange(selection.x, selection.y - selection.x);
 			sendAccessibleTextCaretMoved();
-		}
 	}
+	}
 }
 /** 
  * Sets the selection.
@@ -9727,7 +9727,7 @@
 			}
 			if (partialTopIndex <= lineEnd && lineEnd <= partialBottomIndex) {
 				bottom = getLinePixel(lineEnd + 1);
-			}
+				}
 			if (!isFixedLineHeight() && bottom != expectedBottom) {
 				bottom = clientAreaHeight;
 			}
@@ -9944,7 +9944,7 @@
 	} 
 	scrollVertical(pixel, true);
 }
-/** 
+/**
  * Sets the top margin.
  * 
  * @param topMargin the top margin.
@@ -10057,7 +10057,7 @@
 		scrolled = scrollVertical(rect.y - topMargin, true);
 	} else if (rect.y + rect.height > clientAreaHeight - bottomMargin) {
 		if (clientAreaHeight - topMargin - bottomMargin <= 0) {
-			scrolled = scrollVertical(rect.y - topMargin, true);
+		scrolled = scrollVertical(rect.y - topMargin, true);
 		} else {
 			scrolled = scrollVertical(rect.y + rect.height - (clientAreaHeight - bottomMargin), true);
 		}
Index: org/eclipse/swt/custom/CTabItem.java
===================================================================
--- org/eclipse/swt/custom/CTabItem.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/CTabItem.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -131,7 +131,7 @@
 	shortenedText = null;
 	font = null;
 }
-
+	
 /**
  * Returns a rectangle describing the receiver's size and location
  * relative to its parent.
@@ -299,10 +299,10 @@
 		    	selectedControl = parent.getItem(selectedIndex).getControl();
 		    }
 		    if (this.control != selectedControl) {
-		    	this.control.setVisible(false);
-		    }
+			this.control.setVisible(false);
 		}
 	}
+	}
 }
 /**
  * Sets the image that is displayed if the tab item is disabled.
Index: org/eclipse/swt/custom/BidiSegmentEvent.java
===================================================================
--- org/eclipse/swt/custom/BidiSegmentEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/BidiSegmentEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -58,7 +58,7 @@
  * 		"R4R5R6". 
  *		visual line = "R3R2R1" + "R6R5R4"
  * </pre>
- * 
+ *
  * <p>
  * The segments and segementsChars fields can be used together to obtain different
  * types of bidi reordering and text display. The application can use these two fields
@@ -89,7 +89,7 @@
 	 * bidi segments, see above 
 	 */
 	public int[] segments;
-
+		
 	/** 
 	 * characters to be used in the segment boundaries (optional)
 	 * 
Index: org/eclipse/swt/custom/StyledTextRenderer.java
===================================================================
--- org/eclipse/swt/custom/StyledTextRenderer.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/StyledTextRenderer.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -651,7 +651,7 @@
 			StyleRange style = styles[i];
 			newRanges[j] = style.start;
 			newRanges[j + 1] = style.length;
-		}
+		}		
 	}
 	if (start > newRanges[0]) {
 		newRanges[1] = newRanges[0] + newRanges[1] - start;
@@ -693,14 +693,14 @@
 		System.arraycopy(styles, rangeStart, newStyles, 0, newStyles.length);
 	}
 	if (includeRanges || ranges == null) {
-		StyleRange style = newStyles[0];
-		if (start > style.start) {
+	StyleRange style = newStyles[0];
+	if (start > style.start) {
 			newStyles[0] = style = (StyleRange)style.clone();
-			style.length = style.start + style.length - start;
-			style.start = start;
-		}
-		style = newStyles[newStyles.length - 1];
-		if (end < style.start + style.length - 1) {
+		style.length = style.start + style.length - start;
+		style.start = start;
+	}
+	style = newStyles[newStyles.length - 1];
+	if (end < style.start + style.length - 1) {
 			newStyles[newStyles.length - 1] = style = (StyleRange)style.clone();
 			style.length = end - style.start + 1;
 		}
Index: org/eclipse/swt/custom/CCombo.java
===================================================================
--- org/eclipse/swt/custom/CCombo.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/CCombo.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -59,7 +59,7 @@
 	Shell _shell;
 	
 	static final String PACKAGE_PREFIX = "org.eclipse.swt.custom."; //$NON-NLS-1$
-
+	
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -949,12 +949,12 @@
 		public void getKeyboardShortcut(AccessibleEvent e) {
 			String shortcut = null;
 			String text = getAssociatedLabel ();
-			if (text != null) {
-				char mnemonic = _findMnemonic (text);
-				if (mnemonic != '\0') {
-					shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+				if (text != null) {
+					char mnemonic = _findMnemonic (text);
+					if (mnemonic != '\0') {
+						shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+					}
 				}
-			}
 			e.result = shortcut;
 		}
 		public void getHelp (AccessibleEvent e) {
Index: org/eclipse/swt/custom/CTabFolder.java
===================================================================
--- org/eclipse/swt/custom/CTabFolder.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/CTabFolder.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -128,7 +128,7 @@
 	/* External Listener management */
 	CTabFolder2Listener[] folderListeners = new CTabFolder2Listener[0];
 	// support for deprecated listener mechanism
-	CTabFolderListener[] tabListeners = new CTabFolderListener[0];
+	CTabFolderListener[] tabListeners = new CTabFolderListener[0]; 
 	
 	/* Selected item appearance */
 	Image selectionBgImage;
@@ -139,7 +139,7 @@
 	Color selectionBackground;
 	
 	/* Unselected item appearance */
-	Color[] gradientColors; 
+	Color[] gradientColors;
 	int[] gradientPercents;
 	boolean gradientVertical;
 	boolean showUnselectedImage = true;
@@ -179,7 +179,7 @@
 	// internal constants
 	static final int DEFAULT_WIDTH = 64;
 	static final int DEFAULT_HEIGHT = 64;
-	
+
 	static final int SELECTION_FOREGROUND = SWT.COLOR_LIST_FOREGROUND;
 	static final int SELECTION_BACKGROUND = SWT.COLOR_LIST_BACKGROUND;
 	
@@ -508,7 +508,7 @@
 	updateItems();
 	redrawTabs();
 }
-
+	
 /**
  * Returns <code>true</code> if the receiver's border is visible.
  *
@@ -756,7 +756,7 @@
 }
 /**
  * Returns the receiver's renderer.
- * 
+ *
  * @return the receiver's renderer
  *
  * @exception SWTException <ul>
@@ -1430,7 +1430,7 @@
 				int index = indexOf(item);
 				if (item.showing){
 				    	int oldSelectedIndex = selectedIndex;
-				    	setSelection(index, true);
+					setSelection(index, true);
 				    	if (oldSelectedIndex == selectedIndex) {
 				    	    /* If the click is on the selected tabitem, then set focus to the tabfolder */
 				    	    forceFocus();
@@ -1496,7 +1496,7 @@
 						item.state |= SWT.HOT;
 						redraw(item.x, item.y, item.width, item.height, false);
 					}
-				}
+				} 
 				if (i != selectedIndex && item.closeImageState != SWT.BACKGROUND && !close) {
 					item.closeImageState = SWT.BACKGROUND;
 					redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);
@@ -1730,12 +1730,12 @@
 	
 	gc.setFont(gcFont);
 	gc.setForeground(gcForeground);
-	gc.setBackground(gcBackground);	
+	gc.setBackground(gcBackground);
 	
 	renderer.draw(CTabFolderRenderer.PART_MAX_BUTTON, maxImageState, maxRect, gc);
 	renderer.draw(CTabFolderRenderer.PART_MIN_BUTTON, minImageState, minRect, gc);
 	renderer.draw(CTabFolderRenderer.PART_CHEVRON_BUTTON, chevronImageState, chevronRect, gc);
-
+	
 	gc.setFont(gcFont);
 	gc.setForeground(gcForeground);
 	gc.setBackground(gcBackground);	
@@ -2005,25 +2005,25 @@
 	}
 	
 	// Are these settings the same as before?
-	if ((gradientColors != null) && (colors != null) && 
-		(gradientColors.length == colors.length)) {
-		boolean same = false;
-		for (int i = 0; i < gradientColors.length; i++) {
-		    if (gradientColors[i] == null) {
-			same = colors[i] == null;
-		    } else {
-			same = gradientColors[i].equals(colors[i]);
-		    }
-		    if (!same) break;
+		if ((gradientColors != null) && (colors != null) && 
+			(gradientColors.length == colors.length)) {
+			boolean same = false;
+			for (int i = 0; i < gradientColors.length; i++) {
+				if (gradientColors[i] == null) {
+					same = colors[i] == null;
+				} else {
+					same = gradientColors[i].equals(colors[i]);
+				}
+				if (!same) break;
+			}
+			if (same) {
+				for (int i = 0; i < gradientPercents.length; i++) {
+					same = gradientPercents[i] == percents[i];
+					if (!same) break;
+				}
+			}
+			if (same && this.gradientVertical == vertical) return;
 		}
-		if (same) {
-		    for (int i = 0; i < gradientPercents.length; i++) {
-			same = gradientPercents[i] == percents[i];
-			if (!same) break;
-		    }
-		}
-		if (same && this.gradientVertical == vertical) return;
-	}
 	// Store the new settings
 	if (colors == null) {
 		gradientColors = null;
@@ -2103,7 +2103,7 @@
 		int top = onBottom ? size.y - borderBottom - tabHeight: borderTop + 1;
 		redraw(left, top, right - left, tabHeight, false); 
 	}
-
+	
 	// min button
 	oldX = minRect.x;
 	oldY = minRect.y;
@@ -2394,7 +2394,7 @@
 		tabAreaWidth -= rightSize.x + 3;
 	}
 	tabAreaWidth = Math.max(0, tabAreaWidth);
-
+	
 	// First, try the minimum tab size at full compression.
 	int minWidth = 0;
 	int[] minWidths = new int[items.length];	
@@ -3358,9 +3358,9 @@
 }
 boolean updateTabHeight(boolean force){
 	int oldHeight = tabHeight;
-	GC gc = new GC(this);
+		GC gc = new GC(this);
 	tabHeight = renderer.computeSize(CTabFolderRenderer.PART_HEADER, SWT.NONE, gc, SWT.DEFAULT, SWT.DEFAULT).y;
-	gc.dispose();
+		gc.dispose();
 	if (!force && tabHeight == oldHeight) return false;
 	oldSize = null;
 	notifyListeners(SWT.Resize, new Event());
Index: org/eclipse/swt/custom/LineStyleEvent.java
===================================================================
--- org/eclipse/swt/custom/LineStyleEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/LineStyleEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -61,7 +61,7 @@
 	 */
 	public int indent;
 
-	/**
+	/** 
 	 * line wrap indent (input, output)
 	 * 
 	 * @since 3.6
@@ -86,7 +86,7 @@
 	 * @since 3.2
 	 */
 	public int bulletIndex;
-
+	
 	/**
 	 * line tab stops (output)
 	 * @since 3.6
Index: org/eclipse/swt/custom/TableEditor.java
===================================================================
--- org/eclipse/swt/custom/TableEditor.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/custom/TableEditor.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -113,7 +113,7 @@
 	Rectangle rect = item.getImageBounds(column);
 	if (rect.width != 0) {
 		int imageGap = Math.max(rect.x - cell.x, 0);
-		cell.x = rect.x + rect.width;
+	cell.x = rect.x + rect.width;
 		cell.width -= (imageGap + rect.width);
 	}
 	Rectangle area = table.getClientArea();
Index: org/eclipse/swt/internal/image/TIFFFileFormat.java
===================================================================
--- org/eclipse/swt/internal/image/TIFFFileFormat.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/TIFFFileFormat.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -54,8 +54,8 @@
 			(header[4] & 0xFF) | ((header[5] & 0xFF) << 8) | ((header[6] & 0xFF) << 16) | ((header[7] & 0xFF) << 24) :
 			(header[7] & 0xFF) | ((header[6] & 0xFF) << 8) | ((header[5] & 0xFF) << 16) | ((header[4] & 0xFF) << 24);
 		while (offset != 0) {
-			file.seek(offset);
-			TIFFDirectory directory = new TIFFDirectory(file, isLittleEndian, loader);
+		file.seek(offset);
+		TIFFDirectory directory = new TIFFDirectory(file, isLittleEndian, loader);
 			int [] nextIFDOffset = new int[1];
 			ImageData image = directory.read(nextIFDOffset);
 			offset = nextIFDOffset[0];
Index: org/eclipse/swt/internal/image/PngEncoder.java
===================================================================
--- org/eclipse/swt/internal/image/PngEncoder.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/PngEncoder.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -300,7 +300,7 @@
 				}
 			
 			}
-			
+		
 			os.write(lineBytes);
 			
 		}
Index: org/eclipse/swt/internal/image/PNGFileFormat.java
===================================================================
--- org/eclipse/swt/internal/image/PNGFileFormat.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/PNGFileFormat.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -280,7 +280,7 @@
 					System.arraycopy(data, y * srcBytesPerLine, imageData.data, y * destBytesPerLine, srcBytesPerLine);
 				}
 			} else {
-				imageData.data = data;
+			imageData.data = data;
 			}
 			break;
 	}
Index: org/eclipse/swt/internal/Library.java
===================================================================
--- org/eclipse/swt/internal/Library.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/Library.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -38,7 +38,7 @@
 
 	static final String SEPARATOR;
 	static final String DELIMITER;
-	
+
 	/* 64-bit support */
 	static final boolean IS_64 = longConst() == (long /*int*/)longConst();
 	static final String SUFFIX_64 = "-64";	//$NON-NLS-1$
@@ -211,12 +211,12 @@
 	if (prop == null) prop = System.getProperty ("com.ibm.vm.bitmode"); //$NON-NLS-1$
 	if (prop != null) {
 		if ("32".equals (prop) && IS_64) { //$NON-NLS-1$
-			throw new UnsatisfiedLinkError ("Cannot load 64-bit SWT libraries on 32-bit JVM"); //$NON-NLS-1$
-		}
+				throw new UnsatisfiedLinkError ("Cannot load 64-bit SWT libraries on 32-bit JVM"); //$NON-NLS-1$
+			 }
 		if ("64".equals (prop) && !IS_64) { //$NON-NLS-1$
-			throw new UnsatisfiedLinkError ("Cannot load 32-bit SWT libraries on 64-bit JVM"); //$NON-NLS-1$
+				throw new UnsatisfiedLinkError ("Cannot load 32-bit SWT libraries on 64-bit JVM"); //$NON-NLS-1$
+			}		
 		}
-	}
 	
 	/* Compute the library name and mapped name */
 	String libName1, libName2, mappedName1, mappedName2;
@@ -255,7 +255,7 @@
 	/* Try loading library from java library path */
 	if (load (libName1, message)) return;
 	if (mapName && load (libName2, message)) return;
-
+	
 	/* Try loading library from the tmp directory if swt library path is not specified */
 	String fileName1 = mappedName1;
 	String fileName2 = mappedName2;
Index: org/eclipse/swt/internal/BidiUtil.java
===================================================================
--- org/eclipse/swt/internal/BidiUtil.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/BidiUtil.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -512,13 +512,13 @@
 public static void setKeyboardLanguage(int language) {
 	if (language == getKeyboardLanguage()) return;
 	boolean bidi = language == KEYBOARD_BIDI; 
-	long /*int*/[] list = getKeyboardLanguageList();
-	for (int i=0; i<list.length; i++) {
+		long /*int*/[] list = getKeyboardLanguageList();
+		for (int i=0; i<list.length; i++) {
 		if (bidi == isBidiLang(list[i])) {
-			OS.ActivateKeyboardLayout(list[i], 0);
-			return;
+				OS.ActivateKeyboardLayout(list[i], 0);
+				return;
+			}
 		}
-	}
 }
 /**
  * Sets the orientation (writing order) of the specified control. Text will 
Index: org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java
===================================================================
--- org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -27,11 +27,11 @@
 	/** @field accessor=item.pszText,cast=(LPTSTR) */
 	public long /*int*/ pszText;
   	/** @field accessor=item.cchTextMax */
-	public int cchTextMax;
+  	public int cchTextMax;
   	/** @field accessor=item.iImage */
-	public int iImage;
+  	public int iImage;
   	/** @field accessor=item.iSelectedImage */
-	public int iSelectedImage;
+  	public int iSelectedImage;
 	/** @field accessor=item.cChildren */
 	public int cChildren;
 	/** @field accessor=item.lParam */
Index: org/eclipse/swt/internal/win32/OS.java
===================================================================
--- org/eclipse/swt/internal/win32/OS.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/OS.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.internal.win32;
 
@@ -13,11 +14,85 @@
 
 import org.eclipse.swt.internal.*;
 
+// <QFS>
+import java.util.HashSet;
+import java.util.Set;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 public class OS extends C {
 	static {
 		Library.loadLibrary ("swt"); //$NON-NLS-1$
 	}
-	
+
+    // <QFS>
+    // {{{ QF-Log, statics
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.internal.win32.OS");
+
+
+    // key = int Windows-Event
+    private static Set importantEvents = new HashSet();
+    private static Set unimportantEvents = new HashSet();
+    static {
+        importantEvents.add(new Integer(OS.WM_LBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_LBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_LBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_MBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_MBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_MBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_RBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_RBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_RBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_MOUSEMOVE));
+        importantEvents.add(new Integer(OS.WM_ACTIVATE));
+        importantEvents.add(new Integer(OS.WM_KEYDOWN));
+        importantEvents.add(new Integer(OS.WM_KEYUP));
+        importantEvents.add(new Integer(OS.WM_CHAR)); // why do we get that one when KEYDOWN is suppressed? where does it come from?
+        // importantEvents.add(new Integer(OS.WM_GETDLGCODE)); // why do we get that one when KEYDOWN is suppressed? where does it come from?
+        importantEvents.add(new Integer(OS.WM_NCLBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_SYSCOMMAND)); // -> menubar
+        // importantEvents.add(new Integer(OS.WM_SETCURSOR));
+        importantEvents.add(new Integer(OS.WM_MENUSELECT));
+        importantEvents.add(new Integer(OS.WM_INITMENUPOPUP));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+
+        unimportantEvents.add(new Integer(OS.WM_PAINT));
+        unimportantEvents.add(new Integer(OS.WM_GETFONT));
+        unimportantEvents.add(new Integer(OS.WM_NCACTIVATE));
+        unimportantEvents.add(new Integer(OS.WM_NCCALCSIZE));
+        unimportantEvents.add(new Integer(OS.WM_NCHITTEST));
+        unimportantEvents.add(new Integer(OS.WM_NOTIFY));
+        unimportantEvents.add(new Integer(OS.WM_SETCURSOR));
+        unimportantEvents.add(new Integer(OS.WM_SETFONT));
+        unimportantEvents.add(new Integer(OS.WM_ERASEBKGND));
+        unimportantEvents.add(new Integer(OS.WM_TIMER));
+        unimportantEvents.add(new Integer(OS.WM_ENTERIDLE));
+    }
+
+    static ThreadLocal replayOverride = new ThreadLocal ();
+    public static void setReplaying(boolean replaying, int replayPos)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplaying(boolean,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", replayPos: ").add(replayPos)).log(Log.MTD);
+        }
+        replayOverride.set(replaying ? new Integer (replayPos) : null);
+    }
+    // }}}
+    // </QFS>
+
 	/*
 	* SWT Windows flags
 	*/
@@ -43,7 +118,7 @@
 	public static final int VER_PLATFORM_WIN32_WINDOWS = 1;
 	public static final int VER_PLATFORM_WIN32_NT = 2;
 	public static final int VER_PLATFORM_WIN32_CE = 3;
-	
+
 	/* Forward references */
 	public static final int HEAP_ZERO_MEMORY = 0x8;
 	public static final int ACTCTX_FLAG_RESOURCE_NAME_VALID = 0x00000008;
@@ -53,7 +128,7 @@
 	public static final int SM_IMMENABLED = 0x52;
 	public static final int LANG_KOREAN = 0x12;
 	public static final int MAX_PATH = 260;
-	
+
 	/* Get the Windows version and the flags */
 	static {
 		/*
@@ -61,7 +136,7 @@
 		* and then the ANSI version.  The UNICODE version
 		* is present on all versions of Windows but is not
 		* implemented on Win95/98/ME.
-		* 
+		*
 		* NOTE: The value of OSVERSIONINFO.sizeof cannot
 		* be static final because it relies on the Windows
 		* platform version to be initialized and IsUnicode
@@ -77,7 +152,7 @@
 			OS.GetVersionExA ((OSVERSIONINFOA)info);
 		}
 		OSVERSIONINFO.sizeof = info.dwOSVersionInfoSize;
-		
+
 		IsWin32s = info.dwPlatformId == VER_PLATFORM_WIN32s;
 		IsWin95 = info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
 		IsWinNT = info.dwPlatformId == VER_PLATFORM_WIN32_NT;
@@ -84,7 +159,7 @@
 		IsWinCE = info.dwPlatformId == VER_PLATFORM_WIN32_CE;
 		IsSP = IsSP();
 		IsPPC = IsPPC();
-		IsHPC = IsWinCE && !IsPPC && !IsSP;	
+		IsHPC = IsWinCE && !IsPPC && !IsSP;
 		WIN32_MAJOR = info.dwMajorVersion;
 		WIN32_MINOR = info.dwMinorVersion;
 		WIN32_VERSION = VERSION (WIN32_MAJOR, WIN32_MINOR);
@@ -101,7 +176,7 @@
 				long /*int*/ hHeap = OS.GetProcessHeap ();
 				int byteCount = buffer.length () * (OS.IsUnicode ? 2 : 1);
 				long /*int*/ pszText = OS.HeapAlloc (hHeap, HEAP_ZERO_MEMORY, byteCount);
-				OS.MoveMemory (pszText, buffer, byteCount);	
+				OS.MoveMemory (pszText, buffer, byteCount);
 				ACTCTX pActCtx = new ACTCTX ();
 				pActCtx.cbSize = ACTCTX.sizeof;
 				pActCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_SET_PROCESS_DEFAULT;
@@ -118,7 +193,7 @@
 				*/
 			}
 		}
-		
+
 		/* Make the process DPI aware for Windows Vista */
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) OS.SetProcessDPIAware ();
 
@@ -126,7 +201,7 @@
 		boolean dbcsEnabled = OS.GetSystemMetrics (SM_DBCSENABLED) != 0;
 		boolean immEnabled = OS.GetSystemMetrics (SM_IMMENABLED) != 0;
 		IsDBLocale = dbcsEnabled || immEnabled;
-		
+
 		/*
 		* Bug in Windows.  On Korean Windows XP when the Text
 		* Services Framework support for legacy applications
@@ -135,7 +210,7 @@
 		* to move the composition window outside of the client
 		* area, Windows crashes.  The fix is to disable legacy
 		* support.
-		* 
+		*
 		* Note: The bug is fixed in Service Pack 2.
 		*/
 		if (!OS.IsWinCE && OS.WIN32_VERSION == OS.VERSION (5, 1)) {
@@ -151,7 +226,7 @@
 			}
 		}
 	}
-	
+
 	/* Get the COMCTL32.DLL version */
 	static {
 		DLLVERSIONINFO dvi = new DLLVERSIONINFO ();
@@ -174,7 +249,7 @@
 		COMCTL32_MINOR = dvi.dwMinorVersion;
 		COMCTL32_VERSION = VERSION (COMCTL32_MAJOR, COMCTL32_MINOR);
 	}
-	
+
 	/* Get the Shell32.DLL version */
 	static {
 		DLLVERSIONINFO dvi = new DLLVERSIONINFO ();
@@ -201,7 +276,7 @@
 	static final int SYS_COLOR_INDEX_FLAG = OS.IsWinCE ? 0x40000000 : 0x0;
 
 	/*
-	* NOTE:  There is a bug in JVM 1.2 where loading 
+	* NOTE:  There is a bug in JVM 1.2 where loading
 	* a class with a large number of constants causes
 	* a segment fault to occur sometime later after
 	* the class is loaded.  The fix is to break the
@@ -275,7 +350,7 @@
 	public static final int BFFM_VALIDATEFAILED = IsUnicode ? 0x4 : 0x3;
 	public static final int BFFM_VALIDATEFAILEDW = 0x4;
 	public static final int BFFM_VALIDATEFAILEDA = 0x3;
-	public static final int BF_ADJUST = 0x2000; 
+	public static final int BF_ADJUST = 0x2000;
 	public static final int BF_LEFT = 0x0001;
 	public static final int BF_TOP = 0x0002;
 	public static final int BF_RIGHT = 0x0004;
@@ -578,7 +653,7 @@
 	public static final int DT_VCENTER = 4;
 	public static final int DT_WORDBREAK = 0x10;
 	public static final int DTM_FIRST = 0x1000;
-	public static final int DTM_GETSYSTEMTIME = DTM_FIRST + 1; 
+	public static final int DTM_GETSYSTEMTIME = DTM_FIRST + 1;
 	public static final int DTM_GETIDEALSIZE = DTM_FIRST + 15;
 	public static final int DTM_SETFORMAT = IsUnicode ? DTM_FIRST + 50 : DTM_FIRST + 5;
 	public static final int DTM_SETSYSTEMTIME = DTM_FIRST + 2;
@@ -592,7 +667,7 @@
 	public static final int DTS_TIMEFORMAT = 0x0009;
 	public static final int DTS_UPDOWN = 0x0001;
 	public static final int DWM_BB_ENABLE = 0x1;
-	public static final int DWM_BB_BLURREGION = 0x2; 
+	public static final int DWM_BB_BLURREGION = 0x2;
 	public static final int DWM_BB_TRANSITIONONMAXIMIZED = 0x4;
 	public static final int E_POINTER = 0x80004003;
 	public static final int EBP_NORMALGROUPBACKGROUND = 5;
@@ -971,9 +1046,9 @@
 	public static final int LOCALE_IDATE = 0x00000021;
 	public static final int LOCALE_ITIME = 0x00000023;
 	public static final int LOCALE_RETURN_NUMBER = 0x20000000; // #if(WINVER >= 0x0400)
-	public static final int LOCALE_S1159 = 0x00000028;	
-	public static final int LOCALE_S2359 = 0x00000029;	
-	public static final int LOCALE_SDECIMAL = 14;	
+	public static final int LOCALE_S1159 = 0x00000028;
+	public static final int LOCALE_S2359 = 0x00000029;
+	public static final int LOCALE_SDECIMAL = 14;
 	public static final int LOCALE_SISO3166CTRYNAME = 0x5a;
 	public static final int LOCALE_SISO639LANGNAME = 0x59;
 	public static final int LOCALE_SLONGDATE = 0x00000020;
@@ -1163,7 +1238,7 @@
 	public static final int MFS_GRAYED = 0x3;
 	public static final int MFT_RADIOCHECK = 0x200;
 	public static final int MFT_RIGHTJUSTIFY = 0x4000;
-	public static final int MFT_RIGHTORDER = 0x2000; 
+	public static final int MFT_RIGHTORDER = 0x2000;
 	public static final int MFT_SEPARATOR = 0x800;
 	public static final int MFT_STRING = 0x0;
 	public static final int MF_BYCOMMAND = 0x0;
@@ -1202,12 +1277,12 @@
 	public static final int MONITORINFOF_PRIMARY = 0x1;
 	public static final String MONTHCAL_CLASS = "SysMonthCal32"; //$NON-NLS-1$
 	public static final int MOUSEEVENTF_ABSOLUTE = 0x8000;
-	public static final int MOUSEEVENTF_LEFTDOWN = 0x0002; 
-	public static final int MOUSEEVENTF_LEFTUP = 0x0004; 
-	public static final int MOUSEEVENTF_MIDDLEDOWN = 0x0020; 
-	public static final int MOUSEEVENTF_MIDDLEUP = 0x0040; 
+	public static final int MOUSEEVENTF_LEFTDOWN = 0x0002;
+	public static final int MOUSEEVENTF_LEFTUP = 0x0004;
+	public static final int MOUSEEVENTF_MIDDLEDOWN = 0x0020;
+	public static final int MOUSEEVENTF_MIDDLEUP = 0x0040;
 	public static final int MOUSEEVENTF_MOVE = 0x0001;
-	public static final int MOUSEEVENTF_RIGHTDOWN = 0x0008; 
+	public static final int MOUSEEVENTF_RIGHTDOWN = 0x0008;
 	public static final int MOUSEEVENTF_RIGHTUP = 0x0010;
 	public static final int MOUSEEVENTF_VIRTUALDESK = 0x4000;
 	public static final int MOUSEEVENTF_WHEEL = 0x0800;
@@ -1316,7 +1391,7 @@
 	public static final int PBS_VERTICAL = 0x4;
 	public static final int PBS_NORMAL = 1;
 	public static final int PBS_HOT = 2;
-	public static final int PBS_PRESSED = 3; 
+	public static final int PBS_PRESSED = 3;
 	public static final int PBS_DISABLED = 4;
 	public static final int PBS_DEFAULTED = 5;
 	public static final int PBST_NORMAL = 0x0001;
@@ -1472,6 +1547,11 @@
 	public static final int SB_THUMBPOSITION = 0x4;
 	public static final int SB_THUMBTRACK = 0x5;
 	public static final int SB_TOP = 0x6;
+    // <QFS>
+    public static final int SB_LEFT = 0x6;
+    public static final int SB_PAGELEFT = 0x2;
+    public static final int SB_LINELEFT = 0x0;
+    // </QFS>
 	public static final int SB_VERT = 0x1;
 	public static final int SCF_ALL = 0x4;
 	public static final int SCF_DEFAULT = 0x0;
@@ -1656,7 +1736,7 @@
 	public static final int TBSTYLE_DROPDOWN = 0x8;
 	public static final int TBSTATE_ENABLED = 0x4;
 	public static final int TBSTYLE_AUTOSIZE = 0x10;
-	public static final int TBSTYLE_EX_DOUBLEBUFFER = 0x80; 
+	public static final int TBSTYLE_EX_DOUBLEBUFFER = 0x80;
 	public static final int TBSTYLE_EX_DRAWDDARROWS = 0x1;
 	public static final int TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0x10;
 	public static final int TBSTYLE_EX_MIXEDBUTTONS = 0x8;
@@ -1828,7 +1908,7 @@
 	public static final int TTM_DELTOOL = IsUnicode ? 0x433 : 0x405;
 	public static final int TTM_GETTOOLINFO = 0x400 + (IsUnicode ? 53 : 8);
 	public static final int TTM_NEWTOOLRECT = 0x400 + (IsUnicode ? 52 : 6);
-	public static final int TTM_POP = 0x400 + 28; 
+	public static final int TTM_POP = 0x400 + 28;
 	public static final int TTM_SETDELAYTIME = 0x400 + 3;
 	public static final int TTM_SETMAXTIPWIDTH = 0x418;
 	public static final int TTM_SETTITLEA = 0x400 + 32;
@@ -1849,6 +1929,9 @@
 	public static final int TTS_NOFADE = 0x20;
 	public static final int TTS_NOPREFIX = 0x02;
 	public static final int TV_FIRST = 0x1100;
+        // <QFS>
+        public static final int TVM_SETSCROLLTIME = TV_FIRST + 33;
+        // </QFS>
 	public static final int TVE_COLLAPSE = 0x1;
 	public static final int TVE_COLLAPSERESET = 0x8000;
 	public static final int TVE_EXPAND = 0x2;
@@ -1912,7 +1995,6 @@
 	public static final int TVM_SETINSERTMARK = 0x111a;
 	public static final int TVM_SETITEM = IsUnicode ? 0x113f : 0x110d;
 	public static final int TVM_SETITEMHEIGHT = TV_FIRST + 27;
-	public static final int TVM_SETSCROLLTIME = TV_FIRST + 33;
 	public static final int TVM_SETTEXTCOLOR = 0x111e;
 	public static final int TVM_SORTCHILDREN = TV_FIRST + 19;
 	public static final int TVM_SORTCHILDRENCB = TV_FIRST + 21;
@@ -2078,6 +2160,11 @@
 	public static final int WHITE_BRUSH = 0;
 	public static final int WHITENESS = 0x00FF0062;
 	public static final int WM_ACTIVATE = 0x6;
+    // <QFS>
+    public static final int WM_SETTEXT = 0xC;
+    public static final int WM_GETTEXT = 0xD;
+    public static final int WM_GETTEXTLENGTH = 0xE;
+    // </QFS>
 	public static final int WM_ACTIVATEAPP = 0x1c;
 	public static final int WM_APP = 0x8000;
 	public static final int WM_DWMCOLORIZATIONCOLORCHANGED = 0x320;
@@ -2090,7 +2177,7 @@
 	public static final int WM_COMMAND = 0x111;
 	public static final int WM_CONTEXTMENU = 0x7b;
 	public static final int WM_COPY = 0x301;
-	public static final int WM_CREATE = 0x0001;	
+	public static final int WM_CREATE = 0x0001;
 	public static final int WM_CTLCOLORBTN = 0x135;
 	public static final int WM_CTLCOLORDLG = 0x136;
 	public static final int WM_CTLCOLOREDIT = 0x133;
@@ -2147,7 +2234,13 @@
 	public static final int WM_NCACTIVATE = 0x86;
 	public static final int WM_NCCALCSIZE = 0x83;
 	public static final int WM_NCHITTEST = 0x84;
+    // <QFS>
+    public static final int WM_NCMOUSEMOVE = 0x00A0;
+    // </QFS>
 	public static final int WM_NCLBUTTONDOWN = 0x00A1;
+    // <QFS>
+    public static final int WM_NCLBUTTONUP = 0x00A2;
+    // </QFS>
 	public static final int WM_NCPAINT = 0x85;
 	public static final int WM_NOTIFY = 0x4e;
 	public static final int WM_NULL = 0x0;
@@ -2169,7 +2262,6 @@
 	public static final int WM_SETFONT = 0x30;
 	public static final int WM_SETICON = 0x80;
 	public static final int WM_SETREDRAW = 0xb;
-	public static final int WM_SETTEXT = 12;
 	public static final int WM_SETTINGCHANGE = 0x1A;
 	public static final int WM_SHOWWINDOW = 0x18;
 	public static final int WM_SIZE = 0x5;
@@ -2229,11 +2321,197 @@
 	public static final int XBUTTON1 = 0x1;
 	public static final int XBUTTON2 = 0x2;
 	public static final int X509_ASN_ENCODING = 1;
-	
+
+    // <QFS>
+    public static final int WA_INACTIVE = 0;
+    public static final int WA_ACTIVE = 1;
+    public static final int WA_CLICKACTIVE = 2;
+    // </QFS>
+
 public static int VERSION (int major, int minor) {
 	return major << 16 | minor;
 }
 
+// <QFS>
+    // {{{ getWinMsgType
+
+    public final static String getWinMsgType(long /*int*/ msg, boolean[] hasMatch)
+    {
+        String msgtype = null;
+        switch ((int) msg) {
+            // {{{ big case to get name
+
+        case OS.WM_SETTEXT: msgtype = "WM_SETTEXT"; break;
+        case OS.WM_GETTEXT: msgtype = "WM_GETTEXT"; break;
+        case OS.WM_GETTEXTLENGTH: msgtype = "WM_GETTEXTLENGTH"; break;
+        case OS.WM_ACTIVATE: msgtype = "WM_ACTIVATE"; break;
+        case OS.WM_ACTIVATEAPP: msgtype = "WM_ACTIVATEAPP"; break;
+        case OS.WM_APP: msgtype = "WM_APP"; break;
+        case OS.WM_CANCELMODE: msgtype = "WM_CANCELMODE"; break;
+        case OS.WM_CAPTURECHANGED: msgtype = "WM_CAPTURECHANGED"; break;
+        case OS.WM_CHANGEUISTATE: msgtype = "WM_CHANGEUISTATE"; break;
+        case OS.WM_CHAR: msgtype = "WM_CHAR"; break;
+        case OS.WM_CLEAR: msgtype = "WM_CLEAR"; break;
+        case OS.WM_CLOSE: msgtype = "WM_CLOSE"; break;
+        case OS.WM_COMMAND: msgtype = "WM_COMMAND"; break;
+        case OS.WM_CONTEXTMENU: msgtype = "WM_CONTEXTMENU"; break;
+        case OS.WM_COPY: msgtype = "WM_COPY"; break;
+        case OS.WM_CREATE: msgtype = "WM_CREATE"; break;
+        case OS.WM_CTLCOLORBTN: msgtype = "WM_CTLCOLORBTN"; break;
+        case OS.WM_CTLCOLORDLG: msgtype = "WM_CTLCOLORDLG"; break;
+        case OS.WM_CTLCOLOREDIT: msgtype = "WM_CTLCOLOREDIT"; break;
+        case OS.WM_CTLCOLORLISTBOX: msgtype = "WM_CTLCOLORLISTBOX"; break;
+        case OS.WM_CTLCOLORMSGBOX: msgtype = "WM_CTLCOLORMSGBOX"; break;
+        case OS.WM_CTLCOLORSCROLLBAR: msgtype = "WM_CTLCOLORSCROLLBAR"; break;
+        case OS.WM_CTLCOLORSTATIC: msgtype = "WM_CTLCOLORSTATIC"; break;
+        case OS.WM_CUT: msgtype = "WM_CUT"; break;
+        case OS.WM_DEADCHAR: msgtype = "WM_DEADCHAR"; break;
+        case OS.WM_DESTROY: msgtype = "WM_DESTROY"; break;
+        case OS.WM_DRAWITEM: msgtype = "WM_DRAWITEM"; break;
+        case OS.WM_ENDSESSION: msgtype = "WM_ENDSESSION"; break;
+        case OS.WM_ENTERIDLE: msgtype = "WM_ENTERIDLE"; break;
+        case OS.WM_ERASEBKGND: msgtype = "WM_ERASEBKGND"; break;
+        case OS.WM_GETDLGCODE: msgtype = "WM_GETDLGCODE"; break;
+        case OS.WM_GETFONT: msgtype = "WM_GETFONT"; break;
+            //      case OS.WM_GETICON: msgtype = "WM_GETICON"; break;
+        case OS.WM_GETOBJECT: msgtype = "WM_GETOBJECT"; break;
+        case OS.WM_GETMINMAXINFO: msgtype = "WM_GETMINMAXINFO"; break;
+        case OS.WM_HELP: msgtype = "WM_HELP"; break;
+        case OS.WM_HOTKEY: msgtype = "WM_HOTKEY"; break;
+        case OS.WM_HSCROLL: msgtype = "WM_HSCROLL"; break;
+        case OS.WM_IME_CHAR: msgtype = "WM_IME_CHAR"; break;
+        case OS.WM_IME_COMPOSITION: msgtype = "WM_IME_COMPOSITION"; break;
+        case OS.WM_INITDIALOG: msgtype = "WM_INITDIALOG"; break;
+        case OS.WM_INITMENUPOPUP: msgtype = "WM_INITMENUPOPUP"; break;
+        case OS.WM_INPUTLANGCHANGE: msgtype = "WM_INPUTLANGCHANGE"; break;
+        case OS.WM_KEYDOWN: msgtype = "WM_KEYDOWN"; break;
+            // case OS.WM_KEYFIRST: msgtype = "WM_KEYFIRST"; break;
+        case OS.WM_KEYLAST: msgtype = "WM_KEYLAST"; break;
+        case OS.WM_KEYUP: msgtype = "WM_KEYUP"; break;
+        case OS.WM_KILLFOCUS: msgtype = "WM_KILLFOCUS"; break;
+        case OS.WM_LBUTTONDBLCLK: msgtype = "WM_LBUTTONDBLCLK"; break;
+        case OS.WM_LBUTTONDOWN: msgtype = "WM_LBUTTONDOWN"; break;
+        case OS.WM_LBUTTONUP: msgtype = "WM_LBUTTONUP"; break;
+        case OS.WM_MBUTTONDBLCLK: msgtype = "WM_MBUTTONDBLCLK"; break;
+        case OS.WM_MBUTTONDOWN: msgtype = "WM_MBUTTONDOWN"; break;
+        case OS.WM_MBUTTONUP: msgtype = "WM_MBUTTONUP"; break;
+        case OS.WM_MEASUREITEM: msgtype = "WM_MEASUREITEM"; break;
+        case OS.WM_MENUCHAR: msgtype = "WM_MENUCHAR"; break;
+        case OS.WM_MENUSELECT: msgtype = "WM_MENUSELECT"; break;
+        case OS.WM_MOUSEACTIVATE: msgtype = "WM_MOUSEACTIVATE"; break;
+        case OS.WM_MOUSEMOVE: msgtype = "WM_MOUSEMOVE"; break;
+        case OS.WM_MOUSEHOVER: msgtype = "WM_MOUSEHOVER"; break;
+        case OS.WM_MOUSELEAVE: msgtype = "WM_MOUSELEAVE"; break;
+        case OS.WM_MOUSEWHEEL: msgtype = "WM_MOUSEWHEEL"; break;
+        case OS.WM_MOUSELAST: msgtype = "WM_MOUSELAST"; break;
+        case OS.WM_MOVE: msgtype = "WM_MOVE"; break;
+        case OS.WM_NCACTIVATE: msgtype = "WM_NCACTIVATE"; break;
+        case OS.WM_NCCALCSIZE: msgtype = "WM_NCCALCSIZE"; break;
+        case OS.WM_NCMOUSEMOVE: msgtype = "WM_NCMOUSEMOVE"; break;
+        case OS.WM_NCHITTEST: msgtype = "WM_NCHITTEST"; break;
+        case OS.WM_NCLBUTTONDOWN: msgtype = "WM_NCLBUTTONDOWN"; break;
+        case OS.WM_NCLBUTTONUP: msgtype = "WM_NCLBUTTONUP"; break;
+        case OS.WM_NOTIFY: msgtype = "WM_NOTIFY"; break;
+        case OS.WM_NULL: msgtype = "WM_NULL"; break;
+        case OS.WM_PAINT: msgtype = "WM_PAINT"; break;
+        case OS.WM_PALETTECHANGED: msgtype = "WM_PALETTECHANGED"; break;
+        case OS.WM_PARENTNOTIFY: msgtype = "WM_PARENTNOTIFY"; break;
+        case OS.WM_PASTE: msgtype = "WM_PASTE"; break;
+        case OS.WM_PRINTCLIENT: msgtype = "WM_PRINTCLIENT"; break;
+        case OS.WM_QUERYENDSESSION: msgtype = "WM_QUERYENDSESSION"; break;
+        case OS.WM_QUERYNEWPALETTE: msgtype = "WM_QUERYNEWPALETTE"; break;
+        case OS.WM_QUERYOPEN: msgtype = "WM_QUERYOPEN"; break;
+        case OS.WM_RBUTTONDBLCLK: msgtype = "WM_RBUTTONDBLCLK"; break;
+        case OS.WM_RBUTTONDOWN: msgtype = "WM_RBUTTONDOWN"; break;
+        case OS.WM_RBUTTONUP: msgtype = "WM_RBUTTONUP"; break;
+        case OS.WM_SETCURSOR: msgtype = "WM_SETCURSOR"; break;
+        case OS.WM_SETFOCUS: msgtype = "WM_SETFOCUS"; break;
+        case OS.WM_SETFONT: msgtype = "WM_SETFONT"; break;
+        case OS.WM_SETICON: msgtype = "WM_SETICON"; break;
+        case OS.WM_SETREDRAW: msgtype = "WM_SETREDRAW"; break;
+        case OS.WM_SETTINGCHANGE: msgtype = "WM_SETTINGCHANGE"; break;
+        case OS.WM_SHOWWINDOW: msgtype = "WM_SHOWWINDOW"; break;
+        case OS.WM_SIZE: msgtype = "WM_SIZE"; break;
+        case OS.WM_SYSCHAR: msgtype = "WM_SYSCHAR"; break;
+        case OS.WM_SYSCOLORCHANGE: msgtype = "WM_SYSCOLORCHANGE"; break;
+        case OS.WM_SYSCOMMAND: msgtype = "WM_SYSCOMMAND"; break;
+        case OS.WM_SYSKEYDOWN: msgtype = "WM_SYSKEYDOWN"; break;
+        case OS.WM_SYSKEYUP: msgtype = "WM_SYSKEYUP"; break;
+        case OS.WM_TIMER: msgtype = "WM_TIMER"; break;
+        case OS.WM_UNDO: msgtype = "WM_UNDO"; break;
+        case OS.WM_USER: msgtype = "WM_USER"; break;
+        case OS.WM_VSCROLL: msgtype = "WM_VSCROLL"; break;
+        case OS.WM_WINDOWPOSCHANGED: msgtype = "WM_WINDOWPOSCHANGED"; break;
+        case OS.WM_WINDOWPOSCHANGING: msgtype = "WM_WINDOWPOSCHANGING"; break;
+
+        case OS.WM_XBUTTONDOWN: msgtype = "WM_XBUTTONDOWN"; break;
+        case OS.WM_XBUTTONUP: msgtype = "WM_XBUTTONUP"; break;
+
+	case OS.TVM_DELETEITEM: msgtype = "TVM_DELETEITEM"; break;
+	case OS.TVM_ENSUREVISIBLE: msgtype = "TVM_ENSUREVISIBLE"; break;
+	case OS.TVM_EXPAND: msgtype = "TVM_EXPAND"; break;
+	case OS.TVM_GETBKCOLOR: msgtype = "TVM_GETBKCOLOR"; break;
+	case OS.TVM_GETCOUNT: msgtype = "TVM_GETCOUNT"; break;
+	case OS.TVM_GETIMAGELIST: msgtype = "TVM_GETIMAGELIST"; break;
+	case 0x113e: msgtype = "TVM_GETITEM"; break;
+	case 0x110c: msgtype = "TVM_GETITEM"; break;
+	case OS.TVM_GETITEMHEIGHT: msgtype = "TVM_GETITEMHEIGHT"; break;
+	case OS.TVM_GETITEMRECT: msgtype = "TVM_GETITEMRECT"; break;
+	case OS.TVM_GETNEXTITEM: msgtype = "TVM_GETNEXTITEM"; break;
+	case OS.TVM_GETTEXTCOLOR: msgtype = "TVM_GETTEXTCOLOR"; break;
+	case OS.TVM_GETTOOLTIPS: msgtype = "TVM_GETTOOLTIPS"; break;
+	case OS.TVM_GETVISIBLECOUNT: msgtype = "TVM_GETVISIBLECOUNT"; break;
+	case OS.TVM_HITTEST: msgtype = "TVM_HITTEST"; break;
+	case 0x1132: msgtype = "TVM_INSERTITEM"; break;
+	case 0x1100: msgtype = "TVM_INSERTITEM"; break;
+	case OS.TVM_MAPACCIDTOHTREEITEM: msgtype = "TVM_MAPACCIDTOHTREEITEM"; break;
+	case OS.TVM_MAPHTREEITEMTOACCID: msgtype = "TVM_MAPHTREEITEMTOACCID"; break;
+	case OS.TVM_SELECTITEM: msgtype = "TVM_SELECTITEM"; break;
+	case OS.TVM_SETBKCOLOR: msgtype = "TVM_SETBKCOLOR"; break;
+	case OS.TVM_SETIMAGELIST: msgtype = "TVM_SETIMAGELIST"; break;
+	case OS.TVM_SETINSERTMARK: msgtype = "TVM_SETINSERTMARK"; break;
+	case 0x113f: msgtype = "TVM_SETITEM"; break;
+	case 0x110d: msgtype = "TVM_SETITEM"; break;
+	case OS.TVM_SETTEXTCOLOR: msgtype = "TVM_SETTEXTCOLOR"; break;
+
+            //case OS.WM_ACTIVATE: msgtype = "WM_ACTIVATE"; break;
+            //case OS.WM_DESTROY: msgtype = "WM_DESTROY"; break;
+            //case OS.WM_MOVE: msgtype = "WM_MOVE"; break;
+            //case OS.WM_SIZE: msgtype = "WM_SIZE"; break;
+            // }}}
+        }
+        if (msgtype == null) {
+            if (hasMatch != null)
+                hasMatch[0] = false;
+            msgtype = Long.toHexString(msg);
+        } else {
+            if (hasMatch != null)
+                hasMatch[0] = true;
+        }
+        return msgtype;
+    }
+
+    // }}}
+    // {{{ isMessageImportant
+
+    public static boolean isMessageImportant(long /*int*/ msg)
+    {
+        return importantEvents.contains(new Integer ((int) msg));
+    }
+
+
+    // }}}
+    // {{{ isMessageUnimportant
+
+    public static boolean isMessageUnimportant(long /*int*/ msg)
+    {
+        return unimportantEvents.contains(new Integer ((int) msg));
+    }
+
+    // }}}
+// </QFS>
+
+
 /** 64 bit */
 public static final native int ACCEL_sizeof ();
 public static final native int ACTCTX_sizeof ();
@@ -2621,7 +2899,7 @@
 	if (IsUnicode) {
 		char [] lpClassName1 = lpClassName == null ? null : lpClassName.chars;
 		char [] lpWindowName1 = lpWindowName == null ? null : lpWindowName.chars;
-		return FindWindowW (lpClassName1, lpWindowName1); 
+		return FindWindowW (lpClassName1, lpWindowName1);
 	}
 	byte [] lpClassName1 = lpClassName == null ? null : lpClassName.bytes;
 	byte [] lpWindowName1 = lpWindowName == null ? null : lpWindowName.bytes;
@@ -2630,7 +2908,7 @@
 
 public static final int FormatMessage (int dwFlags, long /*int*/ lpSource, int dwMessageId, int dwLanguageId, long /*int*/ [] lpBuffer, int nSize, long /*int*/ Arguments) {
 	if (IsUnicode) {
-		return FormatMessageW (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments); 
+		return FormatMessageW (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
 	}
 	return FormatMessageA (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
 }
@@ -2646,7 +2924,7 @@
 		return GetCharacterPlacementW (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);
 	}
 	byte [] lpString1 = lpString == null ? null : lpString.bytes;
-	return GetCharacterPlacementA (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);	
+	return GetCharacterPlacementA (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);
 }
 
 public static final boolean GetCharWidth (long /*int*/ hdc, int iFirstChar, int iLastChar, int [] lpabc) {
@@ -2827,7 +3105,7 @@
 		return GetTextExtentPoint32W (hdc, lpString1, cbString, lpSize);
 	}
 	byte [] lpString1 = lpString == null ? null : lpString.bytes;
-	return GetTextExtentPoint32A (hdc, lpString1, cbString, lpSize);	
+	return GetTextExtentPoint32A (hdc, lpString1, cbString, lpSize);
 }
 
 public static final boolean GetTextMetrics (long /*int*/ hdc, TEXTMETRIC lptm) {
@@ -2954,7 +3232,7 @@
 		return InsertMenuW (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);
 	}
 	byte [] lpNewItem1 = lpNewItem == null ? null : lpNewItem.bytes;
-	return InsertMenuA (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);	
+	return InsertMenuA (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);
 }
 
 public static final boolean InsertMenuItem (long /*int*/ hMenu, int uItem, boolean fByPosition, MENUITEMINFO lpmii) {
@@ -3643,7 +3921,7 @@
  * @param uIDCheckItem cast=(UINT)
  * @param uCheck cast=(UINT)
  */
-public static final native boolean CheckMenuItem (long /*int*/ hmenu, int uIDCheckItem, int uCheck); 
+public static final native boolean CheckMenuItem (long /*int*/ hmenu, int uIDCheckItem, int uCheck);
 /** @param lpcc cast=(LPCHOOSECOLORW) */
 public static final native boolean ChooseColorW (CHOOSECOLOR lpcc);
 public static final native boolean ChooseColorA (CHOOSECOLOR lpcc);
@@ -3730,7 +4008,7 @@
 /** @param pv cast=(LPVOID) */
 public static final native void CoTaskMemFree(long /*int*/ pv);
 /** @param lpaccl cast=(LPACCEL) */
-public static final native long /*int*/ CreateAcceleratorTableW (byte [] lpaccl, int cEntries); 
+public static final native long /*int*/ CreateAcceleratorTableW (byte [] lpaccl, int cEntries);
 /** @param lpaccl cast=(LPACCEL) */
 public static final native long /*int*/ CreateAcceleratorTableA (byte [] lpaccl, int cEntries);
 /**
@@ -3766,7 +4044,7 @@
  * @param lpszOutput cast=(LPWSTR)
  * @param lpInitData cast=(CONST DEVMODEW *)
  */
-public static final native long /*int*/ CreateDCW (char [] lpszDriver, char [] lpszDevice, long /*int*/ lpszOutput, long /*int*/ lpInitData);  
+public static final native long /*int*/ CreateDCW (char [] lpszDriver, char [] lpszDevice, long /*int*/ lpszOutput, long /*int*/ lpInitData);
 /**
  * @param lpszDriver cast=(LPSTR)
  * @param lpszDevice cast=(LPSTR)
@@ -3773,7 +4051,7 @@
  * @param lpszOutput cast=(LPSTR)
  * @param lpInitData cast=(CONST DEVMODE *)
  */
-public static final native long /*int*/ CreateDCA (byte [] lpszDriver, byte [] lpszDevice, long /*int*/ lpszOutput, long /*int*/ lpInitData);  
+public static final native long /*int*/ CreateDCA (byte [] lpszDriver, byte [] lpszDevice, long /*int*/ lpszOutput, long /*int*/ lpInitData);
 /**
  * @param hdc cast=(HDC)
  * @param pbmi cast=(BITMAPINFO *),flags=no_out critical
@@ -4033,7 +4311,7 @@
  * @method flags=dynamic
  * @param hWnd cast=(HWND)
  */
-public static final native int DwmExtendFrameIntoClientArea (long /*int*/ hWnd, MARGINS pMarInset); 
+public static final native int DwmExtendFrameIntoClientArea (long /*int*/ hWnd, MARGINS pMarInset);
 /** @param hdc cast=(HDC) */
 public static final native boolean Ellipse (long /*int*/ hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
 /** @param hMenu cast=(HMENU) */
@@ -4281,6 +4559,31 @@
 public static final native int GetCurrentThreadId ();
 public static final native long /*int*/ GetCursor ();
 public static final native boolean GetCursorPos (POINT lpPoint);
+// <QFS> Wrapper for GetCursorPos to override during replay
+public static final boolean _GetCursorPos (POINT lpPoint)
+{
+    boolean ret;
+    Integer replayPos = (Integer) replayOverride.get();
+    if (replayPos == null) {
+        ret = GetCursorPos(lpPoint);
+    } else {
+        ret = true;
+        lpPoint.x = replayPos.intValue() & 0xFFFF;
+        lpPoint.y = replayPos.intValue() >> 16;
+    }
+    if (logger.level >= Log.DBG) {
+        Logger.Builder lb = logger.build("_GetCursorPos(POINT)").add("ret: ").add(ret);
+        if (ret) {
+            lb.add(", x: ").add(lpPoint.x).add(", y: ").add(lpPoint.y);
+        }
+        if (replayPos != null) {
+            lb.add(" [overridden]");
+        }
+        lb.log(Log.DBG);
+    }
+    return ret;
+}
+// </QFS>
 /**
  * @param Locale cast=(LCID)
  * @param dwFlags cast=(DWORD)
@@ -4860,7 +5163,7 @@
  * @param cx cast=(int *)
  * @param cy cast=(int *)
  */
-public static final native boolean ImageList_GetIconSize (long /*int*/ himl, int [] cx, int [] cy);   
+public static final native boolean ImageList_GetIconSize (long /*int*/ himl, int [] cx, int [] cy);
 /** @param himl cast=(HIMAGELIST) */
 public static final native int ImageList_GetImageCount (long /*int*/ himl);
 /** @param himl cast=(HIMAGELIST) */
@@ -5845,9 +6148,9 @@
 /** @param lpString cast=(LPTSTR) */
 public static final native int RegisterWindowMessageA (byte [] lpString);
 /** @param lpszFormat cast=(LPTSTR) */
-public static final native int RegisterClipboardFormatA (byte[] lpszFormat); 
+public static final native int RegisterClipboardFormatA (byte[] lpszFormat);
 /** @param lpszFormat cast=(LPWSTR) */
-public static final native int RegisterClipboardFormatW (char[] lpszFormat); 
+public static final native int RegisterClipboardFormatW (char[] lpszFormat);
 /**
  * @param hKey cast=(HKEY)
  * @param lpSubKey cast=(LPWSTR)
Index: org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java
===================================================================
--- org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -14,25 +14,25 @@
 	public int otmSize;
     public byte otmFiller;
     /** @field accessor=otmPanoseNumber.bFamilyType */
-	public byte otmPanoseNumber_bFamilyType;
+    public byte otmPanoseNumber_bFamilyType;
     /** @field accessor=otmPanoseNumber.bSerifStyle */
-	public byte otmPanoseNumber_bSerifStyle;
+    public byte otmPanoseNumber_bSerifStyle;
     /** @field accessor=otmPanoseNumber.bWeight */
-	public byte otmPanoseNumber_bWeight;
+    public byte otmPanoseNumber_bWeight;
     /** @field accessor=otmPanoseNumber.bProportion */
-	public byte otmPanoseNumber_bProportion;
+    public byte otmPanoseNumber_bProportion;
     /** @field accessor=otmPanoseNumber.bContrast */
-	public byte otmPanoseNumber_bContrast;
+    public byte otmPanoseNumber_bContrast;
     /** @field accessor=otmPanoseNumber.bStrokeVariation */
-	public byte otmPanoseNumber_bStrokeVariation;
+    public byte otmPanoseNumber_bStrokeVariation;
     /** @field accessor=otmPanoseNumber.bArmStyle */
-	public byte otmPanoseNumber_bArmStyle;
+    public byte otmPanoseNumber_bArmStyle;
     /** @field accessor=otmPanoseNumber.bLetterform */
-	public byte otmPanoseNumber_bLetterform;
+    public byte otmPanoseNumber_bLetterform;
     /** @field accessor=otmPanoseNumber.bMidline */
-	public byte otmPanoseNumber_bMidline;
+    public byte otmPanoseNumber_bMidline;
     /** @field accessor=otmPanoseNumber.bXHeight */
-	public byte otmPanoseNumber_bXHeight;
+    public byte otmPanoseNumber_bXHeight;
     public int otmfsSelection;
     public int otmfsType;
     public int otmsCharSlopeRise;
@@ -58,12 +58,12 @@
     public int otmsUnderscoreSize;
     public int otmsUnderscorePosition;
     /** @field cast=(PSTR) */
-	public long /*int*/ otmpFamilyName;
+    public long /*int*/ otmpFamilyName;
     /** @field cast=(PSTR) */
-	public long /*int*/ otmpFaceName;
+    public long /*int*/ otmpFaceName;
     /** @field cast=(PSTR) */
-	public long /*int*/ otmpStyleName;
+    public long /*int*/ otmpStyleName;
     /** @field cast=(PSTR) */
-	public long /*int*/ otmpFullName;
+    public long /*int*/ otmpFullName;
     public static final int sizeof = OS.IsUnicode ? OS.OUTLINETEXTMETRICW_sizeof ():  OS.OUTLINETEXTMETRICA_sizeof ();
 }
Index: org/eclipse/swt/internal/win32/NMTVDISPINFO.java
===================================================================
--- org/eclipse/swt/internal/win32/NMTVDISPINFO.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/NMTVDISPINFO.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -23,11 +23,11 @@
 	/** @field accessor=item.pszText,cast=(LPTSTR) */
 	public long /*int*/ pszText;
   	/** @field accessor=item.cchTextMax */
-	public int cchTextMax;
+  	public int cchTextMax;
   	/** @field accessor=item.iImage */
-	public int iImage;
+  	public int iImage;
   	/** @field accessor=item.iSelectedImage */
-	public int iSelectedImage;
+  	public int iSelectedImage;
 	/** @field accessor=item.cChildren */
 	public int cChildren;
 	/** @field accessor=item.lParam */
Index: org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMEventTarget extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDOMEVENTTARGET_IID_STR =
-		"1c773b30-d1cf-11d2-bd95-00805f8ae3f4";
-
-	public static final nsID NS_IDOMEVENTTARGET_IID =
-		new nsID(NS_IDOMEVENTTARGET_IID_STR);
-
-	public nsIDOMEventTarget(long /*int*/ address) {
-		super(address);
-	}
-
-	public int AddEventListener(long /*int*/ type, long /*int*/ listener, int useCapture) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), type, listener, useCapture);
-	}
-
-	public int RemoveEventListener(long /*int*/ type, long /*int*/ listener, int useCapture) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), type, listener, useCapture);
-	}
-
-	public int DispatchEvent(long /*int*/ evt, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), evt, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMEventTarget extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDOMEVENTTARGET_IID_STR =
+		"1c773b30-d1cf-11d2-bd95-00805f8ae3f4";
+
+	public static final nsID NS_IDOMEVENTTARGET_IID =
+		new nsID(NS_IDOMEVENTTARGET_IID_STR);
+
+	public nsIDOMEventTarget(long /*int*/ address) {
+		super(address);
+	}
+
+	public int AddEventListener(long /*int*/ type, long /*int*/ listener, int useCapture) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), type, listener, useCapture);
+	}
+
+	public int RemoveEventListener(long /*int*/ type, long /*int*/ listener, int useCapture) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), type, listener, useCapture);
+	}
+
+	public int DispatchEvent(long /*int*/ evt, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), evt, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIIOService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIIOService.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIIOService.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,83 +1,83 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIIOService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
-
-	public static final String NS_IIOSERVICE_IID_STR =
-		"bddeda3f-9020-4d12-8c70-984ee9f7935e";
-
-	public static final nsID NS_IIOSERVICE_IID =
-		new nsID(NS_IIOSERVICE_IID_STR);
-
-	public nsIIOService(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetProtocolHandler(byte[] aScheme, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aScheme, _retval);
-	}
-
-	public int GetProtocolFlags(byte[] aScheme, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aScheme, _retval);
-	}
-
-	public int NewURI(long /*int*/ aSpec, byte[] aOriginCharset, long /*int*/ aBaseURI, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSpec, aOriginCharset, aBaseURI, _retval);
-	}
-
-	public int NewFileURI(long /*int*/ aFile, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aFile, _retval);
-	}
-
-	public int NewChannelFromURI(long /*int*/ aURI, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aURI, _retval);
-	}
-
-	public int NewChannel(long /*int*/ aSpec, byte[] aOriginCharset, long /*int*/ aBaseURI, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aSpec, aOriginCharset, aBaseURI, _retval);
-	}
-
-	public int GetOffline(int[] aOffline) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aOffline);
-	}
-
-	public int SetOffline(int aOffline) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aOffline);
-	}
-
-	public int AllowPort(int aPort, byte[] aScheme, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPort, aScheme, _retval);
-	}
-
-	public int ExtractScheme(long /*int*/ urlString, long /*int*/ _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), urlString, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIIOService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
+
+	public static final String NS_IIOSERVICE_IID_STR =
+		"bddeda3f-9020-4d12-8c70-984ee9f7935e";
+
+	public static final nsID NS_IIOSERVICE_IID =
+		new nsID(NS_IIOSERVICE_IID_STR);
+
+	public nsIIOService(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetProtocolHandler(byte[] aScheme, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aScheme, _retval);
+	}
+
+	public int GetProtocolFlags(byte[] aScheme, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aScheme, _retval);
+	}
+
+	public int NewURI(long /*int*/ aSpec, byte[] aOriginCharset, long /*int*/ aBaseURI, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSpec, aOriginCharset, aBaseURI, _retval);
+	}
+
+	public int NewFileURI(long /*int*/ aFile, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aFile, _retval);
+	}
+
+	public int NewChannelFromURI(long /*int*/ aURI, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aURI, _retval);
+	}
+
+	public int NewChannel(long /*int*/ aSpec, byte[] aOriginCharset, long /*int*/ aBaseURI, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aSpec, aOriginCharset, aBaseURI, _retval);
+	}
+
+	public int GetOffline(int[] aOffline) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aOffline);
+	}
+
+	public int SetOffline(int aOffline) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aOffline);
+	}
+
+	public int AllowPort(int aPort, byte[] aScheme, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPort, aScheme, _retval);
+	}
+
+	public int ExtractScheme(long /*int*/ urlString, long /*int*/ _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), urlString, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieService.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieService.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
-
-public class nsICookieService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
-
-	public static final String NS_ICOOKIESERVICE_IID_STR =
-		"011c3190-1434-11d6-a618-0010a401eb10";
-
-	public static final nsID NS_ICOOKIESERVICE_IID =
-		new nsID(NS_ICOOKIESERVICE_IID_STR);
-
-	public nsICookieService(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetCookieString(long /*int*/ aURI, long /*int*/ aChannel, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
-	}
-
-	public int GetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aChannel, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
-	}
-
-	public int SetCookieString(long /*int*/ aURI, long /*int*/ aPrompt, byte[] aCookie, long /*int*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
-	}
-
-	public int SetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aPrompt, byte[] aCookie, byte[] aServerTime, long /*int*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
-	}
-
-	public int GetCookieIconIsVisible(int[] aCookieIconIsVisible) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCookieIconIsVisible);
-	}
-}
+
+public class nsICookieService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
+
+	public static final String NS_ICOOKIESERVICE_IID_STR =
+		"011c3190-1434-11d6-a618-0010a401eb10";
+
+	public static final nsID NS_ICOOKIESERVICE_IID =
+		new nsID(NS_ICOOKIESERVICE_IID_STR);
+
+	public nsICookieService(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetCookieString(long /*int*/ aURI, long /*int*/ aChannel, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
+	}
+
+	public int GetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aChannel, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
+	}
+
+	public int SetCookieString(long /*int*/ aURI, long /*int*/ aPrompt, byte[] aCookie, long /*int*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
+	}
+
+	public int SetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aPrompt, byte[] aCookie, byte[] aServerTime, long /*int*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
+	}
+
+	public int GetCookieIconIsVisible(int[] aCookieIconIsVisible) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCookieIconIsVisible);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,81 +1,81 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIEmbeddingSiteWindow extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
-
-	public static final String NS_IEMBEDDINGSITEWINDOW_IID_STR =
-		"3e5432cd-9568-4bd1-8cbe-d50aba110743";
-
-	public static final nsID NS_IEMBEDDINGSITEWINDOW_IID =
-		new nsID(NS_IEMBEDDINGSITEWINDOW_IID_STR);
-
-	public nsIEmbeddingSiteWindow(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int DIM_FLAGS_POSITION = 1;
-
-	public static final int DIM_FLAGS_SIZE_INNER = 2;
-
-	public static final int DIM_FLAGS_SIZE_OUTER = 4;
-
-	public int SetDimensions(int flags, int x, int y, int cx, int cy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), flags, x, y, cx, cy);
-	}
-
-	public int GetDimensions(int flags, int[] x, int[] y, int[] cx, int[] cy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), flags, x, y, cx, cy);
-	}
-
-	public int SetFocus() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
-	}
-
-	public int GetVisibility(int[] aVisibility) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aVisibility);
-	}
-
-	public int SetVisibility(int aVisibility) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aVisibility);
-	}
-
-	public int GetTitle(long /*int*/[] aTitle) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aTitle);
-	}
-
-	public int SetTitle(char[] aTitle) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aTitle);
-	}
-
-	public int GetSiteWindow(long /*int*/[] aSiteWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aSiteWindow);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIEmbeddingSiteWindow extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
+
+	public static final String NS_IEMBEDDINGSITEWINDOW_IID_STR =
+		"3e5432cd-9568-4bd1-8cbe-d50aba110743";
+
+	public static final nsID NS_IEMBEDDINGSITEWINDOW_IID =
+		new nsID(NS_IEMBEDDINGSITEWINDOW_IID_STR);
+
+	public nsIEmbeddingSiteWindow(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int DIM_FLAGS_POSITION = 1;
+
+	public static final int DIM_FLAGS_SIZE_INNER = 2;
+
+	public static final int DIM_FLAGS_SIZE_OUTER = 4;
+
+	public int SetDimensions(int flags, int x, int y, int cx, int cy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), flags, x, y, cx, cy);
+	}
+
+	public int GetDimensions(int flags, int[] x, int[] y, int[] cx, int[] cy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), flags, x, y, cx, cy);
+	}
+
+	public int SetFocus() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
+	}
+
+	public int GetVisibility(int[] aVisibility) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aVisibility);
+	}
+
+	public int SetVisibility(int aVisibility) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aVisibility);
+	}
+
+	public int GetTitle(long /*int*/[] aTitle) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aTitle);
+	}
+
+	public int SetTitle(char[] aTitle) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aTitle);
+	}
+
+	public int GetSiteWindow(long /*int*/[] aSiteWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aSiteWindow);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDocShell.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDocShell.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDocShell.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,269 +1,269 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDocShell extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 51;
-
-	public static final String NS_IDOCSHELL_IID_STR =
-		"69e5de00-7b8b-11d3-af61-00a024ffc08c";
-
-	public static final nsID NS_IDOCSHELL_IID =
-		new nsID(NS_IDOCSHELL_IID_STR);
-
-	public nsIDocShell(long /*int*/ address) {
-		super(address);
-	}
-
-	public int LoadURI(long /*int*/ uri, long /*int*/ loadInfo, int aLoadFlags, int firstParty) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uri, loadInfo, aLoadFlags, firstParty);
-	}
-
-	public int LoadStream(long /*int*/ aStream, long /*int*/ aURI, long /*int*/ aContentType, long /*int*/ aContentCharset, long /*int*/ aLoadInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aStream, aURI, aContentType, aContentCharset, aLoadInfo);
-	}
-
-	public int InternalLoad(long /*int*/ aURI, long /*int*/ aReferrer, long /*int*/ aOwner, int aInheritOwner, char[] aWindowTarget, long /*int*/ aPostDataStream, long /*int*/ aHeadersStream, int aLoadFlags, long /*int*/ aSHEntry, int firstParty, long /*int*/[] aDocShell, long /*int*/[] aRequest) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aReferrer, aOwner, aInheritOwner, aWindowTarget, aPostDataStream, aHeadersStream, aLoadFlags, aSHEntry, firstParty, aDocShell, aRequest);
-	}
-
-	public int CreateLoadInfo(long /*int*/[] loadInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), loadInfo);
-	}
-
-	public int PrepareForNewContentModel() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
-	}
-
-	public int SetCurrentURI(long /*int*/ aURI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aURI);
-	}
-
-	public int FireUnloadNotification() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress());
-	}
-
-	public int GetPresContext(long /*int*/[] aPresContext) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPresContext);
-	}
-
-	public int GetPresShell(long /*int*/[] aPresShell) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPresShell);
-	}
-
-	public int GetEldestPresShell(long /*int*/[] aEldestPresShell) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aEldestPresShell);
-	}
-
-	public int GetContentViewer(long /*int*/[] aContentViewer) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aContentViewer);
-	}
-
-	public int GetChromeEventHandler(long /*int*/[] aChromeEventHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aChromeEventHandler);
-	}
-
-	public int SetChromeEventHandler(long /*int*/ aChromeEventHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aChromeEventHandler);
-	}
-
-	public int GetParentURIContentListener(long /*int*/[] aParentURIContentListener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aParentURIContentListener);
-	}
-
-	public int SetParentURIContentListener(long /*int*/ aParentURIContentListener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aParentURIContentListener);
-	}
-
-	public int GetDocumentCharsetInfo(long /*int*/[] aDocumentCharsetInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aDocumentCharsetInfo);
-	}
-
-	public int SetDocumentCharsetInfo(long /*int*/ aDocumentCharsetInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aDocumentCharsetInfo);
-	}
-
-	public int GetAllowPlugins(int[] aAllowPlugins) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aAllowPlugins);
-	}
-
-	public int SetAllowPlugins(int aAllowPlugins) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aAllowPlugins);
-	}
-
-	public int GetAllowJavascript(int[] aAllowJavascript) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aAllowJavascript);
-	}
-
-	public int SetAllowJavascript(int aAllowJavascript) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aAllowJavascript);
-	}
-
-	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aAllowMetaRedirects);
-	}
-
-	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aAllowMetaRedirects);
-	}
-
-	public int GetAllowSubframes(int[] aAllowSubframes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAllowSubframes);
-	}
-
-	public int SetAllowSubframes(int aAllowSubframes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAllowSubframes);
-	}
-
-	public int GetAllowImages(int[] aAllowImages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aAllowImages);
-	}
-
-	public int SetAllowImages(int aAllowImages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aAllowImages);
-	}
-
-	public static final int ENUMERATE_FORWARDS = 0;
-
-	public static final int ENUMERATE_BACKWARDS = 1;
-
-	public int GetDocShellEnumerator(int aItemType, int aDirection, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aItemType, aDirection, _retval);
-	}
-
-	public static final int APP_TYPE_UNKNOWN = 0;
-
-	public static final int APP_TYPE_MAIL = 1;
-
-	public int GetAppType(int[] aAppType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aAppType);
-	}
-
-	public int SetAppType(int aAppType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aAppType);
-	}
-
-	public int GetAllowAuth(int[] aAllowAuth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), aAllowAuth);
-	}
-
-	public int SetAllowAuth(int aAllowAuth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aAllowAuth);
-	}
-
-	public int GetZoom(float[] aZoom) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), aZoom);
-	}
-
-	public int SetZoom(float aZoom) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), aZoom);
-	}
-
-	public int GetMarginWidth(int[] aMarginWidth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), aMarginWidth);
-	}
-
-	public int SetMarginWidth(int aMarginWidth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aMarginWidth);
-	}
-
-	public int GetMarginHeight(int[] aMarginHeight) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), aMarginHeight);
-	}
-
-	public int SetMarginHeight(int aMarginHeight) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), aMarginHeight);
-	}
-
-	public int GetHasFocus(int[] aHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), aHasFocus);
-	}
-
-	public int SetHasFocus(int aHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), aHasFocus);
-	}
-
-	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), aCanvasHasFocus);
-	}
-
-	public int SetCanvasHasFocus(int aCanvasHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), aCanvasHasFocus);
-	}
-
-	public int TabToTreeOwner(int forward, int[] tookFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), forward, tookFocus);
-	}
-
-	public static final int BUSY_FLAGS_NONE = 0;
-
-	public static final int BUSY_FLAGS_BUSY = 1;
-
-	public static final int BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
-
-	public static final int BUSY_FLAGS_PAGE_LOADING = 4;
-
-	public static final int LOAD_CMD_NORMAL = 1;
-
-	public static final int LOAD_CMD_RELOAD = 2;
-
-	public static final int LOAD_CMD_HISTORY = 4;
-
-	public int GetBusyFlags(int[] aBusyFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aBusyFlags);
-	}
-
-	public int GetLoadType(int[] aLoadType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), aLoadType);
-	}
-
-	public int SetLoadType(int aLoadType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 46, getAddress(), aLoadType);
-	}
-
-	public int IsBeingDestroyed(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 47, getAddress(), _retval);
-	}
-
-	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 48, getAddress(), aIsExecutingOnLoadHandler);
-	}
-
-	public int GetLayoutHistoryState(long /*int*/[] aLayoutHistoryState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 49, getAddress(), aLayoutHistoryState);
-	}
-
-	public int SetLayoutHistoryState(long /*int*/ aLayoutHistoryState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 50, getAddress(), aLayoutHistoryState);
-	}
-
-	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 51, getAddress(), aShouldSaveLayoutState);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDocShell extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 51;
+
+	public static final String NS_IDOCSHELL_IID_STR =
+		"69e5de00-7b8b-11d3-af61-00a024ffc08c";
+
+	public static final nsID NS_IDOCSHELL_IID =
+		new nsID(NS_IDOCSHELL_IID_STR);
+
+	public nsIDocShell(long /*int*/ address) {
+		super(address);
+	}
+
+	public int LoadURI(long /*int*/ uri, long /*int*/ loadInfo, int aLoadFlags, int firstParty) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uri, loadInfo, aLoadFlags, firstParty);
+	}
+
+	public int LoadStream(long /*int*/ aStream, long /*int*/ aURI, long /*int*/ aContentType, long /*int*/ aContentCharset, long /*int*/ aLoadInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aStream, aURI, aContentType, aContentCharset, aLoadInfo);
+	}
+
+	public int InternalLoad(long /*int*/ aURI, long /*int*/ aReferrer, long /*int*/ aOwner, int aInheritOwner, char[] aWindowTarget, long /*int*/ aPostDataStream, long /*int*/ aHeadersStream, int aLoadFlags, long /*int*/ aSHEntry, int firstParty, long /*int*/[] aDocShell, long /*int*/[] aRequest) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aReferrer, aOwner, aInheritOwner, aWindowTarget, aPostDataStream, aHeadersStream, aLoadFlags, aSHEntry, firstParty, aDocShell, aRequest);
+	}
+
+	public int CreateLoadInfo(long /*int*/[] loadInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), loadInfo);
+	}
+
+	public int PrepareForNewContentModel() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
+	}
+
+	public int SetCurrentURI(long /*int*/ aURI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aURI);
+	}
+
+	public int FireUnloadNotification() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress());
+	}
+
+	public int GetPresContext(long /*int*/[] aPresContext) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPresContext);
+	}
+
+	public int GetPresShell(long /*int*/[] aPresShell) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPresShell);
+	}
+
+	public int GetEldestPresShell(long /*int*/[] aEldestPresShell) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aEldestPresShell);
+	}
+
+	public int GetContentViewer(long /*int*/[] aContentViewer) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aContentViewer);
+	}
+
+	public int GetChromeEventHandler(long /*int*/[] aChromeEventHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aChromeEventHandler);
+	}
+
+	public int SetChromeEventHandler(long /*int*/ aChromeEventHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aChromeEventHandler);
+	}
+
+	public int GetParentURIContentListener(long /*int*/[] aParentURIContentListener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aParentURIContentListener);
+	}
+
+	public int SetParentURIContentListener(long /*int*/ aParentURIContentListener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aParentURIContentListener);
+	}
+
+	public int GetDocumentCharsetInfo(long /*int*/[] aDocumentCharsetInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aDocumentCharsetInfo);
+	}
+
+	public int SetDocumentCharsetInfo(long /*int*/ aDocumentCharsetInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aDocumentCharsetInfo);
+	}
+
+	public int GetAllowPlugins(int[] aAllowPlugins) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aAllowPlugins);
+	}
+
+	public int SetAllowPlugins(int aAllowPlugins) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aAllowPlugins);
+	}
+
+	public int GetAllowJavascript(int[] aAllowJavascript) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aAllowJavascript);
+	}
+
+	public int SetAllowJavascript(int aAllowJavascript) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aAllowJavascript);
+	}
+
+	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aAllowMetaRedirects);
+	}
+
+	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aAllowMetaRedirects);
+	}
+
+	public int GetAllowSubframes(int[] aAllowSubframes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAllowSubframes);
+	}
+
+	public int SetAllowSubframes(int aAllowSubframes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAllowSubframes);
+	}
+
+	public int GetAllowImages(int[] aAllowImages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aAllowImages);
+	}
+
+	public int SetAllowImages(int aAllowImages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aAllowImages);
+	}
+
+	public static final int ENUMERATE_FORWARDS = 0;
+
+	public static final int ENUMERATE_BACKWARDS = 1;
+
+	public int GetDocShellEnumerator(int aItemType, int aDirection, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aItemType, aDirection, _retval);
+	}
+
+	public static final int APP_TYPE_UNKNOWN = 0;
+
+	public static final int APP_TYPE_MAIL = 1;
+
+	public int GetAppType(int[] aAppType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aAppType);
+	}
+
+	public int SetAppType(int aAppType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aAppType);
+	}
+
+	public int GetAllowAuth(int[] aAllowAuth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), aAllowAuth);
+	}
+
+	public int SetAllowAuth(int aAllowAuth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aAllowAuth);
+	}
+
+	public int GetZoom(float[] aZoom) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), aZoom);
+	}
+
+	public int SetZoom(float aZoom) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), aZoom);
+	}
+
+	public int GetMarginWidth(int[] aMarginWidth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), aMarginWidth);
+	}
+
+	public int SetMarginWidth(int aMarginWidth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aMarginWidth);
+	}
+
+	public int GetMarginHeight(int[] aMarginHeight) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), aMarginHeight);
+	}
+
+	public int SetMarginHeight(int aMarginHeight) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), aMarginHeight);
+	}
+
+	public int GetHasFocus(int[] aHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), aHasFocus);
+	}
+
+	public int SetHasFocus(int aHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), aHasFocus);
+	}
+
+	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), aCanvasHasFocus);
+	}
+
+	public int SetCanvasHasFocus(int aCanvasHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), aCanvasHasFocus);
+	}
+
+	public int TabToTreeOwner(int forward, int[] tookFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), forward, tookFocus);
+	}
+
+	public static final int BUSY_FLAGS_NONE = 0;
+
+	public static final int BUSY_FLAGS_BUSY = 1;
+
+	public static final int BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
+
+	public static final int BUSY_FLAGS_PAGE_LOADING = 4;
+
+	public static final int LOAD_CMD_NORMAL = 1;
+
+	public static final int LOAD_CMD_RELOAD = 2;
+
+	public static final int LOAD_CMD_HISTORY = 4;
+
+	public int GetBusyFlags(int[] aBusyFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aBusyFlags);
+	}
+
+	public int GetLoadType(int[] aLoadType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), aLoadType);
+	}
+
+	public int SetLoadType(int aLoadType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 46, getAddress(), aLoadType);
+	}
+
+	public int IsBeingDestroyed(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 47, getAddress(), _retval);
+	}
+
+	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 48, getAddress(), aIsExecutingOnLoadHandler);
+	}
+
+	public int GetLayoutHistoryState(long /*int*/[] aLayoutHistoryState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 49, getAddress(), aLayoutHistoryState);
+	}
+
+	public int SetLayoutHistoryState(long /*int*/ aLayoutHistoryState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 50, getAddress(), aLayoutHistoryState);
+	}
+
+	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 51, getAddress(), aShouldSaveLayoutState);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIURI.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIURI.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIURI.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,147 +1,147 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIURI extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 26;
-
-	public static final String NS_IURI_IID_STR =
-		"07a22cc0-0ce5-11d3-9331-00104ba0fd40";
-
-	public static final nsID NS_IURI_IID =
-		new nsID(NS_IURI_IID_STR);
-
-	public nsIURI(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetSpec(long /*int*/ aSpec) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aSpec);
-	}
-
-	public int SetSpec(long /*int*/ aSpec) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSpec);
-	}
-
-	public int GetPrePath(long /*int*/ aPrePath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aPrePath);
-	}
-
-	public int GetScheme(long /*int*/ aScheme) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aScheme);
-	}
-
-	public int SetScheme(long /*int*/ aScheme) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aScheme);
-	}
-
-	public int GetUserPass(long /*int*/ aUserPass) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aUserPass);
-	}
-
-	public int SetUserPass(long /*int*/ aUserPass) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aUserPass);
-	}
-
-	public int GetUsername(long /*int*/ aUsername) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aUsername);
-	}
-
-	public int SetUsername(long /*int*/ aUsername) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aUsername);
-	}
-
-	public int GetPassword(long /*int*/ aPassword) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aPassword);
-	}
-
-	public int SetPassword(long /*int*/ aPassword) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aPassword);
-	}
-
-	public int GetHostPort(long /*int*/ aHostPort) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aHostPort);
-	}
-
-	public int SetHostPort(long /*int*/ aHostPort) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aHostPort);
-	}
-
-	public int GetHost(long /*int*/ aHost) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aHost);
-	}
-
-	public int SetHost(long /*int*/ aHost) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aHost);
-	}
-
-	public int GetPort(int[] aPort) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aPort);
-	}
-
-	public int SetPort(int aPort) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aPort);
-	}
-
-	public int GetPath(long /*int*/ aPath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPath);
-	}
-
-	public int SetPath(long /*int*/ aPath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aPath);
-	}
-
-	public int Equals(long /*int*/ other, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), other, _retval);
-	}
-
-	public int SchemeIs(byte[] scheme, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), scheme, _retval);
-	}
-
-	public int Clone(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), _retval);
-	}
-
-	public int Resolve(long /*int*/ relativePath, long /*int*/ _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), relativePath, _retval);
-	}
-
-	public int GetAsciiSpec(long /*int*/ aAsciiSpec) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAsciiSpec);
-	}
-
-	public int GetAsciiHost(long /*int*/ aAsciiHost) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAsciiHost);
-	}
-
-	public int GetOriginCharset(long /*int*/ aOriginCharset) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aOriginCharset);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIURI extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 26;
+
+	public static final String NS_IURI_IID_STR =
+		"07a22cc0-0ce5-11d3-9331-00104ba0fd40";
+
+	public static final nsID NS_IURI_IID =
+		new nsID(NS_IURI_IID_STR);
+
+	public nsIURI(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetSpec(long /*int*/ aSpec) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aSpec);
+	}
+
+	public int SetSpec(long /*int*/ aSpec) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSpec);
+	}
+
+	public int GetPrePath(long /*int*/ aPrePath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aPrePath);
+	}
+
+	public int GetScheme(long /*int*/ aScheme) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aScheme);
+	}
+
+	public int SetScheme(long /*int*/ aScheme) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aScheme);
+	}
+
+	public int GetUserPass(long /*int*/ aUserPass) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aUserPass);
+	}
+
+	public int SetUserPass(long /*int*/ aUserPass) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aUserPass);
+	}
+
+	public int GetUsername(long /*int*/ aUsername) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aUsername);
+	}
+
+	public int SetUsername(long /*int*/ aUsername) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aUsername);
+	}
+
+	public int GetPassword(long /*int*/ aPassword) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aPassword);
+	}
+
+	public int SetPassword(long /*int*/ aPassword) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aPassword);
+	}
+
+	public int GetHostPort(long /*int*/ aHostPort) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aHostPort);
+	}
+
+	public int SetHostPort(long /*int*/ aHostPort) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aHostPort);
+	}
+
+	public int GetHost(long /*int*/ aHost) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aHost);
+	}
+
+	public int SetHost(long /*int*/ aHost) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aHost);
+	}
+
+	public int GetPort(int[] aPort) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aPort);
+	}
+
+	public int SetPort(int aPort) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aPort);
+	}
+
+	public int GetPath(long /*int*/ aPath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPath);
+	}
+
+	public int SetPath(long /*int*/ aPath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aPath);
+	}
+
+	public int Equals(long /*int*/ other, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), other, _retval);
+	}
+
+	public int SchemeIs(byte[] scheme, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), scheme, _retval);
+	}
+
+	public int Clone(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), _retval);
+	}
+
+	public int Resolve(long /*int*/ relativePath, long /*int*/ _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), relativePath, _retval);
+	}
+
+	public int GetAsciiSpec(long /*int*/ aAsciiSpec) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAsciiSpec);
+	}
+
+	public int GetAsciiHost(long /*int*/ aAsciiHost) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAsciiHost);
+	}
+
+	public int GetOriginCharset(long /*int*/ aOriginCharset) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aOriginCharset);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebProgress.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebProgress.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebProgress.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,79 +1,79 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIWebProgress extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_IWEBPROGRESS_IID_STR =
-		"570f39d0-efd0-11d3-b093-00a024ffc08c";
-
-	public static final nsID NS_IWEBPROGRESS_IID =
-		new nsID(NS_IWEBPROGRESS_IID_STR);
-
-	public nsIWebProgress(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int NOTIFY_STATE_REQUEST = 1;
-
-	public static final int NOTIFY_STATE_DOCUMENT = 2;
-
-	public static final int NOTIFY_STATE_NETWORK = 4;
-
-	public static final int NOTIFY_STATE_WINDOW = 8;
-
-	public static final int NOTIFY_STATE_ALL = 15;
-
-	public static final int NOTIFY_PROGRESS = 16;
-
-	public static final int NOTIFY_STATUS = 32;
-
-	public static final int NOTIFY_SECURITY = 64;
-
-	public static final int NOTIFY_LOCATION = 128;
-
-	public static final int NOTIFY_ALL = 255;
-
-	public int AddProgressListener(long /*int*/ listener, int aNotifyMask) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), listener, aNotifyMask);
-	}
-
-	public int RemoveProgressListener(long /*int*/ listener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), listener);
-	}
-
-	public int GetDOMWindow(long /*int*/[] aDOMWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDOMWindow);
-	}
-
-	public int GetIsLoadingDocument(int[] aIsLoadingDocument) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aIsLoadingDocument);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIWebProgress extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_IWEBPROGRESS_IID_STR =
+		"570f39d0-efd0-11d3-b093-00a024ffc08c";
+
+	public static final nsID NS_IWEBPROGRESS_IID =
+		new nsID(NS_IWEBPROGRESS_IID_STR);
+
+	public nsIWebProgress(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int NOTIFY_STATE_REQUEST = 1;
+
+	public static final int NOTIFY_STATE_DOCUMENT = 2;
+
+	public static final int NOTIFY_STATE_NETWORK = 4;
+
+	public static final int NOTIFY_STATE_WINDOW = 8;
+
+	public static final int NOTIFY_STATE_ALL = 15;
+
+	public static final int NOTIFY_PROGRESS = 16;
+
+	public static final int NOTIFY_STATUS = 32;
+
+	public static final int NOTIFY_SECURITY = 64;
+
+	public static final int NOTIFY_LOCATION = 128;
+
+	public static final int NOTIFY_ALL = 255;
+
+	public int AddProgressListener(long /*int*/ listener, int aNotifyMask) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), listener, aNotifyMask);
+	}
+
+	public int RemoveProgressListener(long /*int*/ listener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), listener);
+	}
+
+	public int GetDOMWindow(long /*int*/[] aDOMWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDOMWindow);
+	}
+
+	public int GetIsLoadingDocument(int[] aIsLoadingDocument) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aIsLoadingDocument);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieManager.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieManager.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsICookieManager extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_ICOOKIEMANAGER_IID_STR =
-		"aaab6710-0f2c-11d5-a53b-0010a401eb10";
-
-	public static final nsID NS_ICOOKIEMANAGER_IID =
-		new nsID(NS_ICOOKIEMANAGER_IID_STR);
-
-	public nsICookieManager(long /*int*/ address) {
-		super(address);
-	}
-
-	public int RemoveAll() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
-	}
-
-	public int GetEnumerator(long /*int*/[] aEnumerator) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aEnumerator);
-	}
-
-	public int Remove(long /*int*/ aDomain, long /*int*/ aName, long /*int*/ aPath, int aBlocked) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDomain, aName, aPath, aBlocked);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsICookieManager extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_ICOOKIEMANAGER_IID_STR =
+		"aaab6710-0f2c-11d5-a53b-0010a401eb10";
+
+	public static final nsID NS_ICOOKIEMANAGER_IID =
+		new nsID(NS_ICOOKIEMANAGER_IID_STR);
+
+	public nsICookieManager(long /*int*/ address) {
+		super(address);
+	}
+
+	public int RemoveAll() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
+	}
+
+	public int GetEnumerator(long /*int*/[] aEnumerator) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aEnumerator);
+	}
+
+	public int Remove(long /*int*/ aDomain, long /*int*/ aName, long /*int*/ aPath, int aBlocked) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDomain, aName, aPath, aBlocked);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIFactory.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFactory.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFactory.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,51 +1,51 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIFactory extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 2;
-
-	public static final String NS_IFACTORY_IID_STR =
-		"00000001-0000-0000-c000-000000000046";
-
-	public static final nsID NS_IFACTORY_IID =
-		new nsID(NS_IFACTORY_IID_STR);
-
-	public nsIFactory(long /*int*/ address) {
-		super(address);
-	}
-
-	public int CreateInstance(long /*int*/ aOuter, nsID iid, long /*int*/[] result) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aOuter, iid, result);
-	}
-
-	public int LockFactory(int lock) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), lock);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIFactory extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 2;
+
+	public static final String NS_IFACTORY_IID_STR =
+		"00000001-0000-0000-c000-000000000046";
+
+	public static final nsID NS_IFACTORY_IID =
+		new nsID(NS_IFACTORY_IID_STR);
+
+	public nsIFactory(long /*int*/ address) {
+		super(address);
+	}
+
+	public int CreateInstance(long /*int*/ aOuter, nsID iid, long /*int*/[] result) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aOuter, iid, result);
+	}
+
+	public int LockFactory(int lock) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), lock);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICategoryManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICategoryManager.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICategoryManager.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,67 +1,67 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsICategoryManager extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 6;
-
-	public static final String NS_ICATEGORYMANAGER_IID_STR =
-		"3275b2cd-af6d-429a-80d7-f0c5120342ac";
-
-	public static final nsID NS_ICATEGORYMANAGER_IID =
-		new nsID(NS_ICATEGORYMANAGER_IID_STR);
-
-	public nsICategoryManager(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetCategoryEntry(byte[] aCategory, byte[] aEntry, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCategory, aEntry, _retval);
-	}
-
-	public int AddCategoryEntry(byte[] aCategory, byte[] aEntry, byte[] aValue, int aPersist, int aReplace, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCategory, aEntry, aValue, aPersist, aReplace, _retval);
-	}
-
-	public int DeleteCategoryEntry(byte[] aCategory, byte[] aEntry, int aPersist) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aCategory, aEntry, aPersist);
-	}
-
-	public int DeleteCategory(byte[] aCategory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aCategory);
-	}
-
-	public int EnumerateCategory(byte[] aCategory, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCategory, _retval);
-	}
-
-	public int EnumerateCategories(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsICategoryManager extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 6;
+
+	public static final String NS_ICATEGORYMANAGER_IID_STR =
+		"3275b2cd-af6d-429a-80d7-f0c5120342ac";
+
+	public static final nsID NS_ICATEGORYMANAGER_IID =
+		new nsID(NS_ICATEGORYMANAGER_IID_STR);
+
+	public nsICategoryManager(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetCategoryEntry(byte[] aCategory, byte[] aEntry, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCategory, aEntry, _retval);
+	}
+
+	public int AddCategoryEntry(byte[] aCategory, byte[] aEntry, byte[] aValue, int aPersist, int aReplace, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCategory, aEntry, aValue, aPersist, aReplace, _retval);
+	}
+
+	public int DeleteCategoryEntry(byte[] aCategory, byte[] aEntry, int aPersist) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aCategory, aEntry, aPersist);
+	}
+
+	public int DeleteCategory(byte[] aCategory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aCategory);
+	}
+
+	public int EnumerateCategory(byte[] aCategory, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCategory, _retval);
+	}
+
+	public int EnumerateCategories(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,83 +1,83 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIHelperAppLauncher_1_9 extends nsICancelable {
-
-	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 10;
-
-	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
-		"cc75c21a-0a79-4f68-90e1-563253d0c555";
-
-	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
-		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
-
-	public nsIHelperAppLauncher_1_9(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
-	}
-
-	public int GetSource(long /*int*/[] aSource) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
-	}
-
-	public int GetSuggestedFileName(long /*int*/ aSuggestedFileName) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
-	}
-
-	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
-	}
-
-	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
-	}
-
-	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
-	}
-
-	public int CloseProgressWindow() {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
-	}
-
-	public int GetTargetFile(long /*int*/[] aTargetFile) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
-	}
-
-	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTargetFileIsExecutable);
-	}
-
-	public int GetTimeDownloadStarted(long /*int*/ aTimeDownloadStarted) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 10, getAddress(), aTimeDownloadStarted);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIHelperAppLauncher_1_9 extends nsICancelable {
+
+	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 10;
+
+	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
+		"cc75c21a-0a79-4f68-90e1-563253d0c555";
+
+	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
+		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
+
+	public nsIHelperAppLauncher_1_9(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
+	}
+
+	public int GetSource(long /*int*/[] aSource) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
+	}
+
+	public int GetSuggestedFileName(long /*int*/ aSuggestedFileName) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
+	}
+
+	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
+	}
+
+	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
+	}
+
+	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
+	}
+
+	public int CloseProgressWindow() {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
+	}
+
+	public int GetTargetFile(long /*int*/[] aTargetFile) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
+	}
+
+	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTargetFileIsExecutable);
+	}
+
+	public int GetTimeDownloadStarted(long /*int*/ aTimeDownloadStarted) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 10, getAddress(), aTimeDownloadStarted);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,137 +1,137 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIWebBrowserChrome extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
-
-	public static final String NS_IWEBBROWSERCHROME_IID_STR =
-		"ba434c60-9d52-11d3-afb0-00a024ffc08c";
-
-	public static final nsID NS_IWEBBROWSERCHROME_IID =
-		new nsID(NS_IWEBBROWSERCHROME_IID_STR);
-
-	public nsIWebBrowserChrome(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int STATUS_SCRIPT = 1;
-
-	public static final int STATUS_SCRIPT_DEFAULT = 2;
-
-	public static final int STATUS_LINK = 3;
-
-	public int SetStatus(int statusType, char[] status) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), statusType, status);
-	}
-
-	public int GetWebBrowser(long /*int*/[] aWebBrowser) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aWebBrowser);
-	}
-
-	public int SetWebBrowser(long /*int*/ aWebBrowser) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aWebBrowser);
-	}
-
-	public static final int CHROME_DEFAULT = 1;
-
-	public static final int CHROME_WINDOW_BORDERS = 2;
-
-	public static final int CHROME_WINDOW_CLOSE = 4;
-
-	public static final int CHROME_WINDOW_RESIZE = 8;
-
-	public static final int CHROME_MENUBAR = 16;
-
-	public static final int CHROME_TOOLBAR = 32;
-
-	public static final int CHROME_LOCATIONBAR = 64;
-
-	public static final int CHROME_STATUSBAR = 128;
-
-	public static final int CHROME_PERSONAL_TOOLBAR = 256;
-
-	public static final int CHROME_SCROLLBARS = 512;
-
-	public static final int CHROME_TITLEBAR = 1024;
-
-	public static final int CHROME_EXTRA = 2048;
-
-	public static final int CHROME_WITH_SIZE = 4096;
-
-	public static final int CHROME_WITH_POSITION = 8192;
-
-	public static final int CHROME_WINDOW_MIN = 16384;
-
-	public static final int CHROME_WINDOW_POPUP = 32768;
-
-	public static final int CHROME_WINDOW_RAISED = 33554432;
-
-	public static final int CHROME_WINDOW_LOWERED = 67108864;
-
-	public static final int CHROME_CENTER_SCREEN = 134217728;
-
-	public static final int CHROME_DEPENDENT = 268435456;
-
-	public static final int CHROME_MODAL = 536870912;
-
-	public static final int CHROME_OPENAS_DIALOG = 1073741824;
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIWebBrowserChrome extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
+
+	public static final String NS_IWEBBROWSERCHROME_IID_STR =
+		"ba434c60-9d52-11d3-afb0-00a024ffc08c";
+
+	public static final nsID NS_IWEBBROWSERCHROME_IID =
+		new nsID(NS_IWEBBROWSERCHROME_IID_STR);
+
+	public nsIWebBrowserChrome(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int STATUS_SCRIPT = 1;
+
+	public static final int STATUS_SCRIPT_DEFAULT = 2;
+
+	public static final int STATUS_LINK = 3;
+
+	public int SetStatus(int statusType, char[] status) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), statusType, status);
+	}
+
+	public int GetWebBrowser(long /*int*/[] aWebBrowser) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aWebBrowser);
+	}
+
+	public int SetWebBrowser(long /*int*/ aWebBrowser) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aWebBrowser);
+	}
+
+	public static final int CHROME_DEFAULT = 1;
+
+	public static final int CHROME_WINDOW_BORDERS = 2;
+
+	public static final int CHROME_WINDOW_CLOSE = 4;
+
+	public static final int CHROME_WINDOW_RESIZE = 8;
+
+	public static final int CHROME_MENUBAR = 16;
+
+	public static final int CHROME_TOOLBAR = 32;
+
+	public static final int CHROME_LOCATIONBAR = 64;
+
+	public static final int CHROME_STATUSBAR = 128;
+
+	public static final int CHROME_PERSONAL_TOOLBAR = 256;
+
+	public static final int CHROME_SCROLLBARS = 512;
+
+	public static final int CHROME_TITLEBAR = 1024;
+
+	public static final int CHROME_EXTRA = 2048;
+
+	public static final int CHROME_WITH_SIZE = 4096;
+
+	public static final int CHROME_WITH_POSITION = 8192;
+
+	public static final int CHROME_WINDOW_MIN = 16384;
+
+	public static final int CHROME_WINDOW_POPUP = 32768;
+
+	public static final int CHROME_WINDOW_RAISED = 33554432;
+
+	public static final int CHROME_WINDOW_LOWERED = 67108864;
+
+	public static final int CHROME_CENTER_SCREEN = 134217728;
+
+	public static final int CHROME_DEPENDENT = 268435456;
+
+	public static final int CHROME_MODAL = 536870912;
+
+	public static final int CHROME_OPENAS_DIALOG = 1073741824;
+
 	public static final int CHROME_OPENAS_CHROME = -2147483648;
-
-	public static final int CHROME_ALL = 4094;
-
-	public int GetChromeFlags(int[] aChromeFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aChromeFlags);
-	}
-
-	public int SetChromeFlags(int aChromeFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aChromeFlags);
-	}
-
-	public int DestroyBrowserWindow() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
-	}
-
-	public int SizeBrowserTo(int aCX, int aCY) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aCX, aCY);
-	}
-
-	public int ShowAsModal() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
-	}
-
-	public int IsWindowModal(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), _retval);
-	}
-
-	public int ExitModalEventLoop(int aStatus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aStatus);
-	}
-}
+
+	public static final int CHROME_ALL = 4094;
+
+	public int GetChromeFlags(int[] aChromeFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aChromeFlags);
+	}
+
+	public int SetChromeFlags(int aChromeFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aChromeFlags);
+	}
+
+	public int DestroyBrowserWindow() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
+	}
+
+	public int SizeBrowserTo(int aCX, int aCY) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aCX, aCY);
+	}
+
+	public int ShowAsModal() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
+	}
+
+	public int IsWindowModal(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), _retval);
+	}
+
+	public int ExitModalEventLoop(int aStatus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aStatus);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,89 +1,89 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMEvent extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
-
-	public static final String NS_IDOMEVENT_IID_STR =
-		"a66b7b80-ff46-bd97-0080-5f8ae38add32";
-
-	public static final nsID NS_IDOMEVENT_IID =
-		new nsID(NS_IDOMEVENT_IID_STR);
-
-	public nsIDOMEvent(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int CAPTURING_PHASE = 1;
-
-	public static final int AT_TARGET = 2;
-
-	public static final int BUBBLING_PHASE = 3;
-
-	public int GetType(long /*int*/ aType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aType);
-	}
-
-	public int GetTarget(long /*int*/[] aTarget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aTarget);
-	}
-
-	public int GetCurrentTarget(long /*int*/[] aCurrentTarget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aCurrentTarget);
-	}
-
-	public int GetEventPhase(short[] aEventPhase) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aEventPhase);
-	}
-
-	public int GetBubbles(int[] aBubbles) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aBubbles);
-	}
-
-	public int GetCancelable(int[] aCancelable) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aCancelable);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMEvent extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
+
+	public static final String NS_IDOMEVENT_IID_STR =
+		"a66b7b80-ff46-bd97-0080-5f8ae38add32";
+
+	public static final nsID NS_IDOMEVENT_IID =
+		new nsID(NS_IDOMEVENT_IID_STR);
+
+	public nsIDOMEvent(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int CAPTURING_PHASE = 1;
+
+	public static final int AT_TARGET = 2;
+
+	public static final int BUBBLING_PHASE = 3;
+
+	public int GetType(long /*int*/ aType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aType);
+	}
+
+	public int GetTarget(long /*int*/[] aTarget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aTarget);
+	}
+
+	public int GetCurrentTarget(long /*int*/[] aCurrentTarget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aCurrentTarget);
+	}
+
+	public int GetEventPhase(short[] aEventPhase) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aEventPhase);
+	}
+
+	public int GetBubbles(int[] aBubbles) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aBubbles);
+	}
+
+	public int GetCancelable(int[] aCancelable) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aCancelable);
+	}
+
 	public int GetTimeStamp(long /*int*/[] aTimeStamp) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aTimeStamp);
-	}
-
-	public int StopPropagation() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
-	}
-
-	public int PreventDefault() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress());
-	}
-
-	public int InitEvent(long /*int*/ eventTypeArg, int canBubbleArg, int cancelableArg) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), eventTypeArg, canBubbleArg, cancelableArg);
-	}
-}
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aTimeStamp);
+	}
+
+	public int StopPropagation() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
+	}
+
+	public int PreventDefault() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress());
+	}
+
+	public int InitEvent(long /*int*/ eventTypeArg, int canBubbleArg, int cancelableArg) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), eventTypeArg, canBubbleArg, cancelableArg);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,299 +1,299 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMKeyEvent extends nsIDOMUIEvent {
-
-	static final int LAST_METHOD_ID = nsIDOMUIEvent.LAST_METHOD_ID + 7;
-
-	public static final String NS_IDOMKEYEVENT_IID_STR =
-		"028e0e6e-8b01-11d3-aae7-0010838a3123";
-
-	public static final nsID NS_IDOMKEYEVENT_IID =
-		new nsID(NS_IDOMKEYEVENT_IID_STR);
-
-	public nsIDOMKeyEvent(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int DOM_VK_CANCEL = 3;
-
-	public static final int DOM_VK_HELP = 6;
-
-	public static final int DOM_VK_BACK_SPACE = 8;
-
-	public static final int DOM_VK_TAB = 9;
-
-	public static final int DOM_VK_CLEAR = 12;
-
-	public static final int DOM_VK_RETURN = 13;
-
-	public static final int DOM_VK_ENTER = 14;
-
-	public static final int DOM_VK_SHIFT = 16;
-
-	public static final int DOM_VK_CONTROL = 17;
-
-	public static final int DOM_VK_ALT = 18;
-
-	public static final int DOM_VK_PAUSE = 19;
-
-	public static final int DOM_VK_CAPS_LOCK = 20;
-
-	public static final int DOM_VK_ESCAPE = 27;
-
-	public static final int DOM_VK_SPACE = 32;
-
-	public static final int DOM_VK_PAGE_UP = 33;
-
-	public static final int DOM_VK_PAGE_DOWN = 34;
-
-	public static final int DOM_VK_END = 35;
-
-	public static final int DOM_VK_HOME = 36;
-
-	public static final int DOM_VK_LEFT = 37;
-
-	public static final int DOM_VK_UP = 38;
-
-	public static final int DOM_VK_RIGHT = 39;
-
-	public static final int DOM_VK_DOWN = 40;
-
-	public static final int DOM_VK_PRINTSCREEN = 44;
-
-	public static final int DOM_VK_INSERT = 45;
-
-	public static final int DOM_VK_DELETE = 46;
-
-	public static final int DOM_VK_0 = 48;
-
-	public static final int DOM_VK_1 = 49;
-
-	public static final int DOM_VK_2 = 50;
-
-	public static final int DOM_VK_3 = 51;
-
-	public static final int DOM_VK_4 = 52;
-
-	public static final int DOM_VK_5 = 53;
-
-	public static final int DOM_VK_6 = 54;
-
-	public static final int DOM_VK_7 = 55;
-
-	public static final int DOM_VK_8 = 56;
-
-	public static final int DOM_VK_9 = 57;
-
-	public static final int DOM_VK_SEMICOLON = 59;
-
-	public static final int DOM_VK_EQUALS = 61;
-
-	public static final int DOM_VK_A = 65;
-
-	public static final int DOM_VK_B = 66;
-
-	public static final int DOM_VK_C = 67;
-
-	public static final int DOM_VK_D = 68;
-
-	public static final int DOM_VK_E = 69;
-
-	public static final int DOM_VK_F = 70;
-
-	public static final int DOM_VK_G = 71;
-
-	public static final int DOM_VK_H = 72;
-
-	public static final int DOM_VK_I = 73;
-
-	public static final int DOM_VK_J = 74;
-
-	public static final int DOM_VK_K = 75;
-
-	public static final int DOM_VK_L = 76;
-
-	public static final int DOM_VK_M = 77;
-
-	public static final int DOM_VK_N = 78;
-
-	public static final int DOM_VK_O = 79;
-
-	public static final int DOM_VK_P = 80;
-
-	public static final int DOM_VK_Q = 81;
-
-	public static final int DOM_VK_R = 82;
-
-	public static final int DOM_VK_S = 83;
-
-	public static final int DOM_VK_T = 84;
-
-	public static final int DOM_VK_U = 85;
-
-	public static final int DOM_VK_V = 86;
-
-	public static final int DOM_VK_W = 87;
-
-	public static final int DOM_VK_X = 88;
-
-	public static final int DOM_VK_Y = 89;
-
-	public static final int DOM_VK_Z = 90;
-
-	public static final int DOM_VK_NUMPAD0 = 96;
-
-	public static final int DOM_VK_NUMPAD1 = 97;
-
-	public static final int DOM_VK_NUMPAD2 = 98;
-
-	public static final int DOM_VK_NUMPAD3 = 99;
-
-	public static final int DOM_VK_NUMPAD4 = 100;
-
-	public static final int DOM_VK_NUMPAD5 = 101;
-
-	public static final int DOM_VK_NUMPAD6 = 102;
-
-	public static final int DOM_VK_NUMPAD7 = 103;
-
-	public static final int DOM_VK_NUMPAD8 = 104;
-
-	public static final int DOM_VK_NUMPAD9 = 105;
-
-	public static final int DOM_VK_MULTIPLY = 106;
-
-	public static final int DOM_VK_ADD = 107;
-
-	public static final int DOM_VK_SEPARATOR = 108;
-
-	public static final int DOM_VK_SUBTRACT = 109;
-
-	public static final int DOM_VK_DECIMAL = 110;
-
-	public static final int DOM_VK_DIVIDE = 111;
-
-	public static final int DOM_VK_F1 = 112;
-
-	public static final int DOM_VK_F2 = 113;
-
-	public static final int DOM_VK_F3 = 114;
-
-	public static final int DOM_VK_F4 = 115;
-
-	public static final int DOM_VK_F5 = 116;
-
-	public static final int DOM_VK_F6 = 117;
-
-	public static final int DOM_VK_F7 = 118;
-
-	public static final int DOM_VK_F8 = 119;
-
-	public static final int DOM_VK_F9 = 120;
-
-	public static final int DOM_VK_F10 = 121;
-
-	public static final int DOM_VK_F11 = 122;
-
-	public static final int DOM_VK_F12 = 123;
-
-	public static final int DOM_VK_F13 = 124;
-
-	public static final int DOM_VK_F14 = 125;
-
-	public static final int DOM_VK_F15 = 126;
-
-	public static final int DOM_VK_F16 = 127;
-
-	public static final int DOM_VK_F17 = 128;
-
-	public static final int DOM_VK_F18 = 129;
-
-	public static final int DOM_VK_F19 = 130;
-
-	public static final int DOM_VK_F20 = 131;
-
-	public static final int DOM_VK_F21 = 132;
-
-	public static final int DOM_VK_F22 = 133;
-
-	public static final int DOM_VK_F23 = 134;
-
-	public static final int DOM_VK_F24 = 135;
-
-	public static final int DOM_VK_NUM_LOCK = 144;
-
-	public static final int DOM_VK_SCROLL_LOCK = 145;
-
-	public static final int DOM_VK_COMMA = 188;
-
-	public static final int DOM_VK_PERIOD = 190;
-
-	public static final int DOM_VK_SLASH = 191;
-
-	public static final int DOM_VK_BACK_QUOTE = 192;
-
-	public static final int DOM_VK_OPEN_BRACKET = 219;
-
-	public static final int DOM_VK_BACK_SLASH = 220;
-
-	public static final int DOM_VK_CLOSE_BRACKET = 221;
-
-	public static final int DOM_VK_QUOTE = 222;
-
-	public static final int DOM_VK_META = 224;
-
-	public int GetCharCode(int[] aCharCode) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 1, getAddress(), aCharCode);
-	}
-
-	public int GetKeyCode(int[] aKeyCode) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 2, getAddress(), aKeyCode);
-	}
-
-	public int GetAltKey(int[] aAltKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 3, getAddress(), aAltKey);
-	}
-
-	public int GetCtrlKey(int[] aCtrlKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aCtrlKey);
-	}
-
-	public int GetShiftKey(int[] aShiftKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aShiftKey);
-	}
-
-	public int GetMetaKey(int[] aMetaKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aMetaKey);
-	}
-
-	public int InitKeyEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, int keyCodeArg, int charCodeArg) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, keyCodeArg, charCodeArg);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMKeyEvent extends nsIDOMUIEvent {
+
+	static final int LAST_METHOD_ID = nsIDOMUIEvent.LAST_METHOD_ID + 7;
+
+	public static final String NS_IDOMKEYEVENT_IID_STR =
+		"028e0e6e-8b01-11d3-aae7-0010838a3123";
+
+	public static final nsID NS_IDOMKEYEVENT_IID =
+		new nsID(NS_IDOMKEYEVENT_IID_STR);
+
+	public nsIDOMKeyEvent(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int DOM_VK_CANCEL = 3;
+
+	public static final int DOM_VK_HELP = 6;
+
+	public static final int DOM_VK_BACK_SPACE = 8;
+
+	public static final int DOM_VK_TAB = 9;
+
+	public static final int DOM_VK_CLEAR = 12;
+
+	public static final int DOM_VK_RETURN = 13;
+
+	public static final int DOM_VK_ENTER = 14;
+
+	public static final int DOM_VK_SHIFT = 16;
+
+	public static final int DOM_VK_CONTROL = 17;
+
+	public static final int DOM_VK_ALT = 18;
+
+	public static final int DOM_VK_PAUSE = 19;
+
+	public static final int DOM_VK_CAPS_LOCK = 20;
+
+	public static final int DOM_VK_ESCAPE = 27;
+
+	public static final int DOM_VK_SPACE = 32;
+
+	public static final int DOM_VK_PAGE_UP = 33;
+
+	public static final int DOM_VK_PAGE_DOWN = 34;
+
+	public static final int DOM_VK_END = 35;
+
+	public static final int DOM_VK_HOME = 36;
+
+	public static final int DOM_VK_LEFT = 37;
+
+	public static final int DOM_VK_UP = 38;
+
+	public static final int DOM_VK_RIGHT = 39;
+
+	public static final int DOM_VK_DOWN = 40;
+
+	public static final int DOM_VK_PRINTSCREEN = 44;
+
+	public static final int DOM_VK_INSERT = 45;
+
+	public static final int DOM_VK_DELETE = 46;
+
+	public static final int DOM_VK_0 = 48;
+
+	public static final int DOM_VK_1 = 49;
+
+	public static final int DOM_VK_2 = 50;
+
+	public static final int DOM_VK_3 = 51;
+
+	public static final int DOM_VK_4 = 52;
+
+	public static final int DOM_VK_5 = 53;
+
+	public static final int DOM_VK_6 = 54;
+
+	public static final int DOM_VK_7 = 55;
+
+	public static final int DOM_VK_8 = 56;
+
+	public static final int DOM_VK_9 = 57;
+
+	public static final int DOM_VK_SEMICOLON = 59;
+
+	public static final int DOM_VK_EQUALS = 61;
+
+	public static final int DOM_VK_A = 65;
+
+	public static final int DOM_VK_B = 66;
+
+	public static final int DOM_VK_C = 67;
+
+	public static final int DOM_VK_D = 68;
+
+	public static final int DOM_VK_E = 69;
+
+	public static final int DOM_VK_F = 70;
+
+	public static final int DOM_VK_G = 71;
+
+	public static final int DOM_VK_H = 72;
+
+	public static final int DOM_VK_I = 73;
+
+	public static final int DOM_VK_J = 74;
+
+	public static final int DOM_VK_K = 75;
+
+	public static final int DOM_VK_L = 76;
+
+	public static final int DOM_VK_M = 77;
+
+	public static final int DOM_VK_N = 78;
+
+	public static final int DOM_VK_O = 79;
+
+	public static final int DOM_VK_P = 80;
+
+	public static final int DOM_VK_Q = 81;
+
+	public static final int DOM_VK_R = 82;
+
+	public static final int DOM_VK_S = 83;
+
+	public static final int DOM_VK_T = 84;
+
+	public static final int DOM_VK_U = 85;
+
+	public static final int DOM_VK_V = 86;
+
+	public static final int DOM_VK_W = 87;
+
+	public static final int DOM_VK_X = 88;
+
+	public static final int DOM_VK_Y = 89;
+
+	public static final int DOM_VK_Z = 90;
+
+	public static final int DOM_VK_NUMPAD0 = 96;
+
+	public static final int DOM_VK_NUMPAD1 = 97;
+
+	public static final int DOM_VK_NUMPAD2 = 98;
+
+	public static final int DOM_VK_NUMPAD3 = 99;
+
+	public static final int DOM_VK_NUMPAD4 = 100;
+
+	public static final int DOM_VK_NUMPAD5 = 101;
+
+	public static final int DOM_VK_NUMPAD6 = 102;
+
+	public static final int DOM_VK_NUMPAD7 = 103;
+
+	public static final int DOM_VK_NUMPAD8 = 104;
+
+	public static final int DOM_VK_NUMPAD9 = 105;
+
+	public static final int DOM_VK_MULTIPLY = 106;
+
+	public static final int DOM_VK_ADD = 107;
+
+	public static final int DOM_VK_SEPARATOR = 108;
+
+	public static final int DOM_VK_SUBTRACT = 109;
+
+	public static final int DOM_VK_DECIMAL = 110;
+
+	public static final int DOM_VK_DIVIDE = 111;
+
+	public static final int DOM_VK_F1 = 112;
+
+	public static final int DOM_VK_F2 = 113;
+
+	public static final int DOM_VK_F3 = 114;
+
+	public static final int DOM_VK_F4 = 115;
+
+	public static final int DOM_VK_F5 = 116;
+
+	public static final int DOM_VK_F6 = 117;
+
+	public static final int DOM_VK_F7 = 118;
+
+	public static final int DOM_VK_F8 = 119;
+
+	public static final int DOM_VK_F9 = 120;
+
+	public static final int DOM_VK_F10 = 121;
+
+	public static final int DOM_VK_F11 = 122;
+
+	public static final int DOM_VK_F12 = 123;
+
+	public static final int DOM_VK_F13 = 124;
+
+	public static final int DOM_VK_F14 = 125;
+
+	public static final int DOM_VK_F15 = 126;
+
+	public static final int DOM_VK_F16 = 127;
+
+	public static final int DOM_VK_F17 = 128;
+
+	public static final int DOM_VK_F18 = 129;
+
+	public static final int DOM_VK_F19 = 130;
+
+	public static final int DOM_VK_F20 = 131;
+
+	public static final int DOM_VK_F21 = 132;
+
+	public static final int DOM_VK_F22 = 133;
+
+	public static final int DOM_VK_F23 = 134;
+
+	public static final int DOM_VK_F24 = 135;
+
+	public static final int DOM_VK_NUM_LOCK = 144;
+
+	public static final int DOM_VK_SCROLL_LOCK = 145;
+
+	public static final int DOM_VK_COMMA = 188;
+
+	public static final int DOM_VK_PERIOD = 190;
+
+	public static final int DOM_VK_SLASH = 191;
+
+	public static final int DOM_VK_BACK_QUOTE = 192;
+
+	public static final int DOM_VK_OPEN_BRACKET = 219;
+
+	public static final int DOM_VK_BACK_SLASH = 220;
+
+	public static final int DOM_VK_CLOSE_BRACKET = 221;
+
+	public static final int DOM_VK_QUOTE = 222;
+
+	public static final int DOM_VK_META = 224;
+
+	public int GetCharCode(int[] aCharCode) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 1, getAddress(), aCharCode);
+	}
+
+	public int GetKeyCode(int[] aKeyCode) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 2, getAddress(), aKeyCode);
+	}
+
+	public int GetAltKey(int[] aAltKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 3, getAddress(), aAltKey);
+	}
+
+	public int GetCtrlKey(int[] aCtrlKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aCtrlKey);
+	}
+
+	public int GetShiftKey(int[] aShiftKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aShiftKey);
+	}
+
+	public int GetMetaKey(int[] aMetaKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aMetaKey);
+	}
+
+	public int InitKeyEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, int keyCodeArg, int charCodeArg) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, keyCodeArg, charCodeArg);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,71 +1,71 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
 public class nsIProgressDialog_1_8 extends nsIDownload_1_8 {
-
+
 	static final int LAST_METHOD_ID = nsIDownload_1_8.LAST_METHOD_ID + 7;
-
-	public static final String NS_IPROGRESSDIALOG_IID_STR =
-		"20e790a2-76c6-462d-851a-22ab6cbbe48b";
-
-	public static final nsID NS_IPROGRESSDIALOG_IID =
-		new nsID(NS_IPROGRESSDIALOG_IID_STR);
-
-	public nsIProgressDialog_1_8(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Open(long /*int*/ aParent) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 1, getAddress(), aParent);
-	}
-
-	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
-	}
-
-	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
-	}
-
-	public int GetObserver(long /*int*/[] aObserver) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 4, getAddress(), aObserver);
-	}
-
-	public int SetObserver(long /*int*/ aObserver) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 5, getAddress(), aObserver);
-	}
-
-	public int GetDialog(long /*int*/[] aDialog) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 6, getAddress(), aDialog);
-	}
-
-	public int SetDialog(long /*int*/ aDialog) {
-		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 7, getAddress(), aDialog);
-	}
-}
+
+	public static final String NS_IPROGRESSDIALOG_IID_STR =
+		"20e790a2-76c6-462d-851a-22ab6cbbe48b";
+
+	public static final nsID NS_IPROGRESSDIALOG_IID =
+		new nsID(NS_IPROGRESSDIALOG_IID_STR);
+
+	public nsIProgressDialog_1_8(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Open(long /*int*/ aParent) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 1, getAddress(), aParent);
+	}
+
+	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
+	}
+
+	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
+	}
+
+	public int GetObserver(long /*int*/[] aObserver) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 4, getAddress(), aObserver);
+	}
+
+	public int SetObserver(long /*int*/ aObserver) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 5, getAddress(), aObserver);
+	}
+
+	public int GetDialog(long /*int*/[] aDialog) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 6, getAddress(), aDialog);
+	}
+
+	public int SetDialog(long /*int*/ aDialog) {
+		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 7, getAddress(), aDialog);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIServiceManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIServiceManager.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIServiceManager.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIServiceManager extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_ISERVICEMANAGER_IID_STR =
-		"8bb35ed9-e332-462d-9155-4a002ab5c958";
-
-	public static final nsID NS_ISERVICEMANAGER_IID =
-		new nsID(NS_ISERVICEMANAGER_IID_STR);
-
-	public nsIServiceManager(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetService(nsID aClass, nsID aIID, long /*int*/[] result) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aClass, aIID, result);
-	}
-
-	public int GetServiceByContractID(byte[] aContractID, nsID aIID, long /*int*/[] result) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContractID, aIID, result);
-	}
-
-	public int IsServiceInstantiated(nsID aClass, nsID aIID, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aClass, aIID, _retval);
-	}
-
-	public int IsServiceInstantiatedByContractID(byte[] aContractID, nsID aIID, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContractID, aIID, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIServiceManager extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_ISERVICEMANAGER_IID_STR =
+		"8bb35ed9-e332-462d-9155-4a002ab5c958";
+
+	public static final nsID NS_ISERVICEMANAGER_IID =
+		new nsID(NS_ISERVICEMANAGER_IID_STR);
+
+	public nsIServiceManager(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetService(nsID aClass, nsID aIID, long /*int*/[] result) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aClass, aIID, result);
+	}
+
+	public int GetServiceByContractID(byte[] aContractID, nsID aIID, long /*int*/[] result) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContractID, aIID, result);
+	}
+
+	public int IsServiceInstantiated(nsID aClass, nsID aIID, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aClass, aIID, _retval);
+	}
+
+	public int IsServiceInstantiatedByContractID(byte[] aContractID, nsID aIID, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContractID, aIID, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebNavigation.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebNavigation.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebNavigation.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,119 +1,119 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIWebNavigation extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 13;
-
-	public static final String NS_IWEBNAVIGATION_IID_STR =
-		"f5d9e7b0-d930-11d3-b057-00a024ffc08c";
-
-	public static final nsID NS_IWEBNAVIGATION_IID =
-		new nsID(NS_IWEBNAVIGATION_IID_STR);
-
-	public nsIWebNavigation(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetCanGoBack(int[] aCanGoBack) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCanGoBack);
-	}
-
-	public int GetCanGoForward(int[] aCanGoForward) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCanGoForward);
-	}
-
-	public int GoBack() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
-	}
-
-	public int GoForward() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress());
-	}
-
-	public int GotoIndex(int index) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), index);
-	}
-
-	public static final int LOAD_FLAGS_MASK = 65535;
-
-	public static final int LOAD_FLAGS_NONE = 0;
-
-	public static final int LOAD_FLAGS_IS_REFRESH = 16;
-
-	public static final int LOAD_FLAGS_IS_LINK = 32;
-
-	public static final int LOAD_FLAGS_BYPASS_HISTORY = 64;
-
-	public static final int LOAD_FLAGS_REPLACE_HISTORY = 128;
-
-	public static final int LOAD_FLAGS_BYPASS_CACHE = 256;
-
-	public static final int LOAD_FLAGS_BYPASS_PROXY = 512;
-
-	public static final int LOAD_FLAGS_CHARSET_CHANGE = 1024;
-
-	public int LoadURI(char[] uri, int loadFlags, long /*int*/ referrer, long /*int*/ postData, long /*int*/ headers) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), uri, loadFlags, referrer, postData, headers);
-	}
-
-	public int Reload(int reloadFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), reloadFlags);
-	}
-
-	public static final int STOP_NETWORK = 1;
-
-	public static final int STOP_CONTENT = 2;
-
-	public static final int STOP_ALL = 3;
-
-	public int Stop(int stopFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), stopFlags);
-	}
-
-	public int GetDocument(long /*int*/[] aDocument) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aDocument);
-	}
-
-	public int GetCurrentURI(long /*int*/[] aCurrentURI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aCurrentURI);
-	}
-
-	public int GetReferringURI(long /*int*/[] aReferringURI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aReferringURI);
-	}
-
-	public int GetSessionHistory(long /*int*/[] aSessionHistory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aSessionHistory);
-	}
-
-	public int SetSessionHistory(long /*int*/ aSessionHistory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aSessionHistory);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIWebNavigation extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 13;
+
+	public static final String NS_IWEBNAVIGATION_IID_STR =
+		"f5d9e7b0-d930-11d3-b057-00a024ffc08c";
+
+	public static final nsID NS_IWEBNAVIGATION_IID =
+		new nsID(NS_IWEBNAVIGATION_IID_STR);
+
+	public nsIWebNavigation(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetCanGoBack(int[] aCanGoBack) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCanGoBack);
+	}
+
+	public int GetCanGoForward(int[] aCanGoForward) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCanGoForward);
+	}
+
+	public int GoBack() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
+	}
+
+	public int GoForward() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress());
+	}
+
+	public int GotoIndex(int index) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), index);
+	}
+
+	public static final int LOAD_FLAGS_MASK = 65535;
+
+	public static final int LOAD_FLAGS_NONE = 0;
+
+	public static final int LOAD_FLAGS_IS_REFRESH = 16;
+
+	public static final int LOAD_FLAGS_IS_LINK = 32;
+
+	public static final int LOAD_FLAGS_BYPASS_HISTORY = 64;
+
+	public static final int LOAD_FLAGS_REPLACE_HISTORY = 128;
+
+	public static final int LOAD_FLAGS_BYPASS_CACHE = 256;
+
+	public static final int LOAD_FLAGS_BYPASS_PROXY = 512;
+
+	public static final int LOAD_FLAGS_CHARSET_CHANGE = 1024;
+
+	public int LoadURI(char[] uri, int loadFlags, long /*int*/ referrer, long /*int*/ postData, long /*int*/ headers) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), uri, loadFlags, referrer, postData, headers);
+	}
+
+	public int Reload(int reloadFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), reloadFlags);
+	}
+
+	public static final int STOP_NETWORK = 1;
+
+	public static final int STOP_CONTENT = 2;
+
+	public static final int STOP_ALL = 3;
+
+	public int Stop(int stopFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), stopFlags);
+	}
+
+	public int GetDocument(long /*int*/[] aDocument) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aDocument);
+	}
+
+	public int GetCurrentURI(long /*int*/[] aCurrentURI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aCurrentURI);
+	}
+
+	public int GetReferringURI(long /*int*/[] aReferringURI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aReferringURI);
+	}
+
+	public int GetSessionHistory(long /*int*/[] aSessionHistory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aSessionHistory);
+	}
+
+	public int SetSessionHistory(long /*int*/ aSessionHistory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aSessionHistory);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIPromptService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPromptService.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPromptService.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,113 +1,113 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIPromptService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
-
-	public static final String NS_IPROMPTSERVICE_IID_STR =
-		"1630c61a-325e-49ca-8759-a31b16c47aa5";
-
-	public static final nsID NS_IPROMPTSERVICE_IID =
-		new nsID(NS_IPROMPTSERVICE_IID_STR);
-
-	public nsIPromptService(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Alert(long /*int*/ aParent, char[] aDialogTitle, char[] aText) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aParent, aDialogTitle, aText);
-	}
-
-	public int AlertCheck(long /*int*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState);
-	}
-
-	public int Confirm(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aParent, aDialogTitle, aText, _retval);
-	}
-
-	public int ConfirmCheck(long /*int*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState, _retval);
-	}
-
-	public static final int BUTTON_POS_0 = 1;
-
-	public static final int BUTTON_POS_1 = 256;
-
-	public static final int BUTTON_POS_2 = 65536;
-
-	public static final int BUTTON_TITLE_OK = 1;
-
-	public static final int BUTTON_TITLE_CANCEL = 2;
-
-	public static final int BUTTON_TITLE_YES = 3;
-
-	public static final int BUTTON_TITLE_NO = 4;
-
-	public static final int BUTTON_TITLE_SAVE = 5;
-
-	public static final int BUTTON_TITLE_DONT_SAVE = 6;
-
-	public static final int BUTTON_TITLE_REVERT = 7;
-
-	public static final int BUTTON_TITLE_IS_STRING = 127;
-
-	public static final int BUTTON_POS_0_DEFAULT = 0;
-
-	public static final int BUTTON_POS_1_DEFAULT = 16777216;
-
-	public static final int BUTTON_POS_2_DEFAULT = 33554432;
-
-	public static final int BUTTON_DELAY_ENABLE = 67108864;
-
-	public static final int STD_OK_CANCEL_BUTTONS = 513;
-
-	public static final int STD_YES_NO_BUTTONS = 1027;
-	
-	public int ConfirmEx(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int aButtonFlags, char[] aButton0Title, char[] aButton1Title, char[] aButton2Title, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParent, aDialogTitle, aText, aButtonFlags, aButton0Title, aButton1Title, aButton2Title, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int Prompt(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aValue, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParent, aDialogTitle, aText, aValue, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int PromptUsernameAndPassword(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aUsername, long /*int*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParent, aDialogTitle, aText, aUsername, aPassword, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int PromptPassword(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParent, aDialogTitle, aText, aPassword, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int Select(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int aCount, long /*int*/[] aSelectList, int[] aOutSelection, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aParent, aDialogTitle, aText, aCount, aSelectList, aOutSelection, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIPromptService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
+
+	public static final String NS_IPROMPTSERVICE_IID_STR =
+		"1630c61a-325e-49ca-8759-a31b16c47aa5";
+
+	public static final nsID NS_IPROMPTSERVICE_IID =
+		new nsID(NS_IPROMPTSERVICE_IID_STR);
+
+	public nsIPromptService(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Alert(long /*int*/ aParent, char[] aDialogTitle, char[] aText) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aParent, aDialogTitle, aText);
+	}
+
+	public int AlertCheck(long /*int*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState);
+	}
+
+	public int Confirm(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aParent, aDialogTitle, aText, _retval);
+	}
+
+	public int ConfirmCheck(long /*int*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState, _retval);
+	}
+
+	public static final int BUTTON_POS_0 = 1;
+
+	public static final int BUTTON_POS_1 = 256;
+
+	public static final int BUTTON_POS_2 = 65536;
+
+	public static final int BUTTON_TITLE_OK = 1;
+
+	public static final int BUTTON_TITLE_CANCEL = 2;
+
+	public static final int BUTTON_TITLE_YES = 3;
+
+	public static final int BUTTON_TITLE_NO = 4;
+
+	public static final int BUTTON_TITLE_SAVE = 5;
+
+	public static final int BUTTON_TITLE_DONT_SAVE = 6;
+
+	public static final int BUTTON_TITLE_REVERT = 7;
+
+	public static final int BUTTON_TITLE_IS_STRING = 127;
+
+	public static final int BUTTON_POS_0_DEFAULT = 0;
+
+	public static final int BUTTON_POS_1_DEFAULT = 16777216;
+
+	public static final int BUTTON_POS_2_DEFAULT = 33554432;
+
+	public static final int BUTTON_DELAY_ENABLE = 67108864;
+
+	public static final int STD_OK_CANCEL_BUTTONS = 513;
+
+	public static final int STD_YES_NO_BUTTONS = 1027;
+	
+	public int ConfirmEx(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int aButtonFlags, char[] aButton0Title, char[] aButton1Title, char[] aButton2Title, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParent, aDialogTitle, aText, aButtonFlags, aButton0Title, aButton1Title, aButton2Title, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int Prompt(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aValue, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParent, aDialogTitle, aText, aValue, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int PromptUsernameAndPassword(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aUsername, long /*int*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParent, aDialogTitle, aText, aUsername, aPassword, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int PromptPassword(long /*int*/ aParent, char[] aDialogTitle, char[] aText, long /*int*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParent, aDialogTitle, aText, aPassword, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int Select(long /*int*/ aParent, char[] aDialogTitle, char[] aText, int aCount, long /*int*/[] aSelectList, int[] aOutSelection, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aParent, aDialogTitle, aText, aCount, aSelectList, aOutSelection, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,79 +1,79 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIHelperAppLauncher extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
-
-	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
-		"9503d0fe-4c9d-11d4-98d0-001083010e9b";
-
-	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
-		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
-
-	public nsIHelperAppLauncher(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
-	}
-
-	public int GetSource(long /*int*/[] aSource) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSource);
-	}
-
-	public int GetSuggestedFileName(long /*int*/[] aSuggestedFileName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
-	}
-
-	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
-	}
-
-	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
-	}
-
-	public int Cancel() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
-	}
-
-	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aWebProgressListener);
-	}
-
-	public int CloseProgressWindow() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
-	}
-
-	public int GetDownloadInfo(long /*int*/[] aSourceUrl, long[] aTimeDownloadStarted, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aSourceUrl, aTimeDownloadStarted, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIHelperAppLauncher extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
+
+	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
+		"9503d0fe-4c9d-11d4-98d0-001083010e9b";
+
+	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
+		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
+
+	public nsIHelperAppLauncher(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
+	}
+
+	public int GetSource(long /*int*/[] aSource) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSource);
+	}
+
+	public int GetSuggestedFileName(long /*int*/[] aSuggestedFileName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
+	}
+
+	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
+	}
+
+	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
+	}
+
+	public int Cancel() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
+	}
+
+	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aWebProgressListener);
+	}
+
+	public int CloseProgressWindow() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
+	}
+
+	public int GetDownloadInfo(long /*int*/[] aSourceUrl, long[] aTimeDownloadStarted, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aSourceUrl, aTimeDownloadStarted, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIJSContextStack.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIJSContextStack.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIJSContextStack.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIJSContextStack extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_IJSCONTEXTSTACK_IID_STR =
-		"c67d8270-3189-11d3-9885-006008962422";
-
-	public static final nsID NS_IJSCONTEXTSTACK_IID =
-		new nsID(NS_IJSCONTEXTSTACK_IID_STR);
-
-	public nsIJSContextStack(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetCount(int[] aCount) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCount);
-	}
-
-	public int Peek(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
-	}
-
-	public int Pop(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), _retval);
-	}
-
-	public int Push(long /*int*/ cx) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), cx);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIJSContextStack extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_IJSCONTEXTSTACK_IID_STR =
+		"c67d8270-3189-11d3-9885-006008962422";
+
+	public static final nsID NS_IJSCONTEXTSTACK_IID =
+		new nsID(NS_IJSCONTEXTSTACK_IID_STR);
+
+	public nsIJSContextStack(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetCount(int[] aCount) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCount);
+	}
+
+	public int Peek(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
+	}
+
+	public int Pop(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), _retval);
+	}
+
+	public int Push(long /*int*/ cx) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), cx);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIAppShell.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIAppShell.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIAppShell.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,75 +1,75 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIAppShell extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
-
-	public static final String NS_IAPPSHELL_IID_STR =
-		"a0757c31-eeac-11d1-9ec1-00aa002fb821";
-
-	public static final nsID NS_IAPPSHELL_IID =
-		new nsID(NS_IAPPSHELL_IID_STR);
-
-	public nsIAppShell(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Create(long /*int*/ argc, long /*int*/[] argv) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), argc, argv);
-	}
-
-	public int Run() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
-	}
-
-	public int Spinup() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
-	}
-
-	public int Spindown() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress());
-	}
-
-	public int ListenToEventQueue(long /*int*/ aQueue, int aListen) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aQueue, aListen);
-	}
-
-	public int GetNativeEvent(long /*int*/ aRealEvent, long /*int*/[] aEvent) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aRealEvent, aEvent);
-	}
-
-	public int DispatchNativeEvent(int aRealEvent, long /*int*/ aEvent) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aRealEvent, aEvent);
-	}
-
-	public int Exit() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIAppShell extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
+
+	public static final String NS_IAPPSHELL_IID_STR =
+		"a0757c31-eeac-11d1-9ec1-00aa002fb821";
+
+	public static final nsID NS_IAPPSHELL_IID =
+		new nsID(NS_IAPPSHELL_IID_STR);
+
+	public nsIAppShell(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Create(long /*int*/ argc, long /*int*/[] argv) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), argc, argv);
+	}
+
+	public int Run() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
+	}
+
+	public int Spinup() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
+	}
+
+	public int Spindown() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress());
+	}
+
+	public int ListenToEventQueue(long /*int*/ aQueue, int aListen) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aQueue, aListen);
+	}
+
+	public int GetNativeEvent(long /*int*/ aRealEvent, long /*int*/[] aEvent) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aRealEvent, aEvent);
+	}
+
+	public int DispatchNativeEvent(int aRealEvent, long /*int*/ aEvent) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aRealEvent, aEvent);
+	}
+
+	public int Exit() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/init/XPCOMInit.java
===================================================================
--- org/eclipse/swt/internal/mozilla/init/XPCOMInit.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/init/XPCOMInit.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -32,7 +32,7 @@
 /** @jniclass flags=cpp */
 public class XPCOMInit extends Platform {
 	public static final int PATH_MAX = 4096;
-
+	
 public static final native int GREProperty_sizeof ();
 public static final native int GREVersionRange_sizeof ();
 
Index: org/eclipse/swt/internal/mozilla/nsIPromptService2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPromptService2.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPromptService2.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,51 +1,51 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIPromptService2 extends nsIPromptService {
-
-	static final int LAST_METHOD_ID = nsIPromptService.LAST_METHOD_ID + 2;
-
-	public static final String NS_IPROMPTSERVICE2_IID_STR =
-		"cf86d196-dbee-4482-9dfa-3477aa128319";
-
-	public static final nsID NS_IPROMPTSERVICE2_IID =
-		new nsID(NS_IPROMPTSERVICE2_IID_STR);
-
-	public nsIPromptService2(long /*int*/ address) {
-		super(address);
-	}
-
-	public int PromptAuth(long /*int*/ aParent, long /*int*/ aChannel, int level, long /*int*/ authInfo, char[] checkboxLabel, int[] checkValue, int[] _retval) {
-		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 1, getAddress(), aParent, aChannel, level, authInfo, checkboxLabel, checkValue, _retval);
-	}
-
-	public int AsyncPromptAuth(long /*int*/ aParent, long /*int*/ aChannel, long /*int*/ aCallback, long /*int*/ aContext, int level, long /*int*/ authInfo, char[] checkboxLabel, int[] checkValue, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 2, getAddress(), aParent, aChannel, aCallback, aContext, level, authInfo, checkboxLabel, checkValue, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIPromptService2 extends nsIPromptService {
+
+	static final int LAST_METHOD_ID = nsIPromptService.LAST_METHOD_ID + 2;
+
+	public static final String NS_IPROMPTSERVICE2_IID_STR =
+		"cf86d196-dbee-4482-9dfa-3477aa128319";
+
+	public static final nsID NS_IPROMPTSERVICE2_IID =
+		new nsID(NS_IPROMPTSERVICE2_IID_STR);
+
+	public nsIPromptService2(long /*int*/ address) {
+		super(address);
+	}
+
+	public int PromptAuth(long /*int*/ aParent, long /*int*/ aChannel, int level, long /*int*/ authInfo, char[] checkboxLabel, int[] checkValue, int[] _retval) {
+		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 1, getAddress(), aParent, aChannel, level, authInfo, checkboxLabel, checkValue, _retval);
+	}
+
+	public int AsyncPromptAuth(long /*int*/ aParent, long /*int*/ aChannel, long /*int*/ aCallback, long /*int*/ aContext, int level, long /*int*/ authInfo, char[] checkboxLabel, int[] checkValue, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 2, getAddress(), aParent, aChannel, aCallback, aContext, level, authInfo, checkboxLabel, checkValue, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,118 +1,118 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIFilePicker_1_8 extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 15;
-
-	public static final String NS_IFILEPICKER_IID_STR =
-		"80faf095-c807-4558-a2cc-185ed70754ea";
-
-	public static final nsID NS_IFILEPICKER_IID =
-		new nsID(NS_IFILEPICKER_IID_STR);
-
-	public nsIFilePicker_1_8(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int modeOpen = 0;
-	public static final int modeSave = 1;
-	public static final int modeGetFolder = 2;
-	public static final int modeOpenMultiple = 3;
-	public static final int returnOK = 0;
-	public static final int returnCancel = 1;
-	public static final int returnReplace = 2;
-	public static final int filterAll = 1;
-	public static final int filterHTML = 2;
-	public static final int filterText = 4;
-	public static final int filterImages = 8;
-	public static final int filterXML = 16;
-	public static final int filterXUL = 32;
-	public static final int filterApps = 64;
-
-	public int Init(long /*int*/ parent, long /*int*/ title, int mode) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parent, title, mode);
-	}
-
-	public int AppendFilters(int filterMask) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), filterMask);
-	}
-
-	public int AppendFilter(long /*int*/ title, long /*int*/ filter) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), title, filter);
-	}
-
-	public int GetDefaultString(long /*int*/ aDefaultString) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aDefaultString);
-	}
-
-	public int SetDefaultString(long /*int*/ aDefaultString) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aDefaultString);
-	}
-
-	public int GetDefaultExtension(long /*int*/ aDefaultExtension) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aDefaultExtension);
-	}
-
-	public int SetDefaultExtension(long /*int*/ aDefaultExtension) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aDefaultExtension);
-	}
-
-	public int GetFilterIndex(int[] aFilterIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aFilterIndex);
-	}
-
-	public int SetFilterIndex(int aFilterIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aFilterIndex);
-	}
-
-	public int GetDisplayDirectory(long /*int*/[] aDisplayDirectory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aDisplayDirectory);
-	}
-
-	public int SetDisplayDirectory(long /*int*/ aDisplayDirectory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aDisplayDirectory);
-	}
-
-	public int GetFile(long /*int*/[] aFile) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aFile);
-	}
-
-	public int GetFileURL(long /*int*/[] aFileURL) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aFileURL);
-	}
-
-	public int GetFiles(long /*int*/[] aFiles) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aFiles);
-	}
-
-	public int Show(long /*int*/ _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIFilePicker_1_8 extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 15;
+
+	public static final String NS_IFILEPICKER_IID_STR =
+		"80faf095-c807-4558-a2cc-185ed70754ea";
+
+	public static final nsID NS_IFILEPICKER_IID =
+		new nsID(NS_IFILEPICKER_IID_STR);
+
+	public nsIFilePicker_1_8(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int modeOpen = 0;
+	public static final int modeSave = 1;
+	public static final int modeGetFolder = 2;
+	public static final int modeOpenMultiple = 3;
+	public static final int returnOK = 0;
+	public static final int returnCancel = 1;
+	public static final int returnReplace = 2;
+	public static final int filterAll = 1;
+	public static final int filterHTML = 2;
+	public static final int filterText = 4;
+	public static final int filterImages = 8;
+	public static final int filterXML = 16;
+	public static final int filterXUL = 32;
+	public static final int filterApps = 64;
+
+	public int Init(long /*int*/ parent, long /*int*/ title, int mode) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parent, title, mode);
+	}
+
+	public int AppendFilters(int filterMask) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), filterMask);
+	}
+
+	public int AppendFilter(long /*int*/ title, long /*int*/ filter) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), title, filter);
+	}
+
+	public int GetDefaultString(long /*int*/ aDefaultString) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aDefaultString);
+	}
+
+	public int SetDefaultString(long /*int*/ aDefaultString) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aDefaultString);
+	}
+
+	public int GetDefaultExtension(long /*int*/ aDefaultExtension) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aDefaultExtension);
+	}
+
+	public int SetDefaultExtension(long /*int*/ aDefaultExtension) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aDefaultExtension);
+	}
+
+	public int GetFilterIndex(int[] aFilterIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aFilterIndex);
+	}
+
+	public int SetFilterIndex(int aFilterIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aFilterIndex);
+	}
+
+	public int GetDisplayDirectory(long /*int*/[] aDisplayDirectory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aDisplayDirectory);
+	}
+
+	public int SetDisplayDirectory(long /*int*/ aDisplayDirectory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aDisplayDirectory);
+	}
+
+	public int GetFile(long /*int*/[] aFile) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aFile);
+	}
+
+	public int GetFileURL(long /*int*/[] aFileURL) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aFileURL);
+	}
+
+	public int GetFiles(long /*int*/[] aFiles) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aFiles);
+	}
+
+	public int Show(long /*int*/ _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDirectoryService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDirectoryService.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDirectoryService.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDirectoryService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDIRECTORYSERVICE_IID_STR =
-		"57a66a60-d43a-11d3-8cc2-00609792278c";
-
-	public static final nsID NS_IDIRECTORYSERVICE_IID =
-		new nsID(NS_IDIRECTORYSERVICE_IID_STR);
-
-	public nsIDirectoryService(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Init() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
-	}
-
-	public int RegisterProvider(long /*int*/ prov) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prov);
-	}
-
-	public int UnregisterProvider(long /*int*/ prov) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prov);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDirectoryService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDIRECTORYSERVICE_IID_STR =
+		"57a66a60-d43a-11d3-8cc2-00609792278c";
+
+	public static final nsID NS_IDIRECTORYSERVICE_IID =
+		new nsID(NS_IDIRECTORYSERVICE_IID_STR);
+
+	public nsIDirectoryService(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Init() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
+	}
+
+	public int RegisterProvider(long /*int*/ prov) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prov);
+	}
+
+	public int UnregisterProvider(long /*int*/ prov) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prov);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIRequest.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIRequest.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIRequest.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,101 +1,101 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIRequest extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
-
-	public static final String NS_IREQUEST_IID_STR =
-		"ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe";
-
-	public static final nsID NS_IREQUEST_IID =
-		new nsID(NS_IREQUEST_IID_STR);
-
-	public nsIRequest(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetName(long /*int*/ aName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aName);
-	}
-
-	public int IsPending(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
-	}
-
-	public int GetStatus(long /*int*/[] aStatus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aStatus);
-	}
-
-	public int Cancel(int aStatus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aStatus);
-	}
-
-	public int Suspend() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
-	}
-
-	public int Resume() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
-	}
-
-	public int GetLoadGroup(long /*int*/[] aLoadGroup) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aLoadGroup);
-	}
-
-	public int SetLoadGroup(long /*int*/ aLoadGroup) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aLoadGroup);
-	}
-
-	public int GetLoadFlags(long /*int*/[] aLoadFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aLoadFlags);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIRequest extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 10;
+
+	public static final String NS_IREQUEST_IID_STR =
+		"ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe";
+
+	public static final nsID NS_IREQUEST_IID =
+		new nsID(NS_IREQUEST_IID_STR);
+
+	public nsIRequest(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetName(long /*int*/ aName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aName);
+	}
+
+	public int IsPending(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
+	}
+
+	public int GetStatus(long /*int*/[] aStatus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aStatus);
+	}
+
+	public int Cancel(int aStatus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aStatus);
+	}
+
+	public int Suspend() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
+	}
+
+	public int Resume() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress());
+	}
+
+	public int GetLoadGroup(long /*int*/[] aLoadGroup) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aLoadGroup);
+	}
+
+	public int SetLoadGroup(long /*int*/ aLoadGroup) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aLoadGroup);
+	}
+
+	public int GetLoadFlags(long /*int*/[] aLoadFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aLoadFlags);
+	}
+
 	public int SetLoadFlags(int aLoadFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aLoadFlags);
-	}
-
-	public static final int LOAD_NORMAL = 0;
-
-	public static final int LOAD_BACKGROUND = 1;
-
-	public static final int INHIBIT_CACHING = 128;
-
-	public static final int INHIBIT_PERSISTENT_CACHING = 256;
-
-	public static final int LOAD_BYPASS_CACHE = 512;
-
-	public static final int LOAD_FROM_CACHE = 1024;
-
-	public static final int VALIDATE_ALWAYS = 2048;
-
-	public static final int VALIDATE_NEVER = 4096;
-
-	public static final int VALIDATE_ONCE_PER_SESSION = 8192;
-}
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aLoadFlags);
+	}
+
+	public static final int LOAD_NORMAL = 0;
+
+	public static final int LOAD_BACKGROUND = 1;
+
+	public static final int INHIBIT_CACHING = 128;
+
+	public static final int INHIBIT_PERSISTENT_CACHING = 256;
+
+	public static final int LOAD_BYPASS_CACHE = 512;
+
+	public static final int LOAD_FROM_CACHE = 1024;
+
+	public static final int VALIDATE_ALWAYS = 2048;
+
+	public static final int VALIDATE_NEVER = 4096;
+
+	public static final int VALIDATE_ONCE_PER_SESSION = 8192;
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,51 +1,51 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsISimpleEnumerator extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 2;
-
-	public static final String NS_ISIMPLEENUMERATOR_IID_STR =
-		"d1899240-f9d2-11d2-bdd6-000064657374";
-
-	public static final nsID NS_ISIMPLEENUMERATOR_IID =
-		new nsID(NS_ISIMPLEENUMERATOR_IID_STR);
-
-	public nsISimpleEnumerator(long /*int*/ address) {
-		super(address);
-	}
-
-	public int HasMoreElements(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), _retval);
-	}
-
-	public int GetNext(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsISimpleEnumerator extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 2;
+
+	public static final String NS_ISIMPLEENUMERATOR_IID_STR =
+		"d1899240-f9d2-11d2-bdd6-000064657374";
+
+	public static final nsID NS_ISIMPLEENUMERATOR_IID =
+		new nsID(NS_ISIMPLEENUMERATOR_IID_STR);
+
+	public nsISimpleEnumerator(long /*int*/ address) {
+		super(address);
+	}
+
+	public int HasMoreElements(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), _retval);
+	}
+
+	public int GetNext(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIProperties.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProperties.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProperties.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIProperties extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
-
-	public static final String NS_IPROPERTIES_IID_STR =
-		"78650582-4e93-4b60-8e85-26ebd3eb14ca";
-
-	public static final nsID NS_IPROPERTIES_IID =
-		new nsID(NS_IPROPERTIES_IID_STR);
-
-	public nsIProperties(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Get(byte[] prop, nsID iid, long /*int*/[] result) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, iid, result);
-	}
-
-	public int Set(byte[] prop, long /*int*/ value) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prop, value);
-	}
-
-	public int Has(byte[] prop, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prop, _retval);
-	}
-
-	public int Undefine(byte[] prop) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), prop);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIProperties extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
+
+	public static final String NS_IPROPERTIES_IID_STR =
+		"78650582-4e93-4b60-8e85-26ebd3eb14ca";
+
+	public static final nsID NS_IPROPERTIES_IID =
+		new nsID(NS_IPROPERTIES_IID_STR);
+
+	public nsIProperties(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Get(byte[] prop, nsID iid, long /*int*/[] result) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, iid, result);
+	}
+
+	public int Set(byte[] prop, long /*int*/ value) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prop, value);
+	}
+
+	public int Has(byte[] prop, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prop, _retval);
+	}
+
+	public int Undefine(byte[] prop) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), prop);
+	}
+
 	public int GetKeys(int[] count, long /*int*/[] keys) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), count, keys);
-	}
-}
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsISupports.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISupports.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISupports.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	
 	static final int FIRST_METHOD_ID = IsSolaris ? 2 : 0;
 	static final int LAST_METHOD_ID = FIRST_METHOD_ID + 2;
-	
+
 	public static final String NS_ISUPPORTS_IID_STR =
 		"00000000-0000-0000-c000-000000000046";
 
Index: org/eclipse/swt/internal/mozilla/nsIURIContentListener.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIURIContentListener.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIURIContentListener.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,75 +1,75 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIURIContentListener extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
-
-	public static final String NS_IURICONTENTLISTENER_IID_STR =
-		"94928ab3-8b63-11d3-989d-001083010e9b";
-
-	public static final nsID NS_IURICONTENTLISTENER_IID =
-		new nsID(NS_IURICONTENTLISTENER_IID_STR);
-
-	public nsIURIContentListener(long /*int*/ address) {
-		super(address);
-	}
-
-	public int OnStartURIOpen(long /*int*/ aURI, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, _retval);
-	}
-
-	public int DoContent(byte[] aContentType, int aIsContentPreferred, long /*int*/ aRequest, long /*int*/[] aContentHandler, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContentType, aIsContentPreferred, aRequest, aContentHandler, _retval);
-	}
-
-	public int IsPreferred(byte[] aContentType, long /*int*/[] aDesiredContentType, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aContentType, aDesiredContentType, _retval);
-	}
-
-	public int CanHandleContent(byte[] aContentType, int aIsContentPreferred, long /*int*/[] aDesiredContentType, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContentType, aIsContentPreferred, aDesiredContentType, _retval);
-	}
-
-	public int GetLoadCookie(long /*int*/[] aLoadCookie) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aLoadCookie);
-	}
-
-	public int SetLoadCookie(long /*int*/ aLoadCookie) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aLoadCookie);
-	}
-
-	public int GetParentContentListener(long /*int*/[] aParentContentListener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParentContentListener);
-	}
-
-	public int SetParentContentListener(long /*int*/ aParentContentListener) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParentContentListener);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIURIContentListener extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 8;
+
+	public static final String NS_IURICONTENTLISTENER_IID_STR =
+		"94928ab3-8b63-11d3-989d-001083010e9b";
+
+	public static final nsID NS_IURICONTENTLISTENER_IID =
+		new nsID(NS_IURICONTENTLISTENER_IID_STR);
+
+	public nsIURIContentListener(long /*int*/ address) {
+		super(address);
+	}
+
+	public int OnStartURIOpen(long /*int*/ aURI, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, _retval);
+	}
+
+	public int DoContent(byte[] aContentType, int aIsContentPreferred, long /*int*/ aRequest, long /*int*/[] aContentHandler, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContentType, aIsContentPreferred, aRequest, aContentHandler, _retval);
+	}
+
+	public int IsPreferred(byte[] aContentType, long /*int*/[] aDesiredContentType, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aContentType, aDesiredContentType, _retval);
+	}
+
+	public int CanHandleContent(byte[] aContentType, int aIsContentPreferred, long /*int*/[] aDesiredContentType, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContentType, aIsContentPreferred, aDesiredContentType, _retval);
+	}
+
+	public int GetLoadCookie(long /*int*/[] aLoadCookie) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aLoadCookie);
+	}
+
+	public int SetLoadCookie(long /*int*/ aLoadCookie) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aLoadCookie);
+	}
+
+	public int GetParentContentListener(long /*int*/[] aParentContentListener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParentContentListener);
+	}
+
+	public int SetParentContentListener(long /*int*/ aParentContentListener) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParentContentListener);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,47 +1,47 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDirectoryServiceProvider extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 1;
-
-	public static final String NS_IDIRECTORYSERVICEPROVIDER_IID_STR =
-		"bbf8cab0-d43a-11d3-8cc2-00609792278c";
-
-	public static final nsID NS_IDIRECTORYSERVICEPROVIDER_IID =
-		new nsID(NS_IDIRECTORYSERVICEPROVIDER_IID_STR);
-
-	public nsIDirectoryServiceProvider(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetFile(byte[] prop, int[] persistent, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, persistent, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDirectoryServiceProvider extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 1;
+
+	public static final String NS_IDIRECTORYSERVICEPROVIDER_IID_STR =
+		"bbf8cab0-d43a-11d3-8cc2-00609792278c";
+
+	public static final nsID NS_IDIRECTORYSERVICEPROVIDER_IID =
+		new nsID(NS_IDIRECTORYSERVICEPROVIDER_IID_STR);
+
+	public nsIDirectoryServiceProvider(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetFile(byte[] prop, int[] persistent, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, persistent, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIBaseWindow.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIBaseWindow.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIBaseWindow.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,139 +1,139 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIBaseWindow extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 24;
-
-	public static final String NS_IBASEWINDOW_IID_STR =
-		"046bc8a0-8015-11d3-af70-00a024ffc08c";
-
-	public static final nsID NS_IBASEWINDOW_IID =
-		new nsID(NS_IBASEWINDOW_IID_STR);
-
-	public nsIBaseWindow(long /*int*/ address) {
-		super(address);
-	}
-
-	public int InitWindow(long /*int*/ parentNativeWindow, long /*int*/ parentWidget, int x, int y, int cx, int cy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parentNativeWindow, parentWidget, x, y, cx, cy);
-	}
-
-	public int Create() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
-	}
-
-	public int Destroy() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
-	}
-
-	public int SetPosition(int x, int y) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), x, y);
-	}
-
-	public int GetPosition(int[] x, int[] y) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), x, y);
-	}
-
-	public int SetSize(int cx, int cy, int fRepaint) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), cx, cy, fRepaint);
-	}
-
-	public int GetSize(int[] cx, int[] cy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), cx, cy);
-	}
-
-	public int SetPositionAndSize(int x, int y, int cx, int cy, int fRepaint) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), x, y, cx, cy, fRepaint);
-	}
-
-	public int GetPositionAndSize(int[] x, int[] y, int[] cx, int[] cy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), x, y, cx, cy);
-	}
-
-	public int Repaint(int force) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), force);
-	}
-
-	public int GetParentWidget(long /*int*/[] aParentWidget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aParentWidget);
-	}
-
-	public int SetParentWidget(long /*int*/ aParentWidget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aParentWidget);
-	}
-
-	public int GetParentNativeWindow(long /*int*/[] aParentNativeWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aParentNativeWindow);
-	}
-
-	public int SetParentNativeWindow(long /*int*/ aParentNativeWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aParentNativeWindow);
-	}
-
-	public int GetVisibility(int[] aVisibility) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aVisibility);
-	}
-
-	public int SetVisibility(int aVisibility) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aVisibility);
-	}
-
-	public int GetEnabled(int[] aEnabled) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aEnabled);
-	}
-
-	public int SetEnabled(int aEnabled) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aEnabled);
-	}
-
-	public int GetBlurSuppression(int[] aBlurSuppression) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aBlurSuppression);
-	}
-
-	public int SetBlurSuppression(int aBlurSuppression) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aBlurSuppression);
-	}
-
-	public int GetMainWidget(long /*int*/[] aMainWidget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aMainWidget);
-	}
-
-	public int SetFocus() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress());
-	}
-
-	public int GetTitle(long /*int*/[] aTitle) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aTitle);
-	}
-
-	public int SetTitle(char[] aTitle) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aTitle);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIBaseWindow extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 24;
+
+	public static final String NS_IBASEWINDOW_IID_STR =
+		"046bc8a0-8015-11d3-af70-00a024ffc08c";
+
+	public static final nsID NS_IBASEWINDOW_IID =
+		new nsID(NS_IBASEWINDOW_IID_STR);
+
+	public nsIBaseWindow(long /*int*/ address) {
+		super(address);
+	}
+
+	public int InitWindow(long /*int*/ parentNativeWindow, long /*int*/ parentWidget, int x, int y, int cx, int cy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parentNativeWindow, parentWidget, x, y, cx, cy);
+	}
+
+	public int Create() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
+	}
+
+	public int Destroy() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
+	}
+
+	public int SetPosition(int x, int y) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), x, y);
+	}
+
+	public int GetPosition(int[] x, int[] y) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), x, y);
+	}
+
+	public int SetSize(int cx, int cy, int fRepaint) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), cx, cy, fRepaint);
+	}
+
+	public int GetSize(int[] cx, int[] cy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), cx, cy);
+	}
+
+	public int SetPositionAndSize(int x, int y, int cx, int cy, int fRepaint) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), x, y, cx, cy, fRepaint);
+	}
+
+	public int GetPositionAndSize(int[] x, int[] y, int[] cx, int[] cy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), x, y, cx, cy);
+	}
+
+	public int Repaint(int force) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), force);
+	}
+
+	public int GetParentWidget(long /*int*/[] aParentWidget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aParentWidget);
+	}
+
+	public int SetParentWidget(long /*int*/ aParentWidget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aParentWidget);
+	}
+
+	public int GetParentNativeWindow(long /*int*/[] aParentNativeWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aParentNativeWindow);
+	}
+
+	public int SetParentNativeWindow(long /*int*/ aParentNativeWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aParentNativeWindow);
+	}
+
+	public int GetVisibility(int[] aVisibility) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aVisibility);
+	}
+
+	public int SetVisibility(int aVisibility) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aVisibility);
+	}
+
+	public int GetEnabled(int[] aEnabled) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aEnabled);
+	}
+
+	public int SetEnabled(int aEnabled) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aEnabled);
+	}
+
+	public int GetBlurSuppression(int[] aBlurSuppression) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aBlurSuppression);
+	}
+
+	public int SetBlurSuppression(int aBlurSuppression) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aBlurSuppression);
+	}
+
+	public int GetMainWidget(long /*int*/[] aMainWidget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aMainWidget);
+	}
+
+	public int SetFocus() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress());
+	}
+
+	public int GetTitle(long /*int*/[] aTitle) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aTitle);
+	}
+
+	public int SetTitle(char[] aTitle) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aTitle);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/XPCOMObject.java
===================================================================
--- org/eclipse/swt/internal/mozilla/XPCOMObject.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/XPCOMObject.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -20,9 +20,9 @@
 		String osName = System.getProperty ("os.name").toLowerCase (); //$NON-NLS-1$
 		IsSolaris = osName.startsWith ("sunos") || osName.startsWith("solaris"); //$NON-NLS-1$
 	}
+
+	private long /*int*/ ppVtable;
 	
-	private long /*int*/ ppVtable;
-
 	static private final int MAX_ARG_COUNT = 12;
 	static private final int MAX_VTABLE_LENGTH = 80;
 	static final int OS_OFFSET = IsSolaris ? 2 : 0;
Index: org/eclipse/swt/internal/mozilla/nsIDocShell_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDocShell_1_8.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDocShell_1_8.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,317 +1,317 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDocShell_1_8 extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 61;
-
-	public static final String NS_IDOCSHELL_IID_STR =
-		"9f0c7461-b9a4-47f6-b88c-421dce1bce66";
-
-	public static final nsID NS_IDOCSHELL_IID =
-		new nsID(NS_IDOCSHELL_IID_STR);
-
-	public nsIDocShell_1_8(long /*int*/ address) {
-		super(address);
-	}
-
-	public int LoadURI(long /*int*/ uri, long /*int*/ loadInfo, int aLoadFlags, int firstParty) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uri, loadInfo, aLoadFlags, firstParty);
-	}
-
-	public int LoadStream(long /*int*/ aStream, long /*int*/ aURI, long /*int*/ aContentType, long /*int*/ aContentCharset, long /*int*/ aLoadInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aStream, aURI, aContentType, aContentCharset, aLoadInfo);
-	}
-
-	public static final int INTERNAL_LOAD_FLAGS_NONE = 0;
-
-	public static final int INTERNAL_LOAD_FLAGS_INHERIT_OWNER = 1;
-
-	public static final int INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER = 2;
-
-	public int InternalLoad(long /*int*/ aURI, long /*int*/ aReferrer, long /*int*/ aOwner, int aFlags, char[] aWindowTarget, byte[] aTypeHint, long /*int*/ aPostDataStream, long /*int*/ aHeadersStream, int aLoadFlags, long /*int*/ aSHEntry, int firstParty, long /*int*/[] aDocShell, long /*int*/[] aRequest) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aReferrer, aOwner, aFlags, aWindowTarget, aTypeHint, aPostDataStream, aHeadersStream, aLoadFlags, aSHEntry, firstParty, aDocShell, aRequest);
-	}
-
-	public int CreateLoadInfo(long /*int*/[] loadInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), loadInfo);
-	}
-
-	public int PrepareForNewContentModel() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
-	}
-
-	public int SetCurrentURI(long /*int*/ aURI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aURI);
-	}
-
-	public int FirePageHideNotification(int isUnload) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), isUnload);
-	}
-
-	public int GetPresContext(long /*int*/[] aPresContext) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPresContext);
-	}
-
-	public int GetPresShell(long /*int*/[] aPresShell) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPresShell);
-	}
-
-	public int GetEldestPresShell(long /*int*/[] aEldestPresShell) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aEldestPresShell);
-	}
-
-	public int GetContentViewer(long /*int*/[] aContentViewer) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aContentViewer);
-	}
-
-	public int GetChromeEventHandler(long /*int*/[] aChromeEventHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aChromeEventHandler);
-	}
-
-	public int SetChromeEventHandler(long /*int*/ aChromeEventHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aChromeEventHandler);
-	}
-
-	public int GetDocumentCharsetInfo(long /*int*/[] aDocumentCharsetInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aDocumentCharsetInfo);
-	}
-
-	public int SetDocumentCharsetInfo(long /*int*/ aDocumentCharsetInfo) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aDocumentCharsetInfo);
-	}
-
-	public int GetAllowPlugins(int[] aAllowPlugins) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aAllowPlugins);
-	}
-
-	public int SetAllowPlugins(int aAllowPlugins) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aAllowPlugins);
-	}
-
-	public int GetAllowJavascript(int[] aAllowJavascript) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aAllowJavascript);
-	}
-
-	public int SetAllowJavascript(int aAllowJavascript) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aAllowJavascript);
-	}
-
-	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aAllowMetaRedirects);
-	}
-
-	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aAllowMetaRedirects);
-	}
-
-	public int GetAllowSubframes(int[] aAllowSubframes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aAllowSubframes);
-	}
-
-	public int SetAllowSubframes(int aAllowSubframes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aAllowSubframes);
-	}
-
-	public int GetAllowImages(int[] aAllowImages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAllowImages);
-	}
-
-	public int SetAllowImages(int aAllowImages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAllowImages);
-	}
-
-	public static final int ENUMERATE_FORWARDS = 0;
-
-	public static final int ENUMERATE_BACKWARDS = 1;
-
-	public int GetDocShellEnumerator(int aItemType, int aDirection, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aItemType, aDirection, _retval);
-	}
-
-	public static final int APP_TYPE_UNKNOWN = 0;
-
-	public static final int APP_TYPE_MAIL = 1;
-
-	public static final int APP_TYPE_EDITOR = 2;
-
-	public int GetAppType(int[] aAppType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aAppType);
-	}
-
-	public int SetAppType(int aAppType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aAppType);
-	}
-
-	public int GetAllowAuth(int[] aAllowAuth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aAllowAuth);
-	}
-
-	public int SetAllowAuth(int aAllowAuth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aAllowAuth);
-	}
-
-	public int GetZoom(float[] aZoom) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), aZoom);
-	}
-
-	public int SetZoom(float aZoom) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aZoom);
-	}
-
-	public int GetMarginWidth(int[] aMarginWidth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), aMarginWidth);
-	}
-
-	public int SetMarginWidth(int aMarginWidth) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), aMarginWidth);
-	}
-
-	public int GetMarginHeight(int[] aMarginHeight) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), aMarginHeight);
-	}
-
-	public int SetMarginHeight(int aMarginHeight) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aMarginHeight);
-	}
-
-	public int GetHasFocus(int[] aHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), aHasFocus);
-	}
-
-	public int SetHasFocus(int aHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), aHasFocus);
-	}
-
-	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), aCanvasHasFocus);
-	}
-
-	public int SetCanvasHasFocus(int aCanvasHasFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), aCanvasHasFocus);
-	}
-
-	public int TabToTreeOwner(int forward, int[] tookFocus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), forward, tookFocus);
-	}
-
-	public static final int BUSY_FLAGS_NONE = 0;
-
-	public static final int BUSY_FLAGS_BUSY = 1;
-
-	public static final int BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
-
-	public static final int BUSY_FLAGS_PAGE_LOADING = 4;
-
-	public static final int LOAD_CMD_NORMAL = 1;
-
-	public static final int LOAD_CMD_RELOAD = 2;
-
-	public static final int LOAD_CMD_HISTORY = 4;
-
-	public int GetBusyFlags(int[] aBusyFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), aBusyFlags);
-	}
-
-	public int GetLoadType(int[] aLoadType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), aLoadType);
-	}
-
-	public int SetLoadType(int aLoadType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aLoadType);
-	}
-
-	public int IsBeingDestroyed(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), _retval);
-	}
-
-	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 46, getAddress(), aIsExecutingOnLoadHandler);
-	}
-
-	public int GetLayoutHistoryState(long /*int*/[] aLayoutHistoryState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 47, getAddress(), aLayoutHistoryState);
-	}
-
-	public int SetLayoutHistoryState(long /*int*/ aLayoutHistoryState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 48, getAddress(), aLayoutHistoryState);
-	}
-
-	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 49, getAddress(), aShouldSaveLayoutState);
-	}
-
-	public int GetSecurityUI(long /*int*/[] aSecurityUI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 50, getAddress(), aSecurityUI);
-	}
-
-	public int SetSecurityUI(long /*int*/ aSecurityUI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 51, getAddress(), aSecurityUI);
-	}
-
-	public int SuspendRefreshURIs() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 52, getAddress());
-	}
-
-	public int ResumeRefreshURIs() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 53, getAddress());
-	}
-
-	public int BeginRestore(long /*int*/ viewer, int top) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 54, getAddress(), viewer, top);
-	}
-
-	public int FinishRestore() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 55, getAddress());
-	}
-
-	public int GetRestoringDocument(int[] aRestoringDocument) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 56, getAddress(), aRestoringDocument);
-	}
-
-	public int GetUseErrorPages(int[] aUseErrorPages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 57, getAddress(), aUseErrorPages);
-	}
-
-	public int SetUseErrorPages(int aUseErrorPages) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 58, getAddress(), aUseErrorPages);
-	}
-
-	public int GetPreviousTransIndex(int[] aPreviousTransIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 59, getAddress(), aPreviousTransIndex);
-	}
-
-	public int GetLoadedTransIndex(int[] aLoadedTransIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 60, getAddress(), aLoadedTransIndex);
-	}
-
-	public int HistoryPurged(int numEntries) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 61, getAddress(), numEntries);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDocShell_1_8 extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 61;
+
+	public static final String NS_IDOCSHELL_IID_STR =
+		"9f0c7461-b9a4-47f6-b88c-421dce1bce66";
+
+	public static final nsID NS_IDOCSHELL_IID =
+		new nsID(NS_IDOCSHELL_IID_STR);
+
+	public nsIDocShell_1_8(long /*int*/ address) {
+		super(address);
+	}
+
+	public int LoadURI(long /*int*/ uri, long /*int*/ loadInfo, int aLoadFlags, int firstParty) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uri, loadInfo, aLoadFlags, firstParty);
+	}
+
+	public int LoadStream(long /*int*/ aStream, long /*int*/ aURI, long /*int*/ aContentType, long /*int*/ aContentCharset, long /*int*/ aLoadInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aStream, aURI, aContentType, aContentCharset, aLoadInfo);
+	}
+
+	public static final int INTERNAL_LOAD_FLAGS_NONE = 0;
+
+	public static final int INTERNAL_LOAD_FLAGS_INHERIT_OWNER = 1;
+
+	public static final int INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER = 2;
+
+	public int InternalLoad(long /*int*/ aURI, long /*int*/ aReferrer, long /*int*/ aOwner, int aFlags, char[] aWindowTarget, byte[] aTypeHint, long /*int*/ aPostDataStream, long /*int*/ aHeadersStream, int aLoadFlags, long /*int*/ aSHEntry, int firstParty, long /*int*/[] aDocShell, long /*int*/[] aRequest) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aReferrer, aOwner, aFlags, aWindowTarget, aTypeHint, aPostDataStream, aHeadersStream, aLoadFlags, aSHEntry, firstParty, aDocShell, aRequest);
+	}
+
+	public int CreateLoadInfo(long /*int*/[] loadInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), loadInfo);
+	}
+
+	public int PrepareForNewContentModel() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress());
+	}
+
+	public int SetCurrentURI(long /*int*/ aURI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aURI);
+	}
+
+	public int FirePageHideNotification(int isUnload) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), isUnload);
+	}
+
+	public int GetPresContext(long /*int*/[] aPresContext) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPresContext);
+	}
+
+	public int GetPresShell(long /*int*/[] aPresShell) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPresShell);
+	}
+
+	public int GetEldestPresShell(long /*int*/[] aEldestPresShell) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aEldestPresShell);
+	}
+
+	public int GetContentViewer(long /*int*/[] aContentViewer) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aContentViewer);
+	}
+
+	public int GetChromeEventHandler(long /*int*/[] aChromeEventHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aChromeEventHandler);
+	}
+
+	public int SetChromeEventHandler(long /*int*/ aChromeEventHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aChromeEventHandler);
+	}
+
+	public int GetDocumentCharsetInfo(long /*int*/[] aDocumentCharsetInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aDocumentCharsetInfo);
+	}
+
+	public int SetDocumentCharsetInfo(long /*int*/ aDocumentCharsetInfo) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aDocumentCharsetInfo);
+	}
+
+	public int GetAllowPlugins(int[] aAllowPlugins) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aAllowPlugins);
+	}
+
+	public int SetAllowPlugins(int aAllowPlugins) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aAllowPlugins);
+	}
+
+	public int GetAllowJavascript(int[] aAllowJavascript) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aAllowJavascript);
+	}
+
+	public int SetAllowJavascript(int aAllowJavascript) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aAllowJavascript);
+	}
+
+	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aAllowMetaRedirects);
+	}
+
+	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aAllowMetaRedirects);
+	}
+
+	public int GetAllowSubframes(int[] aAllowSubframes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aAllowSubframes);
+	}
+
+	public int SetAllowSubframes(int aAllowSubframes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aAllowSubframes);
+	}
+
+	public int GetAllowImages(int[] aAllowImages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAllowImages);
+	}
+
+	public int SetAllowImages(int aAllowImages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAllowImages);
+	}
+
+	public static final int ENUMERATE_FORWARDS = 0;
+
+	public static final int ENUMERATE_BACKWARDS = 1;
+
+	public int GetDocShellEnumerator(int aItemType, int aDirection, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aItemType, aDirection, _retval);
+	}
+
+	public static final int APP_TYPE_UNKNOWN = 0;
+
+	public static final int APP_TYPE_MAIL = 1;
+
+	public static final int APP_TYPE_EDITOR = 2;
+
+	public int GetAppType(int[] aAppType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aAppType);
+	}
+
+	public int SetAppType(int aAppType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aAppType);
+	}
+
+	public int GetAllowAuth(int[] aAllowAuth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aAllowAuth);
+	}
+
+	public int SetAllowAuth(int aAllowAuth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aAllowAuth);
+	}
+
+	public int GetZoom(float[] aZoom) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), aZoom);
+	}
+
+	public int SetZoom(float aZoom) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aZoom);
+	}
+
+	public int GetMarginWidth(int[] aMarginWidth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), aMarginWidth);
+	}
+
+	public int SetMarginWidth(int aMarginWidth) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), aMarginWidth);
+	}
+
+	public int GetMarginHeight(int[] aMarginHeight) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), aMarginHeight);
+	}
+
+	public int SetMarginHeight(int aMarginHeight) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aMarginHeight);
+	}
+
+	public int GetHasFocus(int[] aHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), aHasFocus);
+	}
+
+	public int SetHasFocus(int aHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), aHasFocus);
+	}
+
+	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), aCanvasHasFocus);
+	}
+
+	public int SetCanvasHasFocus(int aCanvasHasFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), aCanvasHasFocus);
+	}
+
+	public int TabToTreeOwner(int forward, int[] tookFocus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), forward, tookFocus);
+	}
+
+	public static final int BUSY_FLAGS_NONE = 0;
+
+	public static final int BUSY_FLAGS_BUSY = 1;
+
+	public static final int BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
+
+	public static final int BUSY_FLAGS_PAGE_LOADING = 4;
+
+	public static final int LOAD_CMD_NORMAL = 1;
+
+	public static final int LOAD_CMD_RELOAD = 2;
+
+	public static final int LOAD_CMD_HISTORY = 4;
+
+	public int GetBusyFlags(int[] aBusyFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), aBusyFlags);
+	}
+
+	public int GetLoadType(int[] aLoadType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), aLoadType);
+	}
+
+	public int SetLoadType(int aLoadType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aLoadType);
+	}
+
+	public int IsBeingDestroyed(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), _retval);
+	}
+
+	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 46, getAddress(), aIsExecutingOnLoadHandler);
+	}
+
+	public int GetLayoutHistoryState(long /*int*/[] aLayoutHistoryState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 47, getAddress(), aLayoutHistoryState);
+	}
+
+	public int SetLayoutHistoryState(long /*int*/ aLayoutHistoryState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 48, getAddress(), aLayoutHistoryState);
+	}
+
+	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 49, getAddress(), aShouldSaveLayoutState);
+	}
+
+	public int GetSecurityUI(long /*int*/[] aSecurityUI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 50, getAddress(), aSecurityUI);
+	}
+
+	public int SetSecurityUI(long /*int*/ aSecurityUI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 51, getAddress(), aSecurityUI);
+	}
+
+	public int SuspendRefreshURIs() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 52, getAddress());
+	}
+
+	public int ResumeRefreshURIs() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 53, getAddress());
+	}
+
+	public int BeginRestore(long /*int*/ viewer, int top) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 54, getAddress(), viewer, top);
+	}
+
+	public int FinishRestore() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 55, getAddress());
+	}
+
+	public int GetRestoringDocument(int[] aRestoringDocument) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 56, getAddress(), aRestoringDocument);
+	}
+
+	public int GetUseErrorPages(int[] aUseErrorPages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 57, getAddress(), aUseErrorPages);
+	}
+
+	public int SetUseErrorPages(int aUseErrorPages) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 58, getAddress(), aUseErrorPages);
+	}
+
+	public int GetPreviousTransIndex(int[] aPreviousTransIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 59, getAddress(), aPreviousTransIndex);
+	}
+
+	public int GetLoadedTransIndex(int[] aLoadedTransIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 60, getAddress(), aLoadedTransIndex);
+	}
+
+	public int HistoryPurged(int numEntries) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 61, getAddress(), numEntries);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookie.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookie.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookie.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,101 +1,101 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsICookie extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
-
-	public static final String NS_ICOOKIE_IID_STR =
-		"e9fcb9a4-d376-458f-b720-e65e7df593bc";
-
-	public static final nsID NS_ICOOKIE_IID =
-		new nsID(NS_ICOOKIE_IID_STR);
-
-	public nsICookie(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetName(long /*int*/ aName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aName);
-	}
-
-	public int GetValue(long /*int*/ aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aValue);
-	}
-
-	public int GetIsDomain(int[] aIsDomain) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aIsDomain);
-	}
-
-	public int GetHost(long /*int*/ aHost) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aHost);
-	}
-
-	public int GetPath(long /*int*/ aPath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aPath);
-	}
-
-	public int GetIsSecure(int[] aIsSecure) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aIsSecure);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsICookie extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
+
+	public static final String NS_ICOOKIE_IID_STR =
+		"e9fcb9a4-d376-458f-b720-e65e7df593bc";
+
+	public static final nsID NS_ICOOKIE_IID =
+		new nsID(NS_ICOOKIE_IID_STR);
+
+	public nsICookie(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetName(long /*int*/ aName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aName);
+	}
+
+	public int GetValue(long /*int*/ aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aValue);
+	}
+
+	public int GetIsDomain(int[] aIsDomain) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aIsDomain);
+	}
+
+	public int GetHost(long /*int*/ aHost) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aHost);
+	}
+
+	public int GetPath(long /*int*/ aPath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aPath);
+	}
+
+	public int GetIsSecure(int[] aIsSecure) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aIsSecure);
+	}
+
 	public int GetExpires(long[] aExpires) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aExpires);
-	}
-
-	public static final int STATUS_UNKNOWN = 0;
-
-	public static final int STATUS_ACCEPTED = 1;
-
-	public static final int STATUS_DOWNGRADED = 2;
-
-	public static final int STATUS_FLAGGED = 3;
-
-	public static final int STATUS_REJECTED = 4;
-
-	public int GetStatus(long /*int*/ aStatus) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aStatus);
-	}
-
-	public static final int POLICY_UNKNOWN = 0;
-
-	public static final int POLICY_NONE = 1;
-
-	public static final int POLICY_NO_CONSENT = 2;
-
-	public static final int POLICY_IMPLICIT_CONSENT = 3;
-
-	public static final int POLICY_EXPLICIT_CONSENT = 4;
-
-	public static final int POLICY_NO_II = 5;
-
-	public int GetPolicy(long /*int*/ aPolicy) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPolicy);
-	}
-}
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aExpires);
+	}
+
+	public static final int STATUS_UNKNOWN = 0;
+
+	public static final int STATUS_ACCEPTED = 1;
+
+	public static final int STATUS_DOWNGRADED = 2;
+
+	public static final int STATUS_FLAGGED = 3;
+
+	public static final int STATUS_REJECTED = 4;
+
+	public int GetStatus(long /*int*/ aStatus) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aStatus);
+	}
+
+	public static final int POLICY_UNKNOWN = 0;
+
+	public static final int POLICY_NONE = 1;
+
+	public static final int POLICY_NO_CONSENT = 2;
+
+	public static final int POLICY_IMPLICIT_CONSENT = 3;
+
+	public static final int POLICY_EXPLICIT_CONSENT = 4;
+
+	public static final int POLICY_NO_II = 5;
+
+	public int GetPolicy(long /*int*/ aPolicy) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPolicy);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,49 +1,49 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIWindowCreator2 extends nsIWindowCreator {
-
-	static final int LAST_METHOD_ID = nsIWindowCreator.LAST_METHOD_ID + 1;
-
-	public static final String NS_IWINDOWCREATOR2_IID_STR =
-		"f673ec81-a4b0-11d6-964b-eb5a2bf216fc";
-
-	public static final nsID NS_IWINDOWCREATOR2_IID =
-		new nsID(NS_IWINDOWCREATOR2_IID_STR);
-
-	public nsIWindowCreator2(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int PARENT_IS_LOADING_OR_RUNNING_TIMEOUT = 1;
-
-	public int CreateChromeWindow2(long /*int*/ parent, int chromeFlags, int contextFlags, long /*int*/ uri, int[] cancel, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsIWindowCreator.LAST_METHOD_ID + 1, getAddress(), parent, chromeFlags, contextFlags, uri, cancel, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIWindowCreator2 extends nsIWindowCreator {
+
+	static final int LAST_METHOD_ID = nsIWindowCreator.LAST_METHOD_ID + 1;
+
+	public static final String NS_IWINDOWCREATOR2_IID_STR =
+		"f673ec81-a4b0-11d6-964b-eb5a2bf216fc";
+
+	public static final nsID NS_IWINDOWCREATOR2_IID =
+		new nsID(NS_IWINDOWCREATOR2_IID_STR);
+
+	public nsIWindowCreator2(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int PARENT_IS_LOADING_OR_RUNNING_TIMEOUT = 1;
+
+	public int CreateChromeWindow2(long /*int*/ parent, int chromeFlags, int contextFlags, long /*int*/ uri, int[] cancel, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsIWindowCreator.LAST_METHOD_ID + 1, getAddress(), parent, chromeFlags, contextFlags, uri, cancel, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIFile.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFile.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFile.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,227 +1,227 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIFile extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 45;
-
-	public static final String NS_IFILE_IID_STR =
-		"c8c0a080-0868-11d3-915f-d9d889d48e3c";
-
-	public static final nsID NS_IFILE_IID =
-		new nsID(NS_IFILE_IID_STR);
-
-	public nsIFile(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int NORMAL_FILE_TYPE = 0;
-
-	public static final int DIRECTORY_TYPE = 1;
-
-	public int Append(long /*int*/ node) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), node);
-	}
-
-	public int AppendNative(long /*int*/ node) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), node);
-	}
-
-	public int Normalize() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
-	}
-
-	public int Create(int type, int permissions) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), type, permissions);
-	}
-
-	public int GetLeafName(long /*int*/ aLeafName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aLeafName);
-	}
-
-	public int SetLeafName(long /*int*/ aLeafName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aLeafName);
-	}
-
-	public int GetNativeLeafName(long /*int*/ aNativeLeafName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aNativeLeafName);
-	}
-
-	public int SetNativeLeafName(long /*int*/ aNativeLeafName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aNativeLeafName);
-	}
-
-	public int CopyTo(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), newParentDir, newName);
-	}
-
-	public int CopyToNative(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), newParentDir, newName);
-	}
-
-	public int CopyToFollowingLinks(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), newParentDir, newName);
-	}
-
-	public int CopyToFollowingLinksNative(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), newParentDir, newName);
-	}
-
-	public int MoveTo(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), newParentDir, newName);
-	}
-
-	public int MoveToNative(long /*int*/ newParentDir, long /*int*/ newName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), newParentDir, newName);
-	}
-
-	public int Remove(int recursive) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), recursive);
-	}
-
-	public int GetPermissions(int[] aPermissions) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aPermissions);
-	}
-
-	public int SetPermissions(int aPermissions) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aPermissions);
-	}
-
-	public int GetPermissionsOfLink(int[] aPermissionsOfLink) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPermissionsOfLink);
-	}
-
-	public int SetPermissionsOfLink(int aPermissionsOfLink) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aPermissionsOfLink);
-	}
-
-	public int GetLastModifiedTime(long[] aLastModifiedTime) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aLastModifiedTime);
-	}
-
-	public int SetLastModifiedTime(long aLastModifiedTime) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aLastModifiedTime);
-	}
-
-	public int GetLastModifiedTimeOfLink(long[] aLastModifiedTimeOfLink) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aLastModifiedTimeOfLink);
-	}
-
-	public int SetLastModifiedTimeOfLink(long aLastModifiedTimeOfLink) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aLastModifiedTimeOfLink);
-	}
-
-	public int GetFileSize(long[] aFileSize) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aFileSize);
-	}
-
-	public int SetFileSize(long aFileSize) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aFileSize);
-	}
-
-	public int GetFileSizeOfLink(long[] aFileSizeOfLink) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aFileSizeOfLink);
-	}
-
-	public int GetTarget(long /*int*/ aTarget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aTarget);
-	}
-
-	public int GetNativeTarget(long /*int*/ aNativeTarget) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aNativeTarget);
-	}
-
-	public int GetPath(long /*int*/ aPath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aPath);
-	}
-
-	public int GetNativePath(long /*int*/ aNativePath) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aNativePath);
-	}
-
-	public int Exists(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), _retval);
-	}
-
-	public int IsWritable(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), _retval);
-	}
-
-	public int IsReadable(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), _retval);
-	}
-
-	public int IsExecutable(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), _retval);
-	}
-
-	public int IsHidden(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), _retval);
-	}
-
-	public int IsDirectory(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), _retval);
-	}
-
-	public int IsFile(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), _retval);
-	}
-
-	public int IsSymlink(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), _retval);
-	}
-
-	public int IsSpecial(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), _retval);
-	}
-
-	public int CreateUnique(int type, int permissions) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), type, permissions);
-	}
-
-	public int Clone(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), _retval);
-	}
-
-	public int Equals(long /*int*/ inFile, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), inFile, _retval);
-	}
-
-	public int Contains(long /*int*/ inFile, int recur, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), inFile, recur, _retval);
-	}
-
-	public int GetParent(long /*int*/[] aParent) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aParent);
-	}
-
-	public int GetDirectoryEntries(long /*int*/[] aDirectoryEntries) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), aDirectoryEntries);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIFile extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 45;
+
+	public static final String NS_IFILE_IID_STR =
+		"c8c0a080-0868-11d3-915f-d9d889d48e3c";
+
+	public static final nsID NS_IFILE_IID =
+		new nsID(NS_IFILE_IID_STR);
+
+	public nsIFile(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int NORMAL_FILE_TYPE = 0;
+
+	public static final int DIRECTORY_TYPE = 1;
+
+	public int Append(long /*int*/ node) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), node);
+	}
+
+	public int AppendNative(long /*int*/ node) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), node);
+	}
+
+	public int Normalize() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
+	}
+
+	public int Create(int type, int permissions) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), type, permissions);
+	}
+
+	public int GetLeafName(long /*int*/ aLeafName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aLeafName);
+	}
+
+	public int SetLeafName(long /*int*/ aLeafName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aLeafName);
+	}
+
+	public int GetNativeLeafName(long /*int*/ aNativeLeafName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aNativeLeafName);
+	}
+
+	public int SetNativeLeafName(long /*int*/ aNativeLeafName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aNativeLeafName);
+	}
+
+	public int CopyTo(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), newParentDir, newName);
+	}
+
+	public int CopyToNative(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), newParentDir, newName);
+	}
+
+	public int CopyToFollowingLinks(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), newParentDir, newName);
+	}
+
+	public int CopyToFollowingLinksNative(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), newParentDir, newName);
+	}
+
+	public int MoveTo(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), newParentDir, newName);
+	}
+
+	public int MoveToNative(long /*int*/ newParentDir, long /*int*/ newName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), newParentDir, newName);
+	}
+
+	public int Remove(int recursive) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), recursive);
+	}
+
+	public int GetPermissions(int[] aPermissions) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aPermissions);
+	}
+
+	public int SetPermissions(int aPermissions) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aPermissions);
+	}
+
+	public int GetPermissionsOfLink(int[] aPermissionsOfLink) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPermissionsOfLink);
+	}
+
+	public int SetPermissionsOfLink(int aPermissionsOfLink) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aPermissionsOfLink);
+	}
+
+	public int GetLastModifiedTime(long[] aLastModifiedTime) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aLastModifiedTime);
+	}
+
+	public int SetLastModifiedTime(long aLastModifiedTime) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aLastModifiedTime);
+	}
+
+	public int GetLastModifiedTimeOfLink(long[] aLastModifiedTimeOfLink) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aLastModifiedTimeOfLink);
+	}
+
+	public int SetLastModifiedTimeOfLink(long aLastModifiedTimeOfLink) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aLastModifiedTimeOfLink);
+	}
+
+	public int GetFileSize(long[] aFileSize) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aFileSize);
+	}
+
+	public int SetFileSize(long aFileSize) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aFileSize);
+	}
+
+	public int GetFileSizeOfLink(long[] aFileSizeOfLink) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aFileSizeOfLink);
+	}
+
+	public int GetTarget(long /*int*/ aTarget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aTarget);
+	}
+
+	public int GetNativeTarget(long /*int*/ aNativeTarget) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aNativeTarget);
+	}
+
+	public int GetPath(long /*int*/ aPath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aPath);
+	}
+
+	public int GetNativePath(long /*int*/ aNativePath) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aNativePath);
+	}
+
+	public int Exists(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), _retval);
+	}
+
+	public int IsWritable(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), _retval);
+	}
+
+	public int IsReadable(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), _retval);
+	}
+
+	public int IsExecutable(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), _retval);
+	}
+
+	public int IsHidden(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), _retval);
+	}
+
+	public int IsDirectory(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), _retval);
+	}
+
+	public int IsFile(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), _retval);
+	}
+
+	public int IsSymlink(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), _retval);
+	}
+
+	public int IsSpecial(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), _retval);
+	}
+
+	public int CreateUnique(int type, int permissions) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), type, permissions);
+	}
+
+	public int Clone(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), _retval);
+	}
+
+	public int Equals(long /*int*/ inFile, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), inFile, _retval);
+	}
+
+	public int Contains(long /*int*/ inFile, int recur, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), inFile, recur, _retval);
+	}
+
+	public int GetParent(long /*int*/[] aParent) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 44, getAddress(), aParent);
+	}
+
+	public int GetDirectoryEntries(long /*int*/[] aDirectoryEntries) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), aDirectoryEntries);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMUIEvent extends nsIDOMEvent {
-
-	static final int LAST_METHOD_ID = nsIDOMEvent.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDOMUIEVENT_IID_STR =
-		"a6cf90c3-15b3-11d2-932e-00805f8add32";
-
-	public static final nsID NS_IDOMUIEVENT_IID =
-		new nsID(NS_IDOMUIEVENT_IID_STR);
-
-	public nsIDOMUIEvent(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetView(long /*int*/[] aView) {
-		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 1, getAddress(), aView);
-	}
-
-	public int GetDetail(int[] aDetail) {
-		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 2, getAddress(), aDetail);
-	}
-
-	public int InitUIEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int detailArg) {
-		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 3, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMUIEvent extends nsIDOMEvent {
+
+	static final int LAST_METHOD_ID = nsIDOMEvent.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDOMUIEVENT_IID_STR =
+		"a6cf90c3-15b3-11d2-932e-00805f8add32";
+
+	public static final nsID NS_IDOMUIEVENT_IID =
+		new nsID(NS_IDOMUIEVENT_IID_STR);
+
+	public nsIDOMUIEvent(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetView(long /*int*/[] aView) {
+		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 1, getAddress(), aView);
+	}
+
+	public int GetDetail(int[] aDetail) {
+		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 2, getAddress(), aDetail);
+	}
+
+	public int InitUIEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int detailArg) {
+		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 3, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsID.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsID.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsID.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -137,4 +137,4 @@
     	toHex (m3[2], 2) + toHex (m3[3], 2) + toHex (m3[4], 2) + toHex (m3[5], 2) + toHex (m3[6], 2) + toHex (m3[7], 2) + '}';
 }
 
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIProgressDialog.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProgressDialog.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProgressDialog.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIProgressDialog extends nsIDownload {
-
-	static final int LAST_METHOD_ID = nsIDownload.LAST_METHOD_ID + 5;
-
-	public static final String NS_IPROGRESSDIALOG_IID_STR =
-		"88a478b3-af65-440a-94dc-ed9b154d2990";
-
-	public static final nsID NS_IPROGRESSDIALOG_IID =
-		new nsID(NS_IPROGRESSDIALOG_IID_STR);
-
-	public nsIProgressDialog(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Open(long /*int*/ aParent) {
-		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 1, getAddress(), aParent);
-	}
-
-	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
-		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
-	}
-
-	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
-		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
-	}
-
-	public int GetDialog(long /*int*/[] aDialog) {
-		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 4, getAddress(), aDialog);
-	}
-
-	public int SetDialog(long /*int*/ aDialog) {
-		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 5, getAddress(), aDialog);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIProgressDialog extends nsIDownload {
+
+	static final int LAST_METHOD_ID = nsIDownload.LAST_METHOD_ID + 5;
+
+	public static final String NS_IPROGRESSDIALOG_IID_STR =
+		"88a478b3-af65-440a-94dc-ed9b154d2990";
+
+	public static final nsID NS_IPROGRESSDIALOG_IID =
+		new nsID(NS_IPROGRESSDIALOG_IID_STR);
+
+	public nsIProgressDialog(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Open(long /*int*/ aParent) {
+		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 1, getAddress(), aParent);
+	}
+
+	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
+		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
+	}
+
+	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
+		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
+	}
+
+	public int GetDialog(long /*int*/[] aDialog) {
+		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 4, getAddress(), aDialog);
+	}
+
+	public int SetDialog(long /*int*/ aDialog) {
+		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 5, getAddress(), aDialog);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,91 +1,91 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIComponentRegistrar extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 12;
-
-	public static final String NS_ICOMPONENTREGISTRAR_IID_STR =
-		"2417cbfe-65ad-48a6-b4b6-eb84db174392";
-
-	public static final nsID NS_ICOMPONENTREGISTRAR_IID =
-		new nsID(NS_ICOMPONENTREGISTRAR_IID_STR);
-
-	public nsIComponentRegistrar(long /*int*/ address) {
-		super(address);
-	}
-
-	public int AutoRegister(long /*int*/ aSpec) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aSpec);
-	}
-
-	public int AutoUnregister(long /*int*/ aSpec) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSpec);
-	}
-
-	public int RegisterFactory(nsID aClass, byte[] aClassName, byte[] aContractID, long /*int*/ aFactory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aClass, aClassName, aContractID, aFactory);
-	}
-
-	public int UnregisterFactory(nsID aClass, long /*int*/ aFactory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aClass, aFactory);
-	}
-
-	public int RegisterFactoryLocation(nsID aClass, byte[] aClassName, byte[] aContractID, long /*int*/ aFile, byte[] aLoaderStr, byte[] aType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aClass, aClassName, aContractID, aFile, aLoaderStr, aType);
-	}
-
-	public int UnregisterFactoryLocation(nsID aClass, long /*int*/ aFile) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aClass, aFile);
-	}
-
-	public int IsCIDRegistered(nsID aClass, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aClass, _retval);
-	}
-
-	public int IsContractIDRegistered(byte[] aContractID, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aContractID, _retval);
-	}
-
-	public int EnumerateCIDs(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), _retval);
-	}
-
-	public int EnumerateContractIDs(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), _retval);
-	}
-
-	public int CIDToContractID(nsID aClass, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aClass, _retval);
-	}
-
-	public int ContractIDToCID(byte[] aContractID, long /*int*/ _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aContractID, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIComponentRegistrar extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 12;
+
+	public static final String NS_ICOMPONENTREGISTRAR_IID_STR =
+		"2417cbfe-65ad-48a6-b4b6-eb84db174392";
+
+	public static final nsID NS_ICOMPONENTREGISTRAR_IID =
+		new nsID(NS_ICOMPONENTREGISTRAR_IID_STR);
+
+	public nsIComponentRegistrar(long /*int*/ address) {
+		super(address);
+	}
+
+	public int AutoRegister(long /*int*/ aSpec) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aSpec);
+	}
+
+	public int AutoUnregister(long /*int*/ aSpec) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aSpec);
+	}
+
+	public int RegisterFactory(nsID aClass, byte[] aClassName, byte[] aContractID, long /*int*/ aFactory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aClass, aClassName, aContractID, aFactory);
+	}
+
+	public int UnregisterFactory(nsID aClass, long /*int*/ aFactory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aClass, aFactory);
+	}
+
+	public int RegisterFactoryLocation(nsID aClass, byte[] aClassName, byte[] aContractID, long /*int*/ aFile, byte[] aLoaderStr, byte[] aType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aClass, aClassName, aContractID, aFile, aLoaderStr, aType);
+	}
+
+	public int UnregisterFactoryLocation(nsID aClass, long /*int*/ aFile) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aClass, aFile);
+	}
+
+	public int IsCIDRegistered(nsID aClass, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aClass, _retval);
+	}
+
+	public int IsContractIDRegistered(byte[] aContractID, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aContractID, _retval);
+	}
+
+	public int EnumerateCIDs(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), _retval);
+	}
+
+	public int EnumerateContractIDs(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), _retval);
+	}
+
+	public int CIDToContractID(nsID aClass, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aClass, _retval);
+	}
+
+	public int ContractIDToCID(byte[] aContractID, long /*int*/ _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aContractID, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsILocalFile.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsILocalFile.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsILocalFile.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,111 +1,111 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsILocalFile extends nsIFile {
-
-	static final int LAST_METHOD_ID = nsIFile.LAST_METHOD_ID + 17;
-
-	public static final String NS_ILOCALFILE_IID_STR =
-		"aa610f20-a889-11d3-8c81-000064657374";
-
-	public static final nsID NS_ILOCALFILE_IID =
-		new nsID(NS_ILOCALFILE_IID_STR);
-
-	public nsILocalFile(long /*int*/ address) {
-		super(address);
-	}
-
-	public int InitWithPath(long /*int*/ filePath) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 1, getAddress(), filePath);
-	}
-
-	public int InitWithNativePath(long /*int*/ filePath) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 2, getAddress(), filePath);
-	}
-
-	public int InitWithFile(long /*int*/ aFile) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 3, getAddress(), aFile);
-	}
-
-	public int GetFollowLinks(int[] aFollowLinks) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 4, getAddress(), aFollowLinks);
-	}
-
-	public int SetFollowLinks(int aFollowLinks) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 5, getAddress(), aFollowLinks);
-	}
-
-	public int OpenNSPRFileDesc(int flags, int mode, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 6, getAddress(), flags, mode, _retval);
-	}
-
-	public int OpenANSIFileDesc(byte[] mode, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 7, getAddress(), mode, _retval);
-	}
-
-	public int Load(long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 8, getAddress(), _retval);
-	}
-
-	public int GetDiskSpaceAvailable(long[] aDiskSpaceAvailable) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 9, getAddress(), aDiskSpaceAvailable);
-	}
-
-	public int AppendRelativePath(long /*int*/ relativeFilePath) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 10, getAddress(), relativeFilePath);
-	}
-
-	public int AppendRelativeNativePath(long /*int*/ relativeFilePath) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 11, getAddress(), relativeFilePath);
-	}
-
-	public int GetPersistentDescriptor(long /*int*/ aPersistentDescriptor) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 12, getAddress(), aPersistentDescriptor);
-	}
-
-	public int SetPersistentDescriptor(long /*int*/ aPersistentDescriptor) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 13, getAddress(), aPersistentDescriptor);
-	}
-
-	public int Reveal() {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 14, getAddress());
-	}
-
-	public int Launch() {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 15, getAddress());
-	}
-
-	public int GetRelativeDescriptor(long /*int*/ fromFile, long /*int*/ _retval) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 16, getAddress(), fromFile, _retval);
-	}
-
-	public int SetRelativeDescriptor(long /*int*/ fromFile, long /*int*/ relativeDesc) {
-		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 17, getAddress(), fromFile, relativeDesc);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsILocalFile extends nsIFile {
+
+	static final int LAST_METHOD_ID = nsIFile.LAST_METHOD_ID + 17;
+
+	public static final String NS_ILOCALFILE_IID_STR =
+		"aa610f20-a889-11d3-8c81-000064657374";
+
+	public static final nsID NS_ILOCALFILE_IID =
+		new nsID(NS_ILOCALFILE_IID_STR);
+
+	public nsILocalFile(long /*int*/ address) {
+		super(address);
+	}
+
+	public int InitWithPath(long /*int*/ filePath) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 1, getAddress(), filePath);
+	}
+
+	public int InitWithNativePath(long /*int*/ filePath) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 2, getAddress(), filePath);
+	}
+
+	public int InitWithFile(long /*int*/ aFile) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 3, getAddress(), aFile);
+	}
+
+	public int GetFollowLinks(int[] aFollowLinks) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 4, getAddress(), aFollowLinks);
+	}
+
+	public int SetFollowLinks(int aFollowLinks) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 5, getAddress(), aFollowLinks);
+	}
+
+	public int OpenNSPRFileDesc(int flags, int mode, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 6, getAddress(), flags, mode, _retval);
+	}
+
+	public int OpenANSIFileDesc(byte[] mode, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 7, getAddress(), mode, _retval);
+	}
+
+	public int Load(long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 8, getAddress(), _retval);
+	}
+
+	public int GetDiskSpaceAvailable(long[] aDiskSpaceAvailable) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 9, getAddress(), aDiskSpaceAvailable);
+	}
+
+	public int AppendRelativePath(long /*int*/ relativeFilePath) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 10, getAddress(), relativeFilePath);
+	}
+
+	public int AppendRelativeNativePath(long /*int*/ relativeFilePath) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 11, getAddress(), relativeFilePath);
+	}
+
+	public int GetPersistentDescriptor(long /*int*/ aPersistentDescriptor) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 12, getAddress(), aPersistentDescriptor);
+	}
+
+	public int SetPersistentDescriptor(long /*int*/ aPersistentDescriptor) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 13, getAddress(), aPersistentDescriptor);
+	}
+
+	public int Reveal() {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 14, getAddress());
+	}
+
+	public int Launch() {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 15, getAddress());
+	}
+
+	public int GetRelativeDescriptor(long /*int*/ fromFile, long /*int*/ _retval) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 16, getAddress(), fromFile, _retval);
+	}
+
+	public int SetRelativeDescriptor(long /*int*/ fromFile, long /*int*/ relativeDesc) {
+		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 17, getAddress(), fromFile, relativeDesc);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog_1_9.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog_1_9.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog_1_9.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -54,4 +54,4 @@
 	public int PromptForSaveToFile(long /*int*/ aLauncher, long /*int*/ aWindowContext, char[] aDefaultFileName, char[] aSuggestedFileExtension, int aForcePrompt, long /*int*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aLauncher, aWindowContext, aDefaultFileName, aSuggestedFileExtension, aForcePrompt, _retval);
 	}
-}
\ No newline at end of file
+}
Index: org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,87 +1,87 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMMouseEvent extends nsIDOMUIEvent {
-
-	static final int LAST_METHOD_ID = nsIDOMUIEvent.LAST_METHOD_ID + 11;
-
-	public static final String NS_IDOMMOUSEEVENT_IID_STR =
-		"ff751edc-8b02-aae7-0010-8301838a3123";
-
-	public static final nsID NS_IDOMMOUSEEVENT_IID =
-		new nsID(NS_IDOMMOUSEEVENT_IID_STR);
-
-	public nsIDOMMouseEvent(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetScreenX(int[] aScreenX) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 1, getAddress(), aScreenX);
-	}
-
-	public int GetScreenY(int[] aScreenY) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 2, getAddress(), aScreenY);
-	}
-
-	public int GetClientX(int[] aClientX) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 3, getAddress(), aClientX);
-	}
-
-	public int GetClientY(int[] aClientY) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aClientY);
-	}
-
-	public int GetCtrlKey(int[] aCtrlKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aCtrlKey);
-	}
-
-	public int GetShiftKey(int[] aShiftKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aShiftKey);
-	}
-
-	public int GetAltKey(int[] aAltKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), aAltKey);
-	}
-
-	public int GetMetaKey(int[] aMetaKey) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 8, getAddress(), aMetaKey);
-	}
-
-	public int GetButton(short[] aButton) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 9, getAddress(), aButton);
-	}
-
-	public int GetRelatedTarget(long /*int*/[] aRelatedTarget) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 10, getAddress(), aRelatedTarget);
-	}
-
-	public int InitMouseEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int detailArg, int screenXArg, int screenYArg, int clientXArg, int clientYArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, short buttonArg, long /*int*/ relatedTargetArg) {
-		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 11, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMMouseEvent extends nsIDOMUIEvent {
+
+	static final int LAST_METHOD_ID = nsIDOMUIEvent.LAST_METHOD_ID + 11;
+
+	public static final String NS_IDOMMOUSEEVENT_IID_STR =
+		"ff751edc-8b02-aae7-0010-8301838a3123";
+
+	public static final nsID NS_IDOMMOUSEEVENT_IID =
+		new nsID(NS_IDOMMOUSEEVENT_IID_STR);
+
+	public nsIDOMMouseEvent(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetScreenX(int[] aScreenX) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 1, getAddress(), aScreenX);
+	}
+
+	public int GetScreenY(int[] aScreenY) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 2, getAddress(), aScreenY);
+	}
+
+	public int GetClientX(int[] aClientX) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 3, getAddress(), aClientX);
+	}
+
+	public int GetClientY(int[] aClientY) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aClientY);
+	}
+
+	public int GetCtrlKey(int[] aCtrlKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aCtrlKey);
+	}
+
+	public int GetShiftKey(int[] aShiftKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aShiftKey);
+	}
+
+	public int GetAltKey(int[] aAltKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), aAltKey);
+	}
+
+	public int GetMetaKey(int[] aMetaKey) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 8, getAddress(), aMetaKey);
+	}
+
+	public int GetButton(short[] aButton) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 9, getAddress(), aButton);
+	}
+
+	public int GetRelatedTarget(long /*int*/[] aRelatedTarget) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 10, getAddress(), aRelatedTarget);
+	}
+
+	public int InitMouseEvent(long /*int*/ typeArg, int canBubbleArg, int cancelableArg, long /*int*/ viewArg, int detailArg, int screenXArg, int screenYArg, int clientXArg, int clientYArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, short buttonArg, long /*int*/ relatedTargetArg) {
+		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 11, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class  nsICookieService_1_9 extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_ICOOKIESERVICE_IID_STR =
-		"2aaa897a-293c-4d2b-a657-8c9b7136996d";
-
-	public static final nsID NS_ICOOKIESERVICE_IID =
-		new nsID(NS_ICOOKIESERVICE_IID_STR);
-
-	public  nsICookieService_1_9(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetCookieString(long /*int*/ aURI, long /*int*/ aChannel, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
-	}
-
-	public int GetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aChannel, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
-	}
-
-	public int SetCookieString(long /*int*/ aURI, long /*int*/ aPrompt, byte[] aCookie, long /*int*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
-	}
-
-	public int SetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aPrompt, byte[] aCookie, byte[] aServerTime, long /*int*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsICookieService_1_9 extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_ICOOKIESERVICE_IID_STR =
+		"2aaa897a-293c-4d2b-a657-8c9b7136996d";
+
+	public static final nsID NS_ICOOKIESERVICE_IID =
+		new nsID(NS_ICOOKIESERVICE_IID_STR);
+
+	public  nsICookieService_1_9(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetCookieString(long /*int*/ aURI, long /*int*/ aChannel, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
+	}
+
+	public int GetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aChannel, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
+	}
+
+	public int SetCookieString(long /*int*/ aURI, long /*int*/ aPrompt, byte[] aCookie, long /*int*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
+	}
+
+	public int SetCookieStringFromHttp(long /*int*/ aURI, long /*int*/ aFirstURI, long /*int*/ aPrompt, byte[] aCookie, byte[] aServerTime, long /*int*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIObserverService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIObserverService.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIObserverService.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIObserverService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_IOBSERVERSERVICE_IID_STR =
-		"d07f5192-e3d1-11d2-8acd-00105a1b8860";
-
-	public static final nsID NS_IOBSERVERSERVICE_IID =
-		new nsID(NS_IOBSERVERSERVICE_IID_STR);
-
-	public nsIObserverService(long /*int*/ address) {
-		super(address);
-	}
-
-	public int AddObserver(long /*int*/ anObserver, byte[] aTopic, int ownsWeak) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), anObserver, aTopic, ownsWeak);
-	}
-
-	public int RemoveObserver(long /*int*/ anObserver, byte[] aTopic) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), anObserver, aTopic);
-	}
-
-	public int NotifyObservers(long /*int*/ aSubject, byte[] aTopic, char[] someData) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSubject, aTopic, someData);
-	}
-
-	public int EnumerateObservers(byte[] aTopic, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aTopic, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIObserverService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_IOBSERVERSERVICE_IID_STR =
+		"d07f5192-e3d1-11d2-8acd-00105a1b8860";
+
+	public static final nsID NS_IOBSERVERSERVICE_IID =
+		new nsID(NS_IOBSERVERSERVICE_IID_STR);
+
+	public nsIObserverService(long /*int*/ address) {
+		super(address);
+	}
+
+	public int AddObserver(long /*int*/ anObserver, byte[] aTopic, int ownsWeak) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), anObserver, aTopic, ownsWeak);
+	}
+
+	public int RemoveObserver(long /*int*/ anObserver, byte[] aTopic) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), anObserver, aTopic);
+	}
+
+	public int NotifyObservers(long /*int*/ aSubject, byte[] aTopic, char[] someData) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSubject, aTopic, someData);
+	}
+
+	public int EnumerateObservers(byte[] aTopic, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aTopic, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIMemory.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIMemory.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIMemory.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIMemory extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
-
-	public static final String NS_IMEMORY_IID_STR =
-		"59e7e77a-38e4-11d4-8cf5-0060b0fc14a3";
-
-	public static final nsID NS_IMEMORY_IID =
-		new nsID(NS_IMEMORY_IID_STR);
-
-	public nsIMemory(long /*int*/ address) {
-		super(address);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIMemory extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
+
+	public static final String NS_IMEMORY_IID_STR =
+		"59e7e77a-38e4-11d4-8cf5-0060b0fc14a3";
+
+	public static final nsID NS_IMEMORY_IID =
+		new nsID(NS_IMEMORY_IID_STR);
+
+	public nsIMemory(long /*int*/ address) {
+		super(address);
+	}
+
 	public long /*int*/ Alloc(int size) {
 		return XPCOM.nsIMemory_Alloc(getAddress(), size);
-	}
-
+	}
+
 	public long /*int*/ Realloc(long /*int*/ ptr, int newSize) {
 		return XPCOM.nsIMemory_Realloc(getAddress(), ptr, newSize);
-	}
-
-	public int Free(long /*int*/ ptr) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), ptr);
-	}
-
-	public int HeapMinimize(int immediate) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), immediate);
-	}
-
-	public int IsLowMemory(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
-	}
-}
+	}
+
+	public int Free(long /*int*/ ptr) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), ptr);
+	}
+
+	public int HeapMinimize(int immediate) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), immediate);
+	}
+
+	public int IsLowMemory(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,79 +1,79 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIHelperAppLauncher_1_8 extends nsICancelable {
-
-	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 9;
-
-	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
-		"99a0882d-2ff9-4659-9952-9ac531ba5592";
-
-	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
-		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
-
-	public nsIHelperAppLauncher_1_8(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
-	}
-
-	public int GetSource(long /*int*/[] aSource) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
-	}
-
-	public int GetSuggestedFileName(long /*int*/ aSuggestedFileName) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
-	}
-
-	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
-	}
-
-	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
-	}
-
-	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
-	}
-
-	public int CloseProgressWindow() {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
-	}
-
-	public int GetTargetFile(long /*int*/[] aTargetFile) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
-	}
-
-	public int GetTimeDownloadStarted(long /*int*/ aTimeDownloadStarted) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTimeDownloadStarted);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIHelperAppLauncher_1_8 extends nsICancelable {
+
+	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 9;
+
+	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
+		"99a0882d-2ff9-4659-9952-9ac531ba5592";
+
+	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
+		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
+
+	public nsIHelperAppLauncher_1_8(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetMIMEInfo(long /*int*/[] aMIMEInfo) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
+	}
+
+	public int GetSource(long /*int*/[] aSource) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
+	}
+
+	public int GetSuggestedFileName(long /*int*/ aSuggestedFileName) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
+	}
+
+	public int SaveToDisk(long /*int*/ aNewFileLocation, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
+	}
+
+	public int LaunchWithApplication(long /*int*/ aApplication, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
+	}
+
+	public int SetWebProgressListener(long /*int*/ aWebProgressListener) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
+	}
+
+	public int CloseProgressWindow() {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
+	}
+
+	public int GetTargetFile(long /*int*/[] aTargetFile) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
+	}
+
+	public int GetTimeDownloadStarted(long /*int*/ aTimeDownloadStarted) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTimeDownloadStarted);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIPrefBranch.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPrefBranch.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPrefBranch.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,123 +1,123 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIPrefBranch extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 18;
-
-	public static final String NS_IPREFBRANCH_IID_STR =
-		"56c35506-f14b-11d3-99d3-ddbfac2ccf65";
-
-	public static final nsID NS_IPREFBRANCH_IID =
-		new nsID(NS_IPREFBRANCH_IID_STR);
-
-	public nsIPrefBranch(long /*int*/ address) {
-		super(address);
-	}
-
-	public static final int PREF_INVALID = 0;
-
-	public static final int PREF_STRING = 32;
-
-	public static final int PREF_INT = 64;
-
-	public static final int PREF_BOOL = 128;
-
-	public int GetRoot(long /*int*/[] aRoot) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aRoot);
-	}
-
-	public int GetPrefType(byte[] aPrefName, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aPrefName, _retval);
-	}
-
-	public int GetBoolPref(byte[] aPrefName, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aPrefName, _retval);
-	}
-
-	public int SetBoolPref(byte[] aPrefName, int aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aPrefName, aValue);
-	}
-
-	public int GetCharPref(byte[] aPrefName, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aPrefName, _retval);
-	}
-
-	public int SetCharPref(byte[] aPrefName, byte[] aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aPrefName, aValue);
-	}
-
-	public int GetIntPref(byte[] aPrefName, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aPrefName, _retval);
-	}
-
-	public int SetIntPref(byte[] aPrefName, int aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPrefName, aValue);
-	}
-
-	public int GetComplexValue(byte[] aPrefName, nsID aType, long /*int*/[] aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPrefName, aType, aValue);
-	}
-
-	public int SetComplexValue(byte[] aPrefName, nsID aType, long /*int*/ aValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aPrefName, aType, aValue);
-	}
-
-	public int ClearUserPref(byte[] aPrefName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aPrefName);
-	}
-
-	public int LockPref(byte[] aPrefName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aPrefName);
-	}
-
-	public int PrefHasUserValue(byte[] aPrefName, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aPrefName, _retval);
-	}
-
-	public int PrefIsLocked(byte[] aPrefName, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aPrefName, _retval);
-	}
-
-	public int UnlockPref(byte[] aPrefName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aPrefName);
-	}
-
-	public int DeleteBranch(byte[] aStartingAt) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aStartingAt);
-	}
-
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIPrefBranch extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 18;
+
+	public static final String NS_IPREFBRANCH_IID_STR =
+		"56c35506-f14b-11d3-99d3-ddbfac2ccf65";
+
+	public static final nsID NS_IPREFBRANCH_IID =
+		new nsID(NS_IPREFBRANCH_IID_STR);
+
+	public nsIPrefBranch(long /*int*/ address) {
+		super(address);
+	}
+
+	public static final int PREF_INVALID = 0;
+
+	public static final int PREF_STRING = 32;
+
+	public static final int PREF_INT = 64;
+
+	public static final int PREF_BOOL = 128;
+
+	public int GetRoot(long /*int*/[] aRoot) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aRoot);
+	}
+
+	public int GetPrefType(byte[] aPrefName, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aPrefName, _retval);
+	}
+
+	public int GetBoolPref(byte[] aPrefName, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aPrefName, _retval);
+	}
+
+	public int SetBoolPref(byte[] aPrefName, int aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aPrefName, aValue);
+	}
+
+	public int GetCharPref(byte[] aPrefName, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aPrefName, _retval);
+	}
+
+	public int SetCharPref(byte[] aPrefName, byte[] aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aPrefName, aValue);
+	}
+
+	public int GetIntPref(byte[] aPrefName, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aPrefName, _retval);
+	}
+
+	public int SetIntPref(byte[] aPrefName, int aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aPrefName, aValue);
+	}
+
+	public int GetComplexValue(byte[] aPrefName, nsID aType, long /*int*/[] aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPrefName, aType, aValue);
+	}
+
+	public int SetComplexValue(byte[] aPrefName, nsID aType, long /*int*/ aValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aPrefName, aType, aValue);
+	}
+
+	public int ClearUserPref(byte[] aPrefName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aPrefName);
+	}
+
+	public int LockPref(byte[] aPrefName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aPrefName);
+	}
+
+	public int PrefHasUserValue(byte[] aPrefName, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aPrefName, _retval);
+	}
+
+	public int PrefIsLocked(byte[] aPrefName, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aPrefName, _retval);
+	}
+
+	public int UnlockPref(byte[] aPrefName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aPrefName);
+	}
+
+	public int DeleteBranch(byte[] aStartingAt) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aStartingAt);
+	}
+
 	public int GetChildList(byte[] aStartingAt, int[] aCount, long /*int*/[] aChildArray) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aStartingAt, aCount, aChildArray);
-	}
-
-	public int ResetBranch(byte[] aStartingAt) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aStartingAt);
-	}
-}
+	}
+
+	public int ResetBranch(byte[] aStartingAt) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aStartingAt);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIInputStream.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIInputStream.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIInputStream.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIInputStream extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
-
-	public static final String NS_IINPUTSTREAM_IID_STR =
-		"fa9c7f6c-61b3-11d4-9877-00c04fa0cf4a";
-
-	public static final nsID NS_IINPUTSTREAM_IID =
-		new nsID(NS_IINPUTSTREAM_IID_STR);
-
-	public nsIInputStream(long /*int*/ address) {
-		super(address);
-	}
-
-	public int Close() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
-	}
-
-	public int Available(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
-	}
-
-	public int Read(byte[] aBuf, int aCount, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aBuf, aCount, _retval);
-	}
-
-	public int ReadSegments(long /*int*/ aWriter, long /*int*/ aClosure, int aCount, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aWriter, aClosure, aCount, _retval);
-	}
-
-	public int IsNonBlocking(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIInputStream extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
+
+	public static final String NS_IINPUTSTREAM_IID_STR =
+		"fa9c7f6c-61b3-11d4-9877-00c04fa0cf4a";
+
+	public static final nsID NS_IINPUTSTREAM_IID =
+		new nsID(NS_IINPUTSTREAM_IID_STR);
+
+	public nsIInputStream(long /*int*/ address) {
+		super(address);
+	}
+
+	public int Close() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
+	}
+
+	public int Available(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
+	}
+
+	public int Read(byte[] aBuf, int aCount, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aBuf, aCount, _retval);
+	}
+
+	public int ReadSegments(long /*int*/ aWriter, long /*int*/ aClosure, int aCount, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aWriter, aClosure, aCount, _retval);
+	}
+
+	public int IsNonBlocking(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java	(.../vendor/swt/win32-64/3.7/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java	(.../trunk/thirdparty/swt/3.7/win32-64/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMWindowCollection extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDOMWINDOWCOLLECTION_IID_STR =
-		"a6cf906f-15b3-11d2-932e-00805f8add32";
-
-	public static final nsID NS_IDOMWINDOWCOLLECTION_IID =
-		new nsID(NS_IDOMWINDOWCOLLECTION_IID_STR);
-
-	public nsIDOMWindowCollection(long /*int*/ address) {
-		super(address);
-	}
-
-	public int GetLength(int[] aLength) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aLength);
-	}
-
-	public int Item(int index, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), index, _retval);
-	}
-
-	public int NamedItem(long /*int*/ name, long /*int*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), name, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMWindowCollection extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDOMWINDOWCOLLECTION_IID_STR =
+		"a6cf906f-15b3-11d2-932e-00805f8add32";
+
+	public static final nsID NS_IDOMWINDOWCOLLECTION_IID =
+		new nsID(NS_IDOMWINDOWCOLLECTION_IID_STR);
+
+	public nsIDOMWindowCollection(long /*int*/ address) {
+		super(address);
+	}
+
+	public int GetLength(int[] aLength) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aLength);
+	}
+
+	public int Item(int index, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), index, _retval);
+	}
+
+	public int NamedItem(long /*int*/ name, long /*int*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), name, _retval);
+	}
+}
\ No newline at end of file
Index: fragment.properties
===================================================================
Index: META-INF/eclipse.inf
===================================================================
--- META-INF/eclipse.inf	(.../vendor/swt/win32-64/3.7/csrc)	(revision 0)
+++ META-INF/eclipse.inf	(.../trunk/thirdparty/swt/3.7/win32-64/csrc)	(revision 23809)
@@ -0,0 +1,3 @@
+#Processed using Jarprocessor
+pack200.args = -E4
+pack200.conditioned = true
Index: META-INF/ECLIPSEF.SF
===================================================================
--- META-INF/ECLIPSEF.SF	(.../vendor/swt/win32-64/3.7/csrc)	(revision 0)
+++ META-INF/ECLIPSEF.SF	(.../trunk/thirdparty/swt/3.7/win32-64/csrc)	(revision 23809)
@@ -0,0 +1,2344 @@
+Signature-Version: 1.0
+SHA1-Digest-Manifest: TK7jWPJEo21+ni5VZGf5m/qApIs=
+Created-By: 1.6.0 (IBM Corporation)
+SHA1-Digest-Manifest-Main-Attributes: KVGPi8pIgAl/cI4fSdrmI4MuTAg=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebProgressListener.java
+SHA1-Digest: wIVAiOf/dInZmnlDWfn1ROaY9PA=
+
+Name: org/eclipse/swt/graphics/Image.java
+SHA1-Digest: YY7lfq45QZGA2t7rqKG19ffvyho=
+
+Name: org/eclipse/swt/accessibility/Accessible.java
+SHA1-Digest: l+VmTTta+IkzHLkiVUCf9Qz623k=
+
+Name: org/eclipse/swt/events/MouseMoveListener.java
+SHA1-Digest: bQ4s5vsG4qV5DHAPF78NkhI0g6s=
+
+Name: org/eclipse/swt/internal/ole/win32/IConnectionPointContainer.jav
+ a
+SHA1-Digest: nGP2ty2W/cytsHhHGQeJP7pwKXk=
+
+Name: org/eclipse/swt/internal/ole/win32/IFont.java
+SHA1-Digest: TBoM0x7BhBcyuQUxFHO3oqxc++E=
+
+Name: org/eclipse/swt/dnd/OleEnumFORMATETC.java
+SHA1-Digest: DfnnmxqmvAk7vC2tqF+9uvy5g5M=
+
+Name: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java
+SHA1-Digest: ar0/v5Ndt93uzwJAKCnJruvC2Eg=
+
+Name: org/eclipse/swt/internal/ImageList.java
+SHA1-Digest: DajbNjgIoNFU66bYjk+oZ0B47es=
+
+Name: org/eclipse/swt/custom/TableCursor.java
+SHA1-Digest: lghsvdpKDjgMShm63quBvmPJHNc=
+
+Name: org/eclipse/swt/dnd/DropTargetEffect.java
+SHA1-Digest: zMQTol0m82rtwWIcKGhQ2byu2hs=
+
+Name: org/eclipse/swt/internal/win32/TCITEM.java
+SHA1-Digest: +oGHEb8yWsGNJK1FLxIXQ5z/SMo=
+
+Name: org/eclipse/swt/internal/image/PNGFileFormat.java
+SHA1-Digest: tjvobIGJGklWJUllps62HuWZxLs=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleInPlaceObject.java
+SHA1-Digest: KiqNrDfO2QFRq6pDkKvjhtzi9tc=
+
+Name: org/eclipse/swt/internal/win32/OPENFILENAME.java
+SHA1-Digest: 1CMgdJnj1gIrxtuBNDHOcOtXa5E=
+
+Name: org/eclipse/swt/internal/win32/HDITEM.java
+SHA1-Digest: qcYPsukB8iJ0pM8i7rspJTRxuYY=
+
+Name: org/eclipse/swt/internal/image/JPEGArithmeticConditioningTable.j
+ ava
+SHA1-Digest: KDiS4S5OFU8zoG/Ce7muNUw9vzQ=
+
+Name: org/eclipse/swt/events/ShellListener.java
+SHA1-Digest: 1g4esdasSNnqc9AQseCVmGTjOiA=
+
+Name: org/eclipse/swt/internal/win32/NMTTDISPINFOA.java
+SHA1-Digest: yGuxFkzXMTGOH4K5A8S8+UIz8YM=
+
+Name: org/eclipse/swt/internal/win32/SHELLEXECUTEINFO.java
+SHA1-Digest: nQAs7sSBZfpfsDuGoXRsjtgmwPk=
+
+Name: org/eclipse/swt/internal/image/JPEGScanHeader.java
+SHA1-Digest: p8+ewC9Aj0DwMntP6n/7MJcwCJE=
+
+Name: org/eclipse/swt/custom/CaretEvent.java
+SHA1-Digest: V9iAqZk98EGsV67VnUhPmiqhK6g=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebProgress.java
+SHA1-Digest: SJYzBQHbS6voBSi1DJxIo35NmIk=
+
+Name: org/eclipse/swt/events/SelectionListener.java
+SHA1-Digest: fzo3FezLB30Aj0jQUskf0ilXzdc=
+
+Name: org/eclipse/swt/internal/ole/win32/IUnknown.java
+SHA1-Digest: 6lGHrBalyUe5Sd7DkzNWFOjQCtY=
+
+Name: org/eclipse/swt/printing/PrinterData.java
+SHA1-Digest: vAgpz1Br9Q4FOsQPnx3uo20cILE=
+
+Name: org/eclipse/swt/graphics/RGB.java
+SHA1-Digest: hDZ6eYxHzi3zGkfjgb87qi11qKc=
+
+Name: org/eclipse/swt/internal/image/JPEGSegment.java
+SHA1-Digest: 0V/YZrPHwqHzByIIKZL6nkkjCVE=
+
+Name: org/eclipse/swt/custom/ViewForm.java
+SHA1-Digest: 82WLNB8o+Hf6VWuhLZOucla2GTU=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java
+SHA1-Digest: NgtJyAc0evhzajRBEmNEz8IApyE=
+
+Name: gdip_stats.h
+SHA1-Digest: VpLeuK64sLf5s4t7artLpasWoBo=
+
+Name: org/eclipse/swt/widgets/Caret.java
+SHA1-Digest: ErS1iXkfmXk9n5WjY8AehipjIzQ=
+
+Name: org/eclipse/swt/widgets/Menu.java
+SHA1-Digest: bHMlEywbMquEwg/3BCsjNHkAZHI=
+
+Name: org/eclipse/swt/custom/TableEditor.java
+SHA1-Digest: +EqmSbiBJueuHLPltLhzGjOpOS4=
+
+Name: org/eclipse/swt/events/ShellEvent.java
+SHA1-Digest: HiMopwKnzPcBUTlA32gAxQtmROY=
+
+Name: org/eclipse/swt/internal/win32/OUTLINETEXTMETRICW.java
+SHA1-Digest: 18r3rliDFfw62//KUsfujj8yIkU=
+
+Name: org/eclipse/swt/internal/mozilla/nsIURI.java
+SHA1-Digest: MZIIQe5mgJSMKQL9kYlE3q5JtrI=
+
+Name: org/eclipse/swt/internal/Callback.java
+SHA1-Digest: EPRrgLXkZqctLFked9L7i4+7y/A=
+
+Name: org/eclipse/swt/dnd/DragSourceEvent.java
+SHA1-Digest: LsCIU6KwoSD668Ouw9F3X8qVsi8=
+
+Name: org/eclipse/swt/internal/win32/HDHITTESTINFO.java
+SHA1-Digest: w/fDNqra0HKnnpaD7e+gA9vgq2M=
+
+Name: org/eclipse/swt/layout/GridLayout.java
+SHA1-Digest: 44N0dXx6ptzsv/2/GXvSkSus2P8=
+
+Name: org/eclipse/swt/internal/theme/ToolItemDrawData.java
+SHA1-Digest: OasNVqHKuDQi8cArnqlixJ9Wgi0=
+
+Name: org/eclipse/swt/graphics/ImageLoaderEvent.java
+SHA1-Digest: xdsyGWreWdlJdEBn790Xj+J7S78=
+
+Name: org/eclipse/swt/events/FocusAdapter.java
+SHA1-Digest: ckMI56VCSNafajkZzlbj0VmqxcU=
+
+Name: org/eclipse/swt/browser/TitleEvent.java
+SHA1-Digest: HEsUQgwfmoJ9MD4Hs0Jeks6Nhrg=
+
+Name: org/eclipse/swt/internal/mozilla/init/XPCOMInit.java
+SHA1-Digest: 3OxZOhS9LKkCpIxnPSm6sHfD9t0=
+
+Name: org/eclipse/swt/internal/win32/SIZE.java
+SHA1-Digest: mHn4dhmT2uuvT2If2xr7gRYY3Jc=
+
+Name: org/eclipse/swt/internal/win32/WINDOWPOS.java
+SHA1-Digest: Fe/0jsflNdumnhGwzbyLR71ts1I=
+
+Name: xpcom_structs.h
+SHA1-Digest: /Ot32famBdWtSi2g9les4z+PgMA=
+
+Name: swt.c
+SHA1-Digest: hwIH38+fO7jaFqWR018RTNB3q/k=
+
+Name: org/eclipse/swt/widgets/Canvas.java
+SHA1-Digest: hSlehz53OZtI4aL5Z3iXewzT4mE=
+
+Name: org/eclipse/swt/internal/theme/GroupDrawData.java
+SHA1-Digest: hLwx/H8Eol04iMXa1rmJIwo8sTs=
+
+Name: swt.h
+SHA1-Digest: wT3b+m82cFGgU2zFVnp4wD2dvks=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleControl.java
+SHA1-Digest: 7PANWcTEMSmk12NijBW5qiNOqFI=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebNavigation.java
+SHA1-Digest: 6Ny2KDEep741uuxeX1Z7RA4+vMw=
+
+Name: org/eclipse/swt/internal/win32/NOTIFYICONDATAA.java
+SHA1-Digest: gK8fTifIPZfR5kRHhdIiZfG3n4A=
+
+Name: org/eclipse/swt/dnd/DropTargetListener.java
+SHA1-Digest: tYSSDaH/d2oN+u9FTQXY95+y4FA=
+
+Name: build.xml
+SHA1-Digest: V5qWLJlT1SQpqj0nV3SS6LdYhwc=
+
+Name: org/eclipse/swt/events/MouseEvent.java
+SHA1-Digest: srDPHUcAX0NjIzPouK1e7PV/CMY=
+
+Name: org/eclipse/swt/internal/image/PngChunk.java
+SHA1-Digest: r1f+1aGqwIgwqbLPFlKwOIoMtyA=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java
+SHA1-Digest: Qx+/TMtZW2Fl7Quf51sRSwryzyw=
+
+Name: org/eclipse/swt/internal/win32/NMREBARCHEVRON.java
+SHA1-Digest: QDzdFkeXgk4f2AIc7NZssPT37wE=
+
+Name: org/eclipse/swt/internal/mozilla/nsIChannel.java
+SHA1-Digest: 7+vV/OmaDiBAlSqELdqNlvpa0dg=
+
+Name: org/eclipse/swt/internal/image/PngHuffmanTables.java
+SHA1-Digest: zktWjphtkNmJFqWr91mNthconSY=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleDocumentView.java
+SHA1-Digest: 9oy55uzubGLQ3PvsrWEWGcJU5sk=
+
+Name: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java
+SHA1-Digest: n5giIq5xchRjT8vtHCudZViJYGo=
+
+Name: org/eclipse/swt/custom/ScrolledCompositeLayout.java
+SHA1-Digest: MLjJ3UBcsRAwwATURmnEYNXKTQE=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFOA.java
+SHA1-Digest: lhpMCvM5Z/mbAdDuByhcs+u8P6U=
+
+Name: org/eclipse/swt/internal/image/JPEGFileFormat.java
+SHA1-Digest: /33yliMHMOt2EtUX+UcYjKIEd9o=
+
+Name: org/eclipse/swt/events/PaintListener.java
+SHA1-Digest: qI2igSVnh9DDnv51aLMVMYP85b0=
+
+Name: org/eclipse/swt/internal/ole/win32/IStorage.java
+SHA1-Digest: e+qzUzDfrrJZLZUke9k/qQV/G40=
+
+Name: org/eclipse/swt/browser/CloseWindowListener.java
+SHA1-Digest: EyYffGDUva71l0ZLkqhDMV+CR7o=
+
+Name: org/eclipse/swt/graphics/PathData.java
+SHA1-Digest: UfHR7HlG5CaBKVD9nkG/2/nN2/8=
+
+Name: wgl_structs.c
+SHA1-Digest: FpX3XnaDx0Br5Mb0GKhAfGi0FDY=
+
+Name: org/eclipse/swt/internal/ole/win32/IProvideClassInfo2.java
+SHA1-Digest: sZxsJEMugLANiC1UadUCJPuVLXU=
+
+Name: org/eclipse/swt/events/KeyEvent.java
+SHA1-Digest: bc6sznTZXbghl8rwdudljGwUfCI=
+
+Name: org/eclipse/swt/custom/SashFormLayout.java
+SHA1-Digest: HuFN1XzmUeVlptJSAdZhnKh5gE4=
+
+Name: org/eclipse/swt/internal/win32/POINT.java
+SHA1-Digest: 8j4M7C5nP93NjtUpAeA+ri6DgvQ=
+
+Name: org/eclipse/swt/custom/AnimatedProgress.java
+SHA1-Digest: oGV+UTGb02a3r9TN5Wjo5kEuH9g=
+
+Name: wgl_structs.h
+SHA1-Digest: Q7oMKVow/tEwUte6WByzdgY1HeY=
+
+Name: c_structs.c
+SHA1-Digest: n601YpHWfhXZbbrwr1W7vtYUuh4=
+
+Name: org/eclipse/swt/internal/win32/TCHAR.java
+SHA1-Digest: T5nRznRcHiJo2dKB2z3t3Fbxcyw=
+
+Name: c_structs.h
+SHA1-Digest: wfezwG6N3C6ipD9FqjJ4B6mDiFo=
+
+Name: org/eclipse/swt/internal/win32/REBARBANDINFO.java
+SHA1-Digest: 25ZJmlu8vOecW4cKbsIGgOs4MQM=
+
+Name: org/eclipse/swt/browser/FilePicker_1_8.java
+SHA1-Digest: VvBHwwy8/bNa1yK8D8B5vsT0urw=
+
+Name: org/eclipse/swt/widgets/Tray.java
+SHA1-Digest: Vk16Deo+eq+zvJKhBdlp2g6+mmY=
+
+Name: org/eclipse/swt/internal/mozilla/nsIFile.java
+SHA1-Digest: CBFW4IU0i07UgqkB6LQUoBky8Ng=
+
+Name: org/eclipse/swt/internal/win32/BITMAPINFOHEADER.java
+SHA1-Digest: 9VNgQjhkq5tE6GHVGo6CKROcbxI=
+
+Name: org/eclipse/swt/internal/image/JPEGHuffmanTable.java
+SHA1-Digest: CpN+jMrTUa/RpEASCWes8nswmk0=
+
+Name: org/eclipse/swt/internal/win32/NONCLIENTMETRICSW.java
+SHA1-Digest: pZwaC8UosWljP3NWVxVNtHTRGiw=
+
+Name: callback.c
+SHA1-Digest: WK2OaHvOUajqPh2oV8YRS604pO4=
+
+Name: callback.h
+SHA1-Digest: Wxpy3d8PNoy3jvdpl1psVnt0x+E=
+
+Name: org/eclipse/swt/internal/win32/TEXTMETRICA.java
+SHA1-Digest: GJdEY2+QBTEiysJcViD3k7cTuYo=
+
+Name: org/eclipse/swt/graphics/TextLayout.java
+SHA1-Digest: tHugawBtNDDpLEdAdTAg7HlR1V0=
+
+Name: org/eclipse/swt/internal/ole/win32/IPersist.java
+SHA1-Digest: rI7LbFtC9Xm3v1VNrssWC2Sj9hY=
+
+Name: org/eclipse/swt/internal/mozilla/nsIURIContentListener.java
+SHA1-Digest: zFNOik7Zn/XoL+spZkiNVaENdNA=
+
+Name: org/eclipse/swt/internal/mozilla/nsIFactory.java
+SHA1-Digest: ur0Too0GWyCWllwCQzhmpkpCvqU=
+
+Name: org/eclipse/swt/internal/mozilla/nsICookieManager.java
+SHA1-Digest: HKLZEGSnCcTVcBQq4lyey87NOow=
+
+Name: org/eclipse/swt/internal/ole/win32/GUID.java
+SHA1-Digest: t7ckdAFQiG3bfEdgwRpje5LQjWw=
+
+Name: org/eclipse/swt/browser/HelperAppLauncherDialog.java
+SHA1-Digest: roF6SQ7eo8aIgqPkSvsriAdo5Mg=
+
+Name: org/eclipse/swt/events/PaintEvent.java
+SHA1-Digest: O8bu+wmsyVR0bcSSkQO5tAdATyU=
+
+Name: os_structs.c
+SHA1-Digest: gqE8d65eR9jEKaROjh/9xx8SR98=
+
+Name: org/eclipse/swt/internal/win32/NMLISTVIEW.java
+SHA1-Digest: jkiceZmm4Y8RBirMGz/Mq2nupYk=
+
+Name: os_structs.h
+SHA1-Digest: YTEp5TrhhuHI6aFTTFp7H+fGOwk=
+
+Name: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java
+SHA1-Digest: K54gRjc+2a+qOv1RaacYw6B3kVE=
+
+Name: org/eclipse/swt/internal/BidiUtil.java
+SHA1-Digest: tb6v0RgZxjk5FZEHAyu/vhkJyBI=
+
+Name: org/eclipse/swt/events/ControlListener.java
+SHA1-Digest: fQDy9jzlQ2SdDrjv/IORwDYIYXo=
+
+Name: org/eclipse/swt/internal/mozilla/nsIIOService.java
+SHA1-Digest: e85xGMQu0DA8wYib2FcMVDA1MBY=
+
+Name: org/eclipse/swt/internal/win32/NMCUSTOMDRAW.java
+SHA1-Digest: JOqduQbcyyvKPhxemaFCmKI4Src=
+
+Name: org/eclipse/swt/events/SelectionAdapter.java
+SHA1-Digest: 5C4OUryFrbJtGnpmKLYoSjVCxoM=
+
+Name: org/eclipse/swt/internal/ole/win32/IDragSourceHelper2.java
+SHA1-Digest: LTfC3UTtgvZkH5C7JlBEOoRrg3E=
+
+Name: org/eclipse/swt/internal/image/GIFFileFormat.java
+SHA1-Digest: Z4aRjCyAPQSEQMzxDSpwluCPjeo=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWritableVariant.java
+SHA1-Digest: OwAGlWB/qajIRTzBHYUtAGWxTow=
+
+Name: org/eclipse/swt/internal/Library.java
+SHA1-Digest: f//1xlxrnkVSg4luLfJCgbPYS0c=
+
+Name: org/eclipse/swt/internal/mozilla/nsIScriptSecurityManager_1_9_1.
+ java
+SHA1-Digest: bEcUNRFrYcqUnv8jsGI+w/CJiSQ=
+
+Name: org/eclipse/swt/custom/StyledTextContent.java
+SHA1-Digest: Na8upy1nCwBHUiJorNFg/eFvuoA=
+
+Name: org/eclipse/swt/internal/ole/win32/VARIANT.java
+SHA1-Digest: Z4GSms8/KpZPVDApGTCPM3i/Fnk=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_FONTPROPERTIES.java
+SHA1-Digest: OZXilP0YYXEBsQmzcj1ysl+X1ak=
+
+Name: org/eclipse/swt/widgets/Text.java
+SHA1-Digest: Qsb2LqoZPtKf3YUIAr3Lj0IKNco=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFOEXW.java
+SHA1-Digest: SH585+MYvsMT0CX3tVL05TQ3A2w=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleLink.java
+SHA1-Digest: OE2phnD+W14juZhztT/0V1TaBTg=
+
+Name: org/eclipse/swt/internal/win32/MINMAXINFO.java
+SHA1-Digest: vyjQON8jY/LicTg+sVpP4vuuySk=
+
+Name: org/eclipse/swt/internal/win32/MONITORINFO.java
+SHA1-Digest: VkVKjD459Jb01XWKRrMrpbgrET0=
+
+Name: org/eclipse/swt/graphics/PaletteData.java
+SHA1-Digest: auyULUB5e7v8rrgm77F4+ZKQthc=
+
+Name: org/eclipse/swt/browser/FilePickerFactory_1_8.java
+SHA1-Digest: S2Ay6dil5CZFIHPBPTAtoGGtA4k=
+
+Name: org/eclipse/swt/layout/RowLayout.java
+SHA1-Digest: rFiWoqU0IyexFDTJPb5p2yNDeNM=
+
+Name: org/eclipse/swt/ole/win32/OleEventTable.java
+SHA1-Digest: 0ILzxoAqOQnPG/IoPdHTHoLWK5A=
+
+Name: org/eclipse/swt/accessibility/ACC.java
+SHA1-Digest: N8AT3qRa69va4fHoUmohEMusneI=
+
+Name: org/eclipse/swt/internal/theme/ScrollBarDrawData.java
+SHA1-Digest: bDM63RDpGO7ql7I2pnz8q6BXpPY=
+
+Name: org/eclipse/swt/internal/SWTEventObject.java
+SHA1-Digest: iyaT193xvfks94S+TveTKFEajVQ=
+
+Name: org/eclipse/swt/internal/opengl/win32/WGL.java
+SHA1-Digest: PwSHBnb9eK0UyrzMV4AsudsQ1yI=
+
+Name: org/eclipse/swt/internal/win32/LOGFONTA.java
+SHA1-Digest: A6JB/vH/7kcxJNL3lAoDzf0RLiA=
+
+Name: org/eclipse/swt/internal/win32/NMTBHOTITEM.java
+SHA1-Digest: 9rqkRQ7qITR8ObWagQCw4htpFHA=
+
+Name: org/eclipse/swt/internal/image/PngInputStream.java
+SHA1-Digest: NZcYo48/qmoa5kMToNNibHfhkZA=
+
+Name: org/eclipse/swt/dnd/ByteArrayTransfer.java
+SHA1-Digest: OLiuH+9HQ8V3bUnV3Pey/aIetA4=
+
+Name: org/eclipse/swt/internal/win32/LRESULT.java
+SHA1-Digest: 2dFYqRhxNbvGFX9O3NXJEyQgL/E=
+
+Name: org/eclipse/swt/SWTException.java
+SHA1-Digest: yK4pwvgLReCV+vL+TXYGMFM1Qow=
+
+Name: org/eclipse/swt/widgets/Tree.java
+SHA1-Digest: /m+vwvMsz2QqFn1zOF9xrV4H97U=
+
+Name: org/eclipse/swt/custom/CBannerLayout.java
+SHA1-Digest: nnHYK9BSSUDwyWGi571sABrJ8PY=
+
+Name: org/eclipse/swt/browser/ProgressAdapter.java
+SHA1-Digest: tvCaB4CHIUkmkdFk1DaPFHzntbA=
+
+Name: org/eclipse/swt/browser/BrowserFunction.java
+SHA1-Digest: 5pLw8tGd53uGQJESDR63lCfIhqw=
+
+Name: org/eclipse/swt/widgets/MenuItem.java
+SHA1-Digest: gXF5KWCbn2JaU6EPn4w74P2Yieo=
+
+Name: org/eclipse/swt/internal/ole/win32/DISPPARAMS.java
+SHA1-Digest: Yv9QduNNFCYWyhEMpdgCJ76ekyI=
+
+Name: org/eclipse/swt/custom/StyledTextDropTargetEffect.java
+SHA1-Digest: NgJVNv5pmGiaR9xUGzE0F64lBLQ=
+
+Name: c.c
+SHA1-Digest: CfcPB/LF1F5w8HMDCmQrjRyriF4=
+
+Name: org/eclipse/swt/widgets/ProgressBar.java
+SHA1-Digest: 6K3Iw1spwwsuL1CntS5ebfrnQ0Y=
+
+Name: c.h
+SHA1-Digest: +B00noE9fih7PulcRZmGt9m71BM=
+
+Name: org/eclipse/swt/internal/Compatibility.java
+SHA1-Digest: lwVwTwZLQQ66ebGgfC9dJdpNXag=
+
+Name: org/eclipse/swt/widgets/TableItem.java
+SHA1-Digest: v7OQ6l5lltV0WBUSCb3tizyWxuU=
+
+Name: org/eclipse/swt/internal/win32/MENUBARINFO.java
+SHA1-Digest: WXnNxcNnZC4ysPCzmxZeMGbH4bg=
+
+Name: org/eclipse/swt/browser/WebBrowser.java
+SHA1-Digest: 0P1qjYpyMeAQJ/CYkHxa3u9Mos4=
+
+Name: org/eclipse/swt/internal/mozilla/XPCOM.java
+SHA1-Digest: rXRtmSIiHl/Ug//aUjXj/tzpYsA=
+
+Name: org/eclipse/swt/layout/GridData.java
+SHA1-Digest: ImZNY7GipvVdbZq0DXiCzm2L2Eo=
+
+Name: org/eclipse/swt/internal/mozilla/nsID.java
+SHA1-Digest: sUF+XqX6e35dm6dtr1ddIOmGVZ0=
+
+Name: org/eclipse/swt/internal/win32/LOGFONT.java
+SHA1-Digest: 3fgsGJwr0oErIsNa24SNhBA9WFg=
+
+Name: org/eclipse/swt/internal/win32/TVSORTCB.java
+SHA1-Digest: b5itTiNpvgmpUgxt9X3Fg0R0W80=
+
+Name: org/eclipse/swt/internal/win32/NMREBARCHILDSIZE.java
+SHA1-Digest: v3hRpMyI/z40jPc+4aNZqqIaCyU=
+
+Name: org/eclipse/swt/internal/image/TIFFRandomFileAccess.java
+SHA1-Digest: 9WJ1iNVVlt/Ba7gZ0YfLJQxC/Oc=
+
+Name: make_common.mak
+SHA1-Digest: h3DKZN8yNujTYjrU51Tkd3GvDJs=
+
+Name: org/eclipse/swt/internal/ole/win32/IDispatch.java
+SHA1-Digest: +OiNjrP7n8oHHRNG1oDLmrO1AUc=
+
+Name: org/eclipse/swt/internal/mozilla/nsIMemory.java
+SHA1-Digest: acby6HOQUvMs6dgtse0ml41fxvo=
+
+Name: org/eclipse/swt/internal/ole/win32/OLEINPLACEFRAMEINFO.java
+SHA1-Digest: 2hPJdqL8cd+KSC20a/O63fsDcjA=
+
+Name: org/eclipse/swt/browser/WebSite.java
+SHA1-Digest: AKJCDbFX+MKBLKYQwmnGGsgA6BU=
+
+Name: org/eclipse/swt/custom/StyledTextListener.java
+SHA1-Digest: hj1ayWoABBsfHT49aFMKACBemtE=
+
+Name: org/eclipse/swt/internal/win32/BUTTON_IMAGELIST.java
+SHA1-Digest: KeOV8OZsgIgawkgtfQ5hGiB9svk=
+
+Name: org/eclipse/swt/browser/PromptService2.java
+SHA1-Digest: FYB6hfrslmFBUVmLukGAGThE3+0=
+
+Name: org/eclipse/swt/ole/win32/Variant.java
+SHA1-Digest: JKXiYl2qFR8NDiyfodUyxR5YhfI=
+
+Name: org/eclipse/swt/browser/IE.java
+SHA1-Digest: L09WT3JuRZNtslWcEMMGG8b373o=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleDocument.java
+SHA1-Digest: br3huzqHP2hNIn8vkAOekppsA68=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDirectoryService.java
+SHA1-Digest: agHZLDee5AelTeM7X7xZcIKnpkY=
+
+Name: org/eclipse/swt/internal/image/PngLzBlockReader.java
+SHA1-Digest: GAuYmtwAGUIUbM4v3c+Cd3KpjL0=
+
+Name: org/eclipse/swt/internal/ole/win32/OLECMD.java
+SHA1-Digest: 3N0HjhV/3SaFAf+Jo7Ixq9ItyEc=
+
+Name: org/eclipse/swt/custom/LineBackgroundEvent.java
+SHA1-Digest: +hTWYb6PBkMKz1D2r4S4N4PG1y0=
+
+Name: org/eclipse/swt/internal/win32/SHRGINFO.java
+SHA1-Digest: LX7gtWSodNJzupCKWhEn4MkG8JI=
+
+Name: org/eclipse/swt/internal/win32/NMHDR.java
+SHA1-Digest: uApwI2PX7pIIETiszHfx9evgjcA=
+
+Name: org/eclipse/swt/internal/theme/ExpanderDrawData.java
+SHA1-Digest: hxoF0PgwgVuZ0iKcvQArobIVJRA=
+
+Name: gdip_structs.cpp
+SHA1-Digest: qPv7Hfho7Sz8NWH29LhSS9wTQ+s=
+
+Name: gdip_structs.h
+SHA1-Digest: F3h2FvGdjtpTwOtIAiIRKANGCgU=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebNavigationInfo.java
+SHA1-Digest: hzz4dFcMreSBGxQRAnWOfCUBbPA=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_STATE.java
+SHA1-Digest: 4wQxXwdAc2GPoH18sXg5RcI46io=
+
+Name: org/eclipse/swt/widgets/Display.java
+SHA1-Digest: +T3G/2XrIbpDu7IuIjsrbFUD/Ic=
+
+Name: gdip_custom.cpp
+SHA1-Digest: 24NtBm2fDZWJu6cGmELI9tGydf8=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMWindow.java
+SHA1-Digest: fWhBDOWaTa0eUy67UyyyW7iil1k=
+
+Name: org/eclipse/swt/custom/CLayoutData.java
+SHA1-Digest: eoDu3b7LjckaTeCgK55Zmnt99rE=
+
+Name: org/eclipse/swt/internal/image/PngEncoder.java
+SHA1-Digest: bWQcTjCOZA1GOAHh1Byus6Wz4Xw=
+
+Name: org/eclipse/swt/custom/LineStyleListener.java
+SHA1-Digest: 7YVyhVizJkUqytPDLcbKtIybEAI=
+
+Name: org/eclipse/swt/dnd/TableDropTargetEffect.java
+SHA1-Digest: ZAVRcscrEKmwPP1BmEATB+1MhmU=
+
+Name: org/eclipse/swt/events/TypedEvent.java
+SHA1-Digest: OpLiMzOA+i/BNdLSRKh7HqkKOmk=
+
+Name: org/eclipse/swt/dnd/DropTargetEvent.java
+SHA1-Digest: hnCadOoP6HmIR8LjmTBFHgC31bA=
+
+Name: org/eclipse/swt/internal/win32/EXTLOGFONTW.java
+SHA1-Digest: k5Cg0Kb9iaW6WxJJ9GboS+o1bwI=
+
+Name: com_custom.c
+SHA1-Digest: Ukdf6SYqOlEWTfiLU5GAQyJZpps=
+
+Name: org/eclipse/swt/custom/StyledText.java
+SHA1-Digest: 0rrC3+IvcpX/705ILYiBIfebehg=
+
+Name: org/eclipse/swt/internal/theme/TabFolderDrawData.java
+SHA1-Digest: 5Rqz5jQ9k+Z7d6dQRLfGNaTgEn0=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPrefBranch.java
+SHA1-Digest: xrwK9JPEpobMgJ7D57UXn6FyI1U=
+
+Name: com_custom.h
+SHA1-Digest: 9uH5ShE2tTodcdPB5U0TDZRPfh0=
+
+Name: org/eclipse/swt/dnd/TreeDragSourceEffect.java
+SHA1-Digest: nzb7Pmarn1qTJXslMB3PVPL9EI0=
+
+Name: org/eclipse/swt/widgets/TreeItem.java
+SHA1-Digest: WXc0EOJdRbDJEOwBEIpSIuX//uk=
+
+Name: org/eclipse/swt/widgets/TabItem.java
+SHA1-Digest: XuzHB+oEZLf9M2QETJ86FmWDtwU=
+
+Name: org/eclipse/swt/dnd/DragSource.java
+SHA1-Digest: El6Yw3U8bhSSt/YmbPvcrF9hCEQ=
+
+Name: org/eclipse/swt/widgets/TableColumn.java
+SHA1-Digest: SrxVoaPlqz61E5GkVeIPrS07Jmg=
+
+Name: org/eclipse/swt/graphics/DeviceData.java
+SHA1-Digest: A5oQehy3Oh9BKvFOy2PwG0YqTu0=
+
+Name: org/eclipse/swt/internal/image/JPEGQuantizationTable.java
+SHA1-Digest: IHS3GUjH+0RAxcvUYsv6VgKv4zA=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java
+SHA1-Digest: q7V0KMdV0vbYNAStu8n3kWTT7rs=
+
+Name: org/eclipse/swt/internal/mozilla/nsICookie.java
+SHA1-Digest: GIlIi2fMkCXb54tFmc8JEE8njlg=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java
+SHA1-Digest: Hn9G9Ej/synue5WjtUzVTwQgzfA=
+
+Name: org/eclipse/swt/internal/mozilla/nsEmbedString.java
+SHA1-Digest: xTOGvPsQ1h/+iN4wmn6bKCnIgr8=
+
+Name: org/eclipse/swt/internal/ole/win32/IConnectionPoint.java
+SHA1-Digest: 3AeRZPtsUbrp5Whqu5o660qJih4=
+
+Name: swt.rc
+SHA1-Digest: mZpchS7FqyL3OAGoYlVP11Tk4AM=
+
+Name: org/eclipse/swt/custom/TextChangeListener.java
+SHA1-Digest: 4h+Cd+LL8N6tZ2zBak8LjlYO/AE=
+
+Name: org/eclipse/swt/internal/image/PngDeflater.java
+SHA1-Digest: r2sJJkEA9mXPdgX1BMD+lYBSKNc=
+
+Name: org/eclipse/swt/custom/CTabFolder2Listener.java
+SHA1-Digest: ru448JoF54HLocW3MxbQ+E7Z3eg=
+
+Name: org/eclipse/swt/SWTError.java
+SHA1-Digest: 9n4BjYgeE0mnHJws/6f18DNPIIk=
+
+Name: org/eclipse/swt/browser/AuthenticationEvent.java
+SHA1-Digest: 79Xq6Ao4Uku3TjZeotl4zqQaiks=
+
+Name: org/eclipse/swt/browser/OpenWindowListener.java
+SHA1-Digest: tlo/e/m+jLxID8VB5mAiKxNked0=
+
+Name: org/eclipse/swt/internal/win32/NMTTDISPINFO.java
+SHA1-Digest: OUf+IaYb+Y9jQbK1lvw+PRHw04Y=
+
+Name: org/eclipse/swt/internal/win32/NOTIFYICONDATA.java
+SHA1-Digest: 8LfLZWD6/CkNbgPTxnnO2RgQDLE=
+
+Name: org/eclipse/swt/graphics/Pattern.java
+SHA1-Digest: bRHSd3VE06RNoo3AOUJZ+2fJpAY=
+
+Name: org/eclipse/swt/internal/mozilla/nsIProgressDialog.java
+SHA1-Digest: I3/HeAghxpOLrPDmRBWd7apmgmA=
+
+Name: org/eclipse/swt/events/ControlAdapter.java
+SHA1-Digest: 2m17bNMTLWTnFN2F9c9SlvW1ZC8=
+
+Name: org/eclipse/swt/events/HelpEvent.java
+SHA1-Digest: fnJ4/OgC+q5tyjUN8l4YC6v5950=
+
+Name: org/eclipse/swt/internal/mozilla/nsIComponentManager.java
+SHA1-Digest: J/C+5z0TnNrgCSCjNjQwngz0feE=
+
+Name: org/eclipse/swt/internal/win32/DROPFILES.java
+SHA1-Digest: dP9XznF+mD/ftDFF+6wb31IWF1k=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider2.ja
+ va
+SHA1-Digest: l8+fGEA6Av3GSYj6P9NBcqc7Cmo=
+
+Name: org/eclipse/swt/internal/ole/win32/IProvideClassInfo.java
+SHA1-Digest: QOyMb9Ht1kpxymeXkq+tB64AQ/A=
+
+Name: org/eclipse/swt/custom/ScrolledComposite.java
+SHA1-Digest: vme9BWYwOkd+C3nS4zyuq5Wfvdg=
+
+Name: org/eclipse/swt/custom/PaintObjectEvent.java
+SHA1-Digest: Gt+RlAEh8kCe0BwokUXk7MbyltU=
+
+Name: org/eclipse/swt/events/FocusListener.java
+SHA1-Digest: x/w95NZdrH2tcTnT6Qptu5ppK2U=
+
+Name: org/eclipse/swt/internal/mozilla/nsIXPCSecurityManager.java
+SHA1-Digest: H5bVpODcU2AiWzYZotchY6WSMJo=
+
+Name: org/eclipse/swt/internal/mozilla/nsIJSContextStack.java
+SHA1-Digest: QrLpd95u7f+HKqK06BJSHVWytcQ=
+
+Name: org/eclipse/swt/internal/theme/RangeDrawData.java
+SHA1-Digest: HdP0cyFe7cmluedM++rMDOWw07U=
+
+Name: org/eclipse/swt/widgets/DirectoryDialog.java
+SHA1-Digest: LnPQ+hnbqNXuU+4yrGeKsOqqFMI=
+
+Name: wgl.c
+SHA1-Digest: wg1qw3m3mFKpd4q/pNSA11COiLU=
+
+Name: org/eclipse/swt/events/DisposeEvent.java
+SHA1-Digest: geGcw/h5dtBaXDOi/59spgCG5aM=
+
+Name: wgl.h
+SHA1-Digest: Lb6NBSm8NFQQp3zefj5KOawgiYI=
+
+Name: org/eclipse/swt/widgets/Scrollable.java
+SHA1-Digest: eTGIqTNm0zEb+shrwHDJJkcF43Q=
+
+Name: org/eclipse/swt/internal/win32/GCP_RESULTS.java
+SHA1-Digest: k19pJsfd9NNWrBfSX4beaEmhlIE=
+
+Name: org/eclipse/swt/internal/ole/win32/STATSTG.java
+SHA1-Digest: AGGZpWj+Tx3jz7o1V9cDnUr6sa8=
+
+Name: org/eclipse/swt/browser/ProgressEvent.java
+SHA1-Digest: FD8CuG3DKqli5657ACIHzlJGzVk=
+
+Name: org/eclipse/swt/widgets/Slider.java
+SHA1-Digest: S/9kfQwmXjJvwuKdRysm8XNzwhk=
+
+Name: xpcom_stats.cpp
+SHA1-Digest: bqsPzAO9ShGIFs6id/Vm84YCQG8=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java
+SHA1-Digest: Bq81Js4ngYrMaEHlxfGdez2oC00=
+
+Name: org/eclipse/swt/internal/win32/NMLVODSTATECHANGE.java
+SHA1-Digest: TIEK1FbbUtjxJZE4ewjmMyQGAr0=
+
+Name: org/eclipse/swt/browser/HelperAppLauncherDialog_1_9.java
+SHA1-Digest: TG/a/KWqwzvGB+pJolSYd+wIkks=
+
+Name: org/eclipse/swt/internal/mozilla/nsIRequest.java
+SHA1-Digest: ycLNPPPcT6zheERvCcOjhPDcvuw=
+
+Name: org/eclipse/swt/internal/win32/SHDRAGIMAGE.java
+SHA1-Digest: FqkFe40deXf8PuooQqJ34ibO7iM=
+
+Name: org/eclipse/swt/internal/mozilla/nsISecurityCheckedComponent.jav
+ a
+SHA1-Digest: DQkqgypnIFzILytKWBL3FwhJyew=
+
+Name: org/eclipse/swt/internal/win32/COMPOSITIONFORM.java
+SHA1-Digest: t6qEmb/8dqO+SRPAILz/XzkPtFE=
+
+Name: org/eclipse/swt/internal/win32/OUTLINETEXTMETRICA.java
+SHA1-Digest: DeK33/A+Xrx/gG3HomEbY+Y06hA=
+
+Name: org/eclipse/swt/widgets/ScrollBar.java
+SHA1-Digest: ngEVDEQMgVaLmS4h7nRf7Cr2Mu0=
+
+Name: org/eclipse/swt/internal/win32/TBBUTTON.java
+SHA1-Digest: ze36442f1GIIJJsZriyO1bpa+BU=
+
+Name: org/eclipse/swt/events/SelectionEvent.java
+SHA1-Digest: 1pJJ1ewp1vs/IYq6WQXPCLSr/UM=
+
+Name: org/eclipse/swt/accessibility/AccessibleEvent.java
+SHA1-Digest: VYFcVuRuLSPdlBdaaPnefZ3Fcb4=
+
+Name: org/eclipse/swt/internal/win32/SCROLLINFO.java
+SHA1-Digest: LINzbOkGlK/Lbh0gY5oNK22MGO8=
+
+Name: org/eclipse/swt/custom/StyledTextEvent.java
+SHA1-Digest: 6icF/qgfuLkx30Y1tKJUW3/V9KU=
+
+Name: org/eclipse/swt/internal/image/PngFileReadState.java
+SHA1-Digest: V+13Asjv0XZIF1L09T3NFksq7Hc=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_DIGITSUBSTITUTE.java
+SHA1-Digest: hZMHiqlPZnT12xkfRo3VJtSuDDE=
+
+Name: org/eclipse/swt/custom/CTabFolderAdapter.java
+SHA1-Digest: yk0c4sYXAlvGNLCOv8xCbJSZSlI=
+
+Name: org/eclipse/swt/internal/win32/TVITEMEX.java
+SHA1-Digest: 2n54yjtfTTbnFn9nhH5GHrNppaQ=
+
+Name: os.c
+SHA1-Digest: xddFs9oyUkxyqcstmFJ7ijkjwNk=
+
+Name: org/eclipse/swt/graphics/Path.java
+SHA1-Digest: zelxpccr52HY/ddrFuTNBmQgOCM=
+
+Name: org/eclipse/swt/internal/win32/INPUT.java
+SHA1-Digest: O7xRmfPDEbHoXo664EFJyWqqK5k=
+
+Name: org/eclipse/swt/internal/win32/EMR.java
+SHA1-Digest: CWETxuaxrU023Se62cll7/1OoB0=
+
+Name: os.h
+SHA1-Digest: HuioBuevm/Xen/YsiFwRZth0NPw=
+
+Name: org/eclipse/swt/internal/win32/SYSTEMTIME.java
+SHA1-Digest: 7hurdr2LwA4spdiqpi1Wl4nlW5s=
+
+Name: org/eclipse/swt/custom/BidiSegmentListener.java
+SHA1-Digest: jA6NHhGINQVhFYxUMEd+/5V5MjE=
+
+Name: swt_gdip.rc
+SHA1-Digest: eIxdr9j1y14te/Ck81aKFXKOiNc=
+
+Name: org/eclipse/swt/ole/win32/OleEvent.java
+SHA1-Digest: QTKYaSXx6OV90O6m97OAE90r43Y=
+
+Name: org/eclipse/swt/internal/win32/KEYBDINPUT.java
+SHA1-Digest: MbpjubaIegYE7OiSKPZrGqXD2iE=
+
+Name: org/eclipse/swt/internal/mozilla/nsIServiceManager.java
+SHA1-Digest: xuKxovA8n5izIC5uzczkfIe5678=
+
+Name: org/eclipse/swt/widgets/Table.java
+SHA1-Digest: PwFa2DYXwXcp/FY+I08trHcHJWA=
+
+Name: org/eclipse/swt/internal/ole/win32/LICINFO.java
+SHA1-Digest: Cb6RNzmGQEKIvoP2K0uPxjsnWj0=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMSerializer_1_7.java
+SHA1-Digest: D29jRuGBKJWWdBVl+mSx8KtRIK8=
+
+Name: org/eclipse/swt/widgets/Scale.java
+SHA1-Digest: mUxWuiZwhg/e/5mMsneoeZRi28Q=
+
+Name: c_stats.c
+SHA1-Digest: L5+IcncIxuE1k/Mtqkhipx9kx8M=
+
+Name: org/eclipse/swt/browser/DownloadFactory_1_8.java
+SHA1-Digest: fhOBHpTiLnAiGfddVeR2wtIujBY=
+
+Name: c_stats.h
+SHA1-Digest: v2n9SfFbecVkF2oTDw5wFeVPCl4=
+
+Name: org/eclipse/swt/graphics/Drawable.java
+SHA1-Digest: GB46LXdiZph/u30rYcvb/t742Is=
+
+Name: org/eclipse/swt/internal/win32/NMTOOLBAR.java
+SHA1-Digest: FzHFYbEEuxA8DyS9TrqE/7KeQs4=
+
+Name: org/eclipse/swt/widgets/EventTable.java
+SHA1-Digest: XQeGtOkPYBpQZQl4Cu1FAdv9ZxQ=
+
+Name: org/eclipse/swt/browser/LocationAdapter.java
+SHA1-Digest: KJZFIiKVPTWsfbfZmyYijFMDBME=
+
+Name: org/eclipse/swt/internal/image/LZWCodec.java
+SHA1-Digest: rbzBlzIuABXV9kqAARbYA9TOULY=
+
+Name: org/eclipse/swt/custom/ViewFormLayout.java
+SHA1-Digest: vLNSznl2wGFL2SR7yKB6jsgEu7c=
+
+Name: make_win32.mak
+SHA1-Digest: rhUNJH16JXTXm2SrKRQ6CnanOBI=
+
+Name: org/eclipse/swt/internal/mozilla/nsIContextMenuListener.java
+SHA1-Digest: 2wPQ4WL0/daIBITvaOKO/YcsBlY=
+
+Name: org/eclipse/swt/events/MenuEvent.java
+SHA1-Digest: lxg+gcJn8vXuJaxuUgT9DeKLvw0=
+
+Name: org/eclipse/swt/internal/win32/NMLVCUSTOMDRAW.java
+SHA1-Digest: iYp+fPfLKVRYT3g/tlfZFOD/dvw=
+
+Name: org/eclipse/swt/internal/ole/win32/IEnumFORMATETC.java
+SHA1-Digest: SS8fagnIxgZ4VUvvxGVqsdv3qn4=
+
+Name: org/eclipse/swt/internal/win32/NMTVCUSTOMDRAW.java
+SHA1-Digest: k/17K6AR+x0V/CvBiQUoSEMMmWQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPrincipal.java
+SHA1-Digest: JKHxf2EC3vZFEJaBagPXthDHgeY=
+
+Name: about_files/mpl-v11.txt
+SHA1-Digest: kye+J+SfAeSHDb4yfkmEMHDyA6s=
+
+Name: org/eclipse/swt/widgets/Item.java
+SHA1-Digest: JQg6V6cvAjpAqW1BKTrjcVF2o34=
+
+Name: org/eclipse/swt/internal/win32/DEVMODE.java
+SHA1-Digest: 4xJLDxhupYCtO1CZ0AXDPFr+tUU=
+
+Name: org/eclipse/swt/browser/External.java
+SHA1-Digest: GERerXJsQTwYuYP0U3HL4H5R5DQ=
+
+Name: org/eclipse/swt/browser/LocationListener.java
+SHA1-Digest: lMmCVF+74EF9F1G6AcrK+VNS0l8=
+
+Name: org/eclipse/swt/custom/CTabFolderListener.java
+SHA1-Digest: yr5XxX7FlECW4UygEgiRxe6aOy0=
+
+Name: org/eclipse/swt/internal/mozilla/init/GREVersionRange.java
+SHA1-Digest: auLs11FD8kj9YV8RoJ9MtkgYI0Y=
+
+Name: org/eclipse/swt/browser/MozillaDelegate.java
+SHA1-Digest: wSES2Z0p2n4W5LCONCkx2Xaa6vw=
+
+Name: com.c
+SHA1-Digest: SdOVGecXidAG23zsiP58E959mgI=
+
+Name: org/eclipse/swt/internal/win32/INITCOMMONCONTROLSEX.java
+SHA1-Digest: rQxd1q5FmnKgpskXPKzWLuDxR0I=
+
+Name: org/eclipse/swt/internal/image/LEDataOutputStream.java
+SHA1-Digest: SRl6sfnbmXV4XILfth6kZFn4XCo=
+
+Name: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog.java
+SHA1-Digest: dHEajPTIeE2/t1Lbj9h4qXHxZRg=
+
+Name: com.h
+SHA1-Digest: 6kSEuKwaWuq42y/DNJYisl5ZfMk=
+
+Name: org/eclipse/swt/internal/win32/MENUITEMINFO.java
+SHA1-Digest: pFu454tb/mAYAebyDg+Ult6CtH0=
+
+Name: org/eclipse/swt/internal/win32/EMREXTCREATEFONTINDIRECTW.java
+SHA1-Digest: nAw8vlDolcty7ot3R7bZPAx/Yoo=
+
+Name: org/eclipse/swt/browser/TitleListener.java
+SHA1-Digest: FcYFzNpVMdj6atQo3AcuuxmD4dM=
+
+Name: xpcom_structs.cpp
+SHA1-Digest: 3bLjF3qSNpjEJ5W6ltDSxp3eTx8=
+
+Name: org/eclipse/swt/ole/win32/OleParameterDescription.java
+SHA1-Digest: WF3WtoXLGwHBf2kgaWWpoFxu56A=
+
+Name: org/eclipse/swt/internal/theme/ProgressBarDrawData.java
+SHA1-Digest: EARLLPvn1a9I+zl1Vno8xCw21cg=
+
+Name: org/eclipse/swt/awt/SWT_AWT.java
+SHA1-Digest: db+NuoeT8P25BdDGFMpbjY+U0bw=
+
+Name: org/eclipse/swt/internal/Lock.java
+SHA1-Digest: xrG9A9txpLLODbw49piIp2nSy5I=
+
+Name: org/eclipse/swt/accessibility/AccessibleControlListener.java
+SHA1-Digest: fg9p3mYB7lCmCN9mFZh/iBqjFo4=
+
+Name: org/eclipse/swt/dnd/DNDListener.java
+SHA1-Digest: JnO71PJ2tk1/N/s/BCbGLDD0TMU=
+
+Name: org/eclipse/swt/internal/ole/win32/COM.java
+SHA1-Digest: fjDY1dZqdomwwjOvqLf/7JxJL0E=
+
+Name: org/eclipse/swt/internal/win32/UDACCEL.java
+SHA1-Digest: MTXEMNoApWLMuZfOFDEQHTYM5QY=
+
+Name: org/eclipse/swt/accessibility/AccessibleTextEvent.java
+SHA1-Digest: T3EAg+GI1MueXHV58LoQkSzlu1g=
+
+Name: org/eclipse/swt/internal/win32/NONCLIENTMETRICSA.java
+SHA1-Digest: yeq4IVXdCVhorI9CA9daQ5VwIpw=
+
+Name: org/eclipse/swt/custom/BidiSegmentEvent.java
+SHA1-Digest: my/RpeuZbStgUBNSqZVYeaJ3s1c=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java
+SHA1-Digest: YVO/AJaajrVA9g3FTCmjYZu4+nw=
+
+Name: org/eclipse/swt/internal/win32/TOOLINFO.java
+SHA1-Digest: b7s/+uyMdYD24anFYbIrVAyrf40=
+
+Name: org/eclipse/swt/dnd/DragSourceAdapter.java
+SHA1-Digest: rMmZmG/qUveSwK0UcR7YPlJuvWk=
+
+Name: org/eclipse/swt/internal/mozilla/nsIProperties.java
+SHA1-Digest: Uk8Cft4eVq3hnsvWWDUWU/ofAiE=
+
+Name: org/eclipse/swt/internal/win32/TF_DISPLAYATTRIBUTE.java
+SHA1-Digest: V+TWwZdwr+rBJfH196GFfbj118M=
+
+Name: org/eclipse/swt/browser/PromptService2Factory.java
+SHA1-Digest: x8kHWSwhBT6Km8gtky7uMlPdC7s=
+
+Name: org/eclipse/swt/internal/image/PngPlteChunk.java
+SHA1-Digest: GloK8grKrCpBkL0hVMw0WTsifVA=
+
+Name: org/eclipse/swt/internal/mozilla/nsISupports.java
+SHA1-Digest: XD5Rw9OKQKcu1YSD5nEedYLj6Zo=
+
+Name: org/eclipse/swt/internal/win32/DRAWITEMSTRUCT.java
+SHA1-Digest: IggiroTdRo3zL9dXC5JOUwzoDrs=
+
+Name: org/eclipse/swt/custom/StyledTextPrintOptions.java
+SHA1-Digest: AK1Pnwn1i8J7BQezMFp089eTESQ=
+
+Name: org/eclipse/swt/events/HelpListener.java
+SHA1-Digest: XekP0Y/xvjFRqDRDoZlP3aHFp9Q=
+
+Name: org/eclipse/swt/custom/CTabFolderLayout.java
+SHA1-Digest: 82dPiKs9wTatiLlrYg5BC1uA/aQ=
+
+Name: org/eclipse/swt/browser/InputStream.java
+SHA1-Digest: N0gnEYVkFLqljjV9TGTaKRwy0BY=
+
+Name: org/eclipse/swt/widgets/TypedListener.java
+SHA1-Digest: qQynoNboDo5Rd6W7CoLId4ueuPI=
+
+Name: org/eclipse/swt/ole/win32/OlePropertyDescription.java
+SHA1-Digest: a6b/LyL1qxiuRwy46SskV5tuL+Y=
+
+Name: org/eclipse/swt/custom/CTabFolder.java
+SHA1-Digest: qixmNz5SSdwSCyWRYtJED4FS+nw=
+
+Name: org/eclipse/swt/ole/win32/OleFunctionDescription.java
+SHA1-Digest: dnllmnCDW7jr/K9WfioQ9e/mqxo=
+
+Name: org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java
+SHA1-Digest: IjZ4Nqd5s80cyWeoBykKYivNNpg=
+
+Name: org/eclipse/swt/internal/ole/win32/IAccessible.java
+SHA1-Digest: yJBp9R/Uf3E3+Jvp3YAYWZXQT3M=
+
+Name: org/eclipse/swt/internal/win32/WINDOWPLACEMENT.java
+SHA1-Digest: CGzkboxpwq2RADSvBI7/PbM7wAU=
+
+Name: org/eclipse/swt/internal/win32/WNDCLASS.java
+SHA1-Digest: H9yKe2FU48lFutx60ZYkRrvthQI=
+
+Name: org/eclipse/swt/internal/win32/PAINTSTRUCT.java
+SHA1-Digest: gxMp5pU0RRVBQijCvRJ3rjFOqn4=
+
+Name: org/eclipse/swt/internal/SWTEventListener.java
+SHA1-Digest: zKxTSoawaG3ZIVaXzoIsXn1civA=
+
+Name: org/eclipse/swt/custom/SashFormData.java
+SHA1-Digest: ueperLd8KMbUjFTAzBF7B1WJ8JE=
+
+Name: org/eclipse/swt/internal/ole/win32/IDropTargetHelper.java
+SHA1-Digest: eddm1z1QoFZBoRqx0DXy5/xDwr4=
+
+Name: org/eclipse/swt/internal/image/TIFFFileFormat.java
+SHA1-Digest: wMoojXxtvxN9or0bQBWr6Fmfzro=
+
+Name: org/eclipse/swt/internal/image/PngChunkReader.java
+SHA1-Digest: SllWT5nJRTJCFBo+H+u2C6QIsOc=
+
+Name: org/eclipse/swt/internal/win32/STARTUPINFO.java
+SHA1-Digest: k39v8iy7+vepYNGDvXFrnPYSYlY=
+
+Name: org/eclipse/swt/internal/ole/win32/IDataObject.java
+SHA1-Digest: O50KbNbBk42KunxymUa0ohbxxr0=
+
+Name: org/eclipse/swt/events/DisposeListener.java
+SHA1-Digest: HlHn+w6DXyR9MYc9MMSbiCcFy48=
+
+Name: org/eclipse/swt/internal/win32/NMLVDISPINFO.java
+SHA1-Digest: 8ax9AeA0UjazjXyX5vcNY4rrfgg=
+
+Name: org/eclipse/swt/widgets/Event.java
+SHA1-Digest: H8wq7+5DFE6YzVOJG5WsnRSMwZc=
+
+Name: org/eclipse/swt/internal/win32/PROCESS_INFORMATION.java
+SHA1-Digest: eE6k/k32pDcmvJlQ6cq6l3oEcoQ=
+
+Name: org/eclipse/swt/dnd/DragSourceEffect.java
+SHA1-Digest: JTqse/BaF1qRQ+BlWKuIrdmwCXs=
+
+Name: org/eclipse/swt/internal/gdip/ColorPalette.java
+SHA1-Digest: CAe5sK3msUhbmfYV2eHOAgbfYYI=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebProgressListener2.java
+SHA1-Digest: 1LMSiJIV64nJiRBpowob0subLOA=
+
+Name: swt_awt.rc
+SHA1-Digest: W8rZGP/dv4beHpHj6zlb6qHqZb8=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFOEXA.java
+SHA1-Digest: 6jfDSzk/br6gdwTvXUONY8WuiQM=
+
+Name: org/eclipse/swt/custom/ExtendedModifyEvent.java
+SHA1-Digest: toba+Aid8Xy7JqQSz86L7G7zBNU=
+
+Name: org/eclipse/swt/internal/win32/CHOOSEFONT.java
+SHA1-Digest: wO8Mugm2GjYiP4lq4l6xpvU8eeg=
+
+Name: org/eclipse/swt/browser/ProgressListener.java
+SHA1-Digest: eeaSiaax5zZFaRpb5b+KUY79J7M=
+
+Name: org/eclipse/swt/internal/win32/MOUSEINPUT.java
+SHA1-Digest: jmZFWqh3Cbpk4lj8+FaH6iid+RI=
+
+Name: org/eclipse/swt/internal/mozilla/nsDynamicFunctionLoad.java
+SHA1-Digest: 7RZL7Jm3xKkJG9qmjOy0ypkwwcw=
+
+Name: org/eclipse/swt/widgets/CoolBar.java
+SHA1-Digest: f0ooBV9QhGJkVli0JIEZfVWuJm0=
+
+Name: org/eclipse/swt/internal/win32/HIGHCONTRAST.java
+SHA1-Digest: ZAR8m5Vh0Gphzj+OMC7I4Wq8EVI=
+
+Name: gdip.h
+SHA1-Digest: gkKWJM2Qpw1JA3R1y5Q4q4wcUtA=
+
+Name: org/eclipse/swt/ole/win32/OleClientSite.java
+SHA1-Digest: SZda88VdkwQ9rw9n+Jbeb9x/X+s=
+
+Name: org/eclipse/swt/widgets/FontDialog.java
+SHA1-Digest: P6Zvf9h1XvVaC6xpEDJ8eQOMrk0=
+
+Name: org/eclipse/swt/graphics/Device.java
+SHA1-Digest: A5Oh/a2RB6I8ZtmzD3NkP/iwQ/I=
+
+Name: org/eclipse/swt/internal/ole/win32/COMObject.java
+SHA1-Digest: i5mXBBlVv1y0RD3V1/sHmuXdpow=
+
+Name: org/eclipse/swt/internal/win32/HELPINFO.java
+SHA1-Digest: aGssx0vajG1K/8jjyoziTGqx/Ug=
+
+Name: xpcominit_structs.cpp
+SHA1-Digest: f7+R8i8Yh+CfRbMWifIj8ksHT7o=
+
+Name: org/eclipse/swt/internal/ole/win32/FORMATETC.java
+SHA1-Digest: 9mm7MnB6DrE5LUEEzlkMC9hu8H4=
+
+Name: org/eclipse/swt/internal/win32/NONCLIENTMETRICS.java
+SHA1-Digest: dIbGECaQkKglw/GrGxrDq7iBMi0=
+
+Name: org/eclipse/swt/dnd/TextTransfer.java
+SHA1-Digest: G54QYybu3L5ZPvyWauzrWFnNrnI=
+
+Name: xpcominit.h
+SHA1-Digest: rZsVxG2umlwG539//IEoQTN09bk=
+
+Name: org/eclipse/swt/internal/win32/SIPINFO.java
+SHA1-Digest: B03GwElhm7lykuCZbWhj2Ipr0pA=
+
+Name: org/eclipse/swt/internal/win32/TCHITTESTINFO.java
+SHA1-Digest: wMb87XnRMvWG8uYkGEdu4xyfL4A=
+
+Name: org/eclipse/swt/dnd/FileTransfer.java
+SHA1-Digest: WD1PpKc9oDoadouSJKmyPmFqlIU=
+
+Name: org/eclipse/swt/internal/image/PngIhdrChunk.java
+SHA1-Digest: EZ7SBpCRmVAnMnf5+sLlvl0nzAw=
+
+Name: org/eclipse/swt/dnd/DragSourceListener.java
+SHA1-Digest: 6lJuFoSLk+G4JA8Oayi6VTGt+/M=
+
+Name: org/eclipse/swt/internal/win32/BP_PAINTPARAMS.java
+SHA1-Digest: 7jhQWTmilnmucAbNT89mETDQ+5c=
+
+Name: org/eclipse/swt/dnd/DNDEvent.java
+SHA1-Digest: j5vKJQCT5VV4Zg6YiSk1YAUNHq4=
+
+Name: org/eclipse/swt/internal/theme/ButtonDrawData.java
+SHA1-Digest: L9ex61xQ9ta9b9lNDmbQO2vB6k4=
+
+Name: org/eclipse/swt/internal/ole/win32/IPersistFile.java
+SHA1-Digest: 55G7Aq1hNEdLGaJ5CpSV5lBoULQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMEvent.java
+SHA1-Digest: F3gaUp92lX/6G65mauaFFEBFUzc=
+
+Name: org/eclipse/swt/internal/ole/win32/ITypeInfo.java
+SHA1-Digest: 13RIgE9LYJ1lIOMyf/ovHPA5Ly0=
+
+Name: org/eclipse/swt/internal/win32/CANDIDATEFORM.java
+SHA1-Digest: OR4OlCtZ1elaPhAsj5rkilYsUUk=
+
+Name: org/eclipse/swt/browser/AuthenticationListener.java
+SHA1-Digest: dVMTX/kltzm5RzL61nLYYX60vY0=
+
+Name: org/eclipse/swt/internal/mozilla/nsIClassInfo.java
+SHA1-Digest: ZTGrDf8DPewIJVAnGXfz94cRI3w=
+
+Name: org/eclipse/swt/layout/FillData.java
+SHA1-Digest: 9YiGVMcOc64w2VnPWhdzQm35XaY=
+
+Name: org/eclipse/swt/internal/win32/DIBSECTION.java
+SHA1-Digest: qURocliAtYd4VQnEZA6nqiVIRdY=
+
+Name: gdip_stats.cpp
+SHA1-Digest: hmGKK6WmuK08dCg0rQAvKPUhZAs=
+
+Name: xpcom_custom.cpp
+SHA1-Digest: w3tGtVGafcTq5TvaYIZiWSl84sI=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMSerializer.java
+SHA1-Digest: 4w9YqJsunALao50t6qMqhO5p5Hs=
+
+Name: org/eclipse/swt/graphics/GC.java
+SHA1-Digest: QSlt34St8qV0INoOChJurhm8K+k=
+
+Name: xpcom_stats.h
+SHA1-Digest: QEmEa2UMRDkWKG0mZW4KuecsHAY=
+
+Name: org/eclipse/swt/internal/SWTMessages.properties
+SHA1-Digest: MCkv5LNV6OOANnwczOr+nWG8SgQ=
+
+Name: org/eclipse/swt/opengl/GLCanvas.java
+SHA1-Digest: BAiQw2wW49xeFw+/Buvd8FL0CHc=
+
+Name: org/eclipse/swt/internal/image/FileFormat.java
+SHA1-Digest: q7vsdJNPNoJfx2E1ADPWk78gPIY=
+
+Name: org/eclipse/swt/layout/FormLayout.java
+SHA1-Digest: MtnZnx4q2XdwspQbTV7ZxpDfC5g=
+
+Name: org/eclipse/swt/custom/PopupList.java
+SHA1-Digest: HTY72vGjVickbazwNkz/5Uo+xf4=
+
+Name: org/eclipse/swt/internal/image/JPEGRestartInterval.java
+SHA1-Digest: bFmCwLja646QaYyvsfUC82ESdFI=
+
+Name: org/eclipse/swt/custom/StyleRange.java
+SHA1-Digest: JJUpuZ4BPKi9A/JNCr7I4/Nydqk=
+
+Name: org/eclipse/swt/internal/win32/NMRGINFO.java
+SHA1-Digest: Ea8IUKTfiBLOQxquLKzAZVrp86Y=
+
+Name: org/eclipse/swt/internal/mozilla/nsIAppShell.java
+SHA1-Digest: pMNgJPoXdYOIeYElNdadiEa7tpc=
+
+Name: org/eclipse/swt/dnd/URLTransfer.java
+SHA1-Digest: mZU4OA53UTPBUd0ezakD0ypM/FE=
+
+Name: org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java
+SHA1-Digest: 92zZj3LUGoL23Mc8kJYUCKEpSDw=
+
+Name: org/eclipse/swt/accessibility/AccessibleControlEvent.java
+SHA1-Digest: +bpZKd25qkLJ/xW7wSO7y7gqP/0=
+
+Name: org/eclipse/swt/browser/PromptDialog.java
+SHA1-Digest: qDWWLGaWVFVRe6AyqjUUG9jU9Ck=
+
+Name: org/eclipse/swt/internal/mozilla/nsISerializable.java
+SHA1-Digest: TRKJ+z3/+ULFHKheum0FCaAjQgc=
+
+Name: org/eclipse/swt/custom/CBanner.java
+SHA1-Digest: YiH83rxg2UkvdM75A8qkRzA+cdc=
+
+Name: org/eclipse/swt/events/ControlEvent.java
+SHA1-Digest: nmq79JZ70UOhK8rLOQDCwpH5NGI=
+
+Name: org/eclipse/swt/custom/TableTree.java
+SHA1-Digest: EdhQBAXwWPhfgmY9J8RWy7Fzuic=
+
+Name: org/eclipse/swt/internal/win32/NMHEADER.java
+SHA1-Digest: 5oQvQXNQcLWVJpjuY6N52M4ggHw=
+
+Name: org/eclipse/swt/opengl/GLData.java
+SHA1-Digest: gG93AqNWYmSL+tVz8dpvfw8yp7M=
+
+Name: org/eclipse/swt/internal/gdip/RectF.java
+SHA1-Digest: at6jB0/1LY0fi0pepa7wz7DRO0g=
+
+Name: version.txt
+SHA1-Digest: RYRqiBQUQfEMjhyj+pY1QAGh82I=
+
+Name: org/eclipse/swt/dnd/Clipboard.java
+SHA1-Digest: Qc/gM1poz/bSWNQpmlnGg1HMZ48=
+
+Name: org/eclipse/swt/custom/CaretListener.java
+SHA1-Digest: HZZxgiaiziUirc3yXqcyFCyUi4Q=
+
+Name: org/eclipse/swt/custom/LineStyleEvent.java
+SHA1-Digest: cRg/uM25dhOZ5N7UjtmJIvIpi4k=
+
+Name: org/eclipse/swt/widgets/Monitor.java
+SHA1-Digest: 2QGPIdtkSplZWOQhPLkn4zi7mKg=
+
+Name: org/eclipse/swt/custom/ControlEditor.java
+SHA1-Digest: 45UYO6SmMpQiIjiMU3fppTqYTko=
+
+Name: com_structs.c
+SHA1-Digest: JDRa+t2WO3FqcoiNt/FnbFirDoI=
+
+Name: org/eclipse/swt/internal/win32/RECT.java
+SHA1-Digest: 8lchjoQua69VQtbiLPdd+o5av+U=
+
+Name: com_structs.h
+SHA1-Digest: N3FJ37SvVlRH4KcL48g+K7Zqyrg=
+
+Name: org/eclipse/swt/widgets/FileDialog.java
+SHA1-Digest: pps9iyU2vr4dsxlAdVrh/9nhCDQ=
+
+Name: org/eclipse/swt/browser/VisibilityWindowAdapter.java
+SHA1-Digest: VmLETeHrs+o2gpQbOQQvWH8Eqs4=
+
+Name: org/eclipse/swt/internal/win32/ACCEL.java
+SHA1-Digest: 3BU+eCcRxdUsed8Dbht8pLSj+C4=
+
+Name: org/eclipse/swt/internal/win32/LVCOLUMN.java
+SHA1-Digest: 5+xI0oT8xzx9tKi5I08SWzcfVWc=
+
+Name: org/eclipse/swt/widgets/Synchronizer.java
+SHA1-Digest: GUIr/Cj4/aYyexlJcFen5SDi2Oc=
+
+Name: org/eclipse/swt/dnd/Transfer.java
+SHA1-Digest: RhlwNq0ODoFl0p5ZBF9CTwJn9tU=
+
+Name: org/eclipse/swt/custom/CTabItem.java
+SHA1-Digest: OS3lmKPUg3t/pilR/ELcEI0iZwk=
+
+Name: org/eclipse/swt/internal/ole/win32/CONTROLINFO.java
+SHA1-Digest: iD8M+RJLhcFfBxk22LmIZumdXWE=
+
+Name: org/eclipse/swt/widgets/List.java
+SHA1-Digest: vR9L6t0oO7EsQ0kLoygeIJ7ynOI=
+
+Name: org/eclipse/swt/events/DragDetectListener.java
+SHA1-Digest: 53ZeDMxcdGOQyEjnci72o14P2D4=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFO.java
+SHA1-Digest: 9jUPsIVLDskli0jnZSE/5gLTXwE=
+
+Name: org/eclipse/swt/events/ArmListener.java
+SHA1-Digest: 7FkqZEs5QZ5iPHRLjHskjerk1LU=
+
+Name: org/eclipse/swt/events/ArmEvent.java
+SHA1-Digest: NEPDCV3A4qdEx5uXFW9CDSHESog=
+
+Name: org/eclipse/swt/browser/Download.java
+SHA1-Digest: jbxO5RnStEWFo6zemzZJemgfBe4=
+
+Name: org/eclipse/swt/SWT.java
+SHA1-Digest: B+o+t0K+G0U01oZXD+/Dfc0elF4=
+
+Name: build.bat
+SHA1-Digest: l9MjlibMg2wbG72OtGPVgg73iVg=
+
+Name: org/eclipse/swt/ole/win32/OLE.java
+SHA1-Digest: Dvgryp9dF6rqT9YrLnxDRRVgSVc=
+
+Name: org/eclipse/swt/dnd/DND.java
+SHA1-Digest: 5Sa9IC8jMUVJtD8HVGWtHFO40Rg=
+
+Name: org/eclipse/swt/widgets/Decorations.java
+SHA1-Digest: wInejhQ8jYyGDTc3avxVl6R3UfQ=
+
+Name: org/eclipse/swt/internal/opengl/win32/LAYERPLANEDESCRIPTOR.java
+SHA1-Digest: kEiuOx6ZB6i+5FnOPd5oB/D+YZg=
+
+Name: org/eclipse/swt/widgets/DateTime.java
+SHA1-Digest: mloDmjJMH9TJjmarcEZw5Ri3Tmw=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowserChromeFocus.java
+SHA1-Digest: EtWs0z+lAq21l46P2Xagp/CbKuY=
+
+Name: org/eclipse/swt/internal/image/JPEGComment.java
+SHA1-Digest: uf/uMRM5NMWUjLdrHx0gAW8P9ps=
+
+Name: xpcominit_stats.h
+SHA1-Digest: XTeo/nU2+rDwtsVQpk8RnjCaBLs=
+
+Name: org/eclipse/swt/events/VerifyEvent.java
+SHA1-Digest: hpm320MeOOFTLvX4Zp83fe4rTTk=
+
+Name: org/eclipse/swt/accessibility/AccessibleListener.java
+SHA1-Digest: dfMFpbqxgXwe6c5069FeYZQHiVY=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_CONTROL.java
+SHA1-Digest: GwReEvXAqOy/fBYdhRUZS6zFmFY=
+
+Name: org/eclipse/swt/internal/LONG.java
+SHA1-Digest: PfGW/oZov8YKV0q71725oRTfGhk=
+
+Name: org/eclipse/swt/internal/ole/win32/ISpecifyPropertyPages.java
+SHA1-Digest: WiE8C0VTDDUOhRFVqBInJAvf3Ss=
+
+Name: org/eclipse/swt/internal/win32/TRIVERTEX.java
+SHA1-Digest: InF3kFC0NPjy6Lf7oAi9FEUaVSg=
+
+Name: org/eclipse/swt/custom/CCombo.java
+SHA1-Digest: ricktNCU3+B4QCuh2TZKt5L+mL4=
+
+Name: org/eclipse/swt/internal/win32/SHFILEINFO.java
+SHA1-Digest: i9T9biFf3xxqjQoUVPLAL04s0Ao=
+
+Name: org/eclipse/swt/events/MouseAdapter.java
+SHA1-Digest: 8bp2JNzcnGusag2u1f9skAMHl7I=
+
+Name: build-ce.bat
+SHA1-Digest: vfRYaNtF4JPYCdqFVRmAtAZfc9c=
+
+Name: org/eclipse/swt/dnd/DropTargetAdapter.java
+SHA1-Digest: maER557EcmrQ/oWYf2Qr8y70vzA=
+
+Name: org/eclipse/swt/custom/DefaultContent.java
+SHA1-Digest: 6zWE0QM6QXbZsegcAeqLcGw8ZXI=
+
+Name: org/eclipse/swt/internal/win32/TBBUTTONINFO.java
+SHA1-Digest: XyBrVdPc8PtbzTMygBZJ+T7pph4=
+
+Name: org/eclipse/swt/internal/image/WinICOFileFormat.java
+SHA1-Digest: KDsN3hAducOEhomBugE87ySdq4I=
+
+Name: org/eclipse/swt/graphics/LineAttributes.java
+SHA1-Digest: 7ErJ081MXW/PFSmLMZkEyFqwpUI=
+
+Name: org/eclipse/swt/widgets/ColorDialog.java
+SHA1-Digest: giVBXECCa0tyDr/fx/ShLTRLrH0=
+
+Name: org/eclipse/swt/internal/opengl/win32/PIXELFORMATDESCRIPTOR.java
+SHA1-Digest: Dv4rsXkjt+TUmPHK6lsgW2soswg=
+
+Name: org/eclipse/swt/printing/Printer.java
+SHA1-Digest: hQwYOAo6RSwh8a1Kjnavo0zovUU=
+
+Name: org/eclipse/swt/internal/ole/win32/IMoniker.java
+SHA1-Digest: e5TgohtsiLNI60D4Z5904Pwp0a4=
+
+Name: org/eclipse/swt/graphics/ImageDataLoader.java
+SHA1-Digest: g1Ok3PH0mo1LURoAHQhJsgP7xT8=
+
+Name: org/eclipse/swt/accessibility/AccessibleAdapter.java
+SHA1-Digest: 8K79PcSc/ShGnqkvKPixxkbMX6E=
+
+Name: org/eclipse/swt/internal/theme/Theme.java
+SHA1-Digest: orXn6gaFA27r5oh5MNqV77gOY1s=
+
+Name: org/eclipse/swt/graphics/Font.java
+SHA1-Digest: 4Ci/UINYnsH7xw8Z26U0P3sj2P8=
+
+Name: org/eclipse/swt/graphics/Point.java
+SHA1-Digest: TxpVbY6eKWGJef/zSOfi0Ddtv6g=
+
+Name: org/eclipse/swt/internal/image/TIFFModifiedHuffmanCodec.java
+SHA1-Digest: giA2cpCyNmh5D5/euc+K/rXzyA4=
+
+Name: org/eclipse/swt/internal/win32/DWM_BLURBEHIND.java
+SHA1-Digest: Uxr7BY6LqReTQPpckZyaIj9jdJI=
+
+Name: org/eclipse/swt/internal/win32/SHMENUBARINFO.java
+SHA1-Digest: KV5uEsYfvZ5DFaIZuk27p3wvu7E=
+
+Name: org/eclipse/swt/internal/win32/LVHITTESTINFO.java
+SHA1-Digest: IoGn++LjVvGTK+AKU1oakhBculM=
+
+Name: org/eclipse/swt/internal/Platform.java
+SHA1-Digest: ulgiVJmdZR1czFSIqfUt/tKurQk=
+
+Name: org/eclipse/swt/custom/TableTreeItem.java
+SHA1-Digest: SXeeOJRRebyD+i/ZEVofiSZ7SXg=
+
+Name: org/eclipse/swt/internal/win32/DEVMODEW.java
+SHA1-Digest: z9AZjS/hfp3ZuctU4VDUfMWN+Uo=
+
+Name: org/eclipse/swt/internal/SerializableCompatibility.java
+SHA1-Digest: ehkJ12/7eiG9wvvzGFe6oOEhKj0=
+
+Name: org/eclipse/swt/custom/Bullet.java
+SHA1-Digest: UvMGLbEbwUolgj+rl7W8g2q+ym8=
+
+Name: org/eclipse/swt/browser/Download_1_8.java
+SHA1-Digest: bDA7FOFSQcErkdhOn1cqjsSRnD0=
+
+Name: org/eclipse/swt/accessibility/AccessibleTextListener.java
+SHA1-Digest: abOb0W7lsvPQDyVKIbeIH97P9vE=
+
+Name: org/eclipse/swt/custom/BusyIndicator.java
+SHA1-Digest: qnR7eTAHrCiTMnYAYGHkz5qgXs0=
+
+Name: org/eclipse/swt/internal/win32/MCHITTESTINFO.java
+SHA1-Digest: CqdPXtqFkM0WN2gOodG0s0wvnzE=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDocShell_1_8.java
+SHA1-Digest: WMoj4cordTU6DSkSzbpytAJ9oPk=
+
+Name: org/eclipse/swt/events/FocusEvent.java
+SHA1-Digest: S+iIj7y3uyDsZdPRd0ECVZTmpNM=
+
+Name: org/eclipse/swt/internal/win32/BITMAP.java
+SHA1-Digest: eKKxXZgS67kpqsOh+fXuqq25NqA=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleCommandTarget.java
+SHA1-Digest: wMMsYd2c05eM7F7e0YTXsaZQ5ko=
+
+Name: org/eclipse/swt/internal/win32/SCROLLBARINFO.java
+SHA1-Digest: 0wh0TBa3cFBIv99M2pCrv3sAIBQ=
+
+Name: xpcominit_structs.h
+SHA1-Digest: hc4AJEsxqBI5zfUlAeeMuFcuwMw=
+
+Name: os_custom.c
+SHA1-Digest: L4ap8KkU9NoCxbtEDxdutk3obDI=
+
+Name: xpcom_custom.h
+SHA1-Digest: yaK6D7APVqzI2rNysitMjaCncoA=
+
+Name: org/eclipse/swt/custom/ST.java
+SHA1-Digest: bv3h/fJu+evdgI0PEOM86NeO8FA=
+
+Name: org/eclipse/swt/browser/StatusTextListener.java
+SHA1-Digest: wvxNSI3qzFKdH7N5OAbZ8Kf0g4U=
+
+Name: org/eclipse/swt/internal/win32/LOGBRUSH.java
+SHA1-Digest: h92Y7e+tcFTa4MdMH/Pn/XMEvmo=
+
+Name: os_custom.h
+SHA1-Digest: Gvn3Q3SWAr1CV1p2vdayoxVd0qM=
+
+Name: org/eclipse/swt/internal/mozilla/XPCOMObject.java
+SHA1-Digest: 2/PwDRC7kQLJUYoNMxyA54Vbhnw=
+
+Name: org/eclipse/swt/browser/HelperAppLauncherDialogFactory.java
+SHA1-Digest: A+EanO6xK4wa5wO+uILrGxxgKEA=
+
+Name: nsIScriptGlobalObject.h
+SHA1-Digest: VZ5/4AyULMd+5khNdf3/rI8E4fk=
+
+Name: org/eclipse/swt/internal/image/TIFFDirectory.java
+SHA1-Digest: jmJKg1igiMJOwowI5FtFTYDKOaA=
+
+Name: wgl_stats.c
+SHA1-Digest: FXaB/qHJhTVwn3DDLKmiev1rzFQ=
+
+Name: org/eclipse/swt/internal/win32/FILETIME.java
+SHA1-Digest: 5xeljSNn5VP4QDytZSq6l//81uM=
+
+Name: org/eclipse/swt/widgets/Combo.java
+SHA1-Digest: 34a/SmZ9hv6wEQAWsQjx73XcPmU=
+
+Name: org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java
+SHA1-Digest: ZDD/zvtnPtGTRJmvf5VGMlwLNcw=
+
+Name: wgl_stats.h
+SHA1-Digest: /GXLM1F0vsbk+UsWi3tN9i64WZ0=
+
+Name: org/eclipse/swt/internal/win32/CHOOSECOLOR.java
+SHA1-Digest: cXNgMcVSQieZ0IvmaqDEU8zim2A=
+
+Name: org/eclipse/swt/internal/win32/DOCINFO.java
+SHA1-Digest: MdefA2iTEqvqrYFiJh+r1M26xZU=
+
+Name: org/eclipse/swt/internal/ole/win32/FUNCDESC.java
+SHA1-Digest: o4ZOupBik2tGD+276+fctHEAGeo=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWeakReference.java
+SHA1-Digest: WpK9866ICQvE0OrVs77fFr+29po=
+
+Name: javaw.exe.manifest
+SHA1-Digest: 9q081xUuS2SR6gV21a611ZhuSHk=
+
+Name: org/eclipse/swt/ole/win32/OleControlSite.java
+SHA1-Digest: qb/BVAJfdaJzbaqfuoGMgSV4v5Q=
+
+Name: org/eclipse/swt/browser/ExternalFactory.java
+SHA1-Digest: 9YgARWEwi2VNxCtYXItyrH8S1+w=
+
+Name: org/eclipse/swt/widgets/Tracker.java
+SHA1-Digest: 5saA8EGkisKcaClMiiwZyrGmYfc=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowserFocus.java
+SHA1-Digest: hMJN2s/jxV4bzRB6uFlP6rKdkSs=
+
+Name: org/eclipse/swt/internal/image/JPEGFixedSizeSegment.java
+SHA1-Digest: m90V9JGhzfLcAUQKQOJePzUOcWY=
+
+Name: org/eclipse/swt/layout/FormAttachment.java
+SHA1-Digest: DzztBStuvy/a/bWfnvdwtU3C0P4=
+
+Name: org/eclipse/swt/internal/image/LEDataInputStream.java
+SHA1-Digest: P/kF1Nq8w7GMQwAygD+bc5uZfv4=
+
+Name: org/eclipse/swt/events/KeyListener.java
+SHA1-Digest: Md6pkz/XV9fHJTbl+nH6MnJjQxw=
+
+Name: org/eclipse/swt/custom/CTabFolderEvent.java
+SHA1-Digest: TRa8zzjwOePj77NbvC23fveg1b0=
+
+Name: org/eclipse/swt/internal/win32/TVITEM.java
+SHA1-Digest: KmuETlzSWyv+i1hfUGs1AkIgPAc=
+
+Name: org/eclipse/swt/internal/gdip/GdiplusStartupInput.java
+SHA1-Digest: 8oGUZJyhtCstturLrHBjQ+sPJJs=
+
+Name: org/eclipse/swt/dnd/RTFTransfer.java
+SHA1-Digest: jntzR9ujcizPkBYLNCSZwJdQi6Y=
+
+Name: org/eclipse/swt/events/TraverseEvent.java
+SHA1-Digest: Jb9XOHE7LKJDj7reniHcjn+jtD8=
+
+Name: about.html
+SHA1-Digest: boQMbVqv/u1wfb1yEQbALSmYnos=
+
+Name: org/eclipse/swt/widgets/ToolItem.java
+SHA1-Digest: zseoreRwELTls5U24nkhxYq/od4=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_ANALYSIS.java
+SHA1-Digest: LEqNeA+Ie25mMNt3sp9Ka/gXRYw=
+
+Name: org/eclipse/swt/internal/theme/DrawData.java
+SHA1-Digest: 0kS6Nsh8YBvf78sm+E6aM1nwjRA=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_PROPERTIES.java
+SHA1-Digest: bjyOzigEfRTciWZeEf6KH5ik48c=
+
+Name: org/eclipse/swt/graphics/TextStyle.java
+SHA1-Digest: PnnGPQCOauqqw0uEPaWxAF3mHKk=
+
+Name: org/eclipse/swt/internal/win32/DOCHOSTUIINFO.java
+SHA1-Digest: HqqwgvR5tEThCExV8rRrNy2QC7k=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPrefService.java
+SHA1-Digest: I6kpWhvXdvlcEcwPoDn4uc7cc3s=
+
+Name: org/eclipse/swt/widgets/ExpandBar.java
+SHA1-Digest: 84qJCP3zUlSdQAiY1dJV9DBv1TQ=
+
+Name: org/eclipse/swt/internal/win32/SHFILEINFOW.java
+SHA1-Digest: WOLn+WfhGXOK0e6XB1Js+YWwSF0=
+
+Name: org/eclipse/swt/graphics/Resource.java
+SHA1-Digest: vY7xThPE42vyxpWGJYIb4+0y9HI=
+
+Name: org/eclipse/swt/custom/TextChangedEvent.java
+SHA1-Digest: gu9ljHU0hcMSk5Ce+PxnWk+KupQ=
+
+Name: org/eclipse/swt/events/ExpandEvent.java
+SHA1-Digest: Hahbiv/OD+BZ1ImMjkIZOX0+aM4=
+
+Name: org/eclipse/swt/internal/win32/ICONINFO.java
+SHA1-Digest: fQxugTDamAm2fCWqQ4/Wub+abs0=
+
+Name: org/eclipse/swt/widgets/TrayItem.java
+SHA1-Digest: BIiuVwibSG0pmJYvGm5CQ+Gn/3s=
+
+Name: org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java
+SHA1-Digest: iX0GyIGllaBHm76Vab3fiVHBPyA=
+
+Name: org/eclipse/swt/graphics/GCData.java
+SHA1-Digest: NL/vkh/swH5lfxnt2LNjBjqUS0g=
+
+Name: org/eclipse/swt/internal/ole/win32/IEnumVARIANT.java
+SHA1-Digest: D/gLgBbYVOZ61AHRbVhNTsaF6Eo=
+
+Name: org/eclipse/swt/internal/win32/MEASUREITEMSTRUCT.java
+SHA1-Digest: fSq/SqPBnaF78PIoi4RxBl1VUyE=
+
+Name: org/eclipse/swt/internal/image/PngDecodingDataStream.java
+SHA1-Digest: XtpPy3ExYub4NRYGAA9qSiKrlHI=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleWindow.java
+SHA1-Digest: 5U6zWuCAsvpCSqvwCdFJPZ3ZNt8=
+
+Name: org/eclipse/swt/internal/win32/ACTCTX.java
+SHA1-Digest: cNM5lwIfkQNTAnd4pTAJ0XE5l6Q=
+
+Name: org/eclipse/swt/dnd/TableDragSourceEffect.java
+SHA1-Digest: sdGoE3CwJqaqGdP8QuaxNo4CJN0=
+
+Name: org/eclipse/swt/internal/win32/NMTVDISPINFO.java
+SHA1-Digest: fcEKHu8InM4vbW7OOVR3kpfx+/U=
+
+Name: org/eclipse/swt/internal/gdip/BitmapData.java
+SHA1-Digest: ZjG3zPpiFKUVRJHypVY15vTCbmw=
+
+Name: org/eclipse/swt/internal/ole/win32/IViewObject2.java
+SHA1-Digest: lXEbJjM5f+VC+3XoU3Cxv/FwNSE=
+
+Name: org/eclipse/swt/events/DragDetectEvent.java
+SHA1-Digest: PbtHIwow3F0Sxnju8l9RpFe6pOA=
+
+Name: org/eclipse/swt/internal/ole/win32/IPersistStreamInit.java
+SHA1-Digest: xMElD7uRfo3crBLw7SmQrLKlKaA=
+
+Name: org/eclipse/swt/events/ExpandListener.java
+SHA1-Digest: 31upaO7fGgB95esx+5YbaNiImJI=
+
+Name: xpcom.cpp
+SHA1-Digest: fPT+jiwYk00GuEx9G4F27zcx2Ao=
+
+Name: org/eclipse/swt/internal/mozilla/nsIFilePicker.java
+SHA1-Digest: uShWICRXjp3de9QStLfkwUTr8OI=
+
+Name: org/eclipse/swt/custom/StackLayout.java
+SHA1-Digest: yWZHS2PYoqdSTMRHAM/wLgEEoRA=
+
+Name: org/eclipse/swt/events/ShellAdapter.java
+SHA1-Digest: U0f1hEbCb7yZGdIu89o7n/sDZdk=
+
+Name: about_files/IJG_README
+SHA1-Digest: zYrTwlj+wl1kYzRSa3fOxOkPAfs=
+
+Name: org/eclipse/swt/internal/mozilla/nsIInterfaceRequestor.java
+SHA1-Digest: czhw3ZzfH7N1JmsgAKAbd2YTNt4=
+
+Name: org/eclipse/swt/widgets/Shell.java
+SHA1-Digest: pV+VCbaPZTwRY7ridfE+ml105wk=
+
+Name: org/eclipse/swt/internal/win32/TF_DA_COLOR.java
+SHA1-Digest: azWpZ+SOWon2yJrJGxviCqvz3yY=
+
+Name: org/eclipse/swt/internal/image/LZWNode.java
+SHA1-Digest: GOXwaEc3r5bCN3+s+oZALRl5Knw=
+
+Name: org/eclipse/swt/internal/theme/ComboDrawData.java
+SHA1-Digest: u2bvKhNIzTZjGGtshl9K09rzqBo=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_LOGATTR.java
+SHA1-Digest: a3fGeeJJDNmOv+vZHolRg+IjIho=
+
+Name: org/eclipse/swt/internal/win32/NMTTDISPINFOW.java
+SHA1-Digest: K+gHLdWTZ5kETeH5h/WcBv1aFlE=
+
+Name: org/eclipse/swt/internal/ole/win32/IClassFactory2.java
+SHA1-Digest: KhWacu5w4aBsBLRqD/GTbSHefBQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsISupportsWeakReference.java
+SHA1-Digest: jNR8APFOKvJIzIq428udsDFpjt4=
+
+Name: org/eclipse/swt/internal/image/JPEGDecoder.java
+SHA1-Digest: 0P/zkojGU7obfY0IlEUd/lrqmW8=
+
+Name: org/eclipse/swt/browser/FilePickerFactory.java
+SHA1-Digest: RMWgn8TZaNL3KcXUKuIFcP5iO60=
+
+Name: org/eclipse/swt/dnd/DropTarget.java
+SHA1-Digest: l7gOEDCMrIzSN5wwUmQqeNWDyU8=
+
+Name: org/eclipse/swt/graphics/Region.java
+SHA1-Digest: 07oKr94C3da9Ah42g17FrZbyZxM=
+
+Name: org/eclipse/swt/layout/FormData.java
+SHA1-Digest: w1JliU+nlTaSALEyfqv++9Pbm5A=
+
+Name: org/eclipse/swt/internal/win32/TVHITTESTINFO.java
+SHA1-Digest: Mb/bzystOmdBDTxQ+/B3GdsBYHo=
+
+Name: org/eclipse/swt/widgets/Layout.java
+SHA1-Digest: h07vKCh+EjqZiUv+2yvSM4EJf4c=
+
+Name: org/eclipse/swt/internal/win32/OFNOTIFY.java
+SHA1-Digest: mWhtsyP8srJw9NthgHHHRweHz58=
+
+Name: org/eclipse/swt/internal/win32/MARGINS.java
+SHA1-Digest: pwTpuXJgOHRy+InQ17cnj/ct3lk=
+
+Name: org/eclipse/swt/browser/AppFileLocProvider.java
+SHA1-Digest: /0xKbjuNX+IDnXBJl6ixVvVyDI4=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPromptService.java
+SHA1-Digest: be1jkEXZ8fVpdr5O9ICQZn1Lldg=
+
+Name: org/eclipse/swt/internal/win32/PRINTDLG.java
+SHA1-Digest: Zx3ZOAnEXiSBQJoYtCDYycAt82c=
+
+Name: org/eclipse/swt/graphics/FontMetrics.java
+SHA1-Digest: cF2ISeYZLxCsBCwjDKh9hFakLIg=
+
+Name: org/eclipse/swt/layout/FillLayout.java
+SHA1-Digest: KVDYtKFJWE+1fKwVBmVI+y4Rph4=
+
+Name: org/eclipse/swt/dnd/ImageTransfer.java
+SHA1-Digest: nnQFN7DXywBQlphSObrI3XdTwfQ=
+
+Name: defines.h
+SHA1-Digest: geSrZHvqvMr9GeilYq55LvdXFjs=
+
+Name: com_stats.c
+SHA1-Digest: pG/pGGG2BYKr0QqQuEpl2B99mG4=
+
+Name: org/eclipse/swt/internal/win32/PANOSE.java
+SHA1-Digest: he5Q8kkzgGUo6pIaSGbeSWUANJo=
+
+Name: org/eclipse/swt/events/MenuListener.java
+SHA1-Digest: kEwxhFctvQ5l0SY8K/cdqKc8TG8=
+
+Name: org/eclipse/swt/internal/win32/NMTREEVIEW.java
+SHA1-Digest: 2w5zHl9YykZbu9y7EnAFbhqBEGw=
+
+Name: org/eclipse/swt/widgets/MessageBox.java
+SHA1-Digest: IOeeb8qckMNWZUrK5GomSkXs3xE=
+
+Name: com_stats.h
+SHA1-Digest: vLJeUDL2omCgFzHVnebs4cKLOSg=
+
+Name: org/eclipse/swt/ole/win32/OlePropertyChangeSink.java
+SHA1-Digest: Zi8UMXr8YF0aL8rK5TSuFniruj8=
+
+Name: org/eclipse/swt/graphics/ImageLoaderListener.java
+SHA1-Digest: 1OhJF2YJWnJ+OYRe5QlFFw98RRg=
+
+Name: org/eclipse/swt/events/MouseWheelListener.java
+SHA1-Digest: 2qUMxTJRewpjUPtTcUX/2RNeHl0=
+
+Name: org/eclipse/swt/browser/LocationEvent.java
+SHA1-Digest: Mf32BygCrpRFNgiFF+4bj5g8vOk=
+
+Name: org/eclipse/swt/internal/image/JPEGAppn.java
+SHA1-Digest: 4UQs9L9U5wymkIgvIxFU+p2f2Io=
+
+Name: org/eclipse/swt/internal/win32/NMLVFINDITEM.java
+SHA1-Digest: CtMcd5fkIo9ET4CRasrI+W9H36Y=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPromptService2.java
+SHA1-Digest: jsJ5E1RYqruGwwpjMGydujeCHHk=
+
+Name: org/eclipse/swt/internal/ole/win32/TYPEATTR.java
+SHA1-Digest: l2Q5VsGnnM2NCUkelb8d7bdDetk=
+
+Name: org/eclipse/swt/events/MouseTrackListener.java
+SHA1-Digest: zAA0yPxZmIq0um5NFA0rkpPSAB4=
+
+Name: org/eclipse/swt/dnd/HTMLTransfer.java
+SHA1-Digest: g/plpsA/W3bgzhrXQXFbGWLGIfU=
+
+Name: org/eclipse/swt/accessibility/AccessibleTextAdapter.java
+SHA1-Digest: RQB6GIxoudktcIr5lSSBs5jnHyk=
+
+Name: org/eclipse/swt/internal/win32/NOTIFYICONDATAW.java
+SHA1-Digest: JjRy8DbEdMuV36gdVHRvgGylBQQ=
+
+Name: org/eclipse/swt/events/TreeListener.java
+SHA1-Digest: inA0boKyg8WTD4AAecrXd0Q+wy8=
+
+Name: org/eclipse/swt/events/VerifyListener.java
+SHA1-Digest: QRbYwVNVWoKy0seWV1BOLoSikJQ=
+
+Name: org/eclipse/swt/internal/win32/NMLINK.java
+SHA1-Digest: ds7jKOA3U6ouJ5bk88PXYHaEywg=
+
+Name: org/eclipse/swt/internal/win32/LITEM.java
+SHA1-Digest: +VWpyW2OLeqLvxuFVIGn2HOjpiI=
+
+Name: org/eclipse/swt/widgets/Control.java
+SHA1-Digest: zRXkQCmZOycGlmGeUyGequrXt1Y=
+
+Name: org/eclipse/swt/graphics/GlyphMetrics.java
+SHA1-Digest: MuQHYzCCBiQ+cbRJKkrVtEdU/zs=
+
+Name: xpcominit.cpp
+SHA1-Digest: hfgtl/bodJbP7GvqYsjFz8EHJ9U=
+
+Name: swt_wgl.rc
+SHA1-Digest: hx9xn9p1eOGOEzwORL+jq3bRCg4=
+
+Name: org/eclipse/swt/internal/mozilla/nsICancelable.java
+SHA1-Digest: J3Dg6zFRt3jn5VNpg8o8YqnZxpM=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDownload_1_8.java
+SHA1-Digest: IDaH6fA5pKWTvq0MegcF/jBROs0=
+
+Name: org/eclipse/swt/internal/mozilla/nsITransfer.java
+SHA1-Digest: AuzBhPPUYogxBwMiincs0/eGvIk=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFOW.java
+SHA1-Digest: E0CEJ6erD2NjWLUEKeZRukACJkA=
+
+Name: org/eclipse/swt/internal/mozilla/nsIVariant.java
+SHA1-Digest: e1PMn+6pavifgrWIjhMQHxPecP0=
+
+Name: org/eclipse/swt/internal/image/OS2BMPFileFormat.java
+SHA1-Digest: JhiGdb5aEO8649knKvZV1AMN0T8=
+
+Name: org/eclipse/swt/graphics/ImageLoader.java
+SHA1-Digest: F9hhOc+Tq2n3321AnGG/VOz93lg=
+
+Name: org/eclipse/swt/events/MenuDetectListener.java
+SHA1-Digest: Jjay/NTMruC9OXzoIKVa7zRNVTk=
+
+Name: org/eclipse/swt/internal/win32/HDLAYOUT.java
+SHA1-Digest: Xnyk+tU+8Ny81Ex3b4Xm5Jwiuss=
+
+Name: org/eclipse/swt/events/KeyAdapter.java
+SHA1-Digest: f6cAgdYjNxW1tGKOTnsc4gMxMs8=
+
+Name: org/eclipse/swt/events/ExpandAdapter.java
+SHA1-Digest: K6yQyBgqjB7dH2VMQGCj3ztnV48=
+
+Name: org/eclipse/swt/widgets/TabFolder.java
+SHA1-Digest: L/UFOkY3VfuqlnivViE6RLQLpws=
+
+Name: org/eclipse/swt/events/TreeAdapter.java
+SHA1-Digest: RXvjXH8zYddAOioAUsIUmUVGxYc=
+
+Name: org/eclipse/swt/internal/win32/MSG.java
+SHA1-Digest: NXNPdcF4rSGLTGRNubZCApgv3Cs=
+
+Name: org/eclipse/swt/browser/DownloadFactory.java
+SHA1-Digest: /SXhBowLm5ag8OLjlHl6hrGdLXA=
+
+Name: org/eclipse/swt/internal/C.java
+SHA1-Digest: HCi26nZuEWlO51dnLTvY/gO34Z8=
+
+Name: org/eclipse/swt/internal/win32/GRADIENT_RECT.java
+SHA1-Digest: l8RdDMuj+GidsYGZ5S0Kdc3OsVw=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDocShell.java
+SHA1-Digest: kAz+OQi8ZWCDorobEuQteGVY/pU=
+
+Name: org/eclipse/swt/widgets/Dialog.java
+SHA1-Digest: N9jseIeobmKuGZYHOxzm1IiYvjA=
+
+Name: org/eclipse/swt/events/TreeEvent.java
+SHA1-Digest: wzGApLZ1tTlKvPWvQqVleIIOJB4=
+
+Name: org/eclipse/swt/internal/image/PngHuffmanTable.java
+SHA1-Digest: jIamI9WU1yGEwiS0MPJ6T5c0F8k=
+
+Name: org/eclipse/swt/dnd/TreeDropTargetEffect.java
+SHA1-Digest: T03yqmQNF2XUfsgr5RaumOvbE64=
+
+Name: org/eclipse/swt/internal/ole/win32/DVTARGETDEVICE.java
+SHA1-Digest: 88OK2i/evrb+mh7BJJLw4pQIk5w=
+
+Name: org/eclipse/swt/internal/ole/win32/IEnum.java
+SHA1-Digest: 3VWh9HGAasTgmI0NWQRcsa69m+Y=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java
+SHA1-Digest: 68CShEVQiEc1p4tjYVIFaGmQa5w=
+
+Name: META-INF/eclipse.inf
+SHA1-Digest: SAqY+5ITAL0mkdYeijlSRhyIaZk=
+
+Name: org/eclipse/swt/widgets/Link.java
+SHA1-Digest: cnzfVhZKse8jgnMZBLxZ80vy8mk=
+
+Name: org/eclipse/swt/internal/win32/LOGPEN.java
+SHA1-Digest: x2w4dR5rVtDY5J3w5i7Yjc8hqU8=
+
+Name: org/eclipse/swt/internal/win32/TEXTMETRICW.java
+SHA1-Digest: pIwurqxM53M/3Q5LNvUHqgptGJw=
+
+Name: org/eclipse/swt/internal/image/JPEGEndOfImage.java
+SHA1-Digest: 8Ng0of2Ey8GsZU/3RpC1yc7NA8w=
+
+Name: org/eclipse/swt/internal/win32/CREATESTRUCT.java
+SHA1-Digest: NYSXtVHYugHesihcT2+qWl4u0p8=
+
+Name: org/eclipse/swt/internal/image/JPEGStartOfImage.java
+SHA1-Digest: LF4ENVixsDyesC4sxOiWrfkJDxU=
+
+Name: org/eclipse/swt/internal/CloneableCompatibility.java
+SHA1-Digest: hCSchN5XwwcLk5+09v5LP0d4eHI=
+
+Name: org/eclipse/swt/browser/Mozilla.java
+SHA1-Digest: tmZdrLEpN6BKjNdEvLxHvPHjtyA=
+
+Name: org/eclipse/swt/events/MenuAdapter.java
+SHA1-Digest: q+I9ecNgQGhbP1RvlnedOqbC40k=
+
+Name: org/eclipse/swt/internal/win32/TRACKMOUSEEVENT.java
+SHA1-Digest: 3ADV9Hbz/dsE+/A2T0HhU2A2mYI=
+
+Name: org/eclipse/swt/graphics/Cursor.java
+SHA1-Digest: kUaga56WL5QqMwCgnm59IOb+uQA=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowserSetup.java
+SHA1-Digest: NVBPgjbdpQZgslfEFIOGFRYiOO4=
+
+Name: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog_1_9.
+ java
+SHA1-Digest: AttDag2gJOhIFTaCkabX0rndeoA=
+
+Name: org/eclipse/swt/internal/ole/win32/IDispatchEx.java
+SHA1-Digest: /PJgO2t7NkpEN//O+91PezRVB0c=
+
+Name: org/eclipse/swt/internal/ole/win32/IPersistStorage.java
+SHA1-Digest: 6fJjhO4rY1/RoGkBNfRRIAL3noo=
+
+Name: org/eclipse/swt/internal/win32/BLENDFUNCTION.java
+SHA1-Digest: CI8vyOvHgqQa5O2P/au118z9xSU=
+
+Name: org/eclipse/swt/widgets/Composite.java
+SHA1-Digest: ntwewrUlX+L4p7ITSdE0UGnun/k=
+
+Name: org/eclipse/swt/browser/WindowEvent.java
+SHA1-Digest: h56QX1KsCMxPBTMwFEV9O2Ls67U=
+
+Name: org/eclipse/swt/widgets/CoolItem.java
+SHA1-Digest: lVbz5V+57+7J5r5JEqXJV2dN+lY=
+
+Name: org/eclipse/swt/custom/TableTreeEditor.java
+SHA1-Digest: NQov6olXyjEUdeQr2iptLQ0vpCc=
+
+Name: org/eclipse/swt/widgets/Group.java
+SHA1-Digest: Trf2mfc2vEEOAfj1iz2+1u75eTU=
+
+Name: org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java
+SHA1-Digest: tNMNCDidN7koLahawYYjYlNaFhk=
+
+Name: org/eclipse/swt/events/TraverseListener.java
+SHA1-Digest: lTxVd2XZ8Dr5coe12pgiY0c7JnY=
+
+Name: org/eclipse/swt/custom/CTabFolder2Adapter.java
+SHA1-Digest: 2eVfJ+CGIeReeKWt9XM+johcS8E=
+
+Name: org/eclipse/swt/widgets/Button.java
+SHA1-Digest: nVuL16+QUYBToefKfsn+4Ghf2ME=
+
+Name: org/eclipse/swt/internal/ole/win32/IEnumSTATSTG.java
+SHA1-Digest: gs5kseWVGRF/TKnU9M+gAsnvvDQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsIAuthInformation.java
+SHA1-Digest: g6pNRcY549bu7xuNZMkrb9wI/KQ=
+
+Name: org/eclipse/swt/custom/TreeEditor.java
+SHA1-Digest: jNTCIy7AerdvHEKIeR84Q72A5As=
+
+Name: org/eclipse/swt/graphics/ImageData.java
+SHA1-Digest: butxWtOP/3qjc0hs1DqPVnZop9E=
+
+Name: org/eclipse/swt/graphics/Color.java
+SHA1-Digest: PrfMI1Xf4lzby7z6U6O7/wqlFCM=
+
+Name: org/eclipse/swt/internal/gdip/Gdip.java
+SHA1-Digest: /Sdxaf/rNNbMbnInt3KImU6sp9E=
+
+Name: org/eclipse/swt/browser/WindowCreator2.java
+SHA1-Digest: ShpjVKk9Myo9xAtLWry+jWd+YCo=
+
+Name: org/eclipse/swt/internal/ole/win32/IStream.java
+SHA1-Digest: QseymTmZolJhEczsQZB/5cNHxcw=
+
+Name: org/eclipse/swt/internal/mozilla/nsICookieService.java
+SHA1-Digest: JraJC9J3+15BI2qsM/3z6z//I6E=
+
+Name: swt_awt.c
+SHA1-Digest: iYJxH+oXkWhUNPQaUr16AMOu/UI=
+
+Name: org/eclipse/swt/widgets/ToolBar.java
+SHA1-Digest: yrTz0Ivt4fyzOgGXv/0VsJXqcnU=
+
+Name: org/eclipse/swt/widgets/Spinner.java
+SHA1-Digest: 9PUoLsrJSto1RVOJoX/I86JV9p8=
+
+Name: org/eclipse/swt/internal/gdip/PointF.java
+SHA1-Digest: NPIdRzyfP0x+dWxF9RYUxPtxeAI=
+
+Name: org/eclipse/swt/custom/MovementEvent.java
+SHA1-Digest: DVQLhnIL3ZB5ee96X2sVa+XDias=
+
+Name: org/eclipse/swt/internal/win32/COMBOBOXINFO.java
+SHA1-Digest: 3i9oIF74mTZFMVhZlMwHes+l1wY=
+
+Name: org/eclipse/swt/internal/win32/GUITHREADINFO.java
+SHA1-Digest: Zh7/dOWO9cz326WgHogBeySmmbU=
+
+Name: org/eclipse/swt/custom/CLabel.java
+SHA1-Digest: ArWS49hSdyEj9Pf8j8NdLuNYoPM=
+
+Name: org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java
+SHA1-Digest: TVIKXRHHjvzUCGG8JVdH8n2nd2g=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowserStream.java
+SHA1-Digest: UhLDXAcG79UMQsLwHVeojxjb+Vs=
+
+Name: org/eclipse/swt/internal/win32/LOGFONTW.java
+SHA1-Digest: t662H2egNABGUwx4XAL9k431Kb0=
+
+Name: org/eclipse/swt/widgets/Widget.java
+SHA1-Digest: /3z7rBOuK95mlPClCtai3+xSTOM=
+
+Name: org/eclipse/swt/widgets/Sash.java
+SHA1-Digest: 5B1ZFp17IVuHTUcWo9Vm9mGHeVc=
+
+Name: org/eclipse/swt/layout/RowData.java
+SHA1-Digest: s617hoOAm6YpmWXXRr6VAcly1CQ=
+
+Name: org/eclipse/swt/internal/win32/NMUPDOWN.java
+SHA1-Digest: sZJtiItNrmn7qOstE6x4dYfFTZ4=
+
+Name: org/eclipse/swt/custom/MovementListener.java
+SHA1-Digest: 8D7NRyxECZXG/PmwcKeVjAMUpb0=
+
+Name: org/eclipse/swt/custom/StyledTextRenderer.java
+SHA1-Digest: XwwoiRrWY4gnENE6lIYDWITzGkc=
+
+Name: org/eclipse/swt/internal/ole/win32/IDragSourceHelper.java
+SHA1-Digest: d2TtpjhJWWqLMcimmD1NlI13iZQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsIBaseWindow.java
+SHA1-Digest: PU4rhQvQUQXOO5u9EFNxJytvpN0=
+
+Name: org/eclipse/swt/widgets/Listener.java
+SHA1-Digest: FXZen6rpuDKpVlgW8QAWzdWm7N4=
+
+Name: org/eclipse/swt/internal/mozilla/nsIPrefLocalizedString.java
+SHA1-Digest: 5W59XVoeyUgMY6qUTrQosGDk74s=
+
+Name: xpcominit_stats.cpp
+SHA1-Digest: Fd2H1U+RnQnVBqrpLBKKjxMm7jk=
+
+Name: org/eclipse/swt/internal/win32/OSVERSIONINFOEX.java
+SHA1-Digest: FlQ4vJiTB82jOkxw5jctsql7OoY=
+
+Name: org/eclipse/swt/widgets/ExpandItem.java
+SHA1-Digest: AUCe0Tw+sY0pu1ZOCMg/5DTj3zc=
+
+Name: org/eclipse/swt/internal/mozilla/nsIObserverService.java
+SHA1-Digest: P5SAOE2uQnFKGuTv8jN24Ffr+FI=
+
+Name: org/eclipse/swt/internal/ole/win32/COSERVERINFO.java
+SHA1-Digest: +m7365dK4PrNAOLdLa+UNgma6O0=
+
+Name: org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java
+SHA1-Digest: 1uusKPROIV0IWN4/9LMy91JDofA=
+
+Name: org/eclipse/swt/internal/image/PngTrnsChunk.java
+SHA1-Digest: CWpJYQM/hSIEe4qQUF5Il/m4ShM=
+
+Name: org/eclipse/swt/internal/ole/win32/CAUUID.java
+SHA1-Digest: D9uCdScIRnerqqgP7UbcvAKR5vA=
+
+Name: org/eclipse/swt/ole/win32/OleListener.java
+SHA1-Digest: MGu8t4sM9T7pJcLRdWl8L/YBwTw=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleInPlaceActiveObject.java
+SHA1-Digest: 6mYrmpkUAgbWB+p/xwZL56cLZiM=
+
+Name: xpcom.h
+SHA1-Digest: dNz1W8VuYtv1AEkkHsqvmm6FnsQ=
+
+Name: org/eclipse/swt/internal/image/PngIdatChunk.java
+SHA1-Digest: UwzO3mcFQmZa7wzRYb/4RPLYvUE=
+
+Name: org/eclipse/swt/internal/win32/DEVMODEA.java
+SHA1-Digest: WkPuA1keOsWWi+3Hv3go2qwAkl0=
+
+Name: org/eclipse/swt/internal/ole/win32/OLECMDTEXT.java
+SHA1-Digest: IUUQ/MumDmqcQi9iab8RgWIy8Zw=
+
+Name: org/eclipse/swt/custom/TextChangingEvent.java
+SHA1-Digest: mXPGoFMcI4QdsMA4zyK3Vt7+JLQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsITooltipListener.java
+SHA1-Digest: TYABt+y1CYxaoP313iaEdNhkFWk=
+
+Name: org/eclipse/swt/internal/win32/LVITEM.java
+SHA1-Digest: E740kKExlmqEzERVBPBVzyLr4XM=
+
+Name: org/eclipse/swt/browser/VisibilityWindowListener.java
+SHA1-Digest: nvDD9pF+RBTULojap7dHAnHVVqU=
+
+Name: org/eclipse/swt/widgets/IME.java
+SHA1-Digest: PbiPRnONZHPMeUE4kYUf4vNKROs=
+
+Name: org/eclipse/swt/internal/mozilla/nsICategoryManager.java
+SHA1-Digest: Xed1fRHyPDbPnt/AvOJAh/DMzpI=
+
+Name: org/eclipse/swt/internal/mozilla/nsIScriptSecurityManager_1_9.ja
+ va
+SHA1-Digest: PyslXRYto+chNJsy8Mc+DG50vxA=
+
+Name: org/eclipse/swt/internal/win32/NMTTCUSTOMDRAW.java
+SHA1-Digest: iOZaGLwH1+Zft7k0SUmUIrSaE8Q=
+
+Name: org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java
+SHA1-Digest: AQaQcX2Gm3c0L8heZEZnQpacMNo=
+
+Name: org/eclipse/swt/browser/FilePicker.java
+SHA1-Digest: atUwf1nh/i/8G8CzophVKCrT0gg=
+
+Name: org/eclipse/swt/internal/mozilla/nsILocalFile.java
+SHA1-Digest: Venh9nbxlfsbEez+tlz6Dqr6NDc=
+
+Name: org/eclipse/swt/custom/LineBackgroundListener.java
+SHA1-Digest: is+ijtgq1jINABs/ORNEiYs9Jdo=
+
+Name: org/eclipse/swt/internal/win32/EXTLOGPEN.java
+SHA1-Digest: xuRfZ2DfgIJSLIVmShcxqlwrkf0=
+
+Name: org/eclipse/swt/internal/win32/MENUINFO.java
+SHA1-Digest: zn+q4duJJDYq8F7K2cQPp0+QzjY=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.jav
+ a
+SHA1-Digest: YwtliZe0fBFHwFodXffJEQsDaPM=
+
+Name: org/eclipse/swt/graphics/Rectangle.java
+SHA1-Digest: R9IcwYfpipXeEzyqYM32ei516AM=
+
+Name: org/eclipse/swt/internal/ole/win32/VARDESC.java
+SHA1-Digest: 6L1tqSsZypO714V06eGV3Sw/u2w=
+
+Name: org/eclipse/swt/widgets/RunnableLock.java
+SHA1-Digest: ULWUpmBrJhOVDcn4mWxXgH59zms=
+
+Name: org/eclipse/swt/internal/win32/OS.java
+SHA1-Digest: xJiB4MmZAwncZBccC7ohe6NQuAM=
+
+Name: gdip.cpp
+SHA1-Digest: ejgILtxM+O/qslGqTgngjxtqElQ=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWindowCreator.java
+SHA1-Digest: TaLPmggcWPl47u+H0/8numvEw1o=
+
+Name: os_stats.c
+SHA1-Digest: xqP5Df38fSAFOH6/+2sNGiRJ9Mk=
+
+Name: org/eclipse/swt/ole/win32/OleAutomation.java
+SHA1-Digest: k8K8SXhdH3OrlsoXzRrRtkOUEhk=
+
+Name: os_stats.h
+SHA1-Digest: /s7OT7zAnmLTzb5kV5dRjkALqiI=
+
+Name: org/eclipse/swt/widgets/ToolTip.java
+SHA1-Digest: /+A8LwtzUbJMsvZFyTp15tDZ4HM=
+
+Name: org/eclipse/swt/browser/Browser.java
+SHA1-Digest: oEgi1P4kfwLzJ7thfP8sLZGAJuw=
+
+Name: org/eclipse/swt/printing/PrintDialog.java
+SHA1-Digest: m+bwZlajRIAzK3/jB1lj7G44ja4=
+
+Name: swt_xpcom.rc
+SHA1-Digest: 48q5Ffn0yIfdJLUz4HDdn4QT6+g=
+
+Name: org/eclipse/swt/internal/image/PngIendChunk.java
+SHA1-Digest: /ZuFlzc9KEO+8GFz8A+mh4Wy82E=
+
+Name: org/eclipse/swt/events/MouseTrackAdapter.java
+SHA1-Digest: nCbmAmuA0PKYeDN2/62aGQECMIA=
+
+Name: org/eclipse/swt/widgets/Label.java
+SHA1-Digest: TgIjx1WSBcQvlmkS9o03oYsNKsA=
+
+Name: fragment.properties
+SHA1-Digest: NuiUCdWsVv6ZsMMW5qaJZafuy7U=
+
+Name: org/eclipse/swt/internal/image/JPEGFrameHeader.java
+SHA1-Digest: QfJkwdEQ3YltAgbsz5+E+jie6qg=
+
+Name: org/eclipse/swt/internal/image/JPEGVariableSizeSegment.java
+SHA1-Digest: SnjoW5xTGAYOKLNxvF7qIwvpSos=
+
+Name: org/eclipse/swt/graphics/Transform.java
+SHA1-Digest: ERr2JbJuP7tL6Oe1BoM5rRsqYu4=
+
+Name: make_wince.mak
+SHA1-Digest: 41L9TUl1BHYRl9R2aR7pbYEYPw8=
+
+Name: org/eclipse/swt/internal/win32/NMTVITEMCHANGE.java
+SHA1-Digest: CqvOXYYePGtykNqmUg6316wBIRs=
+
+Name: nsIScriptContext.h
+SHA1-Digest: PiYDTDGmasetJ8pB5cFuZenTxlU=
+
+Name: org/eclipse/swt/custom/SashForm.java
+SHA1-Digest: 0za8KI3F99zpkgTp8O4voZFUG7I=
+
+Name: org/eclipse/swt/internal/win32/SCRIPT_ITEM.java
+SHA1-Digest: X7DbY9Qg83APjYrwqdIAD8GeaDs=
+
+Name: org/eclipse/swt/events/ModifyListener.java
+SHA1-Digest: J2lz6ozdpTdfS/0VI0VeG+ra7GY=
+
+Name: org/eclipse/swt/internal/theme/ScaleDrawData.java
+SHA1-Digest: bDV7JvLEqzAsjp5RXLfLburqK6s=
+
+Name: org/eclipse/swt/ole/win32/OleEventSink.java
+SHA1-Digest: CmosvLl1FIjd+Uubh4eRHRbFwXg=
+
+Name: org/eclipse/swt/custom/VerifyKeyListener.java
+SHA1-Digest: 0YQk2kMl+CTu3mOwOMo/G2MtlDU=
+
+Name: org/eclipse/swt/internal/ole/win32/EXCEPINFO.java
+SHA1-Digest: LZf8dGM3wLoovwnp/CuVnqCpx9c=
+
+Name: org/eclipse/swt/internal/win32/BROWSEINFO.java
+SHA1-Digest: hnQhT0Tini0oO7ToqYaaA5HTfN8=
+
+Name: org/eclipse/swt/internal/win32/SHACTIVATEINFO.java
+SHA1-Digest: jhvUkDukkrAVroFh//aVIIQOYdg=
+
+Name: org/eclipse/swt/internal/mozilla/nsIInputStream.java
+SHA1-Digest: N7kyZxZiJZdCHX+Z1bMG8cHc6VM=
+
+Name: org/eclipse/swt/internal/theme/ToolBarDrawData.java
+SHA1-Digest: dDC4j7bDRmUpIim0vv2kwIgAoj0=
+
+Name: org/eclipse/swt/internal/ole/win32/STGMEDIUM.java
+SHA1-Digest: vhLRgTgC1HnHmjqhFrncUDUv7ik=
+
+Name: org/eclipse/swt/events/ModifyEvent.java
+SHA1-Digest: qH2c8MbjDM/AyWqK2TCOicYzHFQ=
+
+Name: org/eclipse/swt/accessibility/AccessibleControlAdapter.java
+SHA1-Digest: 4aI12QNwOj5G5jOMwnsFD08Ua0M=
+
+Name: org/eclipse/swt/internal/ole/win32/IOleObject.java
+SHA1-Digest: scxJgRW0t/G36FoAjM0AbrcL8Zs=
+
+Name: org/eclipse/swt/browser/SimpleEnumerator.java
+SHA1-Digest: G02Ud9dgoSU2jKD/BeyMxiQJoCQ=
+
+Name: org/eclipse/swt/program/Program.java
+SHA1-Digest: INwkrM4hDpxatzGQa2Nb9FEoUFM=
+
+Name: org/eclipse/swt/widgets/TreeColumn.java
+SHA1-Digest: DPnG3WLaaslav2ryiHHtF3MBOrw=
+
+Name: org/eclipse/swt/events/MouseListener.java
+SHA1-Digest: ylcjrU0+XQngoprKhasUCx4+p94=
+
+Name: org/eclipse/swt/events/MenuDetectEvent.java
+SHA1-Digest: z5NhnQY9SDlUPWQLQYHp0VlYUO0=
+
+Name: org/eclipse/swt/internal/win32/TEXTMETRIC.java
+SHA1-Digest: xHCSLQID5f9qPIvuM3Uw8Erby7M=
+
+Name: org/eclipse/swt/internal/image/WinBMPFileFormat.java
+SHA1-Digest: Cos1NyS97l+jLQDvOliMNNTrvoU=
+
+Name: org/eclipse/swt/internal/theme/TabItemDrawData.java
+SHA1-Digest: 0X3sm+7svbXdS1IYgjb6KFY6x/0=
+
+Name: org/eclipse/swt/internal/gdip/Rect.java
+SHA1-Digest: SnxF4YJqEKbgchQhKOELzuKgD3c=
+
+Name: org/eclipse/swt/internal/win32/SHFILEINFOA.java
+SHA1-Digest: jUOOcd+tnYEbDjrlaCVjpADm8/g=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDownload.java
+SHA1-Digest: ID8bbEKZuujt3WW3JbMKuAe646A=
+
+Name: org/eclipse/swt/graphics/FontData.java
+SHA1-Digest: WJUwFfakFok1yxNPqhQ3EOtWHRg=
+
+Name: org/eclipse/swt/internal/mozilla/nsIDataType.java
+SHA1-Digest: aTFbOdXcK9EKFV28UXI0wgjXqA8=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWindowWatcher.java
+SHA1-Digest: F/YJzkfhk7TaC9M8mnSpJRI99QU=
+
+Name: org/eclipse/swt/custom/PaintObjectListener.java
+SHA1-Digest: oUZL3JJ+ThjMbTegug+yEcMpEF0=
+
+Name: org/eclipse/swt/browser/StatusTextEvent.java
+SHA1-Digest: K6zPQpmBwD3VqNC7/gTZLq14vrM=
+
+Name: org/eclipse/swt/dnd/TransferData.java
+SHA1-Digest: mBnB1+Cr4LuU6OBskH4nBF97i5Y=
+
+Name: org/eclipse/swt/internal/mozilla/nsIWebBrowser.java
+SHA1-Digest: APdRT29eAsGL5dY/JxDDf6YVSdM=
+
+Name: org/eclipse/swt/internal/win32/DLLVERSIONINFO.java
+SHA1-Digest: UKkaG4Lx4a8/OKO6j5teHtTwiok=
+
+Name: org/eclipse/swt/custom/ExtendedModifyListener.java
+SHA1-Digest: vml4IoKIEFMPO0PLgL1ztt9EAiw=
+
+Name: org/eclipse/swt/ole/win32/OleFrame.java
+SHA1-Digest: 9JKxn6qzC0FQhL0/A9orjC59cCY=
+
Index: META-INF/ECLIPSEF.RSA
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: META-INF/ECLIPSEF.RSA
===================================================================
--- META-INF/ECLIPSEF.RSA	(.../vendor/swt/win32-64/3.7/csrc)	(revision 0)
+++ META-INF/ECLIPSEF.RSA	(.../trunk/thirdparty/swt/3.7/win32-64/csrc)	(revision 23809)

Property changes on: META-INF/ECLIPSEF.RSA
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: callback.c
===================================================================
--- callback.c	(.../vendor/swt/win32-64/3.7/csrc)	(revision 23809)
+++ callback.c	(.../trunk/thirdparty/swt/3.7/win32-64/csrc)	(revision 23809)
@@ -1243,7 +1243,7 @@
 	}
 	va_end(vl);
 	ATOMIC_DEC(callbackEntryCount);
-
+	
 done:
 	/* If an exception has occurred in Java, return the error result. */
 	if ((ex = (*env)->ExceptionOccurred(env))) {
