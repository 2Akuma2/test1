Index: org/eclipse/swt/ole/win32/OleAutomation.java
===================================================================
--- org/eclipse/swt/ole/win32/OleAutomation.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleAutomation.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -173,7 +173,7 @@
 	} catch (SWTException e) {
 		dispose();
 		throw e;
-	}
+ }
 }
 /**
  * Disposes the automation object.
@@ -192,7 +192,7 @@
 		objITypeInfo.Release();
 	}
 	objITypeInfo = null;
-	
+
 	if (objIUnknown != null){
 		objIUnknown.Release();
 		OS.OleUninitialize();
Index: org/eclipse/swt/ole/win32/OleClientSite.java
===================================================================
--- org/eclipse/swt/ole/win32/OleClientSite.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleClientSite.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -314,98 +314,98 @@
 	 */
 	boolean isOffice2007 = isOffice2007(true);
 	if (!isOffice2007 && COM.IsEqualGUID(appClsid, fileClsid)){
-		// Using the same application that created file, therefore, use default mechanism.
-		tempStorage = createTempStorage();
-		// Create ole object with storage object
-		int /*long*/[] address = new int /*long*/[1];
-		int result = COM.OleCreateFromFile(appClsid, fileName, COM.IIDIUnknown, COM.OLERENDER_DRAW, null, iOleClientSite.getAddress(), tempStorage.getAddress(), address);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		objIUnknown = new IUnknown(address[0]);
-	} else {
-		// Not using the same application that created file, therefore, copy from original file to a new storage file
-		IStorage storage = null;
-		if (COM.StgIsStorageFile(fileName) == COM.S_OK) {
+			// Using the same application that created file, therefore, use default mechanism.
+			tempStorage = createTempStorage();
+			// Create ole object with storage object
 			int /*long*/[] address = new int /*long*/[1];
-			int mode = COM.STGM_READ | COM.STGM_TRANSACTED | COM.STGM_SHARE_EXCLUSIVE;
-			int result = COM.StgOpenStorage(fileName, 0, mode, 0, 0, address); //Does an AddRef if successful
-			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			storage = new IStorage(address[0]);
+			int result = COM.OleCreateFromFile(appClsid, fileName, COM.IIDIUnknown, COM.OLERENDER_DRAW, null, iOleClientSite.getAddress(), tempStorage.getAddress(), address);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			objIUnknown = new IUnknown(address[0]);
 		} else {
-			// Original file is not a Storage file so copy contents to a stream in a new storage file
-			int /*long*/[] address = new int /*long*/[1];
-			int mode = COM.STGM_READWRITE | COM.STGM_DIRECT | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_CREATE;
-			int result = COM.StgCreateDocfile(null, mode | COM.STGM_DELETEONRELEASE, 0, address); // Increments ref count if successful
-			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			storage = new IStorage(address[0]);
-			// Create a stream on the storage object.
-			// Word does not follow the standard and does not use "CONTENTS" as the name of
-			// its primary stream
-			String streamName = "CONTENTS"; //$NON-NLS-1$
-			GUID wordGUID = getClassID(WORDPROGID);
-			if (wordGUID != null && COM.IsEqualGUID(appClsid, wordGUID)) streamName = "WordDocument"; //$NON-NLS-1$
+			// Not using the same application that created file, therefore, copy from original file to a new storage file
+			IStorage storage = null;
+			if (COM.StgIsStorageFile(fileName) == COM.S_OK) {
+				int /*long*/[] address = new int /*long*/[1];
+				int mode = COM.STGM_READ | COM.STGM_TRANSACTED | COM.STGM_SHARE_EXCLUSIVE;
+				int result = COM.StgOpenStorage(fileName, 0, mode, 0, 0, address); //Does an AddRef if successful
+				if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				storage = new IStorage(address[0]);
+			} else {
+				// Original file is not a Storage file so copy contents to a stream in a new storage file
+				int /*long*/[] address = new int /*long*/[1];
+				int mode = COM.STGM_READWRITE | COM.STGM_DIRECT | COM.STGM_SHARE_EXCLUSIVE | COM.STGM_CREATE;
+				int result = COM.StgCreateDocfile(null, mode | COM.STGM_DELETEONRELEASE, 0, address); // Increments ref count if successful
+				if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				storage = new IStorage(address[0]);
+				// Create a stream on the storage object.
+				// Word does not follow the standard and does not use "CONTENTS" as the name of
+				// its primary stream
+				String streamName = "CONTENTS"; //$NON-NLS-1$
+				GUID wordGUID = getClassID(WORDPROGID);
+				if (wordGUID != null && COM.IsEqualGUID(appClsid, wordGUID)) streamName = "WordDocument"; //$NON-NLS-1$
 			if (isOffice2007) streamName = "Package"; //$NON-NLS-1$
-			address = new int /*long*/[1];
-			result = storage.CreateStream(streamName, mode, 0, 0, address); // Increments ref count if successful
-			if (result != COM.S_OK) {
-				storage.Release();
-				OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-			}
-			IStream stream = new IStream(address[0]);
-			try {
-				// Copy over data in file to named stream
-				FileInputStream fileInput = new FileInputStream(file);
-				int increment = 1024*4;
-				byte[] buffer = new byte[increment];
-				int count = 0;
-				while((count = fileInput.read(buffer)) > 0){
-					int /*long*/ pv = COM.CoTaskMemAlloc(count);
-					OS.MoveMemory(pv, buffer, count);
-					result = stream.Write(pv, count, null) ;
-					COM.CoTaskMemFree(pv);
-					if (result != COM.S_OK) {
-						fileInput.close();
-						stream.Release();
-						storage.Release();
-						OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				address = new int /*long*/[1];
+				result = storage.CreateStream(streamName, mode, 0, 0, address); // Increments ref count if successful
+				if (result != COM.S_OK) {
+					storage.Release();
+					OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+				}
+				IStream stream = new IStream(address[0]);
+				try {
+					// Copy over data in file to named stream
+					FileInputStream fileInput = new FileInputStream(file);
+					int increment = 1024*4;
+					byte[] buffer = new byte[increment];
+					int count = 0;
+					while((count = fileInput.read(buffer)) > 0){
+						int /*long*/ pv = COM.CoTaskMemAlloc(count);
+						OS.MoveMemory(pv, buffer, count);
+						result = stream.Write(pv, count, null) ;
+						COM.CoTaskMemFree(pv);
+						if (result != COM.S_OK) {
+							fileInput.close();
+							stream.Release();
+							storage.Release();
+							OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+						}
 					}
+					fileInput.close();
+					stream.Commit(COM.STGC_DEFAULT);
+					stream.Release();
+				} catch (IOException err) {
+					stream.Release();
+					storage.Release();
+					OLE.error(OLE.ERROR_CANNOT_OPEN_FILE);
 				}
-				fileInput.close();
-				stream.Commit(COM.STGC_DEFAULT);
-				stream.Release();
-			} catch (IOException err) {
-				stream.Release();
-				storage.Release();
-				OLE.error(OLE.ERROR_CANNOT_OPEN_FILE);
 			}
+			
+			// Open a temporary storage object
+			tempStorage = createTempStorage();
+			// Copy over contents of file
+			int result = storage.CopyTo(0, null, null, tempStorage.getAddress());
+			storage.Release();
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
+
+			// create ole client
+			int /*long*/[] ppv = new int /*long*/[1];
+			result = COM.CoCreateInstance(appClsid, 0, COM.CLSCTX_INPROC_HANDLER | COM.CLSCTX_INPROC_SERVER, COM.IIDIUnknown, ppv);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			objIUnknown = new IUnknown(ppv[0]);
+			// get the persistent storage of the ole client
+			ppv = new int /*long*/[1];
+			result = objIUnknown.QueryInterface(COM.IIDIPersistStorage, ppv);
+			if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
+			IPersistStorage iPersistStorage = new IPersistStorage(ppv[0]);
+			// load the contents of the file into the ole client site
+			result = iPersistStorage.Load(tempStorage.getAddress());
+			iPersistStorage.Release();
+			if (result != COM.S_OK)OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
 		}
 		
-		// Open a temporary storage object
-		tempStorage = createTempStorage();
-		// Copy over contents of file
-		int result = storage.CopyTo(0, null, null, tempStorage.getAddress());
-		storage.Release();
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_OPEN_FILE, result);
-
-		// create ole client
-		int /*long*/[] ppv = new int /*long*/[1];
-		result = COM.CoCreateInstance(appClsid, 0, COM.CLSCTX_INPROC_HANDLER | COM.CLSCTX_INPROC_SERVER, COM.IIDIUnknown, ppv);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		objIUnknown = new IUnknown(ppv[0]);
-		// get the persistent storage of the ole client
-		ppv = new int /*long*/[1];
-		result = objIUnknown.QueryInterface(COM.IIDIPersistStorage, ppv);
-		if (result != COM.S_OK) OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-		IPersistStorage iPersistStorage = new IPersistStorage(ppv[0]);
-		// load the contents of the file into the ole client site
-		result = iPersistStorage.Load(tempStorage.getAddress());
-		iPersistStorage.Release();
-		if (result != COM.S_OK)OLE.error(OLE.ERROR_CANNOT_CREATE_OBJECT, result);
-	}
-	
-	// Init sinks
-	addObjectReferences();
-	
-	if (COM.OleRun(objIUnknown.getAddress()) == OLE.S_OK) state = STATE_RUNNING;
+		// Init sinks
+		addObjectReferences();
+		
+		if (COM.OleRun(objIUnknown.getAddress()) == OLE.S_OK) state = STATE_RUNNING;
 }
 protected void addObjectReferences() {
 	//
@@ -442,7 +442,7 @@
 	int /*long*/[] ppvClientSite = new int /*long*/[1];
 	result = objIOleObject.GetClientSite(ppvClientSite);
 	if (ppvClientSite[0] == 0) {
-		objIOleObject.SetClientSite(iOleClientSite.getAddress());
+	objIOleObject.SetClientSite(iOleClientSite.getAddress());
 	} else {
 		Release(); // GetClientSite performs an AddRef so we must release it.
 	}
@@ -894,7 +894,7 @@
 }
 private void onDispose(Event e) {
 	inDispose = true;
-
+	
 	// remove listeners
 	removeListener(SWT.Dispose, listener);
 	removeListener(SWT.FocusIn, listener);
@@ -1140,7 +1140,7 @@
 	objIUnknown = null;
 	
 	if (COM.FreeUnusedLibraries) {
-		COM.CoFreeUnusedLibraries();
+	COM.CoFreeUnusedLibraries();
 	}
 }
 /**
@@ -1357,8 +1357,8 @@
 	Rectangle area = frame.getClientArea();
 	setBounds(borderWidths.left, 
 		      borderWidths.top, 
-			  area.width - borderWidths.left - borderWidths.right, 
-			  area.height - borderWidths.top - borderWidths.bottom);
+				area.width - borderWidths.left - borderWidths.right, 
+				area.height - borderWidths.top - borderWidths.bottom);
 	setObjectRects();
 }
 private void setExtent(int width, int height){
Index: org/eclipse/swt/ole/win32/Variant.java
===================================================================
--- org/eclipse/swt/ole/win32/Variant.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/Variant.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -88,7 +88,7 @@
  * @param pVariant pointer to a variant
  *
  * @return a new <code>Variant</code>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  *
  * @since 3.3
Index: org/eclipse/swt/ole/win32/OleControlSite.java
===================================================================
--- org/eclipse/swt/ole/win32/OleControlSite.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleControlSite.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -196,7 +196,7 @@
 		throw e;
 	}			
 }
-/**
+/**	 
  * Create an OleClientSite child widget to edit the specified file using the specified OLE Document
  * application.  Use style bits to select a particular look or set of properties. 
  * <p>
@@ -565,18 +565,18 @@
 	int /*long*/ result = 0;
 	IUnknown unknown = new IUnknown(ppvObject[0]);
 	if (unknown.QueryInterface(COM.IIDIClassFactory2, ppvObject) == COM.S_OK) {
-		IClassFactory2 classFactory = new IClassFactory2(ppvObject[0]);
-		LICINFO licinfo = new LICINFO();
+	IClassFactory2 classFactory = new IClassFactory2(ppvObject[0]);
+	LICINFO licinfo = new LICINFO();
 		if (classFactory.GetLicInfo(licinfo) == COM.S_OK) {
 			int /*long*/[] pBstrKey = new int /*long*/[1];
-			if (licinfo != null && licinfo.fRuntimeKeyAvail) {
-				if (classFactory.RequestLicKey(0, pBstrKey) == COM.S_OK) {
+	if (licinfo != null && licinfo.fRuntimeKeyAvail) {
+		if (classFactory.RequestLicKey(0, pBstrKey) == COM.S_OK) {
 					result = pBstrKey[0];
 				}
-			}
 		}
-		classFactory.Release();
 	}
+	classFactory.Release();
+	}
 	unknown.Release();	
 	return result;
 }
Index: org/eclipse/swt/ole/win32/OleFrame.java
===================================================================
--- org/eclipse/swt/ole/win32/OleFrame.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/ole/win32/OleFrame.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -29,9 +29,9 @@
  *	<li>activate and deactivate the OLE Document's menus
  *	<li>position the OLE Document's menu in the application
  *	<li>translate accelerator keystrokes intended for the container's frame</ul>
- * 
+ *
  * <dl>
- *	<dt><b>Styles</b> <dd>BORDER 
+ *	<dt><b>Styles</b> <dd>BORDER
  *	<dt><b>Events</b> <dd>Dispose, Move, Resize
  * </dl>
  *
@@ -39,24 +39,24 @@
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Examples: OLEExample, OleWebBrowser</a>
  */
 final public class OleFrame extends Composite
-{	
+{
 	// Interfaces for this Ole Client Container
 	private COMObject iUnknown;
 	private COMObject iOleInPlaceFrame;
 
-	// Access to the embedded/linked Ole Object 
+	// Access to the embedded/linked Ole Object
 	private IOleInPlaceActiveObject objIOleInPlaceActiveObject;
-	
+
 	private OleClientSite currentdoc;
 
 	private int refCount = 0;
-	
+
 	private MenuItem[] fileMenuItems;
 	private MenuItem[] containerMenuItems;
 	private MenuItem[] windowMenuItems;
 
 	private Listener listener;
-	
+
 	private static String CHECK_FOCUS = "OLE_CHECK_FOCUS"; //$NON-NLS-1$
 	private static String HHOOK = "OLE_HHOOK"; //$NON-NLS-1$
 	private static String HHOOKMSG = "OLE_HHOOK_MSG"; //$NON-NLS-1$
@@ -63,7 +63,7 @@
 
 	private static boolean ignoreNextKey;
 	private static final short [] ACCENTS = new short [] {'~', '`', '\'', '^', '"'};
-	
+
 	private static final String CONSUME_KEY = "org.eclipse.swt.OleFrame.ConsumeKey"; //$NON-NLS-1$
 	private static final String ACCEL_KEY_HIT = "org.eclipse.swt.internal.win32.accelKeyHit"; //$NON-NLS-1$
 
@@ -84,7 +84,7 @@
  */
 public OleFrame(Composite parent, int style) {
 	super(parent, style);
-	
+
 	createCOMInterfaces();
 
 	// setup cleanup proc
@@ -101,8 +101,8 @@
 			}
 		}
 	};
-	
 
+
 	addListener(SWT.Activate, listener);
 	addListener(SWT.Deactivate, listener);
 	addListener(SWT.Dispose, listener);
@@ -109,7 +109,7 @@
 
 	// inform inplaceactiveobject whenever frame resizes
 	addListener(SWT.Resize, listener);
-	
+
 	// inform inplaceactiveobject whenever frame moves
 	addListener(SWT.Move, listener);
 
@@ -117,7 +117,7 @@
 	// ClientSites close, they don't take the frame away
 	// with them.
 	this.AddRef();
-	
+
 	// Check for focus change
 	Display display = getDisplay();
 	initCheckFocus(display);
@@ -136,12 +136,12 @@
 				int /*long*/ hwnd = OS.GetFocus();
 				while (hwnd != 0) {
 					int /*long*/ ownerHwnd = OS.GetWindow(hwnd, OS.GW_OWNER);
-					if (ownerHwnd != 0) {			
+					if (ownerHwnd != 0) {
 						display.timerExec(time, timer[0]);
 						return;
 					}
 					hwnd = OS.GetParent(hwnd);
-				}	
+				}
 			}
 			if (lastFocus[0] == null || lastFocus[0].isDisposed() || !lastFocus[0].isFocusControl()) {
 				Control currentFocus = display.getFocusControl();
@@ -196,7 +196,7 @@
 	MSG msg = (MSG)display.getData(HHOOKMSG);
 	OS.MoveMemory(msg, lParam, MSG.sizeof);
 	int message = msg.message;
-	if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {		
+	if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {
 		if (display != null) {
 			Widget widget = null;
 			int /*long*/ hwnd = msg.hwnd;
@@ -242,7 +242,7 @@
 									case OS.VK_SCROLL:
 										break;
 									default: {
-										/* 
+										/*
 										* Bug in Windows. The high bit in the result of MapVirtualKey() on
 										* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
 										* They should both be bit 32.  The fix is to test the right bit.
@@ -331,7 +331,7 @@
 		public int /*long*/ method1(int /*long*/[] args) {return AddRef();}
 		public int /*long*/ method2(int /*long*/[] args) {return Release();}
 	};
-	
+
 	iOleInPlaceFrame = new COMObject(new int[]{2, 0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 1, 1, 1, 2}){
 		public int /*long*/ method0(int /*long*/[] args) {return QueryInterface(args[0], args[1]);}
 		public int /*long*/ method1(int /*long*/[] args) {return AddRef();}
@@ -351,11 +351,11 @@
 	};
 }
 private void disposeCOMInterfaces () {
-	
+
 	if (iUnknown != null)
 		iUnknown.dispose();
 	iUnknown = null;
-	
+
 	if (iOleInPlaceFrame != null)
 		iOleInPlaceFrame.dispose();
 	iOleInPlaceFrame = null;
@@ -362,8 +362,8 @@
 }
 private int GetBorder(int /*long*/ lprectBorder) {
 	/*
-	The IOleInPlaceUIWindow::GetBorder function, when called on a document or frame window 
-	object, returns the outer rectangle (relative to the window) where the object can put 
+	The IOleInPlaceUIWindow::GetBorder function, when called on a document or frame window
+	object, returns the outer rectangle (relative to the window) where the object can put
 	toolbars or similar controls.
 	*/
 	if (lprectBorder == 0) return COM.E_INVALIDARG;
@@ -375,16 +375,16 @@
 }
 /**
  *
- * Returns the application menu items that will appear in the Container location when an OLE Document 
+ * Returns the application menu items that will appear in the Container location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
- * @return the application menu items that will appear in the Container location when an OLE Document 
+ * @return the application menu items that will appear in the Container location when an OLE Document
  *         is in-place activated.
  *
  */
@@ -393,16 +393,16 @@
 }
 /**
  *
- * Returns the application menu items that will appear in the File location when an OLE Document 
+ * Returns the application menu items that will appear in the File location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
- * @return the application menu items that will appear in the File location when an OLE Document 
+ * @return the application menu items that will appear in the File location when an OLE Document
  *         is in-place activated.
  *
  */
@@ -433,16 +433,16 @@
 }
 /**
  *
- * Returns the application menu items that will appear in the Window location when an OLE Document 
+ * Returns the application menu items that will appear in the Window location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
- * @return the application menu items that will appear in the Window location when an OLE Document 
+ * @return the application menu items that will appear in the Window location when an OLE Document
  *         is in-place activated.
  *
  */
@@ -479,8 +479,8 @@
 			MenuItem item = this.fileMenuItems[i];
 			if (item != null) {
 				int index = item.getParent().indexOf(item);
-				lpmii.cch = cch;  // lpmii.cch gets updated by GetMenuItemInfo to indicate the 
-				                  // exact number of characters in name.  Reset it to our max size 
+				lpmii.cch = cch;  // lpmii.cch gets updated by GetMenuItemInfo to indicate the
+				                  // exact number of characters in name.  Reset it to our max size
 				                  // before each call.
 				if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {
 					if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {
@@ -504,8 +504,8 @@
 			MenuItem item = this.containerMenuItems[i];
 			if (item != null) {
 				int index = item.getParent().indexOf(item);
-				lpmii.cch = cch; // lpmii.cch gets updated by GetMenuItemInfo to indicate the 
-				                           // exact number of characters in name.  Reset it to a large number 
+				lpmii.cch = cch; // lpmii.cch gets updated by GetMenuItemInfo to indicate the
+				                           // exact number of characters in name.  Reset it to a large number
 				                           // before each call.
 				if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {
 					if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {
@@ -517,7 +517,7 @@
 			}
 		}
 	}
-	
+
 	// copy the menu item count information to the pointer
 	COM.MoveMemory(lpMenuWidths + 8, new int[] {containerMenuCount}, 4);
 
@@ -529,8 +529,8 @@
 			MenuItem item = this.windowMenuItems[i];
 			if (item != null) {
 				int index = item.getParent().indexOf(item);
-				lpmii.cch = cch; // lpmii.cch gets updated by GetMenuItemInfo to indicate the 
-				                           // exact number of characters in name.  Reset it to a large number 
+				lpmii.cch = cch; // lpmii.cch gets updated by GetMenuItemInfo to indicate the
+				                           // exact number of characters in name.  Reset it to a large number
 				                           // before each call.
 				if (OS.GetMenuItemInfo(hMenu, index, true, lpmii)) {
 					if (OS.InsertMenuItem(hmenuShared, newindex, true, lpmii)) {
@@ -542,10 +542,10 @@
 			}
 		}
 	}
-	
+
 	// copy the menu item count information to the pointer
 	COM.MoveMemory(lpMenuWidths + 16, new int[] {windowMenuCount}, 4);
-		
+
 	// free resources used in querying the OS
 	if (pszText != 0)
 		OS.HeapFree(hHeap, 0, pszText);
@@ -605,9 +605,9 @@
 	if (refCount == 0){
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 private void releaseObjectInterfaces() {
@@ -622,7 +622,7 @@
 	if (menubar == null || menubar.isDisposed()) return COM.S_FALSE;
 
 	int /*long*/ hMenu = menubar.handle;
-	
+
 	Vector ids = new Vector();
 	if (this.fileMenuItems != null) {
 		for (int i = 0; i < this.fileMenuItems.length; i++) {
@@ -681,15 +681,15 @@
 }
 private int SetBorderSpace(int /*long*/ pborderwidths) {
 	// A Control/Document can :
-	// Use its own toolbars, requesting border space of a specific size, or, 
-	// Use no toolbars, but force the container to remove its toolbars by passing a 
-	//   valid BORDERWIDTHS structure containing nothing but zeros in the pborderwidths parameter, or, 
-	// Use no toolbars but allow the in-place container to leave its toolbars up by 
+	// Use its own toolbars, requesting border space of a specific size, or,
+	// Use no toolbars, but force the container to remove its toolbars by passing a
+	//   valid BORDERWIDTHS structure containing nothing but zeros in the pborderwidths parameter, or,
+	// Use no toolbars but allow the in-place container to leave its toolbars up by
 	//   passing NULL as the pborderwidths parameter.
 	if (objIOleInPlaceActiveObject == null) return COM.S_OK;
 	RECT borderwidth = new RECT();
 	if (pborderwidths == 0 || currentdoc == null ) return COM.S_OK;
-		
+
 	COM.MoveMemory(borderwidth, pborderwidths, RECT.sizeof);
 	currentdoc.setBorderSpace(borderwidth);
 
@@ -697,12 +697,12 @@
 }
 /**
  *
- * Specify the menu items that should appear in the Container location when an OLE Document 
+ * Specify the menu items that should appear in the Container location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
@@ -709,7 +709,7 @@
  * <p>This method must be called before in place activation of the OLE Document.  After the Document
  * is activated, the menu bar will not be modified until a subsequent activation.
  *
- * @param containerMenus an array of top level MenuItems to be inserted into the Container location of 
+ * @param containerMenus an array of top level MenuItems to be inserted into the Container location of
  *        the menubar
  */
 public void setContainerMenus(MenuItem[] containerMenus){
@@ -729,12 +729,12 @@
 }
 /**
  *
- * Specify the menu items that should appear in the File location when an OLE Document 
+ * Specify the menu items that should appear in the File location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
@@ -741,7 +741,7 @@
  * <p>This method must be called before in place activation of the OLE Document.  After the Document
  * is activated, the menu bar will not be modified until a subsequent activation.
  *
- * @param fileMenus an array of top level MenuItems to be inserted into the File location of 
+ * @param fileMenus an array of top level MenuItems to be inserted into the File location of
  *        the menubar
  */
 public void setFileMenus(MenuItem[] fileMenus){
@@ -750,34 +750,34 @@
 private int SetMenu(int /*long*/ hmenuShared, int /*long*/ holemenu, int /*long*/ hwndActiveObject) {
 	int /*long*/ inPlaceActiveObject = 0;
 	if (objIOleInPlaceActiveObject != null)
-		inPlaceActiveObject = objIOleInPlaceActiveObject.getAddress();		
-	
+		inPlaceActiveObject = objIOleInPlaceActiveObject.getAddress();
+
 	Menu menubar = getShell().getMenuBar();
 	if (menubar == null || menubar.isDisposed()){
 		return COM.OleSetMenuDescriptor(0, getShell().handle, hwndActiveObject, iOleInPlaceFrame.getAddress(), inPlaceActiveObject);
 	}
-	
+
 	int /*long*/ handle = menubar.getShell().handle;
-	
+
 	if (hmenuShared == 0 && holemenu == 0) {
 		// re-instate the original menu - this occurs on deactivation
 		hmenuShared = menubar.handle;
 	}
 	if (hmenuShared == 0) return COM.E_FAIL;
-	
+
 	OS.SetMenu(handle, hmenuShared);
 	OS.DrawMenuBar(handle);
-	
+
 	return COM.OleSetMenuDescriptor(holemenu, handle, hwndActiveObject, iOleInPlaceFrame.getAddress(), inPlaceActiveObject);
 }
 /**
  *
- * Set the menu items that should appear in the Window location when an OLE Document 
+ * Set the menu items that should appear in the Window location when an OLE Document
  * is in-place activated.
  *
  * <p>When an OLE Document is in-place active, the Document provides its own menus but the application
  * is given the opportunity to merge some of its menus into the menubar.  The application
- * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window 
+ * is allowed to insert its menus in three locations: File (far left), Container(middle) and Window
  * (far right just before Help).  The OLE Document retains control of the Edit, Object and Help
  * menu locations.  Note that an application can insert more than one menu into a single location.
  *
@@ -784,7 +784,7 @@
  * <p>This method must be called before in place activation of the OLE Document.  After the Document
  * is activated, the menu bar will not be modified until a subsequent activation.
  *
- * @param windowMenus an array of top level MenuItems to be inserted into the Window location of 
+ * @param windowMenus an array of top level MenuItems to be inserted into the Window location of
  *        the menubar
  */
 public void setWindowMenus(MenuItem[] windowMenus){
@@ -799,12 +799,12 @@
 	Menu menubar = getShell().getMenuBar();
 	if (menubar == null || menubar.isDisposed() || !menubar.isEnabled()) return COM.S_FALSE;
 	if (wID < 0) return COM.S_FALSE;
-	
+
 	Shell shell = menubar.getShell();
 	int /*long*/ hwnd = shell.handle;
 	int /*long*/ hAccel = OS.SendMessage(hwnd, OS.WM_APP+1, 0, 0);
 	if (hAccel == 0) return COM.S_FALSE;
-	
+
 	MSG msg = new MSG();
 	OS.MoveMemory(msg, lpmsg, MSG.sizeof);
 	int result = OS.TranslateAccelerator(hwnd, hAccel, msg);
Index: org/eclipse/swt/browser/PromptDialog.java
===================================================================
--- org/eclipse/swt/browser/PromptDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/PromptDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -223,7 +223,7 @@
 		data.horizontalAlignment = GridData.FILL;
 		data.grabExcessHorizontalSpace = true;
 		label.setLayoutData (data);
-
+		
 		final Button[] buttons = new Button[4];
 		Listener listener = new Listener() {
 			public void handleEvent(Event event) {
@@ -312,7 +312,7 @@
 		data.horizontalAlignment = GridData.FILL;
 		data.grabExcessHorizontalSpace = true;
 		valueText.setLayoutData(data);
-
+				
 		final Button[] buttons = new Button[3];
 		Listener listener = new Listener() {
 			public void handleEvent(Event event) {
Index: org/eclipse/swt/browser/WindowCreator2.java
===================================================================
--- org/eclipse/swt/browser/WindowCreator2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/WindowCreator2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -131,8 +131,8 @@
 		int /*long*/[] result = new int /*long*/[1];
 		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_10_IID, result);
 		if (rc != XPCOM.NS_OK) {
-			rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
-			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
+		if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 		}
 		if (result[0] == 0) Mozilla.error (XPCOM.NS_ERROR_NO_INTERFACE);
 		webBrowser.Release ();
Index: org/eclipse/swt/browser/PromptService2Factory.java
===================================================================
--- org/eclipse/swt/browser/PromptService2Factory.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/PromptService2Factory.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -91,10 +91,10 @@
 	nsID guid = new nsID ();
 	XPCOM.memmove (guid, iid, nsID.sizeof);
 	if (guid.Equals (nsIPromptService2.NS_IPROMPTSERVICE2_IID) || guid.Equals(nsIPromptService.NS_IPROMPTSERVICE_IID)) {
-		PromptService2 promptService = new PromptService2 ();
-		promptService.AddRef ();
-		XPCOM.memmove (result, new int /*long*/[] {promptService.getAddress ()}, C.PTR_SIZEOF);
-		return XPCOM.NS_OK;
+	PromptService2 promptService = new PromptService2 ();
+	promptService.AddRef ();
+	XPCOM.memmove (result, new int /*long*/[] {promptService.getAddress ()}, C.PTR_SIZEOF);
+	return XPCOM.NS_OK;
 	}
 	if (guid.Equals (nsIPromptFactory.NS_IPROMPTFACTORY_IID)) {
 		PromptFactory promptFactory = new PromptFactory();
Index: org/eclipse/swt/browser/FilePicker_10.java
===================================================================
--- org/eclipse/swt/browser/FilePicker_10.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/FilePicker_10.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,49 +1,49 @@
-/*******************************************************************************
- * Copyright (c) 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.swt.browser;
-
-import org.eclipse.swt.internal.mozilla.*;
-
-class FilePicker_10 extends FilePicker_1_8 {
-
-void createCOMInterfaces () {
-	/* Create each of the interfaces that this object implements */
-	supports = new XPCOMObject (new int[] {2, 0, 0}) {
-		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
-		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
-		public int /*long*/ method2 (int /*long*/[] args) {return Release ();}
-	};
-
-	filePicker = new XPCOMObject (new int[] {2, 0, 0, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}) {
-		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
-		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
-		public int /*long*/ method2 (int /*long*/[] args) {return Release ();}
-		public int /*long*/ method3 (int /*long*/[] args) {return Init (args[0], args[1], (short)args[2]);}
-		public int /*long*/ method4 (int /*long*/[] args) {return AppendFilters ((int)/*64*/args[0]);}
-		public int /*long*/ method5 (int /*long*/[] args) {return AppendFilter (args[0], args[1]);}
-		public int /*long*/ method6 (int /*long*/[] args) {return GetDefaultString (args[0]);}
-		public int /*long*/ method7 (int /*long*/[] args) {return SetDefaultString (args[0]);}
-		public int /*long*/ method8 (int /*long*/[] args) {return GetDefaultExtension (args[0]);}
-		public int /*long*/ method9 (int /*long*/[] args) {return SetDefaultExtension (args[0]);}
-		public int /*long*/ method10 (int /*long*/[] args) {return GetFilterIndex (args[0]);}
-		public int /*long*/ method11 (int /*long*/[] args) {return SetFilterIndex ((int)/*64*/args[0]);}
-		public int /*long*/ method12 (int /*long*/[] args) {return GetDisplayDirectory (args[0]);}
-		public int /*long*/ method13 (int /*long*/[] args) {return SetDisplayDirectory (args[0]);}
-		public int /*long*/ method14 (int /*long*/[] args) {return GetFile (args[0]);}
-		public int /*long*/ method15 (int /*long*/[] args) {return GetFileURL (args[0]);}
-		public int /*long*/ method16 (int /*long*/[] args) {return GetFiles (args[0]);}
-		public int /*long*/ method17 (int /*long*/[] args) {return XPCOM.NS_ERROR_NOT_IMPLEMENTED;}
-		public int /*long*/ method18 (int /*long*/[] args) {return XPCOM.NS_ERROR_NOT_IMPLEMENTED;}
-		public int /*long*/ method19 (int /*long*/[] args) {return Show (args[0]);}
-	};
-}
-
-}
+/*******************************************************************************
+ * Copyright (c) 2012 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.swt.browser;
+
+import org.eclipse.swt.internal.mozilla.*;
+
+class FilePicker_10 extends FilePicker_1_8 {
+
+void createCOMInterfaces () {
+	/* Create each of the interfaces that this object implements */
+	supports = new XPCOMObject (new int[] {2, 0, 0}) {
+		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
+		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
+		public int /*long*/ method2 (int /*long*/[] args) {return Release ();}
+	};
+
+	filePicker = new XPCOMObject (new int[] {2, 0, 0, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}) {
+		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
+		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
+		public int /*long*/ method2 (int /*long*/[] args) {return Release ();}
+		public int /*long*/ method3 (int /*long*/[] args) {return Init (args[0], args[1], (short)args[2]);}
+		public int /*long*/ method4 (int /*long*/[] args) {return AppendFilters ((int)/*64*/args[0]);}
+		public int /*long*/ method5 (int /*long*/[] args) {return AppendFilter (args[0], args[1]);}
+		public int /*long*/ method6 (int /*long*/[] args) {return GetDefaultString (args[0]);}
+		public int /*long*/ method7 (int /*long*/[] args) {return SetDefaultString (args[0]);}
+		public int /*long*/ method8 (int /*long*/[] args) {return GetDefaultExtension (args[0]);}
+		public int /*long*/ method9 (int /*long*/[] args) {return SetDefaultExtension (args[0]);}
+		public int /*long*/ method10 (int /*long*/[] args) {return GetFilterIndex (args[0]);}
+		public int /*long*/ method11 (int /*long*/[] args) {return SetFilterIndex ((int)/*64*/args[0]);}
+		public int /*long*/ method12 (int /*long*/[] args) {return GetDisplayDirectory (args[0]);}
+		public int /*long*/ method13 (int /*long*/[] args) {return SetDisplayDirectory (args[0]);}
+		public int /*long*/ method14 (int /*long*/[] args) {return GetFile (args[0]);}
+		public int /*long*/ method15 (int /*long*/[] args) {return GetFileURL (args[0]);}
+		public int /*long*/ method16 (int /*long*/[] args) {return GetFiles (args[0]);}
+		public int /*long*/ method17 (int /*long*/[] args) {return XPCOM.NS_ERROR_NOT_IMPLEMENTED;}
+		public int /*long*/ method18 (int /*long*/[] args) {return XPCOM.NS_ERROR_NOT_IMPLEMENTED;}
+		public int /*long*/ method19 (int /*long*/[] args) {return Show (args[0]);}
+	};
+}
+
+}
Index: org/eclipse/swt/browser/WebKit.java
===================================================================
--- org/eclipse/swt/browser/WebKit.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebKit.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -101,7 +101,7 @@
 		 *
 		 * With earlier versions of Safari the Apple Application Support is installed in a stand-alone location, which
 		 * is pointed to by registry entry "HKEY_LOCAL_MACHINE\SOFTWARE\Apple Inc.\Apple Application Support\InstallDir".
-		 */
+		*/
 
 		String AASDirectory = readInstallDir ("SOFTWARE\\Apple Computer, Inc.\\Safari"); //$NON-NLS-1$
 		if (AASDirectory != null) {
@@ -117,19 +117,19 @@
 
 		if (AASDirectory != null) {
 			TCHAR buffer = new TCHAR (0, AASDirectory, true);
-			boolean success = OS.SetDllDirectory (buffer); /* should succeed on XP+SP1 and newer */
-			if (success) {
-				try {
-					Library.loadLibrary ("swt-webkit"); //$NON-NLS-1$
-					LibraryLoaded = true;
-				} catch (Throwable e) {
-					LibraryLoadError = "Failed to load the swt-webkit library"; //$NON-NLS-1$
+					boolean success = OS.SetDllDirectory (buffer); /* should succeed on XP+SP1 and newer */
+					if (success) {
+						try {
+							Library.loadLibrary ("swt-webkit"); //$NON-NLS-1$
+							LibraryLoaded = true;
+						} catch (Throwable e) {
+							LibraryLoadError = "Failed to load the swt-webkit library"; //$NON-NLS-1$
 					if (Device.DEBUG) System.out.println ("Failed to load swt-webkit library. Apple Application Support directory path: " + AASDirectory); //$NON-NLS-1$
-				}
-			} else {
-				LibraryLoadError = "Failed to add the Apple Application Support package to the library lookup path.  "; //$NON-NLS-1$
-				LibraryLoadError += "To use a SWT.WEBKIT-style Browser prepend " + AASDirectory + " to your Windows 'Path' environment variable and restart."; //$NON-NLS-1$ //$NON-NLS-2$
-			}
+						}
+					} else {
+						LibraryLoadError = "Failed to add the Apple Application Support package to the library lookup path.  "; //$NON-NLS-1$
+						LibraryLoadError += "To use a SWT.WEBKIT-style Browser prepend " + AASDirectory + " to your Windows 'Path' environment variable and restart."; //$NON-NLS-1$ //$NON-NLS-2$
+					}
 		} else {
 			LibraryLoadError = "Safari must be installed to use a SWT.WEBKIT-style Browser"; //$NON-NLS-1$
 		}
@@ -409,33 +409,33 @@
 				type = WebKit_win32.JSValueGetType (ctx, result[0]);
 				if (type == WebKit_win32.kJSTypeString) {
 					String token = (String)convertToJava (ctx, result[0]);
-					BrowserFunction function = (BrowserFunction)functions.get (key);
+				BrowserFunction function = (BrowserFunction)functions.get (key);
 					if (function != null && token.equals (function.token)) {
-						try {
+					try {
 							C.memmove (result, arguments + 2 * C.PTR_SIZEOF, C.PTR_SIZEOF);
-							Object temp = convertToJava (ctx, result[0]);
-							if (temp instanceof Object[]) {
-								Object[] args = (Object[])temp;
-								try {
-									returnValue = function.function (args);
-								} catch (Exception e) {
-									/* exception during function invocation */
-									returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
-								}
+						Object temp = convertToJava (ctx, result[0]);
+						if (temp instanceof Object[]) {
+							Object[] args = (Object[])temp;
+							try {
+								returnValue = function.function (args);
+							} catch (Exception e) {
+								/* exception during function invocation */
+								returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 							}
-						} catch (IllegalArgumentException e) {
-							/* invalid argument value type */
-							if (function.isEvaluate) {
-								/* notify the function so that a java exception can be thrown */
-								function.function (new String[] {WebBrowser.CreateErrorString (new SWTException (SWT.ERROR_INVALID_RETURN_VALUE).getLocalizedMessage ())});
-							}
-							returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 						}
+					} catch (IllegalArgumentException e) {
+						/* invalid argument value type */
+						if (function.isEvaluate) {
+							/* notify the function so that a java exception can be thrown */
+							function.function (new String[] {WebBrowser.CreateErrorString (new SWTException (SWT.ERROR_INVALID_RETURN_VALUE).getLocalizedMessage ())});
+						}
+						returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 					}
 				}
 			}
 		}
 	}
+	}
 	return convertToJS (ctx, returnValue);
 }
 
Index: org/eclipse/swt/browser/WebSite.java
===================================================================
--- org/eclipse/swt/browser/WebSite.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebSite.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -359,11 +359,11 @@
 			case OS.VK_O:
 				if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_MENU) >= 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
 					if (msg.wParam == OS.VK_N || IE.IEVersion >= 8) {
-						frame.setData(CONSUME_KEY, "false"); //$NON-NLS-1$
-						result = COM.S_OK;
-						break;
-					}
+					frame.setData(CONSUME_KEY, "false"); //$NON-NLS-1$
+					result = COM.S_OK;
+					break;
 				}
+				}
 				// FALL THROUGH
 			default:
 				OS.TranslateMessage(msg);
@@ -376,43 +376,43 @@
 		case OS.WM_KEYDOWN:
 		case OS.WM_KEYUP: {
 			if (!OS.IsWinCE) {
-				boolean isAccent = false;
-				switch ((int)/*64*/msg.wParam) {
-					case OS.VK_SHIFT:
-					case OS.VK_MENU:
-					case OS.VK_CONTROL:
-					case OS.VK_CAPITAL:
-					case OS.VK_NUMLOCK:
-					case OS.VK_SCROLL:
-						break;
-					default: {
-						/*
-						* Bug in Windows. The high bit in the result of MapVirtualKey() on
-						* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
-						* They should both be bit 32.  The fix is to test the right bit.
-						*/
-						int mapKey = OS.MapVirtualKey ((int)/*64*/msg.wParam, 2);
-						if (mapKey != 0) {
-							isAccent = (mapKey & (OS.IsWinNT ? 0x80000000 : 0x8000)) != 0;
-							if (!isAccent) {
-								for (int i=0; i<ACCENTS.length; i++) {
-									int value = OS.VkKeyScan (ACCENTS [i]);
-									if (value != -1 && (value & 0xFF) == msg.wParam) {
-										int state = value >> 8;
-										if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
-											(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
-											(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
-												if ((state & 0x7) != 0) isAccent = true;
-												break;
-										}
-									}
-								}
+	boolean isAccent = false;
+	switch ((int)/*64*/msg.wParam) {
+		case OS.VK_SHIFT:
+		case OS.VK_MENU:
+		case OS.VK_CONTROL:
+		case OS.VK_CAPITAL:
+		case OS.VK_NUMLOCK:
+		case OS.VK_SCROLL:
+			break;
+		default: {
+			/* 
+			* Bug in Windows. The high bit in the result of MapVirtualKey() on
+			* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
+			* They should both be bit 32.  The fix is to test the right bit.
+			*/
+			int mapKey = OS.MapVirtualKey ((int)/*64*/msg.wParam, 2);
+			if (mapKey != 0) {
+				isAccent = (mapKey & (OS.IsWinNT ? 0x80000000 : 0x8000)) != 0;
+				if (!isAccent) {
+					for (int i=0; i<ACCENTS.length; i++) {
+						int value = OS.VkKeyScan (ACCENTS [i]);
+						if (value != -1 && (value & 0xFF) == msg.wParam) {
+							int state = value >> 8;
+							if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
+								(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
+								(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
+									if ((state & 0x7) != 0) isAccent = true;
+									break;
 							}
 						}
-						break;
-					}
+		}
+	}
+			}
+			break;
+		}
 				}
-				if (isAccent) result = COM.S_OK;
+	if (isAccent) result = COM.S_OK;
 			}
 		}
 	}
@@ -495,13 +495,13 @@
 	return IE.INET_E_DEFAULT_ACTION;
 }
 
-int MapUrlToZone(int /*long*/ pwszUrl, int /*long*/ pdwZone, int dwFlags) {
+int MapUrlToZone(int /*long*/ pwszUrl, int /*long*/ pdwZone, int dwFlags) {	
 	/*
 	* Feature in IE.  HTML rendered in memory does not enable local links
 	* but the same HTML document loaded through a local file is permitted
 	* to follow local links.  The workaround is to return URLZONE_INTRANET
 	* instead of the default value URLZONE_LOCAL_MACHINE.
-	*/
+	*/	
 	IE ie = (IE)((Browser)getParent().getParent()).webBrowser;
 	/*
 	* For some reason IE8 invokes this function after the Browser has
@@ -508,8 +508,8 @@
 	* been disposed.  To detect this case check for ie.auto != null. 
 	*/
 	if (ie.auto != null && ie.isAboutBlank && !ie.untrustedText) {
-		COM.MoveMemory(pdwZone, new int[] {IE.URLZONE_INTRANET}, 4);
-		return COM.S_OK;
+	COM.MoveMemory(pdwZone, new int[] {IE.URLZONE_INTRANET}, 4);
+	return COM.S_OK;
 	}
 	return IE.INET_E_DEFAULT_ACTION;
 }
@@ -539,10 +539,10 @@
 		if (canExecuteApplets ()) {
 			policy = IE.URLPOLICY_JAVA_LOW;
 		} else {
-			policy = IE.URLPOLICY_JAVA_PROHIBIT;
-			ignoreNextMessage = true;
-		}
+		policy = IE.URLPOLICY_JAVA_PROHIBIT;
+		ignoreNextMessage = true;
 	}
+	}
 	if (dwAction == IE.URLACTION_ACTIVEX_RUN) {
 		GUID guid = new GUID();
 		COM.MoveMemory(guid, pContext, GUID.sizeof);
@@ -788,15 +788,15 @@
 	variant.dispose ();
 
 	if (pVarResult != 0) {
-		try {
-			variant = convertToJS (returnValue);
-		} catch (SWTException e) {
-			/* invalid return value type */
-			variant = convertToJS (WebBrowser.CreateErrorString (e.getLocalizedMessage ()));
+			try {
+				variant = convertToJS (returnValue);
+			} catch (SWTException e) {
+				/* invalid return value type */
+				variant = convertToJS (WebBrowser.CreateErrorString (e.getLocalizedMessage ()));
+			}
+			Variant.win32_copy (pVarResult, variant);
+			variant.dispose ();
 		}
-		Variant.win32_copy (pVarResult, variant);
-		variant.dispose ();
-	}
 	return COM.S_OK;
 }
 
@@ -872,85 +872,85 @@
 		return new Variant (((Number)value).doubleValue ());
 	}
 	if (value instanceof Object[]) {
-		/* get IHTMLDocument2 */
-		IE browser = (IE)((Browser)getParent ().getParent ()).webBrowser;
-		OleAutomation auto = browser.auto;
-		int[] rgdispid = auto.getIDsOfNames (new String[] {"Document"}); //$NON-NLS-1$
-		if (rgdispid == null) return new Variant ();
-		Variant pVarResult = auto.getProperty (rgdispid[0]);
-		if (pVarResult == null) return new Variant ();
-		if (pVarResult.getType () == COM.VT_EMPTY) {
+			/* get IHTMLDocument2 */
+			IE browser = (IE)((Browser)getParent ().getParent ()).webBrowser;
+			OleAutomation auto = browser.auto;
+			int[] rgdispid = auto.getIDsOfNames (new String[] {"Document"}); //$NON-NLS-1$
+			if (rgdispid == null) return new Variant ();
+			Variant pVarResult = auto.getProperty (rgdispid[0]);
+			if (pVarResult == null) return new Variant ();
+			if (pVarResult.getType () == COM.VT_EMPTY) {
+				pVarResult.dispose ();
+				return new Variant ();
+			}
+			OleAutomation document = pVarResult.getAutomation ();
 			pVarResult.dispose ();
-			return new Variant ();
-		}
-		OleAutomation document = pVarResult.getAutomation ();
-		pVarResult.dispose ();
 
-		/* get IHTMLWindow2 */
-		rgdispid = document.getIDsOfNames (new String[] {"parentWindow"}); //$NON-NLS-1$
-		if (rgdispid == null) {
+			/* get IHTMLWindow2 */
+			rgdispid = document.getIDsOfNames (new String[] {"parentWindow"}); //$NON-NLS-1$
+			if (rgdispid == null) {
+				document.dispose ();
+				return new Variant ();
+			}
+			pVarResult = document.getProperty (rgdispid[0]);
+			if (pVarResult == null || pVarResult.getType () == COM.VT_EMPTY) {
+				if (pVarResult != null) pVarResult.dispose ();
+				document.dispose ();
+				return new Variant ();	
+			}
+			OleAutomation ihtmlWindow2 = pVarResult.getAutomation ();
+			pVarResult.dispose ();
 			document.dispose ();
-			return new Variant ();
-		}
-		pVarResult = document.getProperty (rgdispid[0]);
-		if (pVarResult == null || pVarResult.getType () == COM.VT_EMPTY) {
-			if (pVarResult != null) pVarResult.dispose ();
-			document.dispose ();
-			return new Variant ();	
-		}
-		OleAutomation ihtmlWindow2 = pVarResult.getAutomation ();
-		pVarResult.dispose ();
-		document.dispose ();
 
-		/* create a new JS array to be returned */
-		rgdispid = ihtmlWindow2.getIDsOfNames (new String[] {"Array"}); //$NON-NLS-1$
-		if (rgdispid == null) {
+			/* create a new JS array to be returned */
+			rgdispid = ihtmlWindow2.getIDsOfNames (new String[] {"Array"}); //$NON-NLS-1$
+			if (rgdispid == null) {
+				ihtmlWindow2.dispose ();
+				return new Variant ();
+			}
+			Variant arrayType = ihtmlWindow2.getProperty (rgdispid[0]);
 			ihtmlWindow2.dispose ();
-			return new Variant ();
-		}
-		Variant arrayType = ihtmlWindow2.getProperty (rgdispid[0]);
-		ihtmlWindow2.dispose ();
-		IDispatch arrayTypeDispatch = arrayType.getDispatch ();
-		int /*long*/[] result = new int /*long*/[1];
-		int rc = arrayTypeDispatch.QueryInterface (COM.IIDIDispatchEx, result);
+			IDispatch arrayTypeDispatch = arrayType.getDispatch ();
+			int /*long*/[] result = new int /*long*/[1];
+			int rc = arrayTypeDispatch.QueryInterface (COM.IIDIDispatchEx, result);
 		arrayType.dispose ();
-		if (rc != COM.S_OK) return new Variant ();
+			if (rc != COM.S_OK) return new Variant ();
 
-		IDispatchEx arrayTypeDispatchEx = new IDispatchEx (result[0]);
-		result[0] = 0;
-		int /*long*/ resultPtr = OS.GlobalAlloc (OS.GMEM_FIXED | OS.GMEM_ZEROINIT, VARIANT.sizeof);
-		DISPPARAMS params = new DISPPARAMS ();
-		rc = arrayTypeDispatchEx.InvokeEx (COM.DISPID_VALUE, COM.LOCALE_USER_DEFAULT, COM.DISPATCH_CONSTRUCT, params, resultPtr, null, 0);
-		if (rc != COM.S_OK) {
+			IDispatchEx arrayTypeDispatchEx = new IDispatchEx (result[0]);
+			result[0] = 0;
+			int /*long*/ resultPtr = OS.GlobalAlloc (OS.GMEM_FIXED | OS.GMEM_ZEROINIT, VARIANT.sizeof);
+			DISPPARAMS params = new DISPPARAMS ();
+			rc = arrayTypeDispatchEx.InvokeEx (COM.DISPID_VALUE, COM.LOCALE_USER_DEFAULT, COM.DISPATCH_CONSTRUCT, params, resultPtr, null, 0);
+			if (rc != COM.S_OK) {
+				OS.GlobalFree (resultPtr);
+				return new Variant ();	
+			}
+			Variant array = Variant.win32_new (resultPtr);
 			OS.GlobalFree (resultPtr);
-			return new Variant ();	
-		}
-		Variant array = Variant.win32_new (resultPtr);
-		OS.GlobalFree (resultPtr);
 
-		/* populate the array */
+			/* populate the array */
 		Object[] arrayValue = (Object[])value;
 		int length = arrayValue.length;
-		auto = array.getAutomation ();
-		int[] rgdispids = auto.getIDsOfNames (new String[] {"push"}); //$NON-NLS-1$
-		if (rgdispids != null) {
-			for (int i = 0; i < length; i++) {
-				Object currentObject = arrayValue[i];
-				try {
-					Variant variant = convertToJS (currentObject);
-					auto.invoke (rgdispids[0], new Variant[] {variant});
-					variant.dispose ();
-				} catch (SWTException e) {
-					/* invalid return value type */
-					auto.dispose ();
-					array.dispose ();
-					throw e;
+			auto = array.getAutomation ();
+			int[] rgdispids = auto.getIDsOfNames (new String[] {"push"}); //$NON-NLS-1$
+			if (rgdispids != null) {
+				for (int i = 0; i < length; i++) {
+					Object currentObject = arrayValue[i];
+					try {
+						Variant variant = convertToJS (currentObject);
+						auto.invoke (rgdispids[0], new Variant[] {variant});
+						variant.dispose ();
+					} catch (SWTException e) {
+						/* invalid return value type */
+						auto.dispose ();
+						array.dispose ();
+						throw e;
+					}
 				}
 			}
+			auto.dispose ();
+			return array;
 		}
-		auto.dispose ();
-		return array;
-	}
 	SWT.error (SWT.ERROR_INVALID_RETURN_VALUE);
 	return null;
 }
Index: org/eclipse/swt/browser/FilePickerFactory.java
===================================================================
--- org/eclipse/swt/browser/FilePickerFactory.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/FilePickerFactory.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -97,9 +97,9 @@
 		picker.AddRef ();
 		XPCOM.memmove (result, new int /*long*/[] {picker.getAddress ()}, C.PTR_SIZEOF);
 	} else {
-		FilePicker picker = new FilePicker ();
-		picker.AddRef ();
-		XPCOM.memmove (result, new int /*long*/[] {picker.getAddress ()}, C.PTR_SIZEOF);
+	FilePicker picker = new FilePicker ();
+	picker.AddRef ();
+	XPCOM.memmove (result, new int /*long*/[] {picker.getAddress ()}, C.PTR_SIZEOF);
 	}
 	return XPCOM.NS_OK;
 }
Index: org/eclipse/swt/browser/WebUIDelegate.java
===================================================================
--- org/eclipse/swt/browser/WebUIDelegate.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebUIDelegate.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -254,7 +254,7 @@
 	hr = privateFrame.getPrintedPageCount (printDC, count);
 	if (hr != COM.S_OK || count[0] == 0) {
 		privateFrame.Release ();
-		return COM.S_OK;
+	return COM.S_OK;
 	}
 	int pageCount = count[0];
 	String jobName = null;
Index: org/eclipse/swt/browser/Mozilla.java
===================================================================
--- org/eclipse/swt/browser/Mozilla.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/Mozilla.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -60,7 +60,7 @@
 	static AppFileLocProvider LocationProvider;
 	static WindowCreator2 WindowCreator;
 	static int BrowserCount, NextJSFunctionIndex = 1;
-	static Hashtable AllFunctions = new Hashtable ();
+	static Hashtable AllFunctions = new Hashtable (); 
 	static Listener DisplayListener;
 	static boolean Initialized, IsPre_1_8, IsPre_1_9, IsPre_4, IsXULRunner, PerformedVersionCheck, XPCOMWasGlued, XPCOMInitWasGlued;
 	static boolean IsGettingSiteWindow;
@@ -462,7 +462,7 @@
 					}
 				}
 				if (!XPCOM.NS_Free (pathBytes_NSFree, cookieString)) {
-					C.free (cookieString);
+				C.free (cookieString);
 				}
 
 				String allCookies = new String (MozillaDelegate.mbcsToWcs (null, bytes));
@@ -556,119 +556,119 @@
 }
 
 static void LoadLibraries () {
-	boolean initLoaded = false;
+		boolean initLoaded = false;
 
 	if (Boolean.getBoolean (GRE_INITIALIZED)) {
-		/* 
-		 * Another browser has already initialized xulrunner in this process,
-		 * so just bind to it instead of trying to initialize a new one.
-		 */
-		Initialized = true;
-	}
+			/* 
+			 * Another browser has already initialized xulrunner in this process,
+			 * so just bind to it instead of trying to initialize a new one.
+			 */
+			Initialized = true;
+		}
 
 	MozillaPath = System.getProperty (XULRUNNER_PATH);
-	/*
-	* Browser clients that ship XULRunner in a plug-in must have an opportunity 
-	* to set the org.eclipse.swt.browser.XULRunnerPath system property to point
-	* at their XULRunner before the first Mozilla-based Browser is created.  To
-	* facilitate this, reflection is used to reference non-existent class
-	* org.eclipse.swt.browser.XULRunnerInitializer the first time a Mozilla-
-	* based Browser is created.   A client wishing to use this hook can do so
-	* by creating a fragment of org.eclipse.swt that implements this class and
-	* sets the system property in its static initializer.
-	*/
+		/*
+		* Browser clients that ship XULRunner in a plug-in must have an opportunity 
+		* to set the org.eclipse.swt.browser.XULRunnerPath system property to point
+		* at their XULRunner before the first Mozilla-based Browser is created.  To
+		* facilitate this, reflection is used to reference non-existent class
+		* org.eclipse.swt.browser.XULRunnerInitializer the first time a Mozilla-
+		* based Browser is created.   A client wishing to use this hook can do so
+		* by creating a fragment of org.eclipse.swt that implements this class and
+		* sets the system property in its static initializer.
+		*/
 	if (MozillaPath == null) {
-		try {
-			Class.forName ("org.eclipse.swt.browser.XULRunnerInitializer"); //$NON-NLS-1$
+			try {
+				Class.forName ("org.eclipse.swt.browser.XULRunnerInitializer"); //$NON-NLS-1$
 			MozillaPath = System.getProperty (XULRUNNER_PATH);
-		} catch (ClassNotFoundException e) {
-			/* no fragment is providing this class, which is the typical case */
+			} catch (ClassNotFoundException e) {
+				/* no fragment is providing this class, which is the typical case */
+			}
 		}
-	}
 
 	if (MozillaPath == null) {
-		try {
+			try {
 			String libName = MozillaDelegate.getSWTInitLibraryName ();
-			Library.loadLibrary (libName);
-			initLoaded = true;
-		} catch (UnsatisfiedLinkError e) {
-			/* 
-			* If this library failed to load then do not attempt to detect a
-			* xulrunner to use.  The Browser may still be usable if MOZILLA_FIVE_HOME
-			* points at a GRE. 
-			*/
-		}
-	} else {
-		/* ensure that client-supplied path is using correct separators */
-		if (SEPARATOR_OS == '/') {
+				Library.loadLibrary (libName);
+				initLoaded = true;
+			} catch (UnsatisfiedLinkError e) {
+				/* 
+				* If this library failed to load then do not attempt to detect a
+				* xulrunner to use.  The Browser may still be usable if MOZILLA_FIVE_HOME
+				* points at a GRE. 
+				*/
+			}
+		} else {
+			/* ensure that client-supplied path is using correct separators */
+			if (SEPARATOR_OS == '/') {
 			MozillaPath = MozillaPath.replace ('\\', SEPARATOR_OS);
-		} else {
+			} else {
 			MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
-		}
+			}
 
 		MozillaPath += SEPARATOR_OS + MozillaDelegate.getLibraryName ();
 		IsXULRunner = true;
-	}
+		}
 
-	if (initLoaded) {
-		/* attempt to discover a XULRunner to use as the GRE */
+		if (initLoaded) {
+			/* attempt to discover a XULRunner to use as the GRE */
 		MozillaPath = InitDiscoverXULRunner ();
 		IsXULRunner = MozillaPath.length () > 0;
 
-		/*
-		 * Test whether the detected XULRunner can be used as the GRE before loading swt's
-		 * XULRunner library.  If it cannot be used then fall back to attempting to use
-		 * the GRE pointed to by MOZILLA_FIVE_HOME.
-		 * 
-		 * One case where this will fail is attempting to use a 64-bit xulrunner while swt
-		 * is running in 32-bit mode, or vice versa.
-		 */
+				/*
+				 * Test whether the detected XULRunner can be used as the GRE before loading swt's
+				 * XULRunner library.  If it cannot be used then fall back to attempting to use
+				 * the GRE pointed to by MOZILLA_FIVE_HOME.
+				 * 
+				 * One case where this will fail is attempting to use a 64-bit xulrunner while swt
+				 * is running in 32-bit mode, or vice versa.
+				 */
 		if (IsXULRunner) {
 			byte[] bytes = MozillaDelegate.wcsToMbcs (null, MozillaPath, true);
 			int rc = XPCOMInit.XPCOMGlueStartup (bytes);
-			if (rc != XPCOM.NS_OK) {
+					if (rc != XPCOM.NS_OK) {
 				MozillaPath = MozillaPath.substring (0, MozillaPath.lastIndexOf (SEPARATOR_OS));
 				if (Device.DEBUG) System.out.println ("cannot use detected XULRunner: " + MozillaPath); //$NON-NLS-1$
 
-				/* attempt to XPCOMGlueStartup the GRE pointed at by MOZILLA_FIVE_HOME */
-				int /*long*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
-				if (ptr == 0) {
+						/* attempt to XPCOMGlueStartup the GRE pointed at by MOZILLA_FIVE_HOME */
+						int /*long*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
+						if (ptr == 0) {
 					IsXULRunner = false;
-				} else {
-					int length = C.strlen (ptr);
+						} else {
+						int length = C.strlen (ptr);
 					bytes = new byte[length];
 					C.memmove (bytes, ptr, length);
 					MozillaPath = new String (MozillaDelegate.mbcsToWcs (null, bytes));
-					/*
-					 * Attempting to XPCOMGlueStartup a mozilla-based GRE != xulrunner can
-					 * crash, so don't attempt unless the GRE appears to be xulrunner.
-					 */
+							/*
+							 * Attempting to XPCOMGlueStartup a mozilla-based GRE != xulrunner can
+							 * crash, so don't attempt unless the GRE appears to be xulrunner.
+							 */
 					if (MozillaPath.indexOf ("xulrunner") == -1) { //$NON-NLS-1$
 						IsXULRunner = false;	
-					} else {
+							} else {
 						MozillaPath += SEPARATOR_OS + MozillaDelegate.getLibraryName ();
 						bytes = MozillaDelegate.wcsToMbcs (null, MozillaPath, true);
 						rc = XPCOMInit.XPCOMGlueStartup (bytes);
-						if (rc == XPCOM.NS_OK) {
-							/* ensure that client-supplied path is using correct separators */
-							if (SEPARATOR_OS == '/') {
+							if (rc == XPCOM.NS_OK) {
+								/* ensure that client-supplied path is using correct separators */
+								if (SEPARATOR_OS == '/') {
 								MozillaPath = MozillaPath.replace ('\\', SEPARATOR_OS);
+								} else {
+								MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
+								}
 							} else {
-								MozillaPath = MozillaPath.replace ('/', SEPARATOR_OS);
-							}
-						} else {
 							IsXULRunner = false;
 							MozillaPath = MozillaPath.substring (0, MozillaPath.lastIndexOf (SEPARATOR_OS));
 							if (Device.DEBUG) System.out.println ("failed to start as XULRunner: " + MozillaPath); //$NON-NLS-1$
-						}
+								}
+							}
+						} 
 					}
-				} 
-			}
 			if (IsXULRunner) {
-				XPCOMInitWasGlued = true;
+						XPCOMInitWasGlued = true;
+					}
+				}
 			}
-		}
-	}
 }
 
 public void create (Composite parent, int style) {
@@ -686,7 +686,7 @@
 			/*
 			* If style SWT.MOZILLA was specified then this initialization has already
 			* failed, because SWT.MOZILLA-style Browsers must utilize XULRunner.
-			*/
+			 */ 
 			if ((style & SWT.MOZILLA) != 0) {
 				browser.dispose ();
 				String errorString = (MozillaPath != null && MozillaPath.length () > 0) ?
@@ -711,7 +711,7 @@
 
 			/* invoke appropriate Init function (based on mozilla version) */
 			initXPCOM (MozillaPath, IsXULRunner);
-		}
+				}
 
 		/* attempt to initialize JavaXPCOM in the detected XULRunner */
 		if (IsXULRunner) initJavaXPCOM (MozillaPath);
@@ -721,21 +721,21 @@
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+				}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+			}
 		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
 		result[0] = 0;
 
 		rc = XPCOM.NS_GetServiceManager (result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
-			error (rc);
-		}
+			if (rc != XPCOM.NS_OK) {
+				browser.dispose ();
+				error (rc);
+			}
 		if (result[0] == 0) {
-			browser.dispose ();
+				browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
@@ -752,7 +752,7 @@
 
 		/* init our WindowCreator, which mozilla uses for the creation of child browsers in external Shells */
 		if (!factoriesRegistered) {
-			initWindowCreator (serviceManager);
+		initWindowCreator (serviceManager);
 		}
 
 		/* notify mozilla that the profile directory has been changed from its default value */
@@ -761,7 +761,7 @@
 		/* init preference values that give desired mozilla behaviours */ 
 		initPreferences (serviceManager, componentManager);
 
-		/* init our various factories that mozilla can invoke as needed */
+		/* init our various factories that mozilla can invoke as needed */ 
 		if (!factoriesRegistered) {
 			initFactories (serviceManager, componentManager, IsXULRunner);
 		}
@@ -776,7 +776,7 @@
 		MozillaPendingCookies = null;
 
 		Initialized = true;
-	}
+			}
 
 	BrowserCount++;
 
@@ -783,34 +783,34 @@
 	if (display.getData (DISPOSE_LISTENER_HOOKED) == null) {
 		display.setData (DISPOSE_LISTENER_HOOKED, DISPOSE_LISTENER_HOOKED);
 		display.addListener (SWT.Dispose, DisplayListener);
-	}
+		}
 
 	/* get the nsIComponentManager, used throughout initialization */
-	int rc = XPCOM.NS_GetComponentManager (result);
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
-	if (result[0] == 0) {
-		browser.dispose ();
-		error (XPCOM.NS_NOINTERFACE);
-	}
-	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
-	result[0] = 0;
+		int rc = XPCOM.NS_GetComponentManager (result);
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
+		if (result[0] == 0) {
+			browser.dispose ();
+			error (XPCOM.NS_NOINTERFACE);
+		}
+		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
+		result[0] = 0;
 
 	/* create the nsIWebBrowser instance */
 	rc = componentManager.CreateInstance (XPCOM.NS_IWEBBROWSER_CID, 0, nsIWebBrowser.NS_IWEBBROWSER_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
 		rc = componentManager.CreateInstance (XPCOM.NS_IWEBBROWSER_CID, 0, nsIWebBrowser.NS_IWEBBROWSER_IID, result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
-			error (rc);
-		}
+			if (rc != XPCOM.NS_OK) {
+				browser.dispose ();
+				error (rc);
+			}
 	}
-	if (result[0] == 0) {
-		browser.dispose ();
-		error (XPCOM.NS_NOINTERFACE);	
-	}
+			if (result[0] == 0) {
+				browser.dispose ();
+				error (XPCOM.NS_NOINTERFACE);
+			}
 	webBrowser = new nsIWebBrowser (result[0]);
 	result[0] = 0;
 
@@ -823,7 +823,7 @@
 
 	if (!PerformedVersionCheck) {
 		PerformedVersionCheck = true;
-
+		
 		rc = componentManager.QueryInterface (nsIComponentRegistrar.NS_ICOMPONENTREGISTRAR_IID, result);
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
@@ -834,12 +834,12 @@
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		nsIComponentRegistrar componentRegistrar = new nsIComponentRegistrar (result[0]);
-		result[0] = 0;
+		result[0] = 0;		
 
 		/*
-		* Check for the property indicating that factories have already been registered,
-		* in which case this browser should not overwrite them with its own.
-		*/
+		 * Check for the property indicating that factories have already been registered,
+		 * in which case this browser should not overwrite them with its own.
+		 */
 		boolean factoriesRegistered = Boolean.getBoolean (FACTORIES_REGISTERED);
 
 		/*
@@ -847,14 +847,14 @@
 		* to determine if the GRE's version is < 1.8.
 		*/
 		rc = webBrowser.QueryInterface (nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
+			if (rc != XPCOM.NS_OK) {
+				browser.dispose ();
 			error (XPCOM.NS_ERROR_FAILURE);
-		}
-		if (result[0] == 0) {
-			browser.dispose ();
+			}
+			if (result[0] == 0) {
+				browser.dispose ();
 			error (XPCOM.NS_ERROR_NO_INTERFACE);
-		}
+			}
 		nsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor (result[0]);
 		result[0] = 0;
 
@@ -865,7 +865,7 @@
 		}
 		IsPre_1_9 = true;
 		IsPre_4 = true;
-		result[0] = 0;
+			result[0] = 0;
 
 		/*
 		* A Download factory for contract "Transfer" must be registered iff the GRE's version is 1.8.x.
@@ -883,16 +883,16 @@
 				result[0] = 0;
 
 				if (!factoriesRegistered) {
-					DownloadFactory_1_8 downloadFactory_1_8 = new DownloadFactory_1_8 ();
-					downloadFactory_1_8.AddRef ();
+				DownloadFactory_1_8 downloadFactory_1_8 = new DownloadFactory_1_8 ();
+				downloadFactory_1_8.AddRef ();
 					byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_TRANSFER_CONTRACTID, true);
 					byte[] aClassName = MozillaDelegate.wcsToMbcs (null, "swtTransfer", true); //$NON-NLS-1$
-					rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory_1_8.getAddress ());
-					if (rc != XPCOM.NS_OK) {
-						browser.dispose ();
-						error (rc);
-					}
-					downloadFactory_1_8.Release ();
+				rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory_1_8.getAddress ());
+	            	if (rc != XPCOM.NS_OK) {
+	            		browser.dispose ();
+	            		error (rc);
+	            	}
+				downloadFactory_1_8.Release ();
 				}
 			} else { /* >= 1.9 */
 				IsPre_1_9 = false;
@@ -903,7 +903,7 @@
 					new nsISupports (result[0]).Release();
 				}
 			}
-		}
+				}
 		result[0] = 0;
 		interfaceRequestor.Release ();
 		componentRegistrar.Release ();
@@ -922,10 +922,10 @@
 		}
 		
 		System.setProperty (FACTORIES_REGISTERED, TRUE);
-	}
+	        }
 	componentManager.Release ();
 
-	/*
+		/*
 	 * Bug in XULRunner 1.9.  On win32, Mozilla does not clear its background before content has
 	 * been set into it.  As a result, embedders appear broken if they do not immediately display
 	 * a URL or text.  The Mozilla bug for this is https://bugzilla.mozilla.org/show_bug.cgi?id=453523.
@@ -932,7 +932,7 @@
 	 * 
 	 * The workaround is to subclass the Mozilla window and clear it whenever WM_ERASEBKGND is received.
 	 * This subclass should be removed once content has been set into the browser.
-	 */
+		 */
 	if (!IsPre_1_9) {
 		delegate.addWindowSubclass ();
 	}
@@ -939,15 +939,15 @@
 
 	/* add listeners for progress and content */
 	rc = webBrowser.AddWebBrowserListener (weakReference.getAddress (), nsIWebProgressListener.NS_IWEBPROGRESSLISTENER_IID);
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
 	rc = webBrowser.SetParentURIContentListener (uriContentListener.getAddress ());
-	if (rc != XPCOM.NS_OK) {
-		browser.dispose ();
-		error (rc);
-	}
+		if (rc != XPCOM.NS_OK) {
+			browser.dispose ();
+			error (rc);
+		}
 
 	delegate.init ();
 
@@ -959,13 +959,13 @@
 					if (ignoreDispose) {
 						ignoreDispose = false;
 						break;
-					}
+			}
 					ignoreDispose = true;
 					browser.notifyListeners (event.type, event);
 					event.type = SWT.NONE;
 					onDispose (event.display);
 					break;
-				}
+			}
 				case SWT.Resize: onResize (); break;
 				case SWT.FocusIn: {
 					Activate ();
@@ -1022,25 +1022,25 @@
 					Display display = event.display;
 					if (Mozilla.this.browser == display.getFocusControl ()) Deactivate ();
 					break;
-				}
+			}
 				case SWT.Show: {
-					/*
+		/*
 					* Feature in GTK Mozilla.  Mozilla does not show up when
 					* its container (a GTK fixed handle) is made visible
 					* after having been hidden.  The workaround is to reset
 					* its size after the container has been made visible. 
-					*/
+		 */
 					Display display = event.display;
 					display.asyncExec(new Runnable () {
 						public void run() {
 							if (browser.isDisposed ()) return;
 							onResize ();
-						}
+			}
 					});
 					break;
-				}
 			}
 		}
+				}
 	};	
 	int[] folderEvents = new int[] {
 		SWT.Dispose,
@@ -1053,7 +1053,7 @@
 	};
 	for (int i = 0; i < folderEvents.length; i++) {
 		browser.addListener (folderEvents[i], listener);
-	}
+		}
 }
 
 public boolean back () {
@@ -1063,7 +1063,7 @@
 	int rc = webBrowser.QueryInterface (nsIWebNavigation.NS_IWEBNAVIGATION_IID, result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
-	
+
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);		 	
 	rc = webNavigation.GoBack ();	
 	webNavigation.Release ();
@@ -1079,7 +1079,7 @@
 				/* implies that the user did not veto the page unload */
 				result[0] = true;
 			}
-		} 
+		}
 	};
 	execute ("window.location.replace('about:blank');"); //$NON-NLS-1$
 	locationListeners = oldListeners;
@@ -1093,7 +1093,7 @@
 		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
 		public int /*long*/ method2 (int /*long*/[] args) {return Release ();}
 	};
-	
+
 	weakReference = new XPCOMObject (new int[] {2, 0, 0, 2}) {
 		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
 		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
@@ -1111,7 +1111,7 @@
 		public int /*long*/ method6 (int /*long*/[] args) {return OnStatusChange (args[0], args[1], (int)/*64*/args[2], args[3]);}
 		public int /*long*/ method7 (int /*long*/[] args) {return OnSecurityChange (args[0], args[1], (int)/*64*/args[2]);}
 	};
-	
+
 	webBrowserChrome = new XPCOMObject (new int[] {2, 0, 0, 2, 1, 1, 1, 1, 0, 2, 0, 1, 1}) {
 		public int /*long*/ method0 (int /*long*/[] args) {return QueryInterface (args[0], args[1]);}
 		public int /*long*/ method1 (int /*long*/[] args) {return AddRef ();}
@@ -1265,15 +1265,15 @@
 	if (badCertListener != null) {
 		badCertListener.dispose ();
 		badCertListener = null;
-	}
+		}
 }
 
 public boolean execute (String script) {
-	/*
+		/*
 	* This could be the first content that is set into the browser, so
 	* ensure that the custom subclass that works around Mozilla bug
 	* https://bugzilla.mozilla.org/show_bug.cgi?id=453523 is removed.
-	*/
+		*/
 	delegate.removeWindowSubclass ();
 
 	/*
@@ -1298,7 +1298,7 @@
 			result[0] = 0;
 			rc = serviceManager.GetServiceByContractID (aContractID, nsIScriptSecurityManager.NS_ISCRIPTSECURITYMANAGER_191_IID, result);
 			if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
-				result[0] = 0;
+			result[0] = 0;
 				rc = serviceManager.GetServiceByContractID (aContractID, nsIScriptSecurityManager.NS_ISCRIPTSECURITYMANAGER_IID, result);
 				if (rc == XPCOM.NS_OK && result[0] != 0) {
 					isXULRunner190x = true;
@@ -1306,53 +1306,53 @@
 			}
 		}
 
-		if (rc == XPCOM.NS_OK && result[0] != 0) {
+			if (rc == XPCOM.NS_OK && result[0] != 0) {
 			nsIScriptSecurityManager securityManager = new nsIScriptSecurityManager (result[0]);
-			result[0] = 0;
-			rc = securityManager.GetSystemPrincipal (result);
-			securityManager.Release ();
+				result[0] = 0;
+				rc = securityManager.GetSystemPrincipal (result);
+				securityManager.Release ();
 
 			if (rc == XPCOM.NS_OK && result[0] != 0) {
 				nsIPrincipal principal = new nsIPrincipal (result[0]);
 				result[0] = 0;
-				rc = webBrowser.QueryInterface (nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);
-				if (rc != XPCOM.NS_OK) error (rc);
+			rc = webBrowser.QueryInterface (nsIInterfaceRequestor.NS_IINTERFACEREQUESTOR_IID, result);
+			if (rc != XPCOM.NS_OK) error (rc);
 				if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 
-				nsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor (result[0]);
-				result[0] = 0;
+			nsIInterfaceRequestor interfaceRequestor = new nsIInterfaceRequestor (result[0]);
+			result[0] = 0;
 				nsID scriptGlobalObjectNSID_10 = new nsID ("08f73284-26e3-4fa6-bf89-8326f92a94b3"); /* nsIScriptGlobalObject */ //$NON-NLS-1$
 				rc = interfaceRequestor.GetInterface (scriptGlobalObjectNSID_10, result);
-				if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
-					result[0] = 0;
-					nsID scriptGlobalObjectNSID_1_9_2 = new nsID ("e9f3f2c1-2d94-4722-bbd4-2bf6fdf42f48"); /* nsIScriptGlobalObject */ //$NON-NLS-1$
-					rc = interfaceRequestor.GetInterface (scriptGlobalObjectNSID_1_9_2, result);
+			if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
+				result[0] = 0;
+				nsID scriptGlobalObjectNSID_1_9_2 = new nsID ("e9f3f2c1-2d94-4722-bbd4-2bf6fdf42f48"); /* nsIScriptGlobalObject */ //$NON-NLS-1$
+				rc = interfaceRequestor.GetInterface (scriptGlobalObjectNSID_1_9_2, result);
 					if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
 						result[0] = 0;
 						nsID scriptGlobalObjectNSID_1_9 = new nsID ("6afecd40-0b9a-4cfd-8c42-0f645cd91829"); /* nsIScriptGlobalObject */ //$NON-NLS-1$
 						rc = interfaceRequestor.GetInterface (scriptGlobalObjectNSID_1_9, result);
 					}
-				}
-				interfaceRequestor.Release ();
-
-				if (rc == XPCOM.NS_OK && result[0] != 0) {
-					int /*long*/ scriptGlobalObject = result[0];
-					result[0] = 0;
-					rc = (int/*64*/)XPCOM.nsIScriptGlobalObject_EnsureScriptEnvironment (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
+		}
+			interfaceRequestor.Release ();
+		
+			if (rc == XPCOM.NS_OK && result[0] != 0) {
+				int /*long*/ scriptGlobalObject = result[0];
+		result[0] = 0;
+				rc = (int/*64*/)XPCOM.nsIScriptGlobalObject_EnsureScriptEnvironment (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
 					if (rc != XPCOM.NS_OK) {
 						new nsISupports (scriptGlobalObject).Release ();
 					} else {
-						int /*long*/ scriptContext = XPCOM.nsIScriptGlobalObject_GetScriptContext (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
-						new nsISupports (scriptGlobalObject).Release ();
+				int /*long*/ scriptContext = XPCOM.nsIScriptGlobalObject_GetScriptContext (scriptGlobalObject, 2); /* nsIProgrammingLanguage.JAVASCRIPT */
+				new nsISupports (scriptGlobalObject).Release ();
 
 						if (scriptContext != 0) {
-							/* ensure that the received nsIScriptContext implements the expected interface */
+					/* ensure that the received nsIScriptContext implements the expected interface */
 							nsISupports supports = new nsISupports (scriptContext);
 							nsID scriptContextNSID_10 = new nsID ("2e583bf4-3c1f-432d-8283-8dee7eccc88b"); /* nsIScriptContext */ //$NON-NLS-1$					
 							rc = supports.QueryInterface (scriptContextNSID_10, result);
-							if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
-								result[0] = 0;
-								nsID scriptContextNSID_1_9_2 = new nsID ("87482b5e-e019-4df5-9bc2-b2a51b1f2d28"); /* nsIScriptContext */ //$NON-NLS-1$					
+					if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
+						result[0] = 0;
+						nsID scriptContextNSID_1_9_2 = new nsID ("87482b5e-e019-4df5-9bc2-b2a51b1f2d28"); /* nsIScriptContext */ //$NON-NLS-1$					
 								rc = supports.QueryInterface (scriptContextNSID_1_9_2, result);
 								if (!(rc == XPCOM.NS_OK && result[0] != 0)) {
 									result[0] = 0;
@@ -1359,57 +1359,57 @@
 									nsID scriptContextNSID_1_9 = new nsID ("e7b9871d-3adc-4bf7-850d-7fb9554886bf"); /* nsIScriptContext */ //$NON-NLS-1$					
 									rc = supports.QueryInterface (scriptContextNSID_1_9, result);
 								}
-							}
+		}
+		
+					if (rc == XPCOM.NS_OK && result[0] != 0) {
+						new nsISupports (result[0]).Release ();
+						result[0] = 0;
 
+						int /*long*/ nativeContext = XPCOM.nsIScriptContext_GetNativeContext (scriptContext);
+						if (nativeContext != 0) {
+							int length = script.length ();
+							char[] scriptChars = new char[length];
+							script.getChars(0, length, scriptChars, 0);
+							byte[] urlbytes = MozillaDelegate.wcsToMbcs (null, getUrl (), true);
+							rc = principal.GetJSPrincipals (nativeContext, result);
 							if (rc == XPCOM.NS_OK && result[0] != 0) {
-								new nsISupports (result[0]).Release ();
+								int /*long*/ principals = result[0];
 								result[0] = 0;
 
-								int /*long*/ nativeContext = XPCOM.nsIScriptContext_GetNativeContext (scriptContext);
-								if (nativeContext != 0) {
-									int length = script.length ();
-									char[] scriptChars = new char[length];
-									script.getChars(0, length, scriptChars, 0);
-									byte[] urlbytes = MozillaDelegate.wcsToMbcs (null, getUrl (), true);
-									rc = principal.GetJSPrincipals (nativeContext, result);
-									if (rc == XPCOM.NS_OK && result[0] != 0) {
-										int /*long*/ principals = result[0];
-										result[0] = 0;
-
 										byte[] jsLibPath = getJSLibPathBytes ();
 										int /*long*/ globalJSObject = XPCOM.JS_GetGlobalObject (jsLibPath, nativeContext);
 										if (globalJSObject != 0) {
-											aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_CONTEXTSTACK_CONTRACTID, true);
-											rc = serviceManager.GetServiceByContractID (aContractID, nsIJSContextStack.NS_IJSCONTEXTSTACK_IID, result);
+								aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_CONTEXTSTACK_CONTRACTID, true);
+								rc = serviceManager.GetServiceByContractID (aContractID, nsIJSContextStack.NS_IJSCONTEXTSTACK_IID, result);
 											if (rc == XPCOM.NS_OK && result[0] != 0) {
-												nsIJSContextStack stack = new nsIJSContextStack (result[0]);
-												result[0] = 0;
-												rc = stack.Push (nativeContext);
+								nsIJSContextStack stack = new nsIJSContextStack (result[0]);
+		result[0] = 0;
+								rc = stack.Push (nativeContext);
 												if (rc != XPCOM.NS_OK) {
 													stack.Release ();
 												} else {
 													boolean success = XPCOM.JS_EvaluateUCScriptForPrincipals (jsLibPath, nativeContext, globalJSObject, principals, scriptChars, length, urlbytes, 0, isXULRunner190x ? result : null) != 0;
-													result[0] = 0;
-													rc = stack.Pop (result);
-													stack.Release ();
+		result[0] = 0;
+								rc = stack.Pop (result);
+								stack.Release ();
 													// should principals be Release()d too?
 													principal.Release ();
 													serviceManager.Release ();
-													return success;
-												}
-											}
-										}
-									}
-								}
+								return success;
 							}
 						}
 					}
 				}
-				principal.Release ();
 			}
+							}
+						}
+					}
+				}
+			principal.Release ();
 		}
+		}
 		serviceManager.Release ();
-	}
+		}
 
 	/* fall back to the pre-1.9 approach */
 
@@ -1432,13 +1432,13 @@
 }
 
 static Browser getBrowser (int /*long*/ aDOMWindow) {
-	int /*long*/[] result = new int /*long*/[1];
-	int rc = XPCOM.NS_GetServiceManager (result);
+				int /*long*/[] result = new int /*long*/[1];
+				int rc = XPCOM.NS_GetServiceManager (result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 
-	nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
-	result[0] = 0;
+				nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
+				result[0] = 0;		
 	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_WINDOWWATCHER_CONTRACTID, true);
 	rc = serviceManager.GetServiceByContractID (aContractID, nsIWindowWatcher.NS_IWINDOWWATCHER_IID, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error(rc);
@@ -1453,7 +1453,7 @@
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 	int /*long*/ topDOMWindow = result[0];
-	result[0] = 0;
+				result[0] = 0;
 	rc = windowWatcher.GetChromeForWindow (topDOMWindow, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	new nsISupports (topDOMWindow).Release ();
@@ -1463,16 +1463,16 @@
 	nsIWebBrowserChrome webBrowserChrome = new nsIWebBrowserChrome (result[0]);
 	result[0] = 0;
 	rc = webBrowserChrome.QueryInterface (nsIEmbeddingSiteWindow.NS_IEMBEDDINGSITEWINDOW_IID, result);
-	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 	webBrowserChrome.Release ();
 
 	nsIEmbeddingSiteWindow embeddingSiteWindow = new nsIEmbeddingSiteWindow (result[0]);
-	result[0] = 0;
+					result[0] = 0;
 	IsGettingSiteWindow = true;
 	rc = embeddingSiteWindow.GetSiteWindow (result);
 	IsGettingSiteWindow = false;
-	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 	embeddingSiteWindow.Release ();
 
@@ -1484,9 +1484,9 @@
 
 	int /*long*/[] result = new int /*long*/[1];
 	int rc = webBrowser.QueryInterface (nsIWebNavigation.NS_IWEBNAVIGATION_IID, result);
-	if (rc != XPCOM.NS_OK) error (rc);
+					if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
-	
+
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 	rc = webNavigation.GoForward ();
 	webNavigation.Release ();
@@ -1574,13 +1574,13 @@
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 	window.Release ();
-
+	
 	int /*long*/ document = result[0];
 	result[0] = 0;
 	rc = XPCOM.NS_GetComponentManager (result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+	
 	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
 	result[0] = 0;
 	byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_DOMSERIALIZER_CONTRACTID, true);
@@ -1595,7 +1595,7 @@
 		int /*long*/ string = XPCOM.nsEmbedString_new ();
 		rc = serializer.SerializeToString (document, string);
 		serializer.Release ();
-
+			
 		int length = XPCOM.nsEmbedString_Length (string);
 		int /*long*/ buffer = XPCOM.nsEmbedString_get (string);
 		chars = new char[length];
@@ -1605,9 +1605,9 @@
 		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIDOMSerializer.NS_IDOMSERIALIZER_IID, result);
 		if (rc != XPCOM.NS_OK) error (rc);
 		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+	
 		nsIDOMSerializer serializer = new nsIDOMSerializer (result[0]);
-		result[0] = 0;
+	result[0] = 0;
 		rc = serializer.SerializeToString (document, result);
 		serializer.Release ();
 
@@ -1645,14 +1645,14 @@
 		XPCOM.memmove (dest, buffer, length);
 		XPCOM.nsEmbedCString_delete (aSpec);
 		uri.Release ();
-	}
+		}
 	if (dest == null) return ""; //$NON-NLS-1$
 
 	String location = new String (dest);
-	/*
+		/*
 	 * If the URI indicates that the page is being rendered from memory
 	 * (via setText()) then set it to about:blank to be consistent with IE.
-	 */
+		*/
 	if (location.equals (URI_FILEROOT)) {
 		location = ABOUT_BLANK;
 	} else {
@@ -1659,8 +1659,8 @@
 		int length = URI_FILEROOT.length ();
 		if (location.startsWith (URI_FILEROOT) && location.charAt (length) == '#') {
 			location = ABOUT_BLANK + location.substring (length);
-		}
-	}
+				}
+			}
 	return location;
 }
 
@@ -1674,10 +1674,10 @@
 		Object mozilla = method.invoke (null, new Object[0]);
 		method = clazz.getMethod ("wrapXPCOMObject", new Class[] {Long.TYPE, String.class}); //$NON-NLS-1$
 		webBrowserObject = method.invoke (mozilla, new Object[] {new Long (webBrowser.getAddress ()), !IsPre_4 ? nsIWebBrowser.NS_IWEBBROWSER_10_IID_STR : nsIWebBrowser.NS_IWEBBROWSER_IID_STR});
-		/*
+	/*
 		 * The following AddRef() is needed to offset the automatic Release() that
 		 * will be performed by JavaXPCOM when webBrowserObject is finalized.
-		 */
+	 */
 		webBrowser.AddRef ();
 		return webBrowserObject;
 	} catch (ClassNotFoundException e) {
@@ -1733,14 +1733,14 @@
 		rc = XPCOMInit.GRE_GetGREPathWithProperties (range, 1, property, 0, greBuffer, length); /* note: propertiesLength is 0 */
 		if (rc != XPCOM.NS_OK) {
 			/* Fall back to attempt #3 */
-			C.free (lower);
-			bytes = MozillaDelegate.wcsToMbcs (null, GRERANGE_LOWER_FALLBACK, true);
-			lower = C.malloc (bytes.length);
-			C.memmove (lower, bytes, bytes.length);
-			range.lower = lower;
+		C.free (lower);
+		bytes = MozillaDelegate.wcsToMbcs (null, GRERANGE_LOWER_FALLBACK, true);
+		lower = C.malloc (bytes.length);
+		C.memmove (lower, bytes, bytes.length);
+		range.lower = lower;
 			rc = XPCOMInit.GRE_GetGREPathWithProperties (range, 1, property, 0, greBuffer, length); /* note: propertiesLength is 0 */
 		}
-	}
+						}
 	C.free (value);
 	C.free (name);
 	C.free (lower);
@@ -1755,7 +1755,7 @@
 		result = new String (MozillaDelegate.mbcsToWcs (null, bytes));
 	} else {
 		result = ""; //$NON-NLS-1$
-	}
+				}
 	C.free (greBuffer);
 	return result;
 }
@@ -1766,7 +1766,7 @@
 	if (is != null) {
 		if (!componentsDir.exists ()) {
 			componentsDir.mkdirs ();
-		}
+			}
 		int read;
 		byte [] buffer = new byte [4096];
 		File file = new File (componentsDir, "external.xpt"); //$NON-NLS-1$
@@ -1774,13 +1774,13 @@
 			FileOutputStream os = new FileOutputStream (file);
 			while ((read = is.read (buffer)) != -1) {
 				os.write(buffer, 0, read);
-			}
+		}
 			os.close ();
 			is.close ();
 		} catch (FileNotFoundException e) {
 		} catch (IOException e) {
-		}
-	}
+			}
+		} 
 }
 
 void initFactories (nsIServiceManager serviceManager, nsIComponentManager componentManager, boolean isXULRunner) {
@@ -1826,10 +1826,10 @@
 		}
 	}
 	factory.Release();
-
+	
 	ExternalFactory externalFactory = new ExternalFactory ();
 	externalFactory.AddRef ();
-	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.EXTERNAL_CONTRACTID, true);
+	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.EXTERNAL_CONTRACTID, true); 
 	aClassName = MozillaDelegate.wcsToMbcs (null, "External", true); //$NON-NLS-1$
 	rc = componentRegistrar.RegisterFactory (XPCOM.EXTERNAL_CID, aClassName, aContractID, externalFactory.getAddress ());
 	if (rc != XPCOM.NS_OK) {
@@ -1837,11 +1837,11 @@
 		error (rc);
 	}
 	externalFactory.Release ();
-
+	
 	rc = serviceManager.GetService (XPCOM.NS_CATEGORYMANAGER_CID, nsICategoryManager.NS_ICATEGORYMANAGER_IID, result);
 	if (rc != XPCOM.NS_OK) error (rc);
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-
+		
 	nsICategoryManager categoryManager = new nsICategoryManager (result[0]);
 	result[0] = 0;
 	byte[] entry = MozillaDelegate.wcsToMbcs (null, "external", true); //$NON-NLS-1$
@@ -1857,7 +1857,7 @@
 	result[0] = 0;
 
 	categoryManager.Release ();
-
+	
 	/*
 	* This Download factory will be used if the GRE version is < 1.8.
 	* If the GRE version is 1.8.x then the Download factory that is registered later for
@@ -1866,18 +1866,18 @@
 	*   functionality is provided by the GRE.
 	*/
 	if (IsPre_4) {
-		DownloadFactory downloadFactory = new DownloadFactory ();
-		downloadFactory.AddRef ();
-		aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_DOWNLOAD_CONTRACTID, true);
-		aClassName = MozillaDelegate.wcsToMbcs (null, "swtDownload", true); //$NON-NLS-1$
-		rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory.getAddress ());
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
-			error (rc);
-		}
-		downloadFactory.Release ();
+	DownloadFactory downloadFactory = new DownloadFactory ();
+	downloadFactory.AddRef ();
+	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_DOWNLOAD_CONTRACTID, true);
+	aClassName = MozillaDelegate.wcsToMbcs (null, "swtDownload", true); //$NON-NLS-1$
+	rc = componentRegistrar.RegisterFactory (XPCOM.NS_DOWNLOAD_CID, aClassName, aContractID, downloadFactory.getAddress ());
+	if (rc != XPCOM.NS_OK) {
+		browser.dispose ();
+		error (rc);
 	}
-
+	downloadFactory.Release ();
+	}
+		
 	FilePickerFactory pickerFactory = new FilePickerFactory ();
 	pickerFactory.AddRef ();
 	aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_FILEPICKER_CONTRACTID, true);
@@ -1885,10 +1885,10 @@
 	rc = componentRegistrar.RegisterFactory (XPCOM.NS_FILEPICKER_CID, aClassName, aContractID, pickerFactory.getAddress ());
 	/* a failure here is fine, it likely indicates that the OS has provided a default implementation */
 	pickerFactory.Release ();
-
+	
 	componentRegistrar.Release ();
 }
-
+	
 void initJavaXPCOM (String mozillaPath) {
 	try {
 		Class clazz = Class.forName ("org.mozilla.xpcom.Mozilla"); //$NON-NLS-1$
@@ -1915,7 +1915,7 @@
 	} catch (InstantiationException e) {
 	}
 }
-
+	
 String initMozilla (String mozillaPath) {
 	/* attempt to use the GRE pointed at by MOZILLA_FIVE_HOME */
 	int /*long*/ ptr = C.getenv (MozillaDelegate.wcsToMbcs (null, XPCOM.MOZILLA_FIVE_HOME, true));
@@ -1984,7 +1984,7 @@
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_ERROR_NULL_POINTER);
-	}
+	}	
 
 	nsILocalFile localFile = new nsILocalFile (result[0]);
 	result[0] = 0;
@@ -2034,15 +2034,15 @@
 		if (functionPtr == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_ERROR_NULL_POINTER);
-		}
+	}
 		if (IsPre_4) {
-			rc = XPCOM.Call (functionPtr, localFile.getAddress (), localFile.getAddress (), LocationProvider.getAddress (), 0, 0);
+		rc = XPCOM.Call (functionPtr, localFile.getAddress (), localFile.getAddress (), LocationProvider.getAddress (), 0, 0);
 		} else {
 			rc = XPCOM.Call (functionPtr, localFile.getAddress (), localFile.getAddress (), LocationProvider.getAddress ());
 		}
 		if (rc == XPCOM.NS_OK) {
 			System.setProperty (XULRUNNER_PATH, mozillaPath);
-		}
+	}
 	} else {
 		rc = XPCOM.NS_InitXPCOM2 (0, localFile.getAddress(), LocationProvider.getAddress ());
 	}
@@ -2071,7 +2071,7 @@
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_NOINTERFACE);
-	}
+	}		
 
 	nsIPrefService prefService = new nsIPrefService (result[0]);
 	result[0] = 0;
@@ -2081,7 +2081,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+	}	
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_NOINTERFACE);
@@ -2107,7 +2107,7 @@
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+	}
 		localizedString = new nsIPrefLocalizedString (result[0]);
 		result[0] = 0;
 		rc = localizedString.ToString (result);
@@ -2114,11 +2114,11 @@
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+	}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
-		}
+	}
 		int length = XPCOM.strlen_PRUnichar (result[0]);
 		char[] dest = new char[length];
 		XPCOM.memmove (dest, result[0], length * 2);
@@ -2192,26 +2192,26 @@
 	String prefCharset = null;
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_CHARSET, true);
 	rc = prefBranch.GetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
-	/* 
+	/*
 	 * Feature of Debian.  For some reason attempting to query for the current charset
 	 * preference fails on Debian.  The workaround for this is to assume a value of
 	 * "ISO-8859-1" since this is typically the default value when mozilla is used
 	 * without a profile.
-	 */
+	*/
 	if (rc != XPCOM.NS_OK) {
 		prefCharset = "ISO-8859-1";	//$NON-NLS-1$
-	} else {
+		} else {
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
 		}
 		localizedString = new nsIPrefLocalizedString (result[0]);
-		result[0] = 0;
+				result[0] = 0;
 		rc = localizedString.ToString (result);
 		if (rc != XPCOM.NS_OK) {
 			browser.dispose ();
 			error (rc);
-		}
+			}
 		if (result[0] == 0) {
 			browser.dispose ();
 			error (XPCOM.NS_NOINTERFACE);
@@ -2220,8 +2220,8 @@
 		char[] dest = new char[length];
 		XPCOM.memmove (dest, result[0], length * 2);
 		prefCharset = new String (dest);
-	}
-	result[0] = 0;
+			}
+				result[0] = 0;
 
 	String newCharset = System.getProperty ("file.encoding");	// $NON-NLS-1$
 	if (!newCharset.equals (prefCharset)) {
@@ -2241,8 +2241,8 @@
 				error (XPCOM.NS_NOINTERFACE);
 			}
 			localizedString = new nsIPrefLocalizedString (result[0]);
-			result[0] = 0;
-		}
+						result[0] = 0;
+					}
 		localizedString.SetDataWithLength (length, charBuffer);
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
 	}
@@ -2260,11 +2260,11 @@
 	if (proxyHost != null) {
 		byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_PREFLOCALIZEDSTRING_CONTRACTID, true);
 		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
-		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+								if (rc != XPCOM.NS_OK) error (rc);
+								if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 
 		localizedString = new nsIPrefLocalizedString (result[0]);
-		result[0] = 0;
+								result[0] = 0;
 		
 		int length = proxyHost.length ();
 		char[] charBuffer = new char[length];
@@ -2310,7 +2310,7 @@
 		}
 		result[0] = 0;
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
-		if (rc != XPCOM.NS_OK) error (rc);
+								if (rc != XPCOM.NS_OK) error (rc);
 
 		buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_PROXYHOST_SSL, true);
 		rc = prefBranch.GetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, result);
@@ -2330,7 +2330,7 @@
 		}
 		result[0] = 0;
 		rc = prefBranch.SetComplexValue (buffer, nsIPrefLocalizedString.NS_IPREFLOCALIZEDSTRING_IID, localizedString.getAddress ());
-		if (rc != XPCOM.NS_OK) error (rc);
+								if (rc != XPCOM.NS_OK) error (rc);
 
 		localizedString.Release ();
 	}
@@ -2360,7 +2360,7 @@
 		intResult[0] = 0;
 		rc = prefBranch.SetIntPref (buffer, port);
 		if (rc != XPCOM.NS_OK) error (rc);
-	}
+							}
 
 	if (proxyHost != null || port != -1) {
 		buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_PROXYTYPE, true);
@@ -2370,7 +2370,7 @@
 		intResult[0] = 0;
 		rc = prefBranch.SetIntPref (buffer, 1);
 		if (rc != XPCOM.NS_OK) error (rc);
-	}
+						}
 
 	/*
 	* Ensure that windows that are shown during page loads are not blocked.  Firefox may
@@ -2384,7 +2384,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+					}
 
 	/* Ensure that the status text can be set through means like javascript */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_DISABLEWINDOWSTATUSCHANGE, true);
@@ -2392,7 +2392,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+				}
 
 	/* Ensure that the status line can be hidden when opening a window from javascript */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_DISABLEOPENWINDOWSTATUSHIDE, true);
@@ -2400,7 +2400,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+			}
 
 	/* Ensure that javascript execution is enabled since this is the Browser's default behaviour */ 
 	buffer = MozillaDelegate.wcsToMbcs (null, PREFERENCE_JAVASCRIPTENABLED, true);
@@ -2461,7 +2461,7 @@
 		XPCOM.XPCOMGlueLoadXULFunctions (ptr);
 		C.memmove (result, functionLoad.function, C.PTR_SIZEOF);
 		int /*long*/ functionPtr = result[0];
-		result[0] = 0;
+	result[0] = 0;
 		C.free (functionLoad.function);
 		C.free (functionLoad.functionName);
 		C.free (ptr);
@@ -2478,8 +2478,8 @@
 
 void initSpinup (nsIComponentManager componentManager) {
 	if (MozillaDelegate.needsSpinup ()) {
-		int /*long*/[] result = new int /*long*/[1];
-
+	int /*long*/[] result = new int /*long*/[1];
+	
 		/* nsIAppShell is discontinued as of xulrunner 1.9, so do not fail if it is not found */
 		int rc = componentManager.CreateInstance (XPCOM.NS_APPSHELL_CID, 0, nsIAppShell.NS_IAPPSHELL_IID, result);
 		if (rc != XPCOM.NS_ERROR_NO_INTERFACE) {
@@ -2518,17 +2518,17 @@
 	int /*long*/[] result = new int /*long*/[1];
 	rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
-		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
-		if (rc != XPCOM.NS_OK) {
-			browser.dispose ();
-			error (rc);
-		}
+	rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
+	if (rc != XPCOM.NS_OK) {
+		browser.dispose ();
+		error (rc);
 	}
+	}
 	if (result[0] == 0) {
 		browser.dispose ();
 		error (XPCOM.NS_ERROR_NO_INTERFACE);
 	}
-	
+
 	nsIBaseWindow baseWindow = new nsIBaseWindow (result[0]);
 	result[0] = 0;
 	Rectangle rect = browser.getClientArea ();
@@ -2560,7 +2560,7 @@
 void initWindowCreator (nsIServiceManager serviceManager) {
 	WindowCreator = new WindowCreator2 ();
 	WindowCreator.AddRef ();
-	
+
 	int /*long*/[] result = new int /*long*/[1];
 	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_WINDOWWATCHER_CONTRACTID, true);
 	int rc = serviceManager.GetServiceByContractID (aContractID, nsIWindowWatcher.NS_IWINDOWWATCHER_IID, result);
@@ -2574,7 +2574,7 @@
 	}
 
 	nsIWindowWatcher windowWatcher = new nsIWindowWatcher (result[0]);
-	result[0] = 0;
+		result[0] = 0;
 	rc = windowWatcher.SetWindowCreator (WindowCreator.getAddress());
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
@@ -2603,7 +2603,7 @@
 	if (rc != XPCOM.NS_OK) {
 		browser.dispose ();
 		error (rc);
-	}
+		}
 	XPCOMWasGlued = true;
 
 	return mozillaDirPath;
@@ -2668,8 +2668,8 @@
 	int /*long*/[] result = new int /*long*/[1];
 	rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
-		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
+	rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
+	if (rc != XPCOM.NS_OK) error (rc);
 	}
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
 
@@ -2724,7 +2724,7 @@
 	if (rc != XPCOM.NS_OK) error (rc);
 	webBrowserFocus.Release ();
 }
-
+	
 void Deactivate () {
 	isActive = false;
 	int /*long*/[] result = new int /*long*/[1];
@@ -2891,7 +2891,7 @@
 	int rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
 		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
+	if (rc != XPCOM.NS_OK) error (rc);
 	}
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
 
@@ -2916,7 +2916,7 @@
 
 	/*
 	* The following error conditions do not indicate unrecoverable problems:
-	* 
+	*
 	* - NS_ERROR_INVALID_POINTER: happens when Reload is called immediately
 	* after calling LoadURI.
 	* - NS_ERROR_FILE_NOT_FOUND: happens when attempting to reload a file that
@@ -3002,8 +3002,8 @@
 		if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
 		nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 		result[0] = 0;
-		char[] uri = new char[ABOUT_BLANK.length () + 1];
-		ABOUT_BLANK.getChars (0, ABOUT_BLANK.length (), uri, 0);
+	    char[] uri = new char[ABOUT_BLANK.length () + 1];
+	    ABOUT_BLANK.getChars (0, ABOUT_BLANK.length (), uri, 0);
 		rc = webNavigation.LoadURI (uri, nsIWebNavigation.LOAD_FLAGS_NONE, 0, 0, 0);
 		if (rc != XPCOM.NS_OK) error (rc);
 		webNavigation.Release ();
@@ -3037,7 +3037,7 @@
 		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 		XPCOM.nsEmbedCString_delete (aSpec);
 		ioService.Release ();
-
+		
 		nsIURI uri = new nsIURI (result[0]);
 		result[0] = 0;
 
@@ -3065,7 +3065,7 @@
 		docShell.Release ();
 
 		inputStream.Release ();
-		interfaceRequestor.Release ();
+	interfaceRequestor.Release ();
 		uri.Release ();
 		XPCOM.nsEmbedCString_delete (aContentType);
 		XPCOM.nsEmbedCString_delete (aContentCharset);
@@ -3098,27 +3098,27 @@
 
 	nsIWebNavigation webNavigation = new nsIWebNavigation (result[0]);
 	result[0] = 0;
-	char[] uri = new char[url.length () + 1];
-	url.getChars (0, url.length (), uri, 0);
+    char[] uri = new char[url.length () + 1];
+    url.getChars (0, url.length (), uri, 0);
 
-	nsIMIMEInputStream postDataStream = null;
-	InputStream dataStream = null;
+    nsIMIMEInputStream postDataStream = null;
+    InputStream dataStream = null;
 	if (postData != null) {
-		rc = XPCOM.NS_GetComponentManager (result);
-		if (rc != XPCOM.NS_OK) error (rc);
-		if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
-		result[0] = 0;
-		byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MIMEINPUTSTREAM_CONTRACTID, true);
-		rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIMIMEInputStream.NS_IMIMEINPUTSTREAM_IID, result);
-		componentManager.Release();
+    	rc = XPCOM.NS_GetComponentManager (result);
+    	if (rc != XPCOM.NS_OK) error (rc);
+    	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+    	nsIComponentManager componentManager = new nsIComponentManager (result[0]);
+    	result[0] = 0;
+    	byte[] contractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MIMEINPUTSTREAM_CONTRACTID, true);
+    	rc = componentManager.CreateInstanceByContractID (contractID, 0, nsIMIMEInputStream.NS_IMIMEINPUTSTREAM_IID, result);
+    	componentManager.Release();
 
-		if (rc == XPCOM.NS_OK && result[0] != 0) { /* nsIMIMEInputStream is not in mozilla 1.4 */
+    	if (rc == XPCOM.NS_OK && result[0] != 0) { /* nsIMIMEInputStream is not in mozilla 1.4 */
 			dataStream = new InputStream (postData);
-			dataStream.AddRef ();
-			postDataStream = new nsIMIMEInputStream (result[0]);
-			rc = postDataStream.SetData (dataStream.getAddress ());
-			if (rc != XPCOM.NS_OK) error (rc);
+    		dataStream.AddRef ();
+    		postDataStream = new nsIMIMEInputStream (result[0]);
+    		rc = postDataStream.SetData (dataStream.getAddress ());
+    		if (rc != XPCOM.NS_OK) error (rc);
 
 			boolean foundLength = false;
 			boolean foundType = false;
@@ -3136,18 +3136,18 @@
 				}
 			}
 			rc = postDataStream.SetAddContentLength (foundLength ? 0 : 1);
-			if (rc != XPCOM.NS_OK) error (rc);
+    		if (rc != XPCOM.NS_OK) error (rc);
 			if (!foundType) {
-				byte[] name = MozillaDelegate.wcsToMbcs (null, HEADER_CONTENTTYPE, true);
-				byte[] value = MozillaDelegate.wcsToMbcs (null, MIMETYPE_FORMURLENCODED, true);
-				rc = postDataStream.AddHeader (name, value);
-				if (rc != XPCOM.NS_OK) error (rc);
-			}
+    		byte[] name = MozillaDelegate.wcsToMbcs (null, HEADER_CONTENTTYPE, true);
+    		byte[] value = MozillaDelegate.wcsToMbcs (null, MIMETYPE_FORMURLENCODED, true);
+    		rc = postDataStream.AddHeader (name, value);
+    		if (rc != XPCOM.NS_OK) error (rc);
+    	}
 		}
-		result[0] = 0;
+    	result[0] = 0;
 	}
 
-	InputStream headersStream = null;
+    InputStream headersStream = null;
     if (headers != null) {
 		StringBuffer buffer = new StringBuffer ();
 		for (int i = 0; i < headers.length; i++) {
@@ -3166,9 +3166,9 @@
 				}
 			}
 		}
-		byte[] bytes = MozillaDelegate.wcsToMbcs (null, buffer.toString (), true);
-		headersStream = new InputStream (bytes);
-		headersStream.AddRef ();
+    	byte[] bytes = MozillaDelegate.wcsToMbcs (null, buffer.toString (), true);
+    	headersStream = new InputStream (bytes);
+    	headersStream.AddRef ();
     }
 
 	rc = webNavigation.LoadURI (
@@ -3453,10 +3453,10 @@
 		while (elements.hasMoreElements ()) {
 			BrowserFunction function = (BrowserFunction)elements.nextElement ();
 			if (!function.isEvaluate) {
-				execute (function.functionString);
-			}
+			execute (function.functionString);
 		}
 	}
+	}
 
 	/*
 	* Feature of Mozilla.  When a redirect occurs to a site with an invalid
@@ -3503,7 +3503,7 @@
 			int rc = request.QueryInterface (nsIChannel.NS_ICHANNEL_10_IID, result);
 			if (rc != XPCOM.NS_OK) {
 				rc = request.QueryInterface (nsIChannel.NS_ICHANNEL_IID, result);
-				if (rc != XPCOM.NS_OK) error (rc);
+			if (rc != XPCOM.NS_OK) error (rc);
 			}
 			if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 
@@ -3686,9 +3686,9 @@
 				while (elements.hasMoreElements ()) {
 					BrowserFunction function = (BrowserFunction)elements.nextElement ();
 					if (!function.isEvaluate) {
-						execute (function.functionString);
-					}
+					execute (function.functionString);
 				}
+				}
 				/* 
 				* For Mozilla >= 1.9.2, when content is being set via nsIWebBrowserStream,
 				* registered functions must be re-installed in the subsequent Start Request
@@ -3778,10 +3778,10 @@
 			Runnable runnable = new Runnable () {
 				public void run () {
 					if (browser.isDisposed ()) return;
-					for (int i = 0; i < progressListeners.length; i++) {
-						progressListeners[i].completed (event2);
-					}
-				}
+			for (int i = 0; i < progressListeners.length; i++) {
+				progressListeners[i].completed (event2);
+			}
+		}
 			};
 			if (deferCompleted) {
 				display.asyncExec (runnable);
@@ -3804,27 +3804,27 @@
 				rc = request.QueryInterface (nsIChannel.NS_ICHANNEL_IID, result);
 			}
 			if (rc == XPCOM.NS_OK && result[0] != 0) {
-				nsIChannel channel = new nsIChannel (result[0]);
-				result[0] = 0;
-				rc = channel.GetURI (result);
-				if (rc != XPCOM.NS_OK) error (rc);
-				if (result[0] == 0) error (XPCOM.NS_ERROR_NULL_POINTER);
-				channel.Release ();
+			nsIChannel channel = new nsIChannel (result[0]);
+			result[0] = 0;
+			rc = channel.GetURI (result);
+			if (rc != XPCOM.NS_OK) error (rc);
+			if (result[0] == 0) error (XPCOM.NS_ERROR_NULL_POINTER);
+			channel.Release ();
 
-				nsIURI uri = new nsIURI (result[0]);
-				result[0] = 0;
-				int /*long*/ aSpec = XPCOM.nsEmbedCString_new ();
-				rc = uri.GetSpec (aSpec);
-				if (rc != XPCOM.NS_OK) error (rc);
-				int length = XPCOM.nsEmbedCString_Length (aSpec);
-				int /*long*/ buffer = XPCOM.nsEmbedCString_get (aSpec);
-				byte[] bytes = new byte[length];
-				XPCOM.memmove (bytes, buffer, length);
-				lastNavigateURL = new String (bytes);
-				XPCOM.nsEmbedCString_delete (aSpec);
-				uri.Release ();
-			}
+			nsIURI uri = new nsIURI (result[0]);
+			result[0] = 0;
+			int /*long*/ aSpec = XPCOM.nsEmbedCString_new ();
+			rc = uri.GetSpec (aSpec);
+			if (rc != XPCOM.NS_OK) error (rc);
+			int length = XPCOM.nsEmbedCString_Length (aSpec);
+			int /*long*/ buffer = XPCOM.nsEmbedCString_get (aSpec);
+			byte[] bytes = new byte[length];
+			XPCOM.memmove (bytes, buffer, length);
+			lastNavigateURL = new String (bytes);
+			XPCOM.nsEmbedCString_delete (aSpec);
+			uri.Release ();
 		}
+		}
 
 		/*
 		* Hook DOM listeners to the page's nsIDOMWindow here because this is
@@ -4033,7 +4033,7 @@
 	browser.dispose ();
 	return XPCOM.NS_OK;
 }
-
+   	
 int SizeBrowserTo (int aCX, int aCY) {
 	size = new Point (aCX, aCY);
 	boolean isChrome = (chromeFlags & nsIWebBrowserChrome.CHROME_OPENAS_CHROME) != 0;
@@ -4085,7 +4085,7 @@
 	return XPCOM.NS_OK;
 }
 
-/* nsIEmbeddingSiteWindow */
+/* nsIEmbeddingSiteWindow */ 
 
 int SetDimensions (int flags, int x, int y, int cx, int cy) {
 	boolean isChrome = (chromeFlags & nsIWebBrowserChrome.CHROME_OPENAS_CHROME) != 0;
@@ -4092,22 +4092,22 @@
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_POSITION) != 0) {
 		location = new Point (x, y);
 		if (isChrome) {
-			browser.getShell ().setLocation (x, y);
-		}
+		browser.getShell ().setLocation (x, y);
 	}
+	}
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_SIZE_INNER) != 0) {
 		size = new Point (cx, cy);
 		if (isChrome) {
-			browser.setSize (cx, cy);
-		}
+		browser.setSize (cx, cy);
 	}
+	}
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_SIZE_OUTER) != 0) {
 		if (isChrome) {
-			browser.getShell ().setSize (cx, cy);
-		}
+		browser.getShell ().setSize (cx, cy);
 	}
-	return XPCOM.NS_OK;
-}
+	}
+	return XPCOM.NS_OK;   	
+}	
 
 int GetDimensions (int flags, int /*long*/ x, int /*long*/ y, int /*long*/ cx, int /*long*/ cy) {
 	if ((flags & nsIEmbeddingSiteWindow.DIM_FLAGS_POSITION) != 0) {
@@ -4125,8 +4125,8 @@
 		if (cx != 0) C.memmove (cx, new int[] {size.x}, 4); /* PRInt32 */
 		if (cy != 0) C.memmove (cy, new int[] {size.y}, 4); /* PRInt32 */
 	}
-	return XPCOM.NS_OK;
-}
+	return XPCOM.NS_OK;     	
+}	
 
 int SetFocus () {
 	int /*long*/[] result = new int /*long*/[1];
@@ -4133,7 +4133,7 @@
 	int rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
 		rc = webBrowser.QueryInterface (nsIBaseWindow.NS_IBASEWINDOW_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
+	if (rc != XPCOM.NS_OK) error (rc);
 	}
 	if (result[0] == 0) error (XPCOM.NS_ERROR_NO_INTERFACE);
 	
@@ -4232,7 +4232,7 @@
 	int /*long*/ siteWindow = delegate.getSiteWindow ();
 	XPCOM.memmove (aSiteWindow, new int /*long*/[] {siteWindow}, C.PTR_SIZEOF);
 	return XPCOM.NS_OK;     	
-}
+}  
  
 /* nsIWebBrowserChromeFocus */
 
@@ -4339,14 +4339,14 @@
 		 */
 		if (!value.startsWith (PREFIX_JAVASCRIPT)) {
 			if (locationListeners.length > 0) {
-				LocationEvent event = new LocationEvent (browser);
-				event.display = browser.getDisplay();
-				event.widget = browser;
-				event.location = value;
-				/*
-				 * If the URI indicates that the page is being rendered from memory
-				 * (via setText()) then set it to about:blank to be consistent with IE.
-				 */
+		LocationEvent event = new LocationEvent (browser);
+		event.display = browser.getDisplay();
+		event.widget = browser;
+		event.location = value;
+		/*
+		 * If the URI indicates that the page is being rendered from memory
+		 * (via setText()) then set it to about:blank to be consistent with IE.
+		 */
 				if (event.location.equals (URI_FILEROOT)) {
 					event.location = ABOUT_BLANK;
 				} else {
@@ -4355,12 +4355,12 @@
 						event.location = ABOUT_BLANK + event.location.substring (length);
 					}
 				}
-				event.doit = doit;
-				for (int i = 0; i < locationListeners.length; i++) {
-					locationListeners[i].changing (event);
-				}
-				doit = event.doit && !browser.isDisposed();
-			}
+		event.doit = doit;
+		for (int i = 0; i < locationListeners.length; i++) {
+			locationListeners[i].changing (event);
+		}
+			doit = event.doit && !browser.isDisposed();
+		}
 
 			if (doit) {
 				if (jsEnabled != jsEnabledOnNextPage) {
@@ -4608,15 +4608,15 @@
 							Event keyEvent = new Event ();
 							keyEvent.widget = browser;
 							keyEvent.type = SWT.KeyDown;
-							keyEvent.keyCode = lastKeyCode;
+					keyEvent.keyCode = lastKeyCode;
 							keyEvent.stateMask = (aAltKey[0] != 0 ? SWT.ALT : 0) | (aCtrlKey[0] != 0? SWT.CTRL : 0) | (aShiftKey[0] != 0? SWT.SHIFT : 0) | (aMetaKey[0] != 0? SWT.COMMAND : 0);
-							browser.notifyListeners (keyEvent.type, keyEvent);
+					browser.notifyListeners (keyEvent.type, keyEvent);
 							if (!keyEvent.doit || browser.isDisposed ()) {
 								domEvent.PreventDefault ();
 							}
 						}
-					}
 				}
+				}
 			}
 		}
 
@@ -4688,7 +4688,7 @@
 		if (delegate.sendTraverse ()) {
 			doit = sendKeyEvent (keyEvent);
 		} else {
-			browser.notifyListeners (keyEvent.type, keyEvent);
+		browser.notifyListeners (keyEvent.type, keyEvent);
 			doit = keyEvent.doit; 
 		}
 		if (!doit || browser.isDisposed ()) {
@@ -4891,7 +4891,7 @@
 	int rc = supports.QueryInterface (nsISSLStatus.NS_ISSLSTATUS_10_IID, result);
 	if (rc != XPCOM.NS_OK) {
 		rc = supports.QueryInterface (nsISSLStatus.NS_ISSLSTATUS_IID, result);
-		if (rc != XPCOM.NS_OK) error (rc);
+	if (rc != XPCOM.NS_OK) error (rc);
 	}
 	if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
 
@@ -4988,31 +4988,31 @@
 		public void run() {
 			if (browser.isDisposed ()) return;
 			if (url.equals (lastNavigateURL)) {
-				String message = Compatibility.getMessage ("SWT_InvalidCert_Message", new String[] {urlPort}); //$NON-NLS-1$
-				if (new PromptDialog (browser.getShell ()).invalidCert (browser, message, finalProblems, cert)) {
-					int /*long*/[] result = new int /*long*/[1];
-					int rc = XPCOM.NS_GetServiceManager (result);
-					if (rc != XPCOM.NS_OK) error (rc);
-					if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-			
-					nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
-					result[0] = 0;
-					byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_CERTOVERRIDE_CONTRACTID, true);
-					rc = serviceManager.GetServiceByContractID (aContractID, nsICertOverrideService.NS_ICERTOVERRIDESERVICE_IID, result);
-					if (rc != XPCOM.NS_OK) error (rc);
-					if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
-					serviceManager.Release ();
-			
-					nsICertOverrideService overrideService = new nsICertOverrideService (result[0]);
-					result[0] = 0;
-					byte[] hostBytes = MozillaDelegate.wcsToMbcs (null, host, false);
-					int /*long*/ hostString = XPCOM.nsEmbedCString_new (hostBytes, hostBytes.length);
-					rc = overrideService.RememberValidityOverride (hostString, port, cert.getAddress (), finalFlags, 1);
+			String message = Compatibility.getMessage ("SWT_InvalidCert_Message", new String[] {urlPort}); //$NON-NLS-1$
+			if (new PromptDialog (browser.getShell ()).invalidCert (browser, message, finalProblems, cert)) {
+				int /*long*/[] result = new int /*long*/[1];
+				int rc = XPCOM.NS_GetServiceManager (result);
+				if (rc != XPCOM.NS_OK) error (rc);
+				if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+		
+				nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
+				result[0] = 0;
+				byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_CERTOVERRIDE_CONTRACTID, true);
+				rc = serviceManager.GetServiceByContractID (aContractID, nsICertOverrideService.NS_ICERTOVERRIDESERVICE_IID, result);
+				if (rc != XPCOM.NS_OK) error (rc);
+				if (result[0] == 0) error (XPCOM.NS_NOINTERFACE);
+				serviceManager.Release ();
+		
+				nsICertOverrideService overrideService = new nsICertOverrideService (result[0]);
+				result[0] = 0;
+				byte[] hostBytes = MozillaDelegate.wcsToMbcs (null, host, false);
+				int /*long*/ hostString = XPCOM.nsEmbedCString_new (hostBytes, hostBytes.length);
+				rc = overrideService.RememberValidityOverride (hostString, port, cert.getAddress (), finalFlags, 1);
 					navigate (badCertRequest);
-					XPCOM.nsEmbedCString_delete (hostString);
-					overrideService.Release ();
-				}
+				XPCOM.nsEmbedCString_delete (hostString);
+				overrideService.Release ();
 			}
+			}
 			cert.Release ();
 			new nsISupports (badCertRequest).Release ();
 			badCertRequest = 0;
Index: org/eclipse/swt/browser/WebBrowser.java
===================================================================
--- org/eclipse/swt/browser/WebBrowser.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/WebBrowser.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -29,7 +29,7 @@
 	boolean jsEnabledOnNextPage = true, jsEnabled = true;
 	int nextFunctionIndex = 1;
 	Object evaluateResult;
-
+	
 	static final String ERROR_ID = "org.eclipse.swt.browser.error"; // $NON-NLS-1$
 	static final String EXECUTE_ID = "SWTExecuteTemporaryFunction"; // $NON-NLS-1$
 
Index: org/eclipse/swt/browser/External.java
===================================================================
--- org/eclipse/swt/browser/External.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/External.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -28,7 +28,7 @@
 	XPCOMObject securityCheckedComponent;
 	XPCOMObject scriptObjectOwner;
 	int refCount = 0;
-	
+
 	static Callback CallJavaProc;
 	static {
 		CallJavaProc = new Callback (External.class, "callJava", 3); //$NON-NLS-1$
@@ -60,7 +60,7 @@
 	result[0] = 0;
 	rc = serviceManager.GetService (XPCOM.NS_IXPCONNECT_CID, nsIXPConnect.NS_IXPCONNECT_IID, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 
 	nsIXPConnect connect = new nsIXPConnect (result[0]);
 	result[0] = 0;
@@ -107,8 +107,8 @@
 	/* if the BrowserFunction could not be invoked for some reason then return null to JS */
 	if (resultVariant == null) {
 		rc = XPCOM.NS_GetComponentManager (result);
-		if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-		if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
+	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 		nsIComponentManager componentManager = new nsIComponentManager (result[0]);
 		result[0] = 0;
 		resultVariant = convertToJS (null, componentManager);
@@ -119,7 +119,7 @@
 	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
 	rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result);
 	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
 	serviceManager.Release();
 
 	nsIMemory memory = new nsIMemory (result[0]);
@@ -196,21 +196,21 @@
 			XPCOM.memmove (id, iid, nsID.sizeof);
 			C.free (iid);
 
-			int /*long*/[] result = new int /*long*/[1];
+	int /*long*/[] result = new int /*long*/[1];
 			rc = XPCOM.NS_GetServiceManager (result);
-			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-			if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
+	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 
-			nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
-			result[0] = 0;
-			byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
-			rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result);
-			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-			if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
-			serviceManager.Release ();
+	nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
+	result[0] = 0;
+	byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
+	rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result);
+	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);		
+	serviceManager.Release ();
 
-			nsIMemory memory = new nsIMemory (result[0]);
-			result[0] = 0;
+	nsIMemory memory = new nsIMemory (result[0]);
+	result[0] = 0;
 
 			if (id.Equals (nsIVariant.NS_IVARIANT_IID) || id.Equals (nsIVariant.NS_IVARIANT_10_IID)) {
 				arrayReturn = new Object[count[0]];
@@ -219,14 +219,14 @@
 					C.memmove (arrayPtr, ptr[0] + i * C.PTR_SIZEOF, C.PTR_SIZEOF);
 					nsISupports supports = new nsISupports (arrayPtr[0]);
 					rc = supports.QueryInterface (id, result);
-					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-					if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
+	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+	if (result[0] == 0) Mozilla.error (XPCOM.NS_NOINTERFACE);
 
 					nsIVariant currentVariant = new nsIVariant (result[0]);
-					result[0] = 0;
+	result[0] = 0;
 					currentType[0] = 0;
 					rc = currentVariant.GetDataType (currentType);
-					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+	if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 					try {
 						arrayReturn[i] = convertToJava (currentVariant, currentType[0]);
 						currentVariant.Release ();
@@ -268,7 +268,7 @@
 						arrayReturn = new Object[count[0]];
 						for (int i = 0; i < count[0]; i++) {
 							int /*long*/ currentPtr = ptr[0] + i * C.PTR_SIZEOF;
-							int /*long*/[] stringPtr = new int /*long*/[1];
+							int /*long*/[] stringPtr = new int /*long*/[1]; 
 							C.memmove (stringPtr, currentPtr, C.PTR_SIZEOF);
 							int length = XPCOM.strlen_PRUnichar (stringPtr[0]);
 							char[] dest = new char[length];
@@ -356,8 +356,8 @@
 			C.free (arrayPtr);
 			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 		}
-		return variant;
-	}
+			return variant;
+		}
 
 	variant.Release ();
 	SWT.error (SWT.ERROR_INVALID_RETURN_VALUE);
@@ -371,10 +371,10 @@
 
 	if (function != null) {
 		try {
-			short[] type = new short[1]; /* PRUint16 */
+		short[] type = new short[1]; /* PRUint16 */
 			nsIVariant variant = new nsIVariant (tokenVariant);
-			int rc = variant.GetDataType (type);
-			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+		int rc = variant.GetDataType (type);
+		if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 			Object temp = convertToJava (variant, type[0]);
 			type[0] = 0;
 			if (temp instanceof String) {
@@ -384,17 +384,17 @@
 					rc = variant.GetDataType (type);
 					if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 					temp = convertToJava (variant, type[0]);
-					if (temp instanceof Object[]) {
-						Object[] arguments = (Object[])temp;
-						try {
-							returnValue = function.function (arguments);
-						} catch (Exception e) {
-							/* exception during function invocation */
-							returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
-						}
-					}
+			if (temp instanceof Object[]) {
+				Object[] arguments = (Object[])temp;
+				try {
+					returnValue = function.function (arguments);
+				} catch (Exception e) {
+					/* exception during function invocation */
+					returnValue = WebBrowser.CreateErrorString (e.getLocalizedMessage ());
 				}
 			}
+				}
+			}
 		} catch (IllegalArgumentException e) {
 			/* invalid argument value type */
 			if (function.isEvaluate) {
Index: org/eclipse/swt/browser/Browser.java
===================================================================
--- org/eclipse/swt/browser/Browser.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/Browser.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -94,13 +94,13 @@
 
 	style = getStyle ();
 	webBrowser = new BrowserFactory ().createWebBrowser (style);
-	if (webBrowser != null) {
-		webBrowser.setBrowser (this);
+			if (webBrowser != null) {
+				webBrowser.setBrowser (this);
 		webBrowser.create (parent, style);
 		return;
 	}
-	dispose ();
-	SWT.error (SWT.ERROR_NO_HANDLES);
+		dispose ();
+		SWT.error (SWT.ERROR_NO_HANDLES);
 }
 
 static Composite checkParent (Composite parent) {
@@ -204,7 +204,7 @@
 	WebBrowser.clearSessions ();
 }
 
-/**
+/**	 
  * Returns the value of a cookie that is associated with a URL.
  * Note that cookies are shared amongst all Browser instances.
  * 
Index: org/eclipse/swt/browser/PromptService2.java
===================================================================
--- org/eclipse/swt/browser/PromptService2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/PromptService2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -20,7 +20,7 @@
 	XPCOMObject promptService;
 	XPCOMObject promptService2;
 	int refCount = 0;
-	
+
 PromptService2 () {
 	createCOMInterfaces ();
 }
@@ -164,8 +164,8 @@
 	* If mozilla is re-navigating to a page with a bad certificate in order
 	* to get its certificate info then do not show cert error message alerts.
 	*/
-	if (browser != null) {
-		Mozilla mozilla = (Mozilla)browser.webBrowser;
+			if (browser != null) {
+				Mozilla mozilla = (Mozilla)browser.webBrowser;
 		if (mozilla.isRetrievingBadCert) return XPCOM.NS_OK;
 	}
 
@@ -210,7 +210,7 @@
 
 int Confirm (int /*long*/ aParent, int /*long*/ aDialogTitle, int /*long*/ aText, int /*long*/ _retval) {
 	Browser browser = getBrowser (aParent);
-
+	
 	if (browser != null && ((Mozilla)browser.webBrowser).ignoreAllMessages) {
 		XPCOM.memmove (_retval, new boolean[] {true});
 		return XPCOM.NS_OK;
@@ -332,22 +332,22 @@
 		* value that we override must be freed using the nsIMemory service.
 		*/
 		if (valueLabel[0] != null) {
-			int /*long*/[] result2 = new int /*long*/[1];
-			int rc = XPCOM.NS_GetServiceManager (result2);
-			if (rc != XPCOM.NS_OK) SWT.error (rc);
-			if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
+		int /*long*/[] result2 = new int /*long*/[1];
+				int rc = XPCOM.NS_GetServiceManager (result2);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
+			
+				nsIServiceManager serviceManager = new nsIServiceManager (result2[0]);
+				result2[0] = 0;
+				byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
+				rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result2);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
+				serviceManager.Release ();
+				
+				nsIMemory memory = new nsIMemory (result2[0]);
+				result2[0] = 0;
 
-			nsIServiceManager serviceManager = new nsIServiceManager (result2[0]);
-			result2[0] = 0;
-			byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
-			rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result2);
-			if (rc != XPCOM.NS_OK) SWT.error (rc);
-			if (result2[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
-			serviceManager.Release ();
-
-			nsIMemory memory = new nsIMemory (result2[0]);
-			result2[0] = 0;
-
 			int cnt = valueLabel[0].length ();
 			char[] buffer = new char[cnt + 1];
 			valueLabel[0].getChars (0, cnt, buffer, 0);
@@ -359,9 +359,9 @@
 			if (valueAddr[0] != 0) {
 				memory.Free (valueAddr[0]);
 			}
-			memory.Release ();
+				memory.Release ();
+			}
 		}
-	}
 	if (aCheckState != 0) XPCOM.memmove (aCheckState, check);
 	return XPCOM.NS_OK;
 }
@@ -533,57 +533,57 @@
 	if (user == null) {
 		/* no listener handled the challenge, so show an authentication dialog */
 
-		String titleLabel, textLabel, checkLabel = null;
-		String[] userLabel = new String[1], passLabel = new String[1];
-		char[] dest;
-		int length;
-		if (aDialogTitle != 0) {
-			length = XPCOM.strlen_PRUnichar (aDialogTitle);
-			dest = new char[length];
-			XPCOM.memmove (dest, aDialogTitle, length * 2);
-			titleLabel = new String (dest);
-		} else {
-			titleLabel = SWT.getMessage ("SWT_Authentication_Required");	//$NON-NLS-1$
-		}
-		
-		length = XPCOM.strlen_PRUnichar (aText);
+	String titleLabel, textLabel, checkLabel = null;
+	String[] userLabel = new String[1], passLabel = new String[1];
+	char[] dest;
+	int length;
+	if (aDialogTitle != 0) {
+		length = XPCOM.strlen_PRUnichar (aDialogTitle);
 		dest = new char[length];
-		XPCOM.memmove (dest, aText, length * 2);
-		textLabel = new String (dest);
-
-		int /*long*/[] userAddr = new int /*long*/[1];
-		XPCOM.memmove (userAddr, aUsername, C.PTR_SIZEOF);
-		if (userAddr[0] != 0) {
-			length = XPCOM.strlen_PRUnichar (userAddr[0]);
+		XPCOM.memmove (dest, aDialogTitle, length * 2);
+		titleLabel = new String (dest);
+	} else {
+		titleLabel = SWT.getMessage ("SWT_Authentication_Required");	//$NON-NLS-1$
+	}
+	
+	length = XPCOM.strlen_PRUnichar (aText);
+	dest = new char[length];
+	XPCOM.memmove (dest, aText, length * 2);
+	textLabel = new String (dest);
+	
+	int /*long*/[] userAddr = new int /*long*/[1];
+	XPCOM.memmove (userAddr, aUsername, C.PTR_SIZEOF);
+	if (userAddr[0] != 0) {
+		length = XPCOM.strlen_PRUnichar (userAddr[0]);
+		dest = new char[length];
+		XPCOM.memmove (dest, userAddr[0], length * 2);
+		userLabel[0] = new String (dest);		
+	}
+	
+	int /*long*/[] passAddr = new int /*long*/[1];
+	XPCOM.memmove (passAddr, aPassword, C.PTR_SIZEOF);
+	if (passAddr[0] != 0) {
+		length = XPCOM.strlen_PRUnichar (passAddr[0]);
+		dest = new char[length];
+		XPCOM.memmove (dest, passAddr[0], length * 2);
+		passLabel[0] = new String (dest);		
+	}
+	
+	if (aCheckMsg != 0) {
+		length = XPCOM.strlen_PRUnichar (aCheckMsg);
+		if (length > 0) {
 			dest = new char[length];
-			XPCOM.memmove (dest, userAddr[0], length * 2);
-			userLabel[0] = new String (dest);		
+			XPCOM.memmove (dest, aCheckMsg, length * 2);
+			checkLabel = new String (dest);
 		}
+	}
 
-		int /*long*/[] passAddr = new int /*long*/[1];
-		XPCOM.memmove (passAddr, aPassword, C.PTR_SIZEOF);
-		if (passAddr[0] != 0) {
-			length = XPCOM.strlen_PRUnichar (passAddr[0]);
-			dest = new char[length];
-			XPCOM.memmove (dest, passAddr[0], length * 2);
-			passLabel[0] = new String (dest);		
-		}
-		
-		if (aCheckMsg != 0) {
-			length = XPCOM.strlen_PRUnichar (aCheckMsg);
-			if (length > 0) {
-				dest = new char[length];
-				XPCOM.memmove (dest, aCheckMsg, length * 2);
-				checkLabel = new String (dest);
-			}
-		}
-	
-		Shell shell = browser == null ? new Shell () : browser.getShell ();
-		PromptDialog dialog = new PromptDialog (shell);
+	Shell shell = browser == null ? new Shell () : browser.getShell ();
+	PromptDialog dialog = new PromptDialog (shell);
 		boolean[] check = new boolean[1], result = new boolean[1];
 		if (aCheckState != 0) XPCOM.memmove (check, aCheckState);
-		dialog.promptUsernameAndPassword (titleLabel, textLabel, checkLabel, userLabel, passLabel, check, result);
-	
+	dialog.promptUsernameAndPassword (titleLabel, textLabel, checkLabel, userLabel, passLabel, check, result);
+
 		XPCOM.memmove (_retval, result);
 		if (result[0]) {
 			/* User selected OK */
@@ -605,22 +605,22 @@
 
 		int /*long*/[] result = new int /*long*/[1];
 		int rc = XPCOM.NS_GetServiceManager (result);
-		if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
 		if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);
-
+			
 		nsIServiceManager serviceManager = new nsIServiceManager (result[0]);
 		result[0] = 0;
-		byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
+				byte[] aContractID = MozillaDelegate.wcsToMbcs (null, XPCOM.NS_MEMORY_CONTRACTID, true);
 		rc = serviceManager.GetServiceByContractID (aContractID, nsIMemory.NS_IMEMORY_IID, result);
-		if (rc != XPCOM.NS_OK) SWT.error (rc);
-		if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
-		serviceManager.Release ();
-
+				if (rc != XPCOM.NS_OK) SWT.error (rc);
+				if (result[0] == 0) SWT.error (XPCOM.NS_NOINTERFACE);		
+				serviceManager.Release ();
+				
 		nsIMemory memory = new nsIMemory (result[0]);
 		result[0] = 0;
 		if (userAddr[0] != 0) memory.Free (userAddr[0]);
 		if (passAddr[0] != 0) memory.Free (passAddr[0]);
-		memory.Release ();
+				memory.Release ();
 
 		/* write the name and password values */
 
@@ -633,14 +633,14 @@
 		XPCOM.memmove (aUsername, new int /*long*/[] {ptr}, C.PTR_SIZEOF);
 
 		cnt = password.length ();
-		buffer = new char[cnt + 1];
+			buffer = new char[cnt + 1];
 		password.getChars (0, cnt, buffer, 0);
-		size = buffer.length * 2;
-		ptr = C.malloc (size);
-		XPCOM.memmove (ptr, buffer, size);
-		XPCOM.memmove (aPassword, new int /*long*/[] {ptr}, C.PTR_SIZEOF);
+			size = buffer.length * 2;
+			ptr = C.malloc (size);
+			XPCOM.memmove (ptr, buffer, size);
+			XPCOM.memmove (aPassword, new int /*long*/[] {ptr}, C.PTR_SIZEOF);
 	}
-
+			
 	return XPCOM.NS_OK;
 }
 
Index: org/eclipse/swt/browser/AppFileLocProvider.java
===================================================================
--- org/eclipse/swt/browser/AppFileLocProvider.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/AppFileLocProvider.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -23,7 +23,7 @@
 	String mozillaPath, profilePath, cacheParentPath;
 	String[] pluginDirs;
 	boolean isXULRunner;
-
+	
 	static final String SEPARATOR_OS = System.getProperty ("file.separator"); //$NON-NLS-1$
 	static final String CHROME_DIR = "chrome"; //$NON-NLS-1$
 	static final String COMPONENTS_DIR = "components"; //$NON-NLS-1$
@@ -33,7 +33,7 @@
 	static final String PLUGINS_DIR = "plugins"; //$NON-NLS-1$
 	static final String USER_PLUGINS_DIR = ".mozilla" + SEPARATOR_OS + "plugins"; //$NON-NLS-1$ //$NON-NLS-2$
 	static final String PREFERENCES_FILE = "prefs.js"; //$NON-NLS-1$
-
+	
 	static boolean IsSparc;
 	static {
 		String osName = System.getProperty ("os.name").toLowerCase (); //$NON-NLS-1$
@@ -196,7 +196,7 @@
 			* to not add the directory containing this plug-in to the plug-in search path. 
 			*/
 			if (!IsSparc) {
-				pluginDirs[index++] = mozillaPath + PLUGINS_DIR;
+			pluginDirs[index++] = mozillaPath + PLUGINS_DIR;
 			}
 
 			/* set the next value to the home directory + "/.mozilla/plugins" */
@@ -215,17 +215,17 @@
 			int rc = XPCOM.NS_NewLocalFile (pathString.getAddress (), 1, result);
 			if (rc != XPCOM.NS_ERROR_FILE_UNRECOGNIZED_PATH) {
 				/* value appears to be a valid pathname */
-				if (rc != XPCOM.NS_OK) Mozilla.error (rc);
-				if (result[0] == 0) Mozilla.error (XPCOM.NS_ERROR_NULL_POINTER);
+			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+			if (result[0] == 0) Mozilla.error (XPCOM.NS_ERROR_NULL_POINTER);
 
-				nsILocalFile localFile = new nsILocalFile (result[0]);
-				result[0] = 0;
-				rc = localFile.QueryInterface (nsIFile.NS_IFILE_IID, result); 
-				if (rc != XPCOM.NS_OK) Mozilla.error (rc);
+			nsILocalFile localFile = new nsILocalFile (result[0]);
+			result[0] = 0;
+		    rc = localFile.QueryInterface (nsIFile.NS_IFILE_IID, result); 
+			if (rc != XPCOM.NS_OK) Mozilla.error (rc);
 				if (result[0] == 0) Mozilla.error (XPCOM.NS_ERROR_NO_INTERFACE);
-				localFile.Release ();
+			localFile.Release ();
 
-				nsIFile file = new nsIFile (result[0]);
+			nsIFile file = new nsIFile (result[0]);
 				files[index++] = file;
 			}
 			pathString.dispose ();
Index: org/eclipse/swt/browser/IE.java
===================================================================
--- org/eclipse/swt/browser/IE.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/browser/IE.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -215,43 +215,43 @@
 				}
 			}
 			OS.RegCloseKey (phkResult [0]);
-		}
+	}
 
-		/*
-		* Registry entry HKEY_CLASSES_ROOT\Shell.Explorer\CLSID indicates which version of
-		* Shell.Explorer to use by default.  We usually want to use this value because it
-		* typically points at the newest one that is available.  However it is possible for
-		* this registry entry to be changed by another application to point at some other
-		* Shell.Explorer version.
-		*
-		* The Browser depends on the Shell.Explorer version being at least Shell.Explorer.2.
-		* If it is detected in the registry to be Shell.Explorer.1 then change the progId that
-		* will be embedded to explicitly specify Shell.Explorer.2.
-		*/
+	/*
+	* Registry entry HKEY_CLASSES_ROOT\Shell.Explorer\CLSID indicates which version of
+	* Shell.Explorer to use by default.  We usually want to use this value because it
+	* typically points at the newest one that is available.  However it is possible for
+	* this registry entry to be changed by another application to point at some other
+	* Shell.Explorer version.
+	*
+	* The Browser depends on the Shell.Explorer version being at least Shell.Explorer.2.
+	* If it is detected in the registry to be Shell.Explorer.1 then change the progId that
+	* will be embedded to explicitly specify Shell.Explorer.2.
+	*/
 		key = new TCHAR (0, "Shell.Explorer\\CLSID", true);	//$NON-NLS-1$
 		phkResult = new int /*long*/ [1];
-		if (OS.RegOpenKeyEx (OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult) == 0) {
-			int [] lpcbData = new int [1];
-			int result = OS.RegQueryValueEx (phkResult [0], null, 0, null, (TCHAR) null, lpcbData);
+	if (OS.RegOpenKeyEx (OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult) == 0) {
+		int [] lpcbData = new int [1];
+		int result = OS.RegQueryValueEx (phkResult [0], null, 0, null, (TCHAR) null, lpcbData);
+		if (result == 0) {
+			TCHAR lpData = new TCHAR (0, lpcbData [0] / TCHAR.sizeof);
+			result = OS.RegQueryValueEx (phkResult [0], null, 0, null, lpData, lpcbData);
 			if (result == 0) {
-				TCHAR lpData = new TCHAR (0, lpcbData [0] / TCHAR.sizeof);
-				result = OS.RegQueryValueEx (phkResult [0], null, 0, null, lpData, lpcbData);
-				if (result == 0) {
-					String clsid = lpData.toString (0, lpData.strlen ());
-					if (clsid.equals (CLSID_SHELLEXPLORER1)) {
-						/* Shell.Explorer.1 is the default, ensure that Shell.Explorer.2 is available */
-						key = new TCHAR (0, "Shell.Explorer.2", true);	//$NON-NLS-1$
+				String clsid = lpData.toString (0, lpData.strlen ());
+				if (clsid.equals (CLSID_SHELLEXPLORER1)) {
+					/* Shell.Explorer.1 is the default, ensure that Shell.Explorer.2 is available */
+					key = new TCHAR (0, "Shell.Explorer.2", true);	//$NON-NLS-1$
 						int /*long*/ [] phkResult2 = new int /*long*/ [1];
-						if (OS.RegOpenKeyEx (OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult2) == 0) {
-							/* specify that Shell.Explorer.2 is to be used */
-							OS.RegCloseKey (phkResult2 [0]);
+					if (OS.RegOpenKeyEx (OS.HKEY_CLASSES_ROOT, key, 0, OS.KEY_READ, phkResult2) == 0) {
+						/* specify that Shell.Explorer.2 is to be used */
+						OS.RegCloseKey (phkResult2 [0]);
 							ProgId = "Shell.Explorer.2";	//$NON-NLS-1$
-						}
 					}
 				}
 			}
-			OS.RegCloseKey (phkResult [0]);
 		}
+		OS.RegCloseKey (phkResult [0]);
+	}
 
 		if (NativePendingCookies != null) {
 			SetPendingCookies (NativePendingCookies);
@@ -269,7 +269,7 @@
 		browser.dispose();
 		SWT.error(SWT.ERROR_NO_HANDLES);
 	}
-
+	
 	if (!Initialized) {
 		Initialized = true;
 		int version = 0;
@@ -402,8 +402,8 @@
 					if (e.detail == SWT.TRAVERSE_TAB_PREVIOUS && e.widget instanceof WebSite) {
 						/* otherwise will traverse to the Browser control */
 						browser.traverse(SWT.TRAVERSE_TAB_PREVIOUS, e);
-						e.doit = false;
-					}
+							e.doit = false;
+						}
 					if (e.detail == SWT.TRAVERSE_TAB_NEXT && e.widget instanceof Browser) {
 						/* otherwise will traverse to the WebSite control */
 						site.traverse(SWT.TRAVERSE_TAB_NEXT, e);
@@ -447,7 +447,7 @@
 						String url = varResult.getString();
 
 						if (uncRedirect != null) {
-							/*
+						/*
 							* Silently allow the navigate to proceed if the url is the first segment of a
 							* UNC path being navigated to (initiated by the NavigateError listener to show
 							* a name/password prompter), or if the url is the full UNC path (initiated by
@@ -483,9 +483,9 @@
 							if (!OS.IsWinCE && OS.UrlCreateFromPath(filePath, urlResult, size, 0) == COM.S_OK) {
 								url = urlResult.toString(0, size[0]);
 							} else {
-								url = PROTOCOL_FILE + url.replace('\\', '/');
-							}
+							url = PROTOCOL_FILE + url.replace('\\', '/');
 						}
+						}
 
 						/* Disallow local file system accesses if the browser content is untrusted */
 						if (url.startsWith(PROTOCOL_FILE) && _getUrl().startsWith(ABOUT_BLANK) && untrustedText) {
@@ -513,7 +513,7 @@
 						}
 						if (doit) {
 							lastNavigateURL = url;
-						}
+					   }					
 						break;
 					}
 					case CommandStateChange: {
@@ -537,8 +537,8 @@
 							if (pendingText != null) {
 								setText((String)pendingText[0], ((Boolean)pendingText[1]).booleanValue());
 							} else if (pendingUrl != null) {
-								setUrl((String)pendingUrl[0], (String)pendingUrl[1], (String[])pendingUrl[2]);
-							}
+									setUrl((String)pendingUrl[0], (String)pendingUrl[1], (String[])pendingUrl[2]);
+								}
 							pendingText = pendingUrl = null;
 							break;
 						}
@@ -545,7 +545,7 @@
 
 						Variant varResult = event.arguments[0];
 						IDispatch dispatch = varResult.getDispatch();
-
+	
 						varResult = event.arguments[1];
 						String url = varResult.getString();
 						/*
@@ -561,20 +561,20 @@
 							if (!OS.IsWinCE && OS.UrlCreateFromPath(filePath, urlResult, size, 0) == COM.S_OK) {
 								url = urlResult.toString(0, size[0]);
 							} else {
-								url = PROTOCOL_FILE + url.replace('\\', '/');
-							}
+							url = PROTOCOL_FILE + url.replace('\\', '/');
 						}
+						}
 						if (html != null && url.equals(ABOUT_BLANK)) {
 							if (delaySetText) {
 								delaySetText = false;
 								browser.getDisplay().asyncExec(new Runnable() {
-									public void run() {
-										if (browser.isDisposed() || html == null) return;
+								public void run() {
+									if (browser.isDisposed() || html == null) return;
 										setHTML(html);
-										html = null;
-									}
+									html = null;
+												}
 								});
-							} else {
+										} else {
 								setHTML(html);
 								html = null;
 							}
@@ -611,12 +611,12 @@
 								IE ie = (IE)browser.webBrowser;
 								if (ie.installFunctionsOnDocumentComplete) {
 									ie.installFunctionsOnDocumentComplete = false;
-									Enumeration elements = functions.elements ();
-									while (elements.hasMoreElements ()) {
-										BrowserFunction function = (BrowserFunction)elements.nextElement ();
-										execute (function.functionString);
-									}
+								Enumeration elements = functions.elements ();
+								while (elements.hasMoreElements ()) {
+									BrowserFunction function = (BrowserFunction)elements.nextElement ();
+									execute (function.functionString);
 								}
+								}
 
 								ProgressEvent progressEvent = new ProgressEvent(browser);
 								progressEvent.display = browser.getDisplay();
@@ -637,11 +637,11 @@
 					}
 					case DownloadComplete: {
 						/*
-						* IE feature.  Some events that swt relies on are not sent when
+						 * IE feature.  Some events that swt relies on are not sent when
 						* a page is refreshed (as opposed to being navigated to).  The
 						* workaround is to use DownloadComplete as an opportunity to
 						* do this work.   
-						*/
+						 */
 
 						Enumeration elements = functions.elements ();
 						while (elements.hasMoreElements ()) {
@@ -653,10 +653,10 @@
 						isRefresh = false;
 
 						/*
-						* DocumentComplete is not received for refreshes, but clients may rely
-						* on this event for tasks like hooking javascript listeners, so send the
-						* event here.
-						*/
+						 * DocumentComplete is not received for refreshes, but clients may rely
+						 * on this event for tasks like hooking javascript listeners, so send the
+						 * event here.
+						 */
 						ProgressEvent progressEvent = new ProgressEvent(browser);
 						progressEvent.display = browser.getDisplay();
 						progressEvent.widget = browser;
@@ -672,7 +672,7 @@
 						Variant varResult = event.arguments[1];
 						String url = varResult.getString();
 						if (!performingInitialNavigate) {
-							isAboutBlank = url.startsWith(ABOUT_BLANK);
+						isAboutBlank = url.startsWith(ABOUT_BLANK);
 						}
 
 						/*
@@ -691,17 +691,17 @@
 						}
 						if (path != null) {
 							int extensionIndex = path.lastIndexOf('.');
-							if (extensionIndex != -1) {
+						if (extensionIndex != -1) {
 								String extension = path.substring(extensionIndex);
-								if (extension.equalsIgnoreCase(EXTENSION_PDF)) {
+							if (extension.equalsIgnoreCase(EXTENSION_PDF)) {
 									isPDF = true;
-									PDFCount++;
-									if (PDFCount > MAX_PDF) {
-										COM.FreeUnusedLibraries = false;
-									}
+								PDFCount++;
+								if (PDFCount > MAX_PDF) {
+									COM.FreeUnusedLibraries = false;
 								}
 							}
 						}
+						}
 
 						if (uncRedirect != null) {
 							if (uncRedirect.equals(url)) {
@@ -744,7 +744,7 @@
 							}
 						}
 						if (!isPDF) {
-							hookDOMListeners(webBrowser, isTop);
+						hookDOMListeners(webBrowser, isTop);
 						}
 						webBrowser.dispose();
 						break;
@@ -1038,11 +1038,11 @@
 	site.addEventListener(WindowSetLeft, oleListener);
 	site.addEventListener(WindowSetTop, oleListener);
 	site.addEventListener(WindowSetWidth, oleListener);
-
+	
 	Variant variant = new Variant(true);
 	auto.setProperty(RegisterAsBrowser, variant);
 	variant.dispose();
-
+	
 	variant = new Variant(false);
 	int[] rgdispid = auto.getIDsOfNames(new String[] {"RegisterAsDropTarget"}); //$NON-NLS-1$
 	if (rgdispid != null) auto.setProperty(rgdispid[0], variant);
@@ -1416,7 +1416,7 @@
 	this.html = html;
 	untrustedText = !trusted;
 	if (blankLoading) return true;
-
+	
 	/*
 	* Navigate to the blank page and insert the given html when
 	* receiving the next DocumentComplete notification.  See the
@@ -1434,14 +1434,14 @@
 	* that instance was created.
 	*/
 
-	/*
-	* Stopping the loading of a page causes DocumentComplete events from previous
-	* requests to be received before the DocumentComplete for this page.  In such
-	* cases we must be sure to not set the html into the browser too soon, since
-	* doing so could result in its page being cleared out by a subsequent
-	* DocumentComplete.  The Browser's ReadyState can be used to determine whether
-	* these extra events will be received or not.
-	*/
+		/*
+		* Stopping the loading of a page causes DocumentComplete events from previous
+		* requests to be received before the DocumentComplete for this page.  In such
+		* cases we must be sure to not set the html into the browser too soon, since
+		* doing so could result in its page being cleared out by a subsequent
+		* DocumentComplete.  The Browser's ReadyState can be used to determine whether
+		* these extra events will be received or not.
+		*/
 	if (_getUrl().length() != 0) {
 		int[] rgdispid = auto.getIDsOfNames(new String[] { "ReadyState" }); //$NON-NLS-1$
 		Variant pVarResult = auto.getProperty(rgdispid[0]);
@@ -1553,7 +1553,7 @@
 		rgdispid = event.getIDsOfNames (new String[] {PROPERTY_RETURNVALUE});
 		pVarResult = event.getProperty (rgdispid[0]);
 		boolean consume = pVarResult != null && pVarResult.getType () == OLE.VT_BOOL && !pVarResult.getBoolean ();
-		pVarResult.dispose ();
+				pVarResult.dispose ();
 
 		MSG msg = new MSG ();
 		int flags = OS.PM_NOYIELD | (consume ? OS.PM_REMOVE : OS.PM_NOREMOVE);
@@ -1673,7 +1673,7 @@
 		* KeyDown to be sent for this key.  However, keydown and keypress events are 
 		* both sometimes received for OS.VK_RETURN, depending on the page's focus
 		* control.  To handle this, do not send a KeyDown for CR or LF here since
-		* one is always sent for it from the keydown handler.
+		* one is always sent for it from the keydown handler. 
 		*/
 		if (lastCharCode == SWT.CR || lastCharCode == SWT.LF) {
 			event.dispose();
@@ -1819,7 +1819,7 @@
 	pVarResult = event.getProperty(dispIdMember);
 	int screenY = pVarResult.getInt();
 	pVarResult.dispose();
-	
+
 	Point position = new Point(screenX, screenY);
 	position = browser.getDisplay().map(null, browser, position);
 	newEvent.x = position.x; newEvent.y = position.y;
@@ -1897,7 +1897,7 @@
 
 	event.dispose();
 	browser.notifyListeners(newEvent.type, newEvent);
-
+	
 	if (eventType.equals(EVENT_DOUBLECLICK)) {
 		newEvent = new Event ();
 		newEvent.widget = browser;
@@ -1914,7 +1914,7 @@
 void hookDOMListeners(OleAutomation webBrowser, final boolean isTop) {
 	int[] rgdispid = webBrowser.getIDsOfNames(new String[] { PROPERTY_DOCUMENT });
 	int dispIdMember = rgdispid[0];
-	Variant pVarResult = webBrowser.getProperty(dispIdMember);
+	Variant	pVarResult = webBrowser.getProperty(dispIdMember);
 	if (pVarResult == null) return;
 	if (pVarResult.getType() == COM.VT_EMPTY) {
 		pVarResult.dispose();
@@ -1922,7 +1922,7 @@
 	}
 	final OleAutomation document = pVarResult.getAutomation();
 	pVarResult.dispose();
-
+	
 	/*
 	 * In some cases, such as setting the Browser's content from a string,
 	 * NavigateComplete2 is received multiple times for a top-level document.
Index: org/eclipse/swt/accessibility/ACC.java
===================================================================
--- org/eclipse/swt/accessibility/ACC.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/ACC.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -20,12 +20,12 @@
  * @since 2.0
  */
 public class ACC {
-	public static final int STATE_NORMAL = 			0x00000000;
-	public static final int STATE_SELECTED = 		0x00000002;
-	public static final int STATE_SELECTABLE = 		0x00200000;
+	public static final int STATE_NORMAL = 0x00000000;
+	public static final int STATE_SELECTED = 0x00000002;
+	public static final int STATE_SELECTABLE = 0x00200000;
 	public static final int STATE_MULTISELECTABLE = 0x01000000;
-	public static final int STATE_FOCUSED = 		0x00000004;
-	public static final int STATE_FOCUSABLE = 		0x00100000;
+	public static final int STATE_FOCUSED = 0x00000004;
+	public static final int STATE_FOCUSABLE = 0x00100000;
 	public static final int STATE_PRESSED = 		0x00000008;
 	public static final int STATE_CHECKED = 		0x00000010;
 	public static final int STATE_EXPANDED = 		0x00000200;
@@ -133,7 +133,7 @@
 	public static final int CHILDID_SELF = -1;
 	public static final int CHILDID_NONE = -2;
 	public static final int CHILDID_MULTIPLE = -3;
-
+	
 	/**
 	 * An AT is requesting the accessible child object at the specified index.
 	 * 
@@ -406,7 +406,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_VALUE_CHANGED = 0x800E;
-
+	
 	/**
 	 * Send when the loading of a document has completed.
 	 * 
@@ -413,7 +413,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_LOAD_COMPLETE = 0x105;
-
+	
 	/**
 	 * Send when the loading of a document was interrupted.
 	 * 
@@ -420,14 +420,14 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_LOAD_STOPPED = 0x106;
-
+	
 	/**
 	 * Send when the document contents are being reloaded.
 	 * 
-	 * @since 3.6
+	 *  @since 3.6
 	 */
 	public static final int EVENT_DOCUMENT_RELOAD = 0x107;
-
+	
 	/**
 	 * Send when a slide changed in a presentation document
 	 * or a page boundary was crossed in a word processing document. 
@@ -435,7 +435,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_PAGE_CHANGED = 0x111;
-
+	
 	/**
 	 * Send when the caret moved from one section to the next.
 	 * 
@@ -442,7 +442,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_SECTION_CHANGED = 0x112;
-
+	
 	/**
 	 * Send when the count or attributes of an accessible object's actions have changed.
 	 * 
@@ -449,7 +449,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_ACTION_CHANGED = 0x100;
-
+	
 	/**
 	 * Send when the starting index of this link within the containing string has changed.
 	 * 
@@ -456,7 +456,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_START_INDEX_CHANGED = 0x10d;
-
+	
 	/**
 	 * Send when the ending index of this link within the containing string has changed.
 	 * 
@@ -463,7 +463,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_END_INDEX_CHANGED = 0x108;
-
+	
 	/**
 	 * Send when the number of anchors associated with this hyperlink object has changed.
 	 * 
@@ -470,7 +470,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_ANCHOR_COUNT_CHANGED = 0x109;
-
+	
 	/**
 	 * Send when the hyperlink selected state changed from selected to unselected
 	 * or from unselected to selected.
@@ -478,7 +478,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_SELECTED_LINK_CHANGED = 0x10a;
-
+	
 	/**
 	 * Send when the hyperlink has been activated.
 	 * 
@@ -485,7 +485,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERLINK_ACTIVATED = 0x10b;
-
+	
 	/**
 	 * Send when one of the links associated with the hypertext object has been selected.
 	 * <p>
@@ -496,7 +496,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERTEXT_LINK_SELECTED = 0x10c;
-
+	
 	/**
 	 * Send when the number of hyperlinks associated with a hypertext object has changed.
 	 * 
@@ -503,7 +503,7 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_HYPERTEXT_LINK_COUNT_CHANGED = 0x10f;
-
+	
 	/**
 	 * Send when an object's attributes have changed.
 	 * 
@@ -578,13 +578,13 @@
 	 * @since 3.6
 	 */
 	public static final int EVENT_TEXT_ATTRIBUTE_CHANGED = 0x20a;
-	 
+
 	/**
 	 * Send when the caret has moved to a new position.
 	 * 
 	 * @since 3.6
 	 */
-	public static final int EVENT_TEXT_CARET_MOVED = 0x11b;
+	public static final int EVENT_TEXT_CARET_MOVED = 0x11b; 
 
 	/**
 	 * Send when the caret has moved from one column to the next.
@@ -718,5 +718,5 @@
 	 * 
 	 * @since 3.6
 	 */
-	public static final int RELATION_SUBWINDOW_OF = 14;	
+	public static final int RELATION_SUBWINDOW_OF = 14;
 }
Index: org/eclipse/swt/accessibility/Relation.java
===================================================================
--- org/eclipse/swt/accessibility/Relation.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/Relation.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -80,7 +80,7 @@
 			public int /*long*/ method7(int /*long*/[] args) {return get_targets((int)/*64*/args[0], args[1], args[2]);}
 		};
 	}
-
+	
 	/* QueryInterface([in] iid, [out] ppvObject)
 	 * Ownership of ppvObject transfers from callee to caller so reference count on ppvObject 
 	 * must be incremented before returning.  Caller is responsible for releasing ppvObject.
Index: org/eclipse/swt/accessibility/Accessible.java
===================================================================
--- org/eclipse/swt/accessibility/Accessible.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/accessibility/Accessible.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -84,7 +84,7 @@
 			UseIA2 = false;
 		}
 	}
-	
+
 	/**
 	 * Constructs a new instance of this class given its parent.
 	 * 
@@ -171,7 +171,7 @@
 			public int /*long*/ method26(int /*long*/[] args) {return put_accName(args[0], args[1]);}
 			public int /*long*/ method27(int /*long*/[] args) {return put_accValue(args[0], args[1]);}
 		};
-	
+
 		/* If the callback takes a struct parameter (for example, a VARIANT),
 		 * then create a custom callback that dereferences the struct and
 		 * passes a pointer to the original callback.
@@ -515,7 +515,7 @@
 		    public int /*long*/ method3(int /*long*/[] args) {return QueryService(args[0], args[1], args[2]);}
 		};
 	}
-
+	
 	/**
 	 * Invokes platform specific functionality to allocate a new accessible object.
 	 * <p>
@@ -857,7 +857,7 @@
 		if (objIAccessible == null) createIAccessible();
 		return objIAccessible.getAddress();
 	}
-
+	
 	/**
 	 * Returns the control for this Accessible object. 
 	 *
@@ -867,7 +867,7 @@
 	public Control getControl() {
 		return control;
 	}
-	
+
 	/**
 	 * Invokes platform specific functionality to dispose an accessible object.
 	 * <p>
@@ -1013,7 +1013,7 @@
 	 *    <li>ERROR_WIDGET_DISPOSED - if the receiver's control has been disposed</li>
 	 *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver's control</li>
 	 * </ul>
-	 *
+	 * 
 	 * @see AccessibleActionListener
 	 * @see #addAccessibleActionListener
 	 * 
@@ -1059,7 +1059,7 @@
 	 *
 	 * @param listener the listener that should no longer be notified when the receiver
 	 * is asked for <code>AccessibleHyperlinkListener</code> interface properties
-	 *
+	 * 
 	 * @exception IllegalArgumentException <ul>
 	 *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
 	 * </ul>
@@ -1552,7 +1552,7 @@
 			if (DEBUG) print(this + ".QueryInterface guid=" + guidString(guid) + " returning " + objIEnumVARIANT.getAddress() + hresult(COM.S_OK));
 			return COM.S_OK;
 		}
-		
+
 		if (COM.IsEqualGUID(guid, COM.IIDIServiceProvider)) {
 			if (!UseIA2) return COM.E_NOINTERFACE;
 			if (accessibleActionListeners.size() > 0 || accessibleAttributeListeners.size() > 0 ||
@@ -1560,12 +1560,12 @@
 				accessibleTableCellListeners.size() > 0 || accessibleTextExtendedListeners.size() > 0 ||
 				accessibleValueListeners.size() > 0 || getRelationCount() > 0
 				|| (control instanceof Button && ((control.getStyle() & SWT.RADIO) != 0))) {
-				if (objIServiceProvider == null) createIServiceProvider();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIServiceProvider.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
+			if (objIServiceProvider == null) createIServiceProvider();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIServiceProvider.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
 				if (DEBUG) print(this + ".QueryInterface guid=" + guidString(guid) + " returning " + objIServiceProvider.getAddress() + hresult(COM.S_OK));
-				return COM.S_OK;
-			}
+			return COM.S_OK;
+		}
 			if (DEBUG) if (interesting(guid)) print("QueryInterface guid=" + guidString(guid) + " returning" + hresult(COM.E_NOINTERFACE));
 			return COM.E_NOINTERFACE;
 		}
@@ -1578,9 +1578,9 @@
 
 		if (iaccessible != null) {
 			/* Forward any other GUIDs to the OS proxy. */
-			int /*long*/[] ppv = new int /*long*/[1];
+		int /*long*/[] ppv = new int /*long*/[1];
 			code = iaccessible.QueryInterface(guid, ppv);
-			COM.MoveMemory(ppvObject, ppv, OS.PTR_SIZEOF);
+		COM.MoveMemory(ppvObject, ppv, OS.PTR_SIZEOF);
 			if (DEBUG) if (interesting(guid)) print("QueryInterface guid=" + guidString(guid) + " returning super" + hresult(code));
 			return code;
 		}
@@ -1724,21 +1724,21 @@
 					accessibleTableCellListeners.size() > 0 || accessibleTextExtendedListeners.size() > 0 ||
 					accessibleValueListeners.size() > 0 || getRelationCount() > 0
 					|| (control instanceof Button && ((control.getStyle() & SWT.RADIO) != 0))) {
-				if (objIAccessible2 == null) createIAccessible2();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessible2.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessible2 == null) createIAccessible2();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessible2.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleAction)) {
 			if (accessibleActionListeners.size() > 0) {
-				if (objIAccessibleAction == null) createIAccessibleAction();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleAction.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleAction == null) createIAccessibleAction();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleAction.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
@@ -1772,21 +1772,21 @@
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleHyperlink)) {
 			if (accessibleHyperlinkListeners.size() > 0) {
-				if (objIAccessibleHyperlink == null) createIAccessibleHyperlink();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleHyperlink.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleHyperlink == null) createIAccessibleHyperlink();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleHyperlink.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleHypertext)) {
 			if (accessibleTextExtendedListeners.size() > 0) {
-				if (objIAccessibleHypertext == null) createIAccessibleHypertext();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleHypertext.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleHypertext == null) createIAccessibleHypertext();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleHypertext.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
@@ -1808,41 +1808,41 @@
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleTable2)) {
 			if (accessibleTableListeners.size() > 0) {
-				if (objIAccessibleTable2 == null) createIAccessibleTable2();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleTable2.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleTable2 == null) createIAccessibleTable2();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleTable2.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleTableCell)) {
 			if (accessibleTableCellListeners.size() > 0) {
-				if (objIAccessibleTableCell == null) createIAccessibleTableCell();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleTableCell.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleTableCell == null) createIAccessibleTableCell();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleTableCell.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleText)) {
 			if (accessibleTextExtendedListeners.size() > 0 /* || accessibleAttributeListeners.size() > 0*/) {
-				if (objIAccessibleText == null) createIAccessibleText();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleText.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleText == null) createIAccessibleText();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleText.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 		
 		if (COM.IsEqualGUID(guid, COM.IIDIAccessibleValue)) {
 			if (accessibleValueListeners.size() > 0) {
-				if (objIAccessibleValue == null) createIAccessibleValue();
-				COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleValue.getAddress() }, OS.PTR_SIZEOF);
-				AddRef();
-				return COM.S_OK;
-			}
+			if (objIAccessibleValue == null) createIAccessibleValue();
+			COM.MoveMemory(ppvObject, new int /*long*/[] { objIAccessibleValue.getAddress() }, OS.PTR_SIZEOF);
+			AddRef();
+			return COM.S_OK;
+		}
 			return COM.E_NOINTERFACE;
 		}
 
@@ -1958,7 +1958,7 @@
 		OS.MoveMemory(pcyHeight, new int[] { event.height }, 4);
 		return COM.S_OK;
 	}
-	
+
 	/* IAccessible::accNavigate([in] navDir, [in] varStart, [out] pvarEndUpAt) */
 	int accNavigate(int navDir, int /*long*/ varStart, int /*long*/ pvarEndUpAt) {
 		if (DEBUG) print(this + ".IAccessible::accNavigate");
@@ -1985,7 +1985,7 @@
 		if (DEBUG) print(this + ".IAccessible::accSelect(" + flagsSelect + ") returning" + hresult(code));
 		return code;
 	}
-
+	
 	/* IAccessible::get_accChild([in] varChild, [out] ppdispChild)
 	 * Ownership of ppdispChild transfers from callee to caller so reference count on ppdispChild 
 	 * must be incremented before returning.  The caller is responsible for releasing ppdispChild.
@@ -2079,13 +2079,13 @@
 	int get_accChildCount(int /*long*/ pcountChildren) {
 		int osChildCount = 0;
 		if (iaccessible != null) {
-			/* Get the default child count from the OS. */
-			int code = iaccessible.get_accChildCount(pcountChildren);
-			if (code == COM.S_OK) {
-				int[] pChildCount = new int[1];
-				COM.MoveMemory(pChildCount, pcountChildren, 4);
-				osChildCount = pChildCount[0];
-			}
+		/* Get the default child count from the OS. */
+		int code = iaccessible.get_accChildCount(pcountChildren);
+		if (code == COM.S_OK) {
+			int[] pChildCount = new int[1];
+			COM.MoveMemory(pChildCount, pcountChildren, 4);
+			osChildCount = pChildCount[0];
+		}
 			if (accessibleControlListeners.size() == 0) {
 				if (DEBUG) print(this + ".IAccessible::get_accChildCount() returning " + osChildCount + " from super" + hresult(code));
 				return code;
@@ -2112,21 +2112,21 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osDefaultAction = null;
 		if (iaccessible != null) {
-			/* Get the default defaultAction from the OS. */
+		/* Get the default defaultAction from the OS. */
 			code = iaccessible.get_accDefaultAction(varChild, pszDefaultAction);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			if (accessibleControlListeners.size() == 0) return code;
-			if (code == COM.S_OK) {
-				int /*long*/[] pDefaultAction = new int /*long*/[1];
-				COM.MoveMemory(pDefaultAction, pszDefaultAction, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pDefaultAction[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pDefaultAction[0], size);
-					osDefaultAction = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (accessibleControlListeners.size() == 0) return code;
+		if (code == COM.S_OK) {
+			int /*long*/[] pDefaultAction = new int /*long*/[1];
+			COM.MoveMemory(pDefaultAction, pszDefaultAction, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pDefaultAction[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pDefaultAction[0], size);
+				osDefaultAction = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2162,22 +2162,22 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osDescription = null;
 		if (iaccessible != null) {
-			/* Get the default description from the OS. */
+		/* Get the default description from the OS. */
 			code = iaccessible.get_accDescription(varChild, pszDescription);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			// TEMPORARY CODE - process tree even if there are no apps listening
-			if (accessibleListeners.size() == 0 && !(control instanceof Tree)) return code;
-			if (code == COM.S_OK) {
-				int /*long*/[] pDescription = new int /*long*/[1];
-				COM.MoveMemory(pDescription, pszDescription, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pDescription[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pDescription[0], size);
-					osDescription = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		// TEMPORARY CODE - process tree even if there are no apps listening
+		if (accessibleListeners.size() == 0 && !(control instanceof Tree)) return code;
+		if (code == COM.S_OK) {
+			int /*long*/[] pDescription = new int /*long*/[1];
+			COM.MoveMemory(pDescription, pszDescription, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pDescription[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pDescription[0], size);
+				osDescription = new String(buffer);
 			}
 		}
+		}
 		
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2227,10 +2227,10 @@
 	int get_accFocus(int /*long*/ pvarChild) {
 		int osChild = ACC.CHILDID_NONE;
 		if (iaccessible != null) {
-			/* Get the default focus child from the OS. */
-			int code = iaccessible.get_accFocus(pvarChild);
-			if (code == COM.S_OK) {
-				VARIANT v = getVARIANT(pvarChild);
+		/* Get the default focus child from the OS. */
+		int code = iaccessible.get_accFocus(pvarChild);
+		if (code == COM.S_OK) {
+			VARIANT v = getVARIANT(pvarChild);
 				if (v.vt == COM.VT_I4) osChild = v.lVal;
 				// TODO: need to check VT_DISPATCH (don't use struct)
 				if (DEBUG) if (v.vt == COM.VT_DISPATCH) print("IAccessible::get_accFocus() super returned VT_DISPATCH"); 
@@ -2238,8 +2238,8 @@
 			if (accessibleControlListeners.size() == 0) {
 				if (DEBUG) print(this + ".IAccessible::get_accFocus() returning childID=" + osChild + " from super" + hresult(code));
 				return code;
-			}
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osChild == ACC.CHILDID_NONE ? ACC.CHILDID_NONE : osToChildID(osChild);
@@ -2279,21 +2279,21 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osHelp = null;
 		if (iaccessible != null) {
-			/* Get the default help string from the OS. */
+		/* Get the default help string from the OS. */
 			code = iaccessible.get_accHelp(varChild, pszHelp);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
-			if (accessibleListeners.size() == 0) return code;
-			if (code == COM.S_OK) {
-				int /*long*/[] pHelp = new int /*long*/[1];
-				COM.MoveMemory(pHelp, pszHelp, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pHelp[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pHelp[0], size);
-					osHelp = new String(buffer);
-				}
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (accessibleListeners.size() == 0) return code;
+		if (code == COM.S_OK) {
+			int /*long*/[] pHelp = new int /*long*/[1];
+			COM.MoveMemory(pHelp, pszHelp, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pHelp[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pHelp[0], size);
+				osHelp = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2317,7 +2317,7 @@
 			/* Since it is possible that a native control might still handle get_accHelpTopic,
 			 * we will continue to send this through to the proxy. */
 			code = iaccessible.get_accHelpTopic(pszHelpFile, varChild, pidTopic);
-			if (code == COM.E_INVALIDARG) code = COM.DISP_E_MEMBERNOTFOUND; // proxy doesn't know about app childID
+		if (code == COM.E_INVALIDARG) code = COM.DISP_E_MEMBERNOTFOUND; // proxy doesn't know about app childID
 		}
 		return code;
 	}
@@ -2330,22 +2330,22 @@
 		int code = COM.DISP_E_MEMBERNOTFOUND;
 		String osKeyboardShortcut = null;
 		if (iaccessible != null) {
-			/* Get the default keyboard shortcut from the OS. */
+		/* Get the default keyboard shortcut from the OS. */
 			code = iaccessible.get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
-			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
+		if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
 			/* Process TabFolder even if there are no apps listening. */
 			if (accessibleListeners.size() == 0 && !(control instanceof TabFolder)) return code;
-			if (code == COM.S_OK) {
-				int /*long*/[] pKeyboardShortcut = new int /*long*/[1];
-				COM.MoveMemory(pKeyboardShortcut, pszKeyboardShortcut, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pKeyboardShortcut[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pKeyboardShortcut[0], size);
-					osKeyboardShortcut = new String(buffer);
-				}
+		if (code == COM.S_OK) {
+			int /*long*/[] pKeyboardShortcut = new int /*long*/[1];
+			COM.MoveMemory(pKeyboardShortcut, pszKeyboardShortcut, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pKeyboardShortcut[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pKeyboardShortcut[0], size);
+				osKeyboardShortcut = new String(buffer);
 			}
 		}
+		}
 
 		AccessibleEvent event = new AccessibleEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2371,18 +2371,18 @@
 		int code = COM.S_FALSE;
 		String osName = null;
 		if (iaccessible != null) {
-			/* Get the default name from the OS. */
+		/* Get the default name from the OS. */
 			code = iaccessible.get_accName(varChild, pszName);
-			if (code == COM.S_OK) {
-				int /*long*/[] pName = new int /*long*/[1];
-				COM.MoveMemory(pName, pszName, OS.PTR_SIZEOF);
-				int size = COM.SysStringByteLen(pName[0]);
-				if (size > 0) {
-					char[] buffer = new char[(size + 1) /2];
-					COM.MoveMemory(buffer, pName[0], size);
-					osName = new String(buffer);
-				}
+		if (code == COM.S_OK) {
+			int /*long*/[] pName = new int /*long*/[1];
+			COM.MoveMemory(pName, pszName, OS.PTR_SIZEOF);
+			int size = COM.SysStringByteLen(pName[0]);
+			if (size > 0) {
+				char[] buffer = new char[(size + 1) /2];
+				COM.MoveMemory(buffer, pName[0], size);
+				osName = new String(buffer);
 			}
+		}
 			if (code == COM.E_INVALIDARG) code = COM.S_FALSE; // proxy doesn't know about app childID
 			/* Process Text even if there are no apps listening. */
 			if (accessibleListeners.size() == 0 && !(control instanceof Text)) {
@@ -2440,13 +2440,13 @@
 		if (v.vt != COM.VT_I4) return COM.E_INVALIDARG;
 		int osRole = COM.ROLE_SYSTEM_CLIENT;
 		if (iaccessible != null) {
-			/* Get the default role from the OS. */
-			int code = iaccessible.get_accRole(varChild, pvarRole);
-			if (code == COM.S_OK) {
-				VARIANT v2 = getVARIANT(pvarRole);
-				if (v2.vt == COM.VT_I4) osRole = v2.lVal;
-			}
+		/* Get the default role from the OS. */
+		int code = iaccessible.get_accRole(varChild, pvarRole);
+		if (code == COM.S_OK) {
+			VARIANT v2 = getVARIANT(pvarRole);
+			if (v2.vt == COM.VT_I4) osRole = v2.lVal;
 		}
+		}
 
 		AccessibleControlEvent event = new AccessibleControlEvent(this);
 		event.childID = osToChildID(v.lVal);
@@ -2454,7 +2454,7 @@
 		// TEMPORARY CODE
 		/* Currently our checkbox table and tree are emulated using state mask images,
 		 * so we need to specify 'checkbox' role for the items. */
-		if (control instanceof Tree || control instanceof Table) {
+			if (control instanceof Tree || control instanceof Table) {
 			if (v.lVal != COM.CHILDID_SELF && (control.getStyle() & SWT.CHECK) != 0) event.detail = ACC.ROLE_CHECKBUTTON;
 		}
 		for (int i = 0; i < accessibleControlListeners.size(); i++) {
@@ -2583,7 +2583,7 @@
 		setIntVARIANT(pvarState, COM.VT_I4, state);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessible::get_accValue([in] varChild, [out] pszValue) */
 	int get_accValue(int /*long*/ varChild, int /*long*/ pszValue) {
 		VARIANT v = getVARIANT(varChild);
@@ -2754,7 +2754,7 @@
 		}
 		return COM.S_FALSE;
 	}
-
+	
 	/* IEnumVARIANT::Skip([in] celt) over the specified number of elements in the enumeration sequence. */
 	int Skip(int celt) {
 		if (DEBUG) print(this + ".IEnumVARIANT::Skip");
@@ -3223,8 +3223,8 @@
 		if (DEBUG) print(this + ".IAccessibleAction::get_localizedName(" + actionIndex + ") returning " + event.result + hresult(event.result == null || event.result.length() == 0 ? COM.S_FALSE : COM.S_OK));
 		if (event.result == null || event.result.length() == 0) {
 			setString(pbstrLocalizedName, null);
-			return COM.S_FALSE;
-		}
+		return COM.S_FALSE;
+	}
 		setString(pbstrLocalizedName, event.result);
 		return COM.S_OK;
 	}
@@ -3591,7 +3591,7 @@
 			setIntVARIANT(ppHyperlink, COM.VT_EMPTY, 0);
 			return COM.E_INVALIDARG;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppHyperlink, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3668,7 +3668,7 @@
 		Accessible accessible = event.accessible;
 		if (DEBUG) print(this + ".IAccessibleTable2::get_cellAt(row=" + row + ", column=" + column + ") returning " + accessible);
 		if (accessible == null) return COM.E_INVALIDARG;
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppCell, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3686,7 +3686,7 @@
 			COM.MoveMemory(ppAccessible, new int /*long*/[] { 0 }, OS.PTR_SIZEOF);
 			return COM.S_FALSE;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppAccessible, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 		return COM.S_OK;
 	}
@@ -3797,8 +3797,8 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
 			}
@@ -3951,8 +3951,8 @@
 		if (DEBUG) print(this + ".IAccessibleTable2::get_modelChange() returning " + (tableChange == null ? "null" : "tableChange=" + tableChange[0] + ", " + tableChange[1] + ", " + tableChange[2] + ", " + tableChange[3]));
 		if (tableChange == null) {
 			COM.MoveMemory(pModelChange, new int /*long*/ [] { 0 }, OS.PTR_SIZEOF);
-			return COM.S_FALSE;
-		}
+		return COM.S_FALSE;
+	}
 		COM.MoveMemory(pModelChange, tableChange, tableChange.length * 4);
 		return COM.S_OK;
 	}
@@ -3987,12 +3987,12 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
-			}
 		}
+		}
 		COM.MoveMemory(ppCellAccessibles, new int /*long*/ [] { pv }, OS.PTR_SIZEOF);
 		COM.MoveMemory(pNColumnHeaderCells, new int [] { count }, 4);
 		return COM.S_OK;
@@ -4040,8 +4040,8 @@
 		int count = 0;
 		for (int i = 0; i < length; i++) {
 			Accessible accessible = event.accessibles[i];
-			if (accessible != null) {
-				accessible.AddRef();
+		if (accessible != null) {
+			accessible.AddRef();
 				COM.MoveMemory(pv + i * OS.PTR_SIZEOF, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
 				count++;
 			}
@@ -4062,7 +4062,7 @@
 		COM.MoveMemory(pRowIndex, new int [] { event.index }, 4);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleTableCell::get_isSelected([out] pIsSelected) */
 	int get_isSelected(int /*long*/ pIsSelected) {
 		AccessibleTableCellEvent event = new AccessibleTableCellEvent(this);
@@ -4090,7 +4090,7 @@
 //		COM.MoveMemory(pRowExtents, new int [] { event.rowExtents }, 4);
 //		COM.MoveMemory(pColumnExtents, new int [] { event.columnExtents }, 4);
 //		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleTableCell::get_table([out] ppTable) */
 	int get_table(int /*long*/ ppTable) {
@@ -4106,10 +4106,10 @@
 			COM.MoveMemory(ppTable, new int /*long*/[] { 0 }, OS.PTR_SIZEOF);
 			return COM.S_FALSE;
 		}
-		accessible.AddRef();
+			accessible.AddRef();
 		COM.MoveMemory(ppTable, new int /*long*/[] { accessible.getAddress() }, OS.PTR_SIZEOF);
-		return COM.S_OK;
-	}
+			return COM.S_OK;
+		}
 
 	/* IAccessibleText::addSelection([in] startOffset, [in] endOffset) */
 	int addSelection(int startOffset, int endOffset) {
@@ -4122,8 +4122,8 @@
 			listener.addSelection(event);
 		}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
-		return COM.S_OK;
-	}
+			return COM.S_OK;
+		}
 
 	/* IAccessibleText::get_attributes([in] offset, [out] pStartOffset, [out] pEndOffset, [out] pbstrTextAttributes) */
 	int get_attributes(int offset, int /*long*/ pStartOffset, int /*long*/ pEndOffset, int /*long*/ pbstrTextAttributes) {
@@ -4185,7 +4185,7 @@
 		if (textAttributes.length() == 0) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_caretOffset([out] pOffset) */
 	int get_caretOffset(int /*long*/ pOffset) {
 		int offset = getCaretOffset();
@@ -4193,7 +4193,7 @@
 		COM.MoveMemory(pOffset, new int [] { offset }, 4);
 		if (offset == -1) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+				}
 
 	/* IAccessibleText::get_characterExtents([in] offset, [in] coordType, [out] pX, [out] pY, [out] pWidth, [out] pHeight) */
 	int get_characterExtents(int offset, int coordType, int /*long*/ pX, int /*long*/ pY, int /*long*/ pWidth, int /*long*/ pHeight) {
@@ -4204,7 +4204,7 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.getTextBounds(event);
-		}
+				}
 		/* Note: event.rectangles is not used here, because IAccessibleText::get_characterExtents is just for one character. */
 		if (DEBUG) print(this + ".IAccessibleText::get_characterExtents(" + offset + ") returning " + event.x + ", " + event.y + ", " + event.width + ", " + event.height);
 		COM.MoveMemory(pX, new int [] { event.x }, 4);
@@ -4213,7 +4213,7 @@
 		COM.MoveMemory(pHeight, new int [] { event.height }, 4);
 		if (event.width == 0 && event.height == 0) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::get_nSelections([out] pNSelections) */
 	int get_nSelections(int /*long*/ pNSelections) {
@@ -4236,7 +4236,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::get_nSelections returning " + event.count);
 		COM.MoveMemory(pNSelections, new int [] { event.count }, 4);
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_offsetAtPoint([in] x, [in] y, [in] coordType, [out] pOffset) */
 	int get_offsetAtPoint(int x, int y, int coordType, int /*long*/ pOffset) {
@@ -4257,7 +4257,7 @@
 		if (event.offset == -1) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_selection([in] selectionIndex, [out] pStartOffset, [out] pEndOffset) */
 	int get_selection(int selectionIndex, int /*long*/ pStartOffset, int /*long*/ pEndOffset) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4267,7 +4267,7 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.getSelection(event);
-		}
+			}
 		if (event.start == -1 && selectionIndex == 0) {
 			event.childID = ACC.CHILDID_SELF;
 			event.offset = -1;
@@ -4288,7 +4288,7 @@
 		 */
 		if (event.start == -1) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_text([in] startOffset, [in] endOffset, [out] pbstrText) */
 	int get_text(int startOffset, int endOffset, int /*long*/ pbstrText) {
@@ -4325,7 +4325,7 @@
 		if (event.result == null) return COM.E_INVALIDARG;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_textBeforeOffset([in] offset, [in] boundaryType, [out] pStartOffset, [out] pEndOffset, [out] pbstrText) */
 	int get_textBeforeOffset(int offset, int boundaryType, int /*long*/ pStartOffset, int /*long*/ pEndOffset, int /*long*/ pbstrText) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4378,7 +4378,7 @@
 		if (event.result == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_textAfterOffset([in] offset, [in] boundaryType, [out] pStartOffset, [out] pEndOffset, [out] pbstrText) */
 	int get_textAfterOffset(int offset, int boundaryType, int /*long*/ pStartOffset, int /*long*/ pEndOffset, int /*long*/ pbstrText) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4491,7 +4491,7 @@
 		if (event.result == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	 
 	/* IAccessibleText::removeSelection([in] selectionIndex) */
 	int removeSelection(int selectionIndex) {
 		AccessibleTextEvent event = new AccessibleTextEvent(this);
@@ -4503,7 +4503,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::removeSelection(" + selectionIndex + ") returning" + hresult(event.result == null || !event.result.equals(ACC.OK) ? COM.E_INVALIDARG : COM.S_OK));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::setCaretOffset([in] offset) */
 	int setCaretOffset(int offset) {
@@ -4516,7 +4516,7 @@
 		if (DEBUG) print(this + ".IAccessibleText::setCaretOffset(" + offset + ") returning" + hresult(event.result == null || !event.result.equals(ACC.OK) ? COM.E_INVALIDARG : COM.S_OK));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG; // TODO: @retval E_FAIL if the caret cannot be set ?
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::setSelection([in] selectionIndex, [in] startOffset, [in] endOffset) */
 	int setSelection(int selectionIndex, int startOffset, int endOffset) {
@@ -4527,11 +4527,11 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.setSelection(event);
-		}
+		}	
 		if (DEBUG) print(this + ".IAccessibleText::setSelection(index=" + selectionIndex + ", start=" + event.start + ", end=" + event.end + ") returning " + (event.result.equals(ACC.OK) ? "OK" : "INVALIDARG"));
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+					}
 
 	/* IAccessibleText::get_nCharacters([out] pNCharacters) */
 	int get_nCharacters(int /*long*/ pNCharacters) {
@@ -4539,7 +4539,7 @@
 		COM.MoveMemory(pNCharacters, new int [] { count }, 4);
 		if (DEBUG) print(this + ".IAccessibleText::get_nCharacters returning " + count);
 		return COM.S_OK;
-	}
+			}
 
 	/* IAccessibleText::scrollSubstringTo([in] startIndex, [in] endIndex, [in] scrollType) */
 	int scrollSubstringTo(int startIndex, int endIndex, int scrollType) {
@@ -4562,7 +4562,7 @@
 		}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG;
 		return COM.S_OK;
-	}
+				}
 
 	/* IAccessibleText::scrollSubstringToPoint([in] startIndex, [in] endIndex, [in] coordinateType, [in] x, [in] y) */
 	int scrollSubstringToPoint(int startIndex, int endIndex, int coordinateType, int x, int y) {
@@ -4576,10 +4576,10 @@
 		for (int i = 0; i < accessibleTextExtendedListeners.size(); i++) {
 			AccessibleTextExtendedListener listener = (AccessibleTextExtendedListener) accessibleTextExtendedListeners.elementAt(i);
 			listener.scrollText(event);
-		}
+			}
 		if (event.result == null || !event.result.equals(ACC.OK)) return COM.E_INVALIDARG; // TODO: @retval S_FALSE if the object is already at the specified location.
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleText::get_newText([out] pNewText) */
 	int get_newText(int /*long*/ pNewText) {
@@ -4598,7 +4598,7 @@
 		if (textInserted == null) return COM.S_FALSE;
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleText::get_oldText([out] pOldText) */
 	int get_oldText(int /*long*/ pOldText) {
 		if (DEBUG) print(this + ".IAccessibleText::get_oldText");
@@ -4615,7 +4615,7 @@
 		COM.MoveMemory(pOldText + OS.PTR_SIZEOF + 4, new int [] {end}, 4);
 		if (textDeleted == null) return COM.S_FALSE;
 		return COM.S_OK;
-	}
+		}
 
 	/* IAccessibleValue::get_currentValue([out] pCurrentValue) */
 	int get_currentValue(int /*long*/ pCurrentValue) {
@@ -4628,7 +4628,7 @@
 		setNumberVARIANT(pCurrentValue, event.value);
 		return COM.S_OK;
 	}
-
+	
 	/* IAccessibleValue::setCurrentValue([in] value) */
 	int setCurrentValue(int /*long*/ value) {
 		if (DEBUG) print(this + ".IAccessibleValue::setCurrentValue");
@@ -4640,8 +4640,8 @@
 		}
 		//if (event.value == null) return COM.S_FALSE;
 		return COM.S_OK;
-	}
-
+		}
+		
 	/* IAccessibleValue::get_maximumValue([out] pMaximumValue) */
 	int get_maximumValue(int /*long*/ pMaximumValue) {
 		AccessibleValueEvent event = new AccessibleValueEvent(this);
@@ -4665,7 +4665,7 @@
 		setNumberVARIANT(pMinimumValue, event.value);
 		return COM.S_OK;
 	}
-
+	
 	int eventChildID() {
 		if (parent == null) return COM.CHILDID_SELF;
 		if (uniqueID == -1) uniqueID = UniqueID--;
@@ -4692,8 +4692,8 @@
 		/* ChildIDs are 1-based indices. */
 		int osChildID = childID + 1;
 		if (control instanceof Tree) {
-			/*
-			* Feature of Windows:
+		/*
+		* Feature of Windows:
 			* Before Windows XP, tree item ids were 1-based indices.
 			* Windows XP and later use the tree item handle for the
 			* accessible child ID. For backward compatibility, we still
@@ -4982,7 +4982,7 @@
 		COM.MoveMemory(v, variant, VARIANT.sizeof);
 		return v;
 	}
-	
+
 	Number getNumberVARIANT(int /*long*/ variant) {
 		VARIANT v = new VARIANT();
 		COM.MoveMemory(v, variant, VARIANT.sizeof);
@@ -5003,7 +5003,7 @@
 			COM.MoveMemory(variant + 8, new int /*long*/ [] { lVal }, OS.PTR_SIZEOF);
 		}
 	}
-	
+
 	void setNumberVARIANT(int /*long*/ variant, Number number) {
 		if (number == null) {
 			COM.MoveMemory(variant, new short[] { COM.VT_EMPTY }, 2);
@@ -5026,7 +5026,7 @@
 	void setString(int /*long*/ psz, String string) {
 		int /*long*/ ptr = 0;
 		if (string != null) {
-			char[] data = (string + "\0").toCharArray();
+		char[] data = (string + "\0").toCharArray();
 			ptr = COM.SysAllocString(data);
 		}
 		COM.MoveMemory(psz, new int /*long*/ [] { ptr }, OS.PTR_SIZEOF);
Index: org/eclipse/swt/printing/Printer.java
===================================================================
--- org/eclipse/swt/printing/Printer.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/printing/Printer.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -242,28 +242,28 @@
 	
 	/* Initialize DEVMODE struct fields from the printerData. */
 	if (lpInitData != 0) {
-		DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-		OS.MoveMemory(devmode, lpInitData, DEVMODE.sizeof);
-		devmode.dmFields |= OS.DM_ORIENTATION;
-		devmode.dmOrientation = data.orientation == PrinterData.LANDSCAPE ? OS.DMORIENT_LANDSCAPE : OS.DMORIENT_PORTRAIT;
-		if (data.copyCount != 1) {
-			devmode.dmFields |= OS.DM_COPIES;
-			devmode.dmCopies = (short)data.copyCount;
+	DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+	OS.MoveMemory(devmode, lpInitData, DEVMODE.sizeof);
+	devmode.dmFields |= OS.DM_ORIENTATION;
+	devmode.dmOrientation = data.orientation == PrinterData.LANDSCAPE ? OS.DMORIENT_LANDSCAPE : OS.DMORIENT_PORTRAIT;
+	if (data.copyCount != 1) {
+		devmode.dmFields |= OS.DM_COPIES;
+		devmode.dmCopies = (short)data.copyCount;
+	}
+	if (data.collate != false) {
+		devmode.dmFields |= OS.DM_COLLATE;
+		devmode.dmCollate = OS.DMCOLLATE_TRUE;
+	}
+	if (data.duplex != SWT.DEFAULT) {
+		devmode.dmFields |= OS.DM_DUPLEX;
+		switch (data.duplex) {
+			case PrinterData.DUPLEX_SHORT_EDGE: devmode.dmDuplex = OS.DMDUP_HORIZONTAL; break;
+			case PrinterData.DUPLEX_LONG_EDGE: devmode.dmDuplex = OS.DMDUP_VERTICAL; break;
+			default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
 		}
-		if (data.collate != false) {
-			devmode.dmFields |= OS.DM_COLLATE;
-			devmode.dmCollate = OS.DMCOLLATE_TRUE;
-		}
-		if (data.duplex != SWT.DEFAULT) {
-			devmode.dmFields |= OS.DM_DUPLEX;
-			switch (data.duplex) {
-				case PrinterData.DUPLEX_SHORT_EDGE: devmode.dmDuplex = OS.DMDUP_HORIZONTAL; break;
-				case PrinterData.DUPLEX_LONG_EDGE: devmode.dmDuplex = OS.DMDUP_VERTICAL; break;
-				default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
-			}
-		}
-		OS.MoveMemory(lpInitData, devmode, DEVMODE.sizeof);
 	}
+	OS.MoveMemory(lpInitData, devmode, DEVMODE.sizeof);
+	}
 	handle = OS.CreateDC(driver, device, 0, lpInitData);
 	if (lpInitData != 0) OS.HeapFree(hHeap, 0, lpInitData);
 	if (handle == 0) SWT.error(SWT.ERROR_NO_HANDLES);
Index: org/eclipse/swt/printing/PrintDialog.java
===================================================================
--- org/eclipse/swt/printing/PrintDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/printing/PrintDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -336,55 +336,55 @@
 			}
 		}
 		if (success) {
-			/* Initialize PRINTDLG DEVNAMES for the specified printer. */
-			TCHAR buffer = new TCHAR(0, printerData.name, true);
-			int size = buffer.length() * TCHAR.sizeof;
-			short[] offsets = new short[4]; // DEVNAMES (4 offsets)
-			int offsetsSize = offsets.length * 2; // 2 bytes each
-			offsets[1] = (short) offsets.length; // offset 1 points to wDeviceOffset
-			int /*long*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, offsetsSize + size);
-			int /*long*/ ptr = OS.GlobalLock(hMem);
-			OS.MoveMemory(ptr, offsets, offsetsSize);
-			OS.MoveMemory(ptr + offsetsSize, buffer, size);
-			OS.GlobalUnlock(hMem);
-			pd.hDevNames = hMem;
+		/* Initialize PRINTDLG DEVNAMES for the specified printer. */
+		TCHAR buffer = new TCHAR(0, printerData.name, true);
+		int size = buffer.length() * TCHAR.sizeof;
+		short[] offsets = new short[4]; // DEVNAMES (4 offsets)
+		int offsetsSize = offsets.length * 2; // 2 bytes each
+		offsets[1] = (short) offsets.length; // offset 1 points to wDeviceOffset
+		int /*long*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, offsetsSize + size);
+		int /*long*/ ptr = OS.GlobalLock(hMem);
+		OS.MoveMemory(ptr, offsets, offsetsSize);
+		OS.MoveMemory(ptr + offsetsSize, buffer, size);
+		OS.GlobalUnlock(hMem);
+		pd.hDevNames = hMem;
 		}
 	}
 	if (!success) {
 		/* Initialize PRINTDLG fields, including DEVMODE, for the default printer. */
-		pd.Flags = OS.PD_RETURNDEFAULT;
+	pd.Flags = OS.PD_RETURNDEFAULT;
 		if (success = OS.PrintDlg(pd)) {
-			if (pd.hDevNames != 0) {
-				OS.GlobalFree(pd.hDevNames);
-				pd.hDevNames = 0;
-			}
+		if (pd.hDevNames != 0) {
+			OS.GlobalFree(pd.hDevNames);
+			pd.hDevNames = 0;
 		}
+		}
 	}
 
 	if (success) {
-		/*
-		 * If user setup info from a previous print dialog was specified,
-		 * then restore the previous DEVMODE struct.
-		 */
-		byte devmodeData [] = printerData.otherData;
-		if (devmodeData != null && devmodeData.length != 0) {
+	/*
+	 * If user setup info from a previous print dialog was specified,
+	 * then restore the previous DEVMODE struct.
+	 */
+	byte devmodeData [] = printerData.otherData;
+	if (devmodeData != null && devmodeData.length != 0) {
 			int /*long*/ hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, devmodeData.length);
 			int /*long*/ ptr = OS.GlobalLock(hMem);
 			OS.MoveMemory(ptr, devmodeData, devmodeData.length);
 			OS.GlobalUnlock(hMem);
-			if (pd.hDevMode != 0) OS.GlobalFree(pd.hDevMode);
+		if (pd.hDevMode != 0) OS.GlobalFree(pd.hDevMode);
 			pd.hDevMode = hMem;
 		}
-		
-		/* Initialize the DEVMODE struct's fields from the printerData. */
-		int /*long*/ hMem = pd.hDevMode;
+	
+	/* Initialize the DEVMODE struct's fields from the printerData. */
+	int /*long*/ hMem = pd.hDevMode;
 		if (hMem == 0) {
 			hMem = OS.GlobalAlloc(OS.GMEM_MOVEABLE | OS.GMEM_ZEROINIT, DEVMODE.sizeof);
 			pd.hDevMode = hMem;
 		}
-		int /*long*/ ptr = OS.GlobalLock(hMem);
-		DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-		OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+	int /*long*/ ptr = OS.GlobalLock(hMem);
+	DEVMODE devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+	OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
 		if (printerData.name != null) {
 			/* Copy PRINTDLG DEVNAMES into DEVMODE dmDeviceName (truncate if necessary). */
 			int max = Math.min(printerData.name.length(), OS.CCHDEVICENAME - 1);
@@ -399,16 +399,16 @@
 				}
 			}
 		}
-		devmode.dmFields |= OS.DM_ORIENTATION;
-		devmode.dmOrientation = printerData.orientation == PrinterData.PORTRAIT ? OS.DMORIENT_PORTRAIT : OS.DMORIENT_LANDSCAPE;
-		if (printerData.copyCount != 1) {
-			devmode.dmFields |= OS.DM_COPIES;
-			devmode.dmCopies = (short)printerData.copyCount;
-		}
-		if (printerData.collate != false) {
-			devmode.dmFields |= OS.DM_COLLATE;
-			devmode.dmCollate = OS.DMCOLLATE_TRUE;
-		}
+	devmode.dmFields |= OS.DM_ORIENTATION;
+	devmode.dmOrientation = printerData.orientation == PrinterData.PORTRAIT ? OS.DMORIENT_PORTRAIT : OS.DMORIENT_LANDSCAPE;
+	if (printerData.copyCount != 1) {
+		devmode.dmFields |= OS.DM_COPIES;
+		devmode.dmCopies = (short)printerData.copyCount;
+	}
+	if (printerData.collate != false) {
+		devmode.dmFields |= OS.DM_COLLATE;
+		devmode.dmCollate = OS.DMCOLLATE_TRUE;
+	}
 		if (printerData.duplex != SWT.DEFAULT) {
 			devmode.dmFields |= OS.DM_DUPLEX;
 			switch (printerData.duplex) {
@@ -417,110 +417,110 @@
 				default: devmode.dmDuplex = OS.DMDUP_SIMPLEX;
 			}
 		}
-		OS.MoveMemory(ptr, devmode, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
-		OS.GlobalUnlock(hMem);
+	OS.MoveMemory(ptr, devmode, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+	OS.GlobalUnlock(hMem);
+
+	pd.Flags = OS.PD_USEDEVMODECOPIESANDCOLLATE;
+	if (printerData.printToFile) pd.Flags |= OS.PD_PRINTTOFILE;
+	switch (printerData.scope) {
+		case PrinterData.PAGE_RANGE: pd.Flags |= OS.PD_PAGENUMS; break;
+		case PrinterData.SELECTION: pd.Flags |= OS.PD_SELECTION; break;
+		default: pd.Flags |= OS.PD_ALLPAGES;
+	}
+	pd.nMinPage = 1;
+	pd.nMaxPage = -1;
+	pd.nFromPage = (short) Math.min (0xFFFF, Math.max (1, printerData.startPage));
+	pd.nToPage = (short) Math.min (0xFFFF, Math.max (1, printerData.endPage));
 	
-		pd.Flags = OS.PD_USEDEVMODECOPIESANDCOLLATE;
-		if (printerData.printToFile) pd.Flags |= OS.PD_PRINTTOFILE;
-		switch (printerData.scope) {
-			case PrinterData.PAGE_RANGE: pd.Flags |= OS.PD_PAGENUMS; break;
-			case PrinterData.SELECTION: pd.Flags |= OS.PD_SELECTION; break;
-			default: pd.Flags |= OS.PD_ALLPAGES;
-		}
-		pd.nMinPage = 1;
-		pd.nMaxPage = -1;
-		pd.nFromPage = (short) Math.min (0xFFFF, Math.max (1, printerData.startPage));
-		pd.nToPage = (short) Math.min (0xFFFF, Math.max (1, printerData.endPage));
-	
-		Display display = parent.getDisplay();
-		Shell [] shells = display.getShells();
-		if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
-			for (int i=0; i<shells.length; i++) {
-				if (shells[i].isEnabled() && shells[i] != parent) {
-					shells[i].setEnabled(false);
-				} else {
-					shells[i] = null;
-				}
+	Display display = parent.getDisplay();
+	Shell [] shells = display.getShells();
+	if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
+		for (int i=0; i<shells.length; i++) {
+			if (shells[i].isEnabled() && shells[i] != parent) {
+				shells[i].setEnabled(false);
+			} else {
+				shells[i] = null;
 			}
 		}
-		String key = "org.eclipse.swt.internal.win32.runMessagesInIdle"; //$NON-NLS-1$
-		Object oldValue = display.getData(key);
-		display.setData(key, new Boolean(true));
+	}
+	String key = "org.eclipse.swt.internal.win32.runMessagesInIdle"; //$NON-NLS-1$
+	Object oldValue = display.getData(key);
+	display.setData(key, new Boolean(true));
 		success = OS.PrintDlg(pd);
-		display.setData(key, oldValue);
-		if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
-			for (int i=0; i<shells.length; i++) {
-				if (shells[i] != null && !shells[i].isDisposed ()) {
-					shells[i].setEnabled(true);
-				}
+	display.setData(key, oldValue);
+	if ((getStyle() & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
+		for (int i=0; i<shells.length; i++) {
+			if (shells[i] != null && !shells[i].isDisposed ()) {
+				shells[i].setEnabled(true);
 			}
 		}
-		
-		if (success) {
-			/* Get driver and device from the DEVNAMES struct */
-			hMem = pd.hDevNames;
-			/* Ensure size is a multiple of 2 bytes on UNICODE platforms */
-			int size = OS.GlobalSize(hMem) / TCHAR.sizeof * TCHAR.sizeof;
-			ptr = OS.GlobalLock(hMem);
-			short[] offsets = new short[4];
-			OS.MoveMemory(offsets, ptr, 2 * offsets.length);
-			TCHAR buffer = new TCHAR(0, size);
-			OS.MoveMemory(buffer, ptr, size);	
-			OS.GlobalUnlock(hMem);
+	}
 	
-			int driverOffset = offsets[0];
-			int i = 0;
-			while (driverOffset + i < size) {
-				if (buffer.tcharAt(driverOffset + i) == 0) break;
-				i++;
-			}
-			String driver = buffer.toString(driverOffset, i);
-	
-			int deviceOffset = offsets[1];
-			i = 0;
-			while (deviceOffset + i < size) {
-				if (buffer.tcharAt(deviceOffset + i) == 0) break;
-				i++;
-			}
-			String device = buffer.toString(deviceOffset, i);	
+	if (success) {
+		/* Get driver and device from the DEVNAMES struct */
+		hMem = pd.hDevNames;
+		/* Ensure size is a multiple of 2 bytes on UNICODE platforms */
+		int size = OS.GlobalSize(hMem) / TCHAR.sizeof * TCHAR.sizeof;
+		ptr = OS.GlobalLock(hMem);
+		short[] offsets = new short[4];
+		OS.MoveMemory(offsets, ptr, 2 * offsets.length);
+		TCHAR buffer = new TCHAR(0, size);
+		OS.MoveMemory(buffer, ptr, size);	
+		OS.GlobalUnlock(hMem);
 
-			/* Create PrinterData object and set fields from PRINTDLG */
-			data = new PrinterData(driver, device);
-			if ((pd.Flags & OS.PD_PAGENUMS) != 0) {
-				data.scope = PrinterData.PAGE_RANGE;
-				data.startPage = pd.nFromPage & 0xFFFF;
-				data.endPage = pd.nToPage & 0xFFFF;
-			} else if ((pd.Flags & OS.PD_SELECTION) != 0) {
-				data.scope = PrinterData.SELECTION;
-			}
-			data.printToFile = (pd.Flags & OS.PD_PRINTTOFILE) != 0;
+		int driverOffset = offsets[0];
+		int i = 0;
+		while (driverOffset + i < size) {
+			if (buffer.tcharAt(driverOffset + i) == 0) break;
+			i++;
+		}
+		String driver = buffer.toString(driverOffset, i);
+
+		int deviceOffset = offsets[1];
+		i = 0;
+		while (deviceOffset + i < size) {
+			if (buffer.tcharAt(deviceOffset + i) == 0) break;
+			i++;
+		}
+		String device = buffer.toString(deviceOffset, i);	
+
+		/* Create PrinterData object and set fields from PRINTDLG */
+		data = new PrinterData(driver, device);
+		if ((pd.Flags & OS.PD_PAGENUMS) != 0) {
+			data.scope = PrinterData.PAGE_RANGE;
+			data.startPage = pd.nFromPage & 0xFFFF;
+			data.endPage = pd.nToPage & 0xFFFF;
+		} else if ((pd.Flags & OS.PD_SELECTION) != 0) {
+			data.scope = PrinterData.SELECTION;
+		}
+		data.printToFile = (pd.Flags & OS.PD_PRINTTOFILE) != 0;
 			if (data.printToFile) data.fileName = printerData.fileName;
-			data.copyCount = pd.nCopies;
-			data.collate = (pd.Flags & OS.PD_COLLATE) != 0;
-	
-			/* Bulk-save the printer-specific settings in the DEVMODE struct */
-			hMem = pd.hDevMode;
-			size = OS.GlobalSize(hMem);
-			ptr = OS.GlobalLock(hMem);
-			data.otherData = new byte[size];
-			OS.MoveMemory(data.otherData, ptr, size);
+		data.copyCount = pd.nCopies;
+		data.collate = (pd.Flags & OS.PD_COLLATE) != 0;
+
+		/* Bulk-save the printer-specific settings in the DEVMODE struct */
+		hMem = pd.hDevMode;
+		size = OS.GlobalSize(hMem);
+		ptr = OS.GlobalLock(hMem);
+		data.otherData = new byte[size];
+		OS.MoveMemory(data.otherData, ptr, size);
 			
 			/* Set PrinterData fields from DEVMODE */
-			devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
-			OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
-			if ((devmode.dmFields & OS.DM_ORIENTATION) != 0) {
-				int dmOrientation = devmode.dmOrientation;
-				data.orientation = dmOrientation == OS.DMORIENT_LANDSCAPE ? PrinterData.LANDSCAPE : PrinterData.PORTRAIT;
-			}
+		devmode = OS.IsUnicode ? (DEVMODE)new DEVMODEW () : new DEVMODEA ();
+		OS.MoveMemory(devmode, ptr, OS.IsUnicode ? OS.DEVMODEW_sizeof() : OS.DEVMODEA_sizeof());
+		if ((devmode.dmFields & OS.DM_ORIENTATION) != 0) {
+			int dmOrientation = devmode.dmOrientation;
+			data.orientation = dmOrientation == OS.DMORIENT_LANDSCAPE ? PrinterData.LANDSCAPE : PrinterData.PORTRAIT;
+		}
 			if ((devmode.dmFields & OS.DM_DUPLEX) != 0) {
 				short dmDuplex = devmode.dmDuplex;
 				data.duplex = dmDuplex == OS.DMDUP_SIMPLEX ? PrinterData.DUPLEX_NONE : dmDuplex == OS.DMDUP_HORIZONTAL ? PrinterData.DUPLEX_SHORT_EDGE : PrinterData.DUPLEX_LONG_EDGE;
 			}
 
-			OS.GlobalUnlock(hMem);
-			printerData = data;
-		}
+		OS.GlobalUnlock(hMem);
+		printerData = data;
 	}
+	}
 	if (pd.hDevNames != 0) {
 		OS.GlobalFree(pd.hDevNames);
 		pd.hDevNames = 0;
Index: org/eclipse/swt/printing/PrinterData.java
===================================================================
--- org/eclipse/swt/printing/PrinterData.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/printing/PrinterData.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -155,7 +155,7 @@
 	 * the current selection should be printed
 	 */	
 	public static final int SELECTION = 2;
-		
+	
 	/**
 	 * <code>orientation</code> field value indicating
 	 * portrait paper orientation
@@ -172,7 +172,7 @@
 	 */
 	public static final int LANDSCAPE = 2;
 	
- 	/**
+	/**
 	 * <code>duplex</code> field value indicating
 	 * single-sided printing.
 	 * <p>
Index: org/eclipse/swt/awt/SWT_AWT.java
===================================================================
--- org/eclipse/swt/awt/SWT_AWT.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/awt/SWT_AWT.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -146,43 +146,43 @@
 	Runnable runnable = new Runnable () {
 		public void run () {
 			try {
-				/*
-				 * Some JREs have implemented the embedded frame constructor to take an integer
-				 * and other JREs take a long.  To handle this binary incompatibility, use
-				 * reflection to create the embedded frame.
-				 */
-				Class clazz = null;
-				try {
-					String className = embeddedFrameClass != null ? embeddedFrameClass : "sun.awt.windows.WEmbeddedFrame";
-					clazz = Class.forName(className);
-				} catch (Throwable e) {
+	/*
+	 * Some JREs have implemented the embedded frame constructor to take an integer
+	 * and other JREs take a long.  To handle this binary incompatibility, use
+	 * reflection to create the embedded frame.
+	 */
+	Class clazz = null;
+	try {
+		String className = embeddedFrameClass != null ? embeddedFrameClass : "sun.awt.windows.WEmbeddedFrame";
+		clazz = Class.forName(className);
+	} catch (Throwable e) {
 					exception[0] = e;
 					return;
-				}
-				initializeSwing ();
-				Object value = null;
-				Constructor constructor = null;
-				try {
-					constructor = clazz.getConstructor (new Class [] {int.class});
-					value = constructor.newInstance (new Object [] {new Integer ((int)/*64*/handle)});
-				} catch (Throwable e1) {
-					try {
-						constructor = clazz.getConstructor (new Class [] {long.class});
-						value = constructor.newInstance (new Object [] {new Long (handle)});
-					} catch (Throwable e2) {
+	}
+	initializeSwing ();
+	Object value = null;
+	Constructor constructor = null;
+	try {
+		constructor = clazz.getConstructor (new Class [] {int.class});
+		value = constructor.newInstance (new Object [] {new Integer ((int)/*64*/handle)});
+	} catch (Throwable e1) {
+		try {
+			constructor = clazz.getConstructor (new Class [] {long.class});
+			value = constructor.newInstance (new Object [] {new Long (handle)});
+		} catch (Throwable e2) {
 						exception[0] = e2;
 						return;
-					}
-				}
-				final Frame frame = (Frame) value;
+		}
+	}
+	final Frame frame = (Frame) value;
+	/*
+	 * This is necessary to make lightweight components
+	 * directly added to the frame receive mouse events
+	 * properly.
+	 */
+	frame.addNotify();
+
 				/*
-				 * This is necessary to make lightweight components
-				 * directly added to the frame receive mouse events
-				 * properly.
-				 */
-				frame.addNotify();
-				
-				/*
 				* TEMPORARY CODE
 				* 
 				* For some reason, the graphics configuration of the embedded
@@ -274,7 +274,7 @@
 					EventQueue.invokeLater(new Runnable () {
 						public void run () {
 							try {
-								frame.dispose ();
+							frame.dispose ();
 							} catch (Throwable e) {}
 						}
 					});
@@ -324,7 +324,7 @@
 		}
 	};
 	if (Library.JAVA_VERSION < Library.JAVA_VERSION(1, 5, 0)) {
-		parent.addListener (SWT.Activate, listener);
+	parent.addListener (SWT.Activate, listener);
 	} else {
 		parent.addListener (SWT.FocusIn, listener);
 	}
Index: org/eclipse/swt/SWT.java
===================================================================
--- org/eclipse/swt/SWT.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/SWT.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt;
 
@@ -34,9 +35,9 @@
  *
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
  */
- 
+
 /* NOTE:
- *   Good javadoc coding style is to put the values of static final 
+ *   Good javadoc coding style is to put the values of static final
  *   constants in the comments. This reinforces the fact that
  *   consumers are allowed to rely on the value (and they must
  *   since the values are compiled inline in their code). We
@@ -44,23 +45,23 @@
  *   releases.
  */
 public class SWT {
-	
+
 	/* Widget Event Constants */
-	
+
 	/**
 	 * The null event type (value is 0).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int None = 0;
-	
+
 	/**
 	 * The key down event type (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addKeyListener
 	 * @see org.eclipse.swt.widgets.Tracker#addKeyListener
 	 * @see org.eclipse.swt.events.KeyListener#keyPressed
@@ -67,14 +68,14 @@
 	 * @see org.eclipse.swt.events.KeyEvent
 	 */
 	public static final int KeyDown = 1;
-	
+
 	/**
 	 * The key up event type (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addKeyListener
 	 * @see org.eclipse.swt.widgets.Tracker#addKeyListener
 	 * @see org.eclipse.swt.events.KeyListener#keyReleased
@@ -81,105 +82,105 @@
 	 * @see org.eclipse.swt.events.KeyEvent
 	 */
 	public static final int KeyUp = 2;
-	
+
 	/**
 	 * The mouse down event type (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseDown
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseDown = 3;
-	
+
 	/**
 	 * The mouse up event type (value is 4).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseUp
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseUp = 4;
-	
+
 	/**
 	 * The mouse move event type (value is 5).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseMoveListener
 	 * @see org.eclipse.swt.events.MouseMoveListener#mouseMove
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseMove = 5;
-	
+
 	/**
 	 * The mouse enter event type (value is 6).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseEnter
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
-	public static final int MouseEnter = 6;		
-	
+	public static final int MouseEnter = 6;
+
 	/**
 	 * The mouse exit event type (value is 7).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseExit
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
 	public static final int MouseExit = 7;
-	
+
 	/**
 	 * The mouse double click event type (value is 8).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseListener
 	 * @see org.eclipse.swt.events.MouseListener#mouseDoubleClick
 	 * @see org.eclipse.swt.events.MouseEvent
 	 */
-	public static final int MouseDoubleClick = 8;	
-	
+	public static final int MouseDoubleClick = 8;
+
 	/**
 	 * The paint event type (value is 9).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addPaintListener
 	 * @see org.eclipse.swt.events.PaintListener#paintControl
 	 * @see org.eclipse.swt.events.PaintEvent
 	 */
-	public static final int Paint = 9;	
-	
+	public static final int Paint = 9;
+
 	/**
 	 * The move event type (value is 10).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addControlListener
 	 * @see org.eclipse.swt.widgets.TableColumn#addControlListener
 	 * @see org.eclipse.swt.widgets.Tracker#addControlListener
@@ -188,14 +189,14 @@
 	 * @see org.eclipse.swt.events.ControlEvent
 	 */
 	public static final int Move = 10;
-	
+
 	/**
 	 * The resize event type (value is 11).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addControlListener
 	 * @see org.eclipse.swt.widgets.TableColumn#addControlListener
 	 * @see org.eclipse.swt.widgets.Tracker#addControlListener
@@ -204,28 +205,28 @@
 	 * @see org.eclipse.swt.events.ControlEvent
 	 */
 	public static final int Resize = 11;
-	
+
 	/**
 	 * The dispose event type (value is 12).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addDisposeListener
 	 * @see org.eclipse.swt.events.DisposeListener#widgetDisposed
 	 * @see org.eclipse.swt.events.DisposeEvent
 	 */
 	public static final int Dispose = 12;
-	
+
 	/**
 	 * The selection event type (value is 13).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Button#addSelectionListener
 	 * @see org.eclipse.swt.widgets.Combo#addSelectionListener
 	 * @see org.eclipse.swt.widgets.CoolItem#addSelectionListener
@@ -247,14 +248,14 @@
 	 * @see org.eclipse.swt.events.SelectionEvent
 	 */
 	public static final int Selection = 13;
-	
+
 	/**
 	 * The default selection event type (value is 14).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Combo#addSelectionListener
 	 * @see org.eclipse.swt.widgets.List#addSelectionListener
 	 * @see org.eclipse.swt.widgets.Spinner#addSelectionListener
@@ -266,132 +267,132 @@
 	 * @see org.eclipse.swt.events.SelectionEvent
 	 */
 	public static final int DefaultSelection = 14;
-	
+
 	/**
 	 * The focus in event type (value is 15).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addFocusListener
 	 * @see org.eclipse.swt.events.FocusListener#focusGained
 	 * @see org.eclipse.swt.events.FocusEvent
 	 */
 	public static final int FocusIn = 15;
-	
+
 	/**
 	 * The focus out event type (value is 16).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addFocusListener
 	 * @see org.eclipse.swt.events.FocusListener#focusLost
 	 * @see org.eclipse.swt.events.FocusEvent
 	 */
 	public static final int FocusOut = 16;
-	
+
 	/**
 	 * The expand event type (value is 17).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Tree#addTreeListener
 	 * @see org.eclipse.swt.events.TreeListener#treeExpanded
 	 * @see org.eclipse.swt.events.TreeEvent
 	 */
 	public static final int Expand = 17;
-	
+
 	/**
 	 * The collapse event type (value is 18).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Tree#addTreeListener
 	 * @see org.eclipse.swt.events.TreeListener#treeCollapsed
 	 * @see org.eclipse.swt.events.TreeEvent
 	 */
 	public static final int Collapse = 18;
-	
+
 	/**
 	 * The iconify event type (value is 19).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellIconified
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Iconify = 19;
-	
+
 	/**
 	 * The de-iconify event type (value is 20).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellDeiconified
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Deiconify = 20;
-	
+
 	/**
 	 * The close event type (value is 21).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellClosed
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Close = 21;
-	
+
 	/**
 	 * The show event type (value is 22).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Menu#addMenuListener
 	 * @see org.eclipse.swt.events.MenuListener#menuShown
 	 * @see org.eclipse.swt.events.MenuEvent
 	 */
 	public static final int Show = 22;
-	
+
 	/**
 	 * The hide event type (value is 23).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Menu#addMenuListener
 	 * @see org.eclipse.swt.events.MenuListener#menuHidden
 	 * @see org.eclipse.swt.events.MenuEvent
 	 */
 	public static final int Hide = 23;
-	
+
 	/**
 	 * The modify event type (value is 24).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Combo#addModifyListener
 	 * @see org.eclipse.swt.widgets.Spinner#addModifyListener
 	 * @see org.eclipse.swt.widgets.Text#addModifyListener
@@ -399,14 +400,14 @@
 	 * @see org.eclipse.swt.events.ModifyEvent
 	 */
 	public static final int Modify = 24;
-	
+
 	/**
 	 * The verify event type (value is 25).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.custom.CCombo#addVerifyListener
 	 * @see org.eclipse.swt.widgets.Combo#addVerifyListener
 	 * @see org.eclipse.swt.custom.StyledText#addVerifyListener
@@ -415,40 +416,40 @@
 	 * @see org.eclipse.swt.events.VerifyEvent
 	 */
 	public static final int Verify = 25;
-	
+
 	/**
 	 * The activate event type (value is 26).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellActivated
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
 	public static final int Activate = 26;
-	
+
 	/**
 	 * The deactivate event type (value is 27).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Shell#addShellListener
 	 * @see org.eclipse.swt.events.ShellListener#shellDeactivated
 	 * @see org.eclipse.swt.events.ShellEvent
 	 */
-	public static final int Deactivate = 27;	
-	
+	public static final int Deactivate = 27;
+
 	/**
 	 * The help event type (value is 28).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addHelpListener
 	 * @see org.eclipse.swt.widgets.Menu#addHelpListener
 	 * @see org.eclipse.swt.widgets.MenuItem#addHelpListener
@@ -456,14 +457,14 @@
 	 * @see org.eclipse.swt.events.HelpEvent
 	 */
 	public static final int Help = 28;
-	
+
 	/**
 	 * The drag detect event type (value is 29).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addDragDetectListener
 	 * @see org.eclipse.swt.events.DragDetectListener#dragDetected
 	 * @see org.eclipse.swt.events.DragDetectEvent
@@ -470,40 +471,40 @@
 	 * @see org.eclipse.swt.dnd.DragSource
 	 */
 	public static final int DragDetect = 29;
-	
+
 	/**
 	 * The arm event type (value is 30).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.MenuItem#addArmListener
 	 * @see org.eclipse.swt.events.ArmListener#widgetArmed
 	 * @see org.eclipse.swt.events.ArmEvent
 	 */
 	public static final int Arm = 30;
-	
+
 	/**
 	 * The traverse event type (value is 31).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addTraverseListener
 	 * @see org.eclipse.swt.events.TraverseListener#keyTraversed
 	 * @see org.eclipse.swt.events.TraverseEvent
 	 */
 	public static final int Traverse = 31;
-	
+
 	/**
 	 * The mouse hover event type (value is 32).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseTrackListener
 	 * @see org.eclipse.swt.events.MouseTrackListener#mouseHover
 	 * @see org.eclipse.swt.events.MouseEvent
@@ -512,16 +513,16 @@
 
 	/**
 	 * The hardware key down event type (value is 33).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
 	 */
 	public static final int HardKeyDown = 33;
-	
+
 	/**
 	 * The hardware key up event type (value is 34).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
@@ -530,11 +531,11 @@
 
 	/**
 	 * The menu detect event type (value is 35).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMenuDetectListener
 	 * @see org.eclipse.swt.widgets.TrayItem#addMenuDetectListener
 	 * @see org.eclipse.swt.events.MenuDetectListener#menuDetected
@@ -543,17 +544,17 @@
 	 * @since 3.0
 	 */
 	public static final int MenuDetect = 35;
-	
+
 	/**
 	 * The set data event type (value is 36).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Table
 	 * @see org.eclipse.swt.widgets.Tree
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int SetData = 36;
@@ -585,11 +586,11 @@
 	 * This is a synonym for {@link #MouseVerticalWheel} (value is 37).  
 	 * Newer applications should use {@link #MouseVerticalWheel} instead 
 	 * of {@link #MouseWheel} to make code more understandable.
-	 *  
+	 *
 	 * @see org.eclipse.swt.widgets.Control#addMouseWheelListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int MouseWheel = MouseVerticalWheel;
@@ -607,55 +608,55 @@
 	 * cached value.  The operating system automatically redraws and
 	 * lays out all widgets after this event is sent.
 	 * </p>
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Display#addListener
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int Settings = 39;
-	
+
 	/**
 	 * The erase item event type (value is 40).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int EraseItem = 40;
-	
+
 	/**
 	 * The measure item event type (value is 41).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
 	public static final int MeasureItem = 41;
-	
+
 	/**
 	 * The paint item event type (value is 42).
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.2
 	 */
-	public static final int PaintItem = 42;	
-	
+	public static final int PaintItem = 42;
+
 	/**
-	 * The IME composition event type (value is 43).  
+	 * The IME composition event type (value is 43).
 	 * <p>
 	 * The IME composition event is sent to allow
 	 * custom text editors to implement in-line
-	 * editing of international text. 
-	 * </p> 
-	 * 
+	 * editing of international text.
+	 * </p>
+	 *
 	 * The detail field indicates the action to be taken:
 	 * <p><ul>
 	 * <li>{@link SWT#COMPOSITION_CHANGED}</li>
@@ -662,11 +663,11 @@
 	 * <li>{@link SWT#COMPOSITION_OFFSET}</li>
 	 * <li>{@link SWT#COMPOSITION_SELECTION}</li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @see org.eclipse.swt.widgets.Widget#addListener
 	 * @see org.eclipse.swt.widgets.Display#addFilter
 	 * @see org.eclipse.swt.widgets.Event
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int ImeComposition = 43;
@@ -772,47 +773,47 @@
 	public static final int Segments = 49;
 
 	/* Event Details */
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * a change in the IME composition. The text field
-	 * of the event is the new composition text. 
+	 * of the event is the new composition text.
 	 * The start and end indicate the offsets where the
 	 * composition text should be inserted.
-	 * The styles and ranges are stored in the IME 
+	 * The styles and ranges are stored in the IME
 	 * object (value is 1).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_CHANGED = 1;
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * that the IME needs the offset for a given location.
-	 * The x and y fields of the event are used by the 
+	 * The x and y fields of the event are used by the
 	 * application to determine the offset.
-	 * 
-	 * The index field of the event should be set to the 
-	 * text offset at that location. The count field should 
+	 *
+	 * The index field of the event should be set to the
+	 * text offset at that location. The count field should
 	 * be set to indicate whether the location is closer to
 	 * the leading edge (0) or the trailing edge (1) (value is 2).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
 	 * @see org.eclipse.swt.graphics.TextLayout#getOffset(int, int, int[])
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_OFFSET = 2;
-	
+
 	/**
 	 * The IME composition event detail that indicates
 	 * that IME needs the selected text and its start
 	 * and end offsets (value is 3).
-	 * 
+	 *
 	 * @see SWT#ImeComposition
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int COMPOSITION_SELECTION = 3;
@@ -822,7 +823,7 @@
 	 * for example dragging the thumb of a scroll bar (value is 1).
 	 */
 	public static final int DRAG = 1;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is selected (value is 1&lt;&lt;1).
@@ -830,15 +831,15 @@
 	 * @since 3.2
 	 */
 	public static final int SELECTED = 1 << 1;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is focused (value is 1&lt;&lt;2).
 	 *
 	 * @since 3.2
-	 */	
+	 */
 	public static final int FOCUSED = 1 << 2;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * draws the background (value is 1&lt;&lt;3).
@@ -846,7 +847,7 @@
 	 * @since 3.2
 	 */
 	public static final int BACKGROUND = 1 << 3;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * draws the foreground (value is 1&lt;&lt;4).
@@ -854,7 +855,7 @@
 	 * @since 3.2
 	 */
 	public static final int FOREGROUND = 1 << 4;
-	
+
 	/**
 	 * Event detail field that indicates a user-interface component
 	 * state is hot (value is 1&lt;&lt;5).
@@ -862,7 +863,7 @@
 	 * @since 3.3
 	 */
 	public static final int HOT = 1 << 5;
-	
+
 	/* This code is intentionally commented */
 	//public static final int PRESSED = 1 << 3;
 	//public static final int ACTIVE = 1 << 4;
@@ -871,14 +872,14 @@
 	//public static final int DEFAULTED = 1 << 7;
 
 	/**
-	 * Traversal event detail field value indicating that no 
+	 * Traversal event detail field value indicating that no
 	 * traversal action should be taken
 	 * (value is 0).
 	 */
 	public static final int TRAVERSE_NONE = 0;
-	
+
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that a dialog should be cancelled was
 	 * pressed; typically, this is the ESC key
 	 * (value is 1&lt;&lt;1).
@@ -894,7 +895,7 @@
 	public static final int TRAVERSE_RETURN = 1 << 2;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab group was pressed; typically, this is the
 	 * SHIFT-TAB key sequence
@@ -903,7 +904,7 @@
 	public static final int TRAVERSE_TAB_PREVIOUS = 1 << 3;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * next tab group was pressed; typically, this is the
 	 * TAB key
@@ -912,7 +913,7 @@
 	public static final int TRAVERSE_TAB_NEXT = 1 << 4;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab item was pressed; typically, this is either
 	 * the LEFT-ARROW or UP-ARROW keys
@@ -921,7 +922,7 @@
 	public static final int TRAVERSE_ARROW_PREVIOUS = 1 << 5;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that focus should be given to the
 	 * previous tab item was pressed; typically, this is either
 	 * the RIGHT-ARROW or DOWN-ARROW keys
@@ -930,7 +931,7 @@
 	public static final int TRAVERSE_ARROW_NEXT = 1 << 6;
 
 	/**
-	 * Traversal event detail field value indicating that a 
+	 * Traversal event detail field value indicating that a
 	 * mnemonic key sequence was pressed
 	 * (value is 1&lt;&lt;7).
 	 */
@@ -937,7 +938,7 @@
 	public static final int TRAVERSE_MNEMONIC = 1 << 7;
 
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that the previous page of a multi-page
 	 * window should be shown was pressed; typically, this
 	 * is the CTRL-PAGEUP key sequence
@@ -944,9 +945,9 @@
 	 * (value is 1&lt;&lt;8).
 	 */
 	public static final int TRAVERSE_PAGE_PREVIOUS = 1 << 8;
-	
+
 	/**
-	 * Traversal event detail field value indicating that the 
+	 * Traversal event detail field value indicating that the
 	 * key which designates that the next page of a multi-page
 	 * window should be shown was pressed; typically, this
 	 * is the CTRL-PAGEDOWN key sequence
@@ -1079,13 +1080,13 @@
 	 * which take bit flags to indicate that "no bits are set".
 	 */
 	public static final int NONE = 0;
-	
+
 	/**
 	 * A constant known to be zero (0), used in operations which
 	 * take pointers to indicate a null argument.
 	 */
 	public static final int NULL = 0;
-	
+
 	/**
 	 * Indicates that a default should be used (value is -1).
 	 */
@@ -1093,14 +1094,14 @@
 
 	/**
 	 * Indicates that a property is off (value is 0).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int OFF = 0;
-	
+
 	/**
 	 * Indicates that a property is on (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ON = 1;
@@ -1107,7 +1108,7 @@
 
 	/**
 	 * Indicates low quality (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int LOW = 1;
@@ -1114,7 +1115,7 @@
 
 	/**
 	 * Indicates high quality (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int HIGH = 2;
@@ -1157,7 +1158,7 @@
 	 */
 	public static final int SEPARATOR = 1 << 1;
 
-    /**
+	/**
      * Constant representing a flexible space separator in a ToolBar.
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>ToolItem.setWidth()</code></li>
@@ -1274,7 +1275,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Text</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int SEARCH = 1 << 7;
@@ -1293,11 +1294,11 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Text</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PASSWORD = 1 << 22;
-	
+
 	/**
 	 * Style constant for shadow in behavior (value is 1&lt;&lt;2).
 	 * <br>Note that this is a <em>HINT</em>.
@@ -1354,7 +1355,7 @@
 	 * </ul></p>
 	 */
 	public static final int INDETERMINATE = 1 << 1;
-	
+
 	/**
 	 * Style constant for tool window behavior (value is 1&lt;&lt;2).
 	 * <p>
@@ -1366,7 +1367,7 @@
 	 * <li><code>Decorations</code> and subclasses</li>
 	 * </ul></p>
 	 */
-	public static final int TOOL = 1 << 2; 
+	public static final int TOOL = 1 << 2;
 
 	/**
 	 * Style constant to ensure no trimmings are used (value is 1&lt;&lt;3).
@@ -1376,7 +1377,7 @@
 	 * </ul></p>
 	 */
 	public static final int NO_TRIM = 1 << 3;
-	
+
 	/**
 	 * Style constant for resize box trim (value is 1&lt;&lt;4).
 	 * <p><b>Used By:</b><ul>
@@ -1478,7 +1479,7 @@
 	 * <li><code>Control</code> and subclasses</li>
 	 * </ul></p>
 	 */
-	public static final int CLIP_CHILDREN = 1 << 12; 
+	public static final int CLIP_CHILDREN = 1 << 12;
 
 	/**
 	 * Style constant indicating that the window manager should clip
@@ -1498,7 +1499,7 @@
 	 * </ul></p>
 	 */
 	public static final int ON_TOP = 1 << 14;
-	
+
 	/**
 	 * Style constant for sheet window behavior (value is 1&lt;&lt;28).
 	 * <p>
@@ -1586,8 +1587,8 @@
 	public static final int HIDE_SELECTION = 1 << 15;
 
 	/**
-	 * Style constant for full row selection behavior and 
-	 * selection constant indicating that a full line should be 
+	 * Style constant for full row selection behavior and
+	 * selection constant indicating that a full line should be
 	 * drawn. (value is 1&lt;&lt;16).
 	 * <br>Note that for some widgets this is a <em>HINT</em>.
 	 * <p><b>Used By:</b><ul>
@@ -1594,7 +1595,7 @@
 	 * <li><code>Table</code></li>
 	 * <li><code>Tree</code></li>
 	 * <li><code>StyledText</code></li>
-	 * <li><code>TextLayout</code></li> 
+	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
 	 */
 	public static final int FULL_SELECTION = 1 << 16;
@@ -1684,7 +1685,7 @@
 	 * </ul></p>
 	 */
 	public static final int NO_RADIO_GROUP = 1 << 22;
-	
+
 	/**
 	 * Style constant for left to right orientation (value is 1&lt;&lt;25).
 	 * <p>
@@ -1698,13 +1699,13 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
-	 * <li><code>GC</code></li> 
+	 * <li><code>GC</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int LEFT_TO_RIGHT = 1 << 25;
-	
+
 	/**
 	 * Style constant for right to left orientation (value is 1&lt;&lt;26).
 	 * <p>
@@ -1718,13 +1719,13 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
-	 * <li><code>GC</code></li> 
+	 * <li><code>GC</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int RIGHT_TO_LEFT = 1 << 26;
-	
+
 	/**
 	 * Style constant to indicate coordinate mirroring (value is 1&lt;&lt;27).
 	 * <p><b>Used By:</b><ul>
@@ -1731,21 +1732,21 @@
 	 * <li><code>Control</code></li>
 	 * <li><code>Menu</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int MIRRORED = 1 << 27;
-	
+
 	/**
 	 * Style constant to allow embedding (value is 1&lt;&lt;24).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Composite</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int EMBEDDED = 1 << 24;
-	
+
 	/**
 	 * Style constant to allow virtual data (value is 1&lt;&lt;28).
 	 * <p><b>Used By:</b><ul>
@@ -1752,7 +1753,7 @@
 	 * <li><code>Table</code></li>
 	 * <li><code>Tree</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int VIRTUAL = 1 << 28;
@@ -1762,11 +1763,11 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int DOUBLE_BUFFERED = 1 << 29;
-	
+
 	/**
 	 * Style constant for transparent behavior (value is 1&lt;&lt;30).
 	 * <p>
@@ -1778,11 +1779,11 @@
 	 * </ul></p>
 	 *
 	 * @since 3.4
-	 * 
+	 *
 	 * WARNING: THIS API IS UNDER CONSTRUCTION AND SHOULD NOT BE USED
 	 */
 	public static final int TRANSPARENT = 1 << 30;
-	
+
 	/**
 	 * Style constant for align up behavior (value is 1&lt;&lt;7,
 	 * since align UP and align TOP are considered the same).
@@ -1794,13 +1795,13 @@
 	 * </ul></p>
 	 */
 	public static final int UP = 1 << 7;
-	
+
 	/**
 	 * Style constant to indicate single underline (value is 0).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_SINGLE = 0;
@@ -1810,31 +1811,31 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_DOUBLE = 1;
-	
+
 	/**
 	 * Style constant to indicate error underline (value is 2).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_ERROR = 2;
-	
+
 	/**
 	 * Style constant to indicate squiggle underline (value is 3).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int UNDERLINE_SQUIGGLE = 3;
-	
+
 	/**
 	 * Style constant to indicate link underline (value is 0).
 	 * <p>
@@ -1858,7 +1859,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_SOLID = 1;
@@ -1868,21 +1869,21 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_DASH = 2;
-	
+
 	/**
 	 * Style constant to indicate dotted border (value is 4).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextStyle</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int BORDER_DOT = 4;
-	
+
 	/**
 	 * Style constant for align top behavior (value is 1&lt;&lt;7,
 	 * since align UP and align TOP are considered the same).
@@ -1923,11 +1924,11 @@
 	 * <li><code>Tracker</code></li>
 	 * <li><code>FormAttachment</code> in a <code>FormLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int LEAD               = 1 << 14;
-	
+
 	/**
 	 * Style constant for align left behavior (value is 1&lt;&lt;14).
 	 * This is a synonym for {@link #LEAD} (value is 1&lt;&lt;14).  Newer
@@ -1949,11 +1950,11 @@
 	 * <li><code>Tracker</code></li>
 	 * <li><code>FormAttachment</code> in a <code>FormLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 2.1.2
 	 */
 	public static final int TRAIL              = 1 << 17;
-		
+
 	/**
 	 * Style constant for align right behavior (value is 1&lt;&lt;17).
 	 * This is a synonym for {@link #TRAIL} (value is 1&lt;&lt;17).  Newer
@@ -2015,7 +2016,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int DATE = 1 << 5;
@@ -2025,17 +2026,17 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int TIME = 1 << 7;
-	
+
 	/**
 	 * Style constant for calendar display (value is 1&lt;&lt;10).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int CALENDAR = 1 << 10;
@@ -2050,7 +2051,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int SHORT = 1 << 15;
@@ -2065,7 +2066,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int MEDIUM = 1 << 16;
@@ -2081,7 +2082,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>DateTime</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int LONG = 1 << 28;
@@ -2093,7 +2094,7 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Browser</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int MOZILLA = 1 << 15;
@@ -2117,9 +2118,9 @@
 	 * </ul></p>
 	 *
 	 * @since 3.2
-	 */	
+	 */
 	public static final int BALLOON = 1 << 12;
-	
+
 	/**
 	 * Style constant for vertical alignment or orientation behavior (value is 1).
 	 * <p><b>Used By:</b><ul>
@@ -2127,7 +2128,7 @@
 	 * </ul></p>
 	 */
 	public static final int BEGINNING = 1;
-	
+
 	/**
 	 * Style constant for vertical alignment or orientation behavior (value is 4).
 	 * <p><b>Used By:</b><ul>
@@ -2135,7 +2136,7 @@
 	 * </ul></p>
 	 */
 	public static final int FILL = 4;
-	
+
 	/**
 	 * Input Method Editor style constant for double byte
 	 * input behavior (value is 1&lt;&lt;1).
@@ -2183,7 +2184,7 @@
 	 * (value is the <code>char</code> with value 127).
 	 */
 	public static final char DEL = 0x7F;
- 
+
 	/**
 	 * ASCII character convenience constant for the escape character
 	 * (value is the <code>char</code> with value 27).
@@ -2199,11 +2200,11 @@
 	/**
 	 * ASCII character convenience constant for the tab character
 	 * (value is the <code>char</code> '\t').
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final char TAB = '\t';
-						
+
 	/**
 	 * ASCII character convenience constant for the space character
 	 * (value is the <code>char</code> ' ').
@@ -2218,7 +2219,7 @@
 	 * (value is 1&lt;&lt;16).
 	 */
 	public static final int ALT = 1 << 16;
-					
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the SHIFT key
 	 * was pushed on the keyboard when the event was generated
@@ -2225,7 +2226,7 @@
 	 * (value is 1&lt;&lt;17).
 	 */
 	public static final int SHIFT = 1 << 17;
-					
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the CTRL key
 	 * was pushed on the keyboard when the event was generated
@@ -2244,27 +2245,27 @@
 	 * Keyboard and/or mouse event mask indicating that the COMMAND key
 	 * was pushed on the keyboard when the event was generated
 	 * (value is 1&lt;&lt;22).
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int COMMAND = 1 << 22;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating all possible
 	 * keyboard modifiers.
-	 * 
-	 * To allow for the future, this mask  is intended to be used in 
-	 * place of code that references  each individual keyboard mask. 
-	 *  For example, the following expression will determine whether 
-	 * any modifier is pressed and will continue to work as new modifier 
+	 *
+	 * To allow for the future, this mask  is intended to be used in
+	 * place of code that references  each individual keyboard mask.
+	 *  For example, the following expression will determine whether
+	 * any modifier is pressed and will continue to work as new modifier
 	 * masks are added.
-	 * 
+	 *
  	 * <code>(stateMask & SWT.MODIFIER_MASK) != 0</code>.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MODIFIER_MASK;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button one
 	 * was pushed when the event was generated. (value is 1&lt;&lt;19).
@@ -2286,7 +2287,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button four
 	 * was pushed when the event was generated. (value is 1&lt;&lt;23).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int BUTTON4 = 1 << 23;
@@ -2294,7 +2295,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that mouse button five
 	 * was pushed when the event was generated. (value is 1&lt;&lt;25).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int BUTTON5 = 1 << 25;
@@ -2302,35 +2303,35 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating all possible
 	 * mouse buttons.
-	 * 
-	 * To allow for the future, this mask  is intended to be used 
-	 * in place of code that references each individual button mask.  
+	 *
+	 * To allow for the future, this mask  is intended to be used
+	 * in place of code that references each individual button mask.
 	 * For example, the following expression will determine whether
-	 * any button is pressed and will continue to work as new button 
+	 * any button is pressed and will continue to work as new button
 	 * masks are added.
-	 * 
+	 *
  	 * <code>(stateMask & SWT.BUTTON_MASK) != 0</code>.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int BUTTON_MASK;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD1 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * This is the primary keyboard modifier for the platform.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD1;
-	
+
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD2 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * This is the secondary keyboard modifier for the platform.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD2;
@@ -2338,7 +2339,7 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD3 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD3;
@@ -2346,17 +2347,17 @@
 	/**
 	 * Keyboard and/or mouse event mask indicating that the MOD4 key
 	 * was pushed on the keyboard when the event was generated.
-	 * 
+	 *
 	 * @since 2.1
 	 */
 	public static final int MOD4;
-	
+
 	/**
 	 * Constants to indicate line scrolling (value is 1).
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int SCROLL_LINE = 1;
@@ -2366,46 +2367,46 @@
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>Control</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int SCROLL_PAGE = 2;
-	
+
 	/**
 	 * Accelerator constant used to differentiate a key code from a
 	 * unicode character.
-	 * 
+	 *
 	 * If this bit is set, then the key stroke
 	 * portion of an accelerator represents a key code.  If this bit
 	 * is not set, then the key stroke portion of an accelerator is
 	 * a unicode character.
-	 * 
+	 *
 	 * The following expression is false:
-	 * 
+	 *
 	 * <code>((SWT.MOD1 | SWT.MOD2 | 'T') & SWT.KEYCODE_BIT) != 0</code>.
-	 * 
+	 *
 	 * The following expression is true:
-	 * 
+	 *
 	 * <code>((SWT.MOD3 | SWT.F2) & SWT.KEYCODE_BIT) != 0</code>.
-	 * 
+	 *
 	 * (value is (1&lt;&lt;24))
-	 * 
+	 *
 	 * @since 2.1
-	 */	
+	 */
 	public static final int KEYCODE_BIT = (1 << 24);
 
 	/**
 	 * Accelerator constant used to extract the key stroke portion of
 	 * an accelerator.
-	 * 
+	 *
 	 * The key stroke may be a key code or a unicode
 	 * value.  If the key stroke is a key code <code>KEYCODE_BIT</code>
 	 * will be set.
-	 * 
+	 *
 	 * @since 2.1
-	 */	
+	 */
 	public static final int KEY_MASK = KEYCODE_BIT + 0xFFFF;
-	
+
 	/**
 	 * Keyboard event constant representing the UP ARROW key
 	 * (value is (1&lt;&lt;24)+1).
@@ -2465,67 +2466,67 @@
 	 * (value is (1&lt;&lt;24)+10).
 	 */
 	public static final int F1 = KEYCODE_BIT + 10;
-	
+
 	/**
 	 * Keyboard event constant representing the F2 key
 	 * (value is (1&lt;&lt;24)+11).
 	 */
 	public static final int F2 = KEYCODE_BIT + 11;
-	
+
 	/**
 	 * Keyboard event constant representing the F3 key
 	 * (value is (1&lt;&lt;24)+12).
 	 */
 	public static final int F3 = KEYCODE_BIT + 12;
-	
+
 	/**
 	 * Keyboard event constant representing the F4 key
 	 * (value is (1&lt;&lt;24)+13).
 	 */
 	public static final int F4 = KEYCODE_BIT + 13;
-	
+
 	/**
 	 * Keyboard event constant representing the F5 key
 	 * (value is (1&lt;&lt;24)+14).
 	 */
 	public static final int F5 = KEYCODE_BIT + 14;
-	
+
 	/**
 	 * Keyboard event constant representing the F6 key
 	 * (value is (1&lt;&lt;24)+15).
 	 */
 	public static final int F6 = KEYCODE_BIT + 15;
-	
+
 	/**
 	 * Keyboard event constant representing the F7 key
 	 * (value is (1&lt;&lt;24)+16).
 	 */
 	public static final int F7 = KEYCODE_BIT + 16;
-	
+
 	/**
 	 * Keyboard event constant representing the F8 key
 	 * (value is (1&lt;&lt;24)+17).
 	 */
 	public static final int F8 = KEYCODE_BIT + 17;
-	
+
 	/**
 	 * Keyboard event constant representing the F9 key
 	 * (value is (1&lt;&lt;24)+18).
 	 */
 	public static final int F9 = KEYCODE_BIT + 18;
-	
+
 	/**
 	 * Keyboard event constant representing the F10 key
 	 * (value is (1&lt;&lt;24)+19).
 	 */
 	public static final int F10 = KEYCODE_BIT + 19;
-	
+
 	/**
 	 * Keyboard event constant representing the F11 key
 	 * (value is (1&lt;&lt;24)+20).
 	 */
 	public static final int F11 = KEYCODE_BIT + 20;
-	
+
 	/**
 	 * Keyboard event constant representing the F12 key
 	 * (value is (1&lt;&lt;24)+21).
@@ -2535,27 +2536,27 @@
 	/**
 	 * Keyboard event constant representing the F13 key
 	 * (value is (1&lt;&lt;24)+22).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F13 = KEYCODE_BIT + 22;
-	
+
 	/**
 	 * Keyboard event constant representing the F14 key
 	 * (value is (1&lt;&lt;24)+23).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F14 = KEYCODE_BIT + 23;
-	
+
 	/**
 	 * Keyboard event constant representing the F15 key
 	 * (value is (1&lt;&lt;24)+24).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int F15 = KEYCODE_BIT + 24;
-	
+
 	/**
 	 * Keyboard event constant representing the F16 key
 	 * (value is (1&lt;&lt;25)+25).
@@ -2610,23 +2611,23 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad multiply key (value is (1&lt;&lt;24)+42).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_MULTIPLY = KEYCODE_BIT + 42;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad add key (value is (1&lt;&lt;24)+43).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_ADD = KEYCODE_BIT + 43;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad subtract key (value is (1&lt;&lt;24)+45).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_SUBTRACT = KEYCODE_BIT + 45;
@@ -2634,7 +2635,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad decimal key (value is (1&lt;&lt;24)+46).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_DECIMAL = KEYCODE_BIT + 46;
@@ -2642,7 +2643,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad divide key (value is (1&lt;&lt;24)+47).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_DIVIDE = KEYCODE_BIT + 47;
@@ -2650,7 +2651,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad zero key (value is (1&lt;&lt;24)+48).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_0 = KEYCODE_BIT + 48;
@@ -2658,7 +2659,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad one key (value is (1&lt;&lt;24)+49).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_1 = KEYCODE_BIT + 49;
@@ -2666,7 +2667,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad two key (value is (1&lt;&lt;24)+50).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_2 = KEYCODE_BIT + 50;
@@ -2674,7 +2675,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad three key (value is (1&lt;&lt;24)+51).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_3 = KEYCODE_BIT + 51;
@@ -2682,23 +2683,23 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad four key (value is (1&lt;&lt;24)+52).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_4 = KEYCODE_BIT + 52;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad five key (value is (1&lt;&lt;24)+53).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_5 = KEYCODE_BIT + 53;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad six key (value is (1&lt;&lt;24)+54).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_6 = KEYCODE_BIT + 54;
@@ -2706,7 +2707,7 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad seven key (value is (1&lt;&lt;24)+55).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_7 = KEYCODE_BIT + 55;
@@ -2714,15 +2715,15 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad eight key (value is (1&lt;&lt;24)+56).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_8 = KEYCODE_BIT + 56;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad nine key (value is (1&lt;&lt;24)+57).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_9 = KEYCODE_BIT + 57;
@@ -2730,82 +2731,82 @@
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad equal key (value is (1&lt;&lt;24)+61).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_EQUAL = KEYCODE_BIT + 61;
-	
+
 	/**
 	 * Keyboard event constant representing the numeric key
 	 * pad enter key (value is (1&lt;&lt;24)+80).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int KEYPAD_CR = KEYCODE_BIT + 80;
-	
+
 	/**
 	 * Keyboard event constant representing the help
 	 * key (value is (1&lt;&lt;24)+81).
-	 * 
+	 *
 	 * NOTE: The HELP key maps to the key labeled "help",
 	 * not "F1". If your keyboard does not have a HELP key,
 	 * you will never see this key press.  To listen for
 	 * help on a control, use SWT.Help.
-	 * 
+	 *
 	 * @since 3.0
-	 * 
+	 *
 	 * @see SWT#Help
 	 */
 	public static final int HELP = KEYCODE_BIT + 81;
-	
+
 	/**
 	 * Keyboard event constant representing the caps
 	 * lock key (value is (1&lt;&lt;24)+82).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int CAPS_LOCK = KEYCODE_BIT + 82;
-	
+
 	/**
 	 * Keyboard event constant representing the num
 	 * lock key (value is (1&lt;&lt;24)+83).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int NUM_LOCK = KEYCODE_BIT + 83;
-	
+
 	/**
 	 * Keyboard event constant representing the scroll
 	 * lock key (value is (1&lt;&lt;24)+84).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int SCROLL_LOCK = KEYCODE_BIT + 84;
-	
+
 	/**
 	 * Keyboard event constant representing the pause
 	 * key (value is (1&lt;&lt;24)+85).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PAUSE = KEYCODE_BIT + 85;
-	
+
 	/**
 	 * Keyboard event constant representing the break
 	 * key (value is (1&lt;&lt;24)+86).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int BREAK = KEYCODE_BIT + 86;
-	
+
 	/**
 	 * Keyboard event constant representing the print screen
 	 * key (value is (1&lt;&lt;24)+87).
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int PRINT_SCREEN = KEYCODE_BIT + 87;
-	
+
 	/**
 	 * The <code>MessageBox</code> style constant for error icon
 	 * behavior (value is 1).
@@ -2835,7 +2836,7 @@
 	 * behavior (value is 1&lt;&lt;4).
 	 */
 	public static final int ICON_WORKING = 1 << 4;
-	
+
 	/**
 	 * The style constant for "search" icon. This style constant is 
 	 * used with <code>Text</code> in combination with <code>SWT.SEARCH
@@ -2896,7 +2897,7 @@
 	 * The <code>MessageBox</code> style constant for a CANCEL button;
 	 * valid combinations are OK|CANCEL, YES|NO|CANCEL, RETRY|CANCEL
 	 * (value is 1&lt;&lt;8).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>MessageBox</code></li>
 	 * </ul></p>
@@ -2944,7 +2945,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_NONE = 0;
-	
+
 	/**
 	 * The <code>Composite</code> constant to indicate that
 	 * an attribute (such as background) is inherited by
@@ -2956,7 +2957,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_DEFAULT = 1;
-	
+
 	/**
 	 * The <code>Composite</code> constant to indicate that
 	 * an attribute (such as background) is inherited by
@@ -2965,7 +2966,7 @@
 	 * @since 3.2
 	 */
 	public static final int INHERIT_FORCE = 2;
-	
+
 	/**
 	 * Default color white (value is 1).
 	 */
@@ -3045,7 +3046,7 @@
 	 * Default color dark gray (value is 16).
 	 */
 	public static final int COLOR_DARK_GRAY = 16;
-	
+
 	/*
 	 * System Colors
 	 *
@@ -3061,7 +3062,7 @@
 	 *	It is expected that the list of supported colors
 	 * will grow over time.
 	 */
-	
+
 	/**
 	 * System color used to paint dark shadow areas (value is 17).
 	 */
@@ -3126,7 +3127,7 @@
 	 * System color used to paint tooltip background areas (value is 29).
 	 */
 	public static final int COLOR_INFO_BACKGROUND = 29;
-	
+
 	/**
 	 * System color used to paint title text (value is 30).
 	 */
@@ -3141,7 +3142,7 @@
 	 * System color used to paint title background gradient (value is 32).
 	 */
 	public static final int COLOR_TITLE_BACKGROUND_GRADIENT = 32;
-	
+
 	/**
 	 * System color used to paint inactive title text (value is 33).
 	 */
@@ -3156,7 +3157,7 @@
 	 * System color used to paint inactive title background gradient (value is 35).
 	 */
 	public static final int COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT = 35;
-	
+
 	/**
 	 * Draw constant indicating whether the drawing operation
 	 * should fill the background (value is 1&lt;&lt;0).
@@ -3179,13 +3180,13 @@
 	 * Draw constant indicating whether the string drawing operation
 	 * should handle mnemonics (value is 1&lt;&lt;3).
 	 */
-	public static final int DRAW_MNEMONIC = 1 << 3;	
+	public static final int DRAW_MNEMONIC = 1 << 3;
 
-	
+
 	/**
-	 * Selection constant indicating that a line delimiter should be 
+	 * Selection constant indicating that a line delimiter should be
 	 * drawn (value is 1&lt;&lt;17).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
@@ -3192,80 +3193,80 @@
 	 *
 	 * @see #FULL_SELECTION
 	 * @see #LAST_LINE_SELECTION
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int DELIMITER_SELECTION = 1 << 17;
-	
+
 	/**
 	 * Selection constant indicating that the last line is selected
-	 * to the end and should be drawn using either a line delimiter 
+	 * to the end and should be drawn using either a line delimiter
 	 * or full line selection (value is 1&lt;&lt;20).
-	 * 
+	 *
 	 * <p><b>Used By:</b><ul>
 	 * <li><code>TextLayout</code></li>
 	 * </ul></p>
-	 * 
+	 *
 	 * @see #DELIMITER_SELECTION
 	 * @see #FULL_SELECTION
-	 * 
+	 *
 	 * @since 3.3
 	 */
 	public static final int LAST_LINE_SELECTION = 1 << 20;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no error number was specified
 	 * (value is 1).
 	 */
 	public static final int ERROR_UNSPECIFIED = 1;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no more handles for an
 	 * operating system resource are available
 	 * (value is 2).
 	 */
 	public static final int ERROR_NO_HANDLES = 2;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that no more callback resources are available
 	 * (value is 3).
 	 */
 	public static final int ERROR_NO_MORE_CALLBACKS = 3;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a null argument was passed in
-	 * (value is 4). 
+	 * (value is 4).
 	 */
 	public static final int ERROR_NULL_ARGUMENT = 4;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an invalid argument was passed in
 	 * (value is 5).
 	 */
 	public static final int ERROR_INVALID_ARGUMENT = 5;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a value was found to be
 	 * outside the allowable range
 	 * (value is 6).
 	 */
 	public static final int ERROR_INVALID_RANGE = 6;
-	
-	/** 
-	 * SWT error constant indicating that a value which can not be 
+
+	/**
+	 * SWT error constant indicating that a value which can not be
 	 * zero was found to be
 	 * (value is 7).
 	 */
 	public static final int ERROR_CANNOT_BE_ZERO = 7;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the value of an item
 	 * (value is 8).
 	 */
 	public static final int ERROR_CANNOT_GET_ITEM = 8;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the selection
 	 * (value is 9).
@@ -3272,15 +3273,15 @@
 	 */
 	public static final int ERROR_CANNOT_GET_SELECTION = 9;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the matrix is not invertible
 	 * (value is 10).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_CANNOT_INVERT_MATRIX = 10;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the height of an item
 	 * (value is 11).
@@ -3287,7 +3288,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_ITEM_HEIGHT = 11;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide the text of a widget
 	 * (value is 12).
@@ -3294,7 +3295,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_TEXT = 12;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the text of a widget
 	 * (value is 13).
@@ -3301,7 +3302,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_TEXT = 13;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to add an item
 	 * (value is 14).
@@ -3308,7 +3309,7 @@
 	 */
 	public static final int ERROR_ITEM_NOT_ADDED = 14;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to remove an item
 	 * (value is 15).
@@ -3315,7 +3316,7 @@
 	 */
 	public static final int ERROR_ITEM_NOT_REMOVED = 15;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the graphics library
 	 * is not available
 	 * (value is 16).
@@ -3322,7 +3323,7 @@
 	 */
 	public static final int ERROR_NO_GRAPHICS_LIBRARY = 16;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a particular feature has
 	 * not been implemented on this platform
 	 * (value is 20).
@@ -3329,7 +3330,7 @@
 	 */
 	public static final int ERROR_NOT_IMPLEMENTED = 20;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the drop down style had some other style instead
 	 * (value is 21).
@@ -3336,7 +3337,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_DROP_DOWN = 21;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation which can only be executed by the
 	 * user-interface thread from some other thread
@@ -3344,15 +3345,15 @@
 	 */
 	public static final int ERROR_THREAD_INVALID_ACCESS = 22;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a widget which had already
 	 * been disposed
-	 * (value is 24). 
+	 * (value is 24).
 	 */
 	public static final int ERROR_WIDGET_DISPOSED = 24;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu item which needed
 	 * to have the cascade style had some other style instead
 	 * (value is 27).
@@ -3359,7 +3360,7 @@
 	 */
 	public static final int ERROR_MENUITEM_NOT_CASCADE = 27;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the selection of a widget
 	 * (value is 28).
@@ -3366,7 +3367,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_SELECTION = 28;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the menu
 	 * (value is 29).
@@ -3373,7 +3374,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_MENU = 29;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to set the enabled state
 	 * (value is 30).
@@ -3380,7 +3381,7 @@
 	 */
 	public static final int ERROR_CANNOT_SET_ENABLED = 30;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide enabled/disabled state information
 	 * (value is 31).
@@ -3387,14 +3388,14 @@
 	 */
 	public static final int ERROR_CANNOT_GET_ENABLED = 31;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a provided widget can
 	 * not be used as a parent in the current operation
 	 * (value is 32).
 	 */
 	public static final int ERROR_INVALID_PARENT = 32;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the menu bar style had some other style instead
 	 * (value is 33).
@@ -3401,7 +3402,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_BAR = 33;
 
-	/** 
+	/**
 	 * SWT error constant indicating that the underlying operating
 	 * system was unable to provide count information
 	 * (value is 36).
@@ -3408,7 +3409,7 @@
 	 */
 	public static final int ERROR_CANNOT_GET_COUNT = 36;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a menu which needed
 	 * to have the pop up menu style had some other style instead
 	 * (value is 37).
@@ -3415,7 +3416,7 @@
 	 */
 	public static final int ERROR_MENU_NOT_POP_UP = 37;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image of an unsupported depth
 	 * (value is 38).
@@ -3422,7 +3423,7 @@
 	 */
 	public static final int ERROR_UNSUPPORTED_DEPTH = 38;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an input/output operation
 	 * failed during the execution of an SWT operation
 	 * (value is 39).
@@ -3429,7 +3430,7 @@
 	 */
 	public static final int ERROR_IO = 39;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image having an invalid format
 	 * (value is 40).
@@ -3436,7 +3437,7 @@
 	 */
 	public static final int ERROR_INVALID_IMAGE = 40;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a graphics operation
 	 * was attempted with an image having a valid but unsupported
 	 * format
@@ -3444,13 +3445,13 @@
 	 */
 	public static final int ERROR_UNSUPPORTED_FORMAT = 42;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made
 	 * to subclass an SWT widget class without implementing the
 	 * <code>checkSubclass()</code> method
 	 * (value is 43).
-	 * 
-	 * For additional information see the comment in 
+	 *
+	 * For additional information see the comment in
 	 * <code>Widget.checkSubclass()</code>.
 	 *
 	 * @see org.eclipse.swt.widgets.Widget#checkSubclass
@@ -3457,7 +3458,7 @@
 	 */
 	public static final int ERROR_INVALID_SUBCLASS = 43;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a graphics object which had
 	 * already been disposed
@@ -3464,40 +3465,40 @@
 	 * (value is 44).
 	 */
 	public static final int ERROR_GRAPHIC_DISPOSED = 44;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * invoke an SWT operation using a device which had already
 	 * been disposed
-	 * (value is 45). 
+	 * (value is 45).
 	 */
 	public static final int ERROR_DEVICE_DISPOSED = 45;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an exception happened
 	 * when executing a runnable
 	 * (value is 46).
 	 */
 	public static final int ERROR_FAILED_EXEC = 46;
-	
-	/** 
+
+	/**
 	 * SWT error constant indicating that an unsatisfied link
 	 * error occurred while attempting to load a library
 	 * (value is 47).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_FAILED_LOAD_LIBRARY = 47;
 
-	/** 
+	/**
 	 * SWT error constant indicating that a font is not valid
 	 * (value is 48).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int ERROR_INVALID_FONT = 48;
 
-	/** 
+	/**
 	 * SWT error constant indicating that an attempt was made to
 	 * use an BrowserFunction object which had already been disposed
 	 * (value is 49).
@@ -3525,12 +3526,12 @@
 
 	/**
 	 * Constant indicating that an image or operation is of type bitmap  (value is 0).
-	 */	
+	 */
 	public static final int BITMAP = 0;
 
 	/**
 	 * Constant indicating that an image or operation is of type icon  (value is 1).
-	 */	
+	 */
 	public static final int ICON = 1;
 
 	/**
@@ -3537,7 +3538,7 @@
 	 * The <code>Image</code> constructor argument indicating that
 	 * the new image should be a copy of the image provided as
 	 * an argument  (value is 0).
-	 */	
+	 */
 	public static final int IMAGE_COPY = 0;
 
 	/**
@@ -3545,16 +3546,16 @@
 	 * the new image should have the appearance of a "disabled"
 	 * (using the platform's rules for how this should look)
 	 * copy of the image provided as an argument  (value is 1).
-	 */	
+	 */
 	public static final int IMAGE_DISABLE = 1;
-	
+
 	/**
 	 * The <code>Image</code> constructor argument indicating that
 	 * the new image should have the appearance of a "gray scaled"
 	 * copy of the image provided as an argument  (value is 2).
-	 */	
+	 */
 	public static final int IMAGE_GRAY = 2;
-	
+
 	/**
 	 * Constant to indicate an error state (value is 1).
 	 * <p><b>Used By:</b><ul>
@@ -3584,135 +3585,135 @@
 	 * </ul></p>
 	 */
 	public static final int NORMAL = 0;
-	
+
 	/**
 	 * The font style constant indicating a bold weight font
 	 * (value is 1&lt;&lt;0).
 	 */
 	public static final int BOLD = 1 << 0;
-	
+
 	/**
 	 * The font style constant indicating an italic font
 	 * (value is 1&lt;&lt;1).
 	 */
 	public static final int ITALIC = 1 << 1;
-		
+
 	/**
 	 * System arrow cursor  (value is 0).
 	 */
 	public static final int CURSOR_ARROW = 0;
-		
+
 	/**
 	 * System wait cursor  (value is 1).
 	 */
 	public static final int CURSOR_WAIT = 1;
-		
+
 	/**
 	 * System cross hair cursor  (value is 2).
 	 */
 	public static final int CURSOR_CROSS = 2;
-		
+
 	/**
 	 * System app startup cursor  (value is 3).
 	 */
 	public static final int CURSOR_APPSTARTING = 3;
-		
+
 	/**
 	 * System help cursor  (value is 4).
 	 */
 	public static final int CURSOR_HELP = 4;
-		
+
 	/**
 	 * System resize all directions cursor (value is 5).
 	 */
 	public static final int CURSOR_SIZEALL = 5;
-		
+
 	/**
 	 * System resize north-east-south-west cursor  (value is 6).
 	 */
 	public static final int CURSOR_SIZENESW = 6;
-		
+
 	/**
 	 * System resize north-south cursor  (value is 7).
 	 */
 	public static final int CURSOR_SIZENS = 7;
-		
+
 	/**
 	 * System resize north-west-south-east cursor  (value is 8).
 	 */
 	public static final int CURSOR_SIZENWSE = 8;
-		
+
 	/**
 	 * System resize west-east cursor  (value is 9).
 	 */
 	public static final int CURSOR_SIZEWE = 9;
-		
+
 	/**
 	 * System resize north cursor  (value is 10).
 	 */
 	public static final int CURSOR_SIZEN = 10;
-		
+
 	/**
 	 * System resize south cursor  (value is 11).
 	 */
 	public static final int CURSOR_SIZES = 11;
-		
+
 	/**
 	 * System resize east cursor  (value is 12).
 	 */
 	public static final int CURSOR_SIZEE = 12;
-		
+
 	/**
 	 * System resize west cursor  (value is 13).
 	 */
 	public static final int CURSOR_SIZEW = 13;
-		
+
 	/**
 	 * System resize north-east cursor (value is 14).
 	 */
 	public static final int CURSOR_SIZENE = 14;
-		
+
 	/**
 	 * System resize south-east cursor (value is 15).
 	 */
 	public static final int CURSOR_SIZESE = 15;
-		
+
 	/**
 	 * System resize south-west cursor (value is 16).
 	 */
 	public static final int CURSOR_SIZESW = 16;
-		
+
 	/**
 	 * System resize north-west cursor (value is 17).
 	 */
 	public static final int CURSOR_SIZENW = 17;
-		
+
 	/**
 	 * System up arrow cursor  (value is 18).
 	 */
 	public static final int CURSOR_UPARROW = 18;
-		
+
 	/**
 	 * System i-beam cursor (value is 19).
 	 */
 	public static final int CURSOR_IBEAM = 19;
-		
+
 	/**
 	 * System "not allowed" cursor (value is 20).
 	 */
 	public static final int CURSOR_NO = 20;
-		
+
 	/**
 	 * System hand cursor (value is 21).
 	 */
 	public static final int CURSOR_HAND = 21;
-		
+
 	/**
 	 * Line drawing style for flat end caps (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_FLAT = 1;
@@ -3719,10 +3720,10 @@
 
 	/**
 	 * Line drawing style for rounded end caps (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_ROUND = 2;
@@ -3729,10 +3730,10 @@
 
 	/**
 	 * Line drawing style for square end caps (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineCap(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineCap()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int CAP_SQUARE = 3;
@@ -3739,10 +3740,10 @@
 
 	/**
 	 * Line drawing style for miter joins (value is 1).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_MITER = 1;
@@ -3749,10 +3750,10 @@
 
 	/**
 	 * Line drawing  style for rounded joins (value is 2).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_ROUND = 2;
@@ -3759,10 +3760,10 @@
 
 	/**
 	 * Line drawing style for bevel joins (value is 3).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineJoin(int)
 	 * @see org.eclipse.swt.graphics.GC#getLineJoin()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int JOIN_BEVEL = 3;
@@ -3771,22 +3772,22 @@
 	 * Line drawing style for solid lines  (value is 1).
 	 */
 	public static final int LINE_SOLID = 1;
-		
+
 	/**
 	 * Line drawing style for dashed lines (value is 2).
 	 */
 	public static final int LINE_DASH = 2;
-		
+
 	/**
 	 * Line drawing style for dotted lines (value is 3).
 	 */
 	public static final int LINE_DOT = 3;
-		
+
 	/**
 	 * Line drawing style for alternating dash-dot lines (value is 4).
 	 */
 	public static final int LINE_DASHDOT = 4;
-		
+
 	/**
 	 * Line drawing style for dash-dot-dot lines (value is 5).
 	 */
@@ -3794,17 +3795,17 @@
 
 	/**
 	 * Line drawing style for custom dashed lines (value is 6).
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.GC#setLineDash(int[])
 	 * @see org.eclipse.swt.graphics.GC#getLineDash()
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int LINE_CUSTOM = 6;
-	
+
 	/**
 	 * Path constant that represents a "move to" operation (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_MOVE_TO = 1;
@@ -3811,7 +3812,7 @@
 
 	/**
 	 * Path constant that represents a "line to" operation (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_LINE_TO = 2;
@@ -3818,7 +3819,7 @@
 
 	/**
 	 * Path constant that represents a "quadratic curve to" operation (value is 3).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_QUAD_TO = 3;
@@ -3825,7 +3826,7 @@
 
 	/**
 	 * Path constant that represents a "cubic curve to" operation (value is 4).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_CUBIC_TO = 4;
@@ -3832,7 +3833,7 @@
 
 	/**
 	 * Path constant that represents a "close" operation (value is 5).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int PATH_CLOSE = 5;
@@ -3839,7 +3840,7 @@
 
 	/**
 	 * Even odd rule for filling operations (value is 1).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int FILL_EVEN_ODD = 1;
@@ -3846,7 +3847,7 @@
 
 	/**
 	 * Winding rule for filling operations (value is 2).
-	 * 
+	 *
 	 * @since 3.1
 	 */
 	public static final int FILL_WINDING = 2;
@@ -3862,7 +3863,7 @@
 	public static final int IMAGE_BMP = 0;
 
 	/**
-	 * Image format constant indicating a run-length encoded 
+	 * Image format constant indicating a run-length encoded
 	 * Windows BMP format image (value is 1).
 	 */
 	public static final int IMAGE_BMP_RLE = 1;
@@ -3905,7 +3906,7 @@
 
 	/**
 	 * GIF image disposal method constants indicating that the
-	 * disposal method is to do nothing; that is, to leave the 
+	 * disposal method is to do nothing; that is, to leave the
 	 * previous image in place (value is 1).
 	 */
 	public static final int DM_FILL_NONE = 0x1;
@@ -3923,25 +3924,25 @@
 	 * (value is 3).
 	 */
 	public static final int DM_FILL_PREVIOUS = 0x3;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains no transparency information (value is 0).
 	 */
 	public static final int TRANSPARENCY_NONE = 0x0;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains alpha transparency information (value is 1&lt;&lt;0).
 	 */
 	public static final int TRANSPARENCY_ALPHA = 1 << 0;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains a transparency mask (value is 1&lt;&lt;1).
 	 */
 	public static final int TRANSPARENCY_MASK = 1 << 1;
-	
+
 	/**
 	 * Image transparency constant indicating that the image
 	 * contains a transparent pixel (value is 1&lt;&lt;2).
@@ -3951,24 +3952,24 @@
 	/**
 	 * The character movement type (value is 1&lt;&lt;0).
 	 * This constant is used to move a text offset over a character.
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
-	 */	
+	 */
 	public static final int MOVEMENT_CHAR = 1 << 0;
 
 	/**
 	 * The cluster movement type (value is 1&lt;&lt;1).
 	 * This constant is used to move a text offset over a cluster.
-	 * A cluster groups one or more characters. A cluster is 
+	 * A cluster groups one or more characters. A cluster is
 	 * undivisible, this means that a caret offset can not be placed in the
-	 * middle of a cluster.  
-	 * 
+	 * middle of a cluster.
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
 	 */
 	public static final int MOVEMENT_CLUSTER = 1 << 1;
@@ -3976,42 +3977,42 @@
 	/**
 	 * The word movement type (value is 1&lt;&lt;2).
 	 * This constant is used to move a text offset over a word.
-	 * The behavior of this constant depends on the platform and on the 
-	 * direction of the movement. For example, on Windows the stop is 
-	 * always at the start of the word. On GTK and Mac the stop is at the end 
-	 * of the word if the direction is next and at the start of the word if the 
+	 * The behavior of this constant depends on the platform and on the
+	 * direction of the movement. For example, on Windows the stop is
+	 * always at the start of the word. On GTK and Mac the stop is at the end
+	 * of the word if the direction is next and at the start of the word if the
 	 * direction is previous.
-	 * 
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.0
-	 */	
+	 */
 	public static final int MOVEMENT_WORD = 1 << 2;
 
 	/**
 	 * The word end movement type (value is 1&lt;&lt;3).
 	 * This constant is used to move a text offset to the next or previous
-	 * word end. The behavior of this constant does not depend on the platform.  
-	 * 
-	 * 
+	 * word end. The behavior of this constant does not depend on the platform.
+	 *
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.3
-	 */	
+	 */
 	public static final int MOVEMENT_WORD_END = 1 << 3;
 
 	/**
 	 * The word start movement type (value is 1&lt;&lt;4).
 	 * This constant is used to move a text offset to the next or previous
-	 * word start. The behavior of this constant does not depend on the platform.  
-	 * 
+	 * word start. The behavior of this constant does not depend on the platform.
+	 *
 	 * @see org.eclipse.swt.graphics.TextLayout#getNextOffset(int, int)
 	 * @see org.eclipse.swt.graphics.TextLayout#getPreviousOffset(int, int)
-	 * 
+	 *
 	 * @since 3.3
-	 */	
+	 */
 	public static final int MOVEMENT_WORD_START = 1 << 4;
 
 	/**
@@ -4107,7 +4108,7 @@
 	 * @since 3.6
 	 */
 	public static final String SKIN_ID = "org.eclipse.swt.skin.id";
-	
+
 	/**
 	 * The <code>Scrollable</code> constant to indicate that
 	 * the receiver is using overlay scrollbars. (value is 1)
@@ -4189,10 +4190,10 @@
 
 /**
  * Returns the NLS'ed message for the given argument.
- * 
+ *
  * @param key the key to look up
  * @return the message for the given key
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the key is null</li>
  * </ul>
@@ -4228,7 +4229,19 @@
 	return Platform.PLATFORM;
 }
 
+// <QFS>
 /**
+ * Returns the SWT platform name including architecture.
+ * Examples: "win32", "motif", "gtk", "gtk-64", "photon", "carbon"
+ *
+ * @return the SWT platform name
+ */
+public static String getPlatformAndArch () {
+    return getPlatform();
+}
+// </QFS>
+
+/**
  * Returns the SWT version number as an integer.
  * Example: "SWT051" == 51
  *
@@ -4301,7 +4314,7 @@
  * @see SWTError
  * @see SWTException
  * @see IllegalArgumentException
- * 
+ *
  * @since 3.0
  */
 public static void error (int code, Throwable throwable, String detail) {
@@ -4308,7 +4321,7 @@
 
 	/*
 	* This code prevents the creation of "chains" of SWTErrors and
-	* SWTExceptions which in turn contain other SWTErrors and 
+	* SWTExceptions which in turn contain other SWTErrors and
 	* SWTExceptions as their throwable. This can occur when low level
 	* code throws an exception past a point where a higher layer is
 	* being "safe" and catching all exceptions. (Note that, this is
@@ -4316,7 +4329,7 @@
 	*
 	* On the theory that the low level code is closest to the
 	* original problem, we simply re-throw the original exception here.
-	* 
+	*
 	* NOTE: Exceptions thrown in syncExec and asyncExec must be
 	* wrapped.
 	*/
@@ -4328,9 +4341,9 @@
 	String message = findErrorText (code);
 	if (detail != null) message += detail;
 	switch (code) {
-		
+
 		/* Illegal Arguments (non-fatal) */
-		case ERROR_NULL_ARGUMENT: 
+		case ERROR_NULL_ARGUMENT:
 		case ERROR_CANNOT_BE_ZERO:
 		case ERROR_INVALID_ARGUMENT:
 		case ERROR_MENU_NOT_BAR:
@@ -4337,11 +4350,11 @@
 		case ERROR_MENU_NOT_DROP_DOWN:
 		case ERROR_MENU_NOT_POP_UP:
 		case ERROR_MENUITEM_NOT_CASCADE:
-		case ERROR_INVALID_PARENT: 		
+		case ERROR_INVALID_PARENT:
 		case ERROR_INVALID_RANGE: {
 			throw new IllegalArgumentException (message);
 		}
-		
+
 		/* SWT Exceptions (non-fatal) */
 		case ERROR_INVALID_SUBCLASS:
 		case ERROR_THREAD_INVALID_ACCESS:
@@ -4362,7 +4375,7 @@
 			exception.throwable = throwable;
 			throw exception;
 		}
-		
+
 		/* Operation System Errors (fatal, may occur only on some platforms) */
 		case ERROR_CANNOT_GET_COUNT:
 		case ERROR_CANNOT_GET_ENABLED:
@@ -4378,7 +4391,7 @@
 		case ERROR_ITEM_NOT_REMOVED:
 		case ERROR_NO_HANDLES:
 		//FALL THROUGH
-		
+
 		/* SWT Errors (fatal, may occur only on some platforms) */
 		case ERROR_FAILED_LOAD_LIBRARY:
 		case ERROR_NO_MORE_CALLBACKS:
@@ -4389,7 +4402,7 @@
 			throw error;
 		}
 	}
-	
+
 	/* Unknown/Undefined Error */
 	SWTError error = new SWTError (code, message);
 	error.throwable = throwable;
@@ -4404,7 +4417,7 @@
 	*/
 	BUTTON_MASK = BUTTON1 | BUTTON2 | BUTTON3 | BUTTON4 | BUTTON5;
 	MODIFIER_MASK = ALT | SHIFT | CTRL | COMMAND;
-	
+
 	/*
 	* These values can be different on different platforms.
 	* Therefore they are not initialized in the declaration
Index: org/eclipse/swt/graphics/Device.java
===================================================================
--- org/eclipse/swt/graphics/Device.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Device.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -67,7 +67,7 @@
 	String[] loadedFonts;
 
 	boolean disposed;
-
+	
 	/*
 	* TEMPORARY CODE. When a graphics object is
 	* created and the device parameter is null,
@@ -290,16 +290,16 @@
  */
 public void dispose () {
 	synchronized (Device.class) {
-		if (isDisposed()) return;
-		checkDevice ();
-		release ();
-		destroy ();
-		disposed = true;
-		if (tracking) {
+	if (isDisposed()) return;
+	checkDevice ();
+	release ();
+	destroy ();
+	disposed = true;
+	if (tracking) {
 			synchronized (trackingLock) {
 				printErrors ();
-				objects = null;
-				errors = null;
+		objects = null;
+		errors = null;
 				trackingLock = null;
 			}
 		}
@@ -308,14 +308,14 @@
 
 void dispose_Object (Object object) {
 	synchronized (trackingLock) {
-		for (int i=0; i<objects.length; i++) {
-			if (objects [i] == object) {
-				objects [i] = null;
-				errors [i] = null;
-				return;
-			}
+	for (int i=0; i<objects.length; i++) {
+		if (objects [i] == object) {
+			objects [i] = null;
+			errors [i] = null;
+			return;
 		}
 	}
+	}
 }
 
 int /*long*/ EnumFontFamProc (int /*long*/ lpelfe, int /*long*/ lpntme, int /*long*/ FontType, int /*long*/ lParam) {
@@ -393,20 +393,20 @@
 	if (tracking) {
 		synchronized (trackingLock) {
 			int count = 0, length = objects.length;
-			for (int i=0; i<length; i++) {
-				if (objects [i] != null) count++;
-			}
-			int index = 0;
-			data.objects = new Object [count];
-			data.errors = new Error [count];
-			for (int i=0; i<length; i++) {
-				if (objects [i] != null) {
-					data.objects [index] = objects [i];
-					data.errors [index] = errors [i];
-					index++;
-				}
-			}
+	for (int i=0; i<length; i++) {
+		if (objects [i] != null) count++;
+	}
+	int index = 0;
+	data.objects = new Object [count];
+	data.errors = new Error [count];
+	for (int i=0; i<length; i++) {
+		if (objects [i] != null) {
+			data.objects [index] = objects [i];
+			data.errors [index] = errors [i];
+			index++;
 		}
+	}
+		}
 	} else {
 		data.objects = new Object [0];
 		data.errors = new Error [0];
@@ -806,7 +806,7 @@
  */
 public boolean isDisposed () {
 	synchronized (Device.class) {
-		return disposed;
+	return disposed;
 	}
 }
 
@@ -853,22 +853,22 @@
 
 void new_Object (Object object) {
 	synchronized (trackingLock) {
-		for (int i=0; i<objects.length; i++) {
-			if (objects [i] == null) {
-				objects [i] = object;
-				errors [i] = new Error ();
-				return;
-			}
+	for (int i=0; i<objects.length; i++) {
+		if (objects [i] == null) {
+			objects [i] = object;
+			errors [i] = new Error ();
+			return;
 		}
-		Object [] newObjects = new Object [objects.length + 128];
-		System.arraycopy (objects, 0, newObjects, 0, objects.length);
-		newObjects [objects.length] = object;
-		objects = newObjects;
-		Error [] newErrors = new Error [errors.length + 128];
-		System.arraycopy (errors, 0, newErrors, 0, errors.length);
-		newErrors [errors.length] = new Error ();
-		errors = newErrors;
 	}
+	Object [] newObjects = new Object [objects.length + 128];
+	System.arraycopy (objects, 0, newObjects, 0, objects.length);
+	newObjects [objects.length] = object;
+	objects = newObjects;
+	Error [] newErrors = new Error [errors.length + 128];
+	System.arraycopy (errors, 0, newErrors, 0, errors.length);
+	newErrors [errors.length] = new Error ();
+	errors = newErrors;
+	}
 }
 
 void printErrors () {
Index: org/eclipse/swt/graphics/ImageLoader.java
===================================================================
--- org/eclipse/swt/graphics/ImageLoader.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/ImageLoader.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -81,7 +81,7 @@
 	 * The default is 1. A value of 0 means 'display repeatedly'
 	 */
 	public int repeatCount;
-	
+		
 	/**
 	 * This is the compression used when saving jpeg and png files.
 	 * <p>
Index: org/eclipse/swt/graphics/Transform.java
===================================================================
--- org/eclipse/swt/graphics/Transform.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Transform.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -301,7 +301,7 @@
 	Gdip.Matrix_SetElements(handle, m11, m12, m21, m22, dx, dy);
 }
 
-/**
+/** 
  * Modifies the receiver so that it represents a transformation that is
  * equivalent to its previous transformation sheared by (shearX, shearY).
  * 
Index: org/eclipse/swt/graphics/Cursor.java
===================================================================
--- org/eclipse/swt/graphics/Cursor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Cursor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -387,8 +387,8 @@
 		hMask = OS.CreateBitmap(source.width, source.height, 1, 1, new byte[(((source.width + 7) / 8) + 3) / 4 * 4 * source.height]);
 		if (hMask == 0) SWT.error(SWT.ERROR_NO_HANDLES);
 	} else {
-		ImageData mask = source.getTransparencyMask();
-		int /*long*/ [] result = Image.init(this.device, null, source, mask);
+	ImageData mask = source.getTransparencyMask();
+	int /*long*/ [] result = Image.init(this.device, null, source, mask);
 		hBitmap = result[0];
 		hMask = result[1];
 	}
Index: org/eclipse/swt/graphics/Image.java
===================================================================
--- org/eclipse/swt/graphics/Image.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/Image.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -667,75 +667,75 @@
 						if (lockedBitmapData != 0) {
 							status = Gdip.Bitmap_LockBits(bitmap, 0, 0, pixelFormat, lockedBitmapData);
 							if (status == 0) {
-								BitmapData bitmapData = new BitmapData();
-								Gdip.MoveMemory(bitmapData, lockedBitmapData);
-								int stride = bitmapData.Stride;
-								int /*long*/ pixels = bitmapData.Scan0;
-								int depth = 0, scanlinePad = 4, transparentPixel = -1;
+							BitmapData bitmapData = new BitmapData();
+							Gdip.MoveMemory(bitmapData, lockedBitmapData);
+							int stride = bitmapData.Stride;
+							int /*long*/ pixels = bitmapData.Scan0;
+							int depth = 0, scanlinePad = 4, transparentPixel = -1;
+							switch (bitmapData.PixelFormat) {
+								case Gdip.PixelFormat1bppIndexed: depth = 1; break;
+								case Gdip.PixelFormat4bppIndexed: depth = 4; break;
+								case Gdip.PixelFormat8bppIndexed: depth = 8; break;
+								case Gdip.PixelFormat16bppARGB1555:
+								case Gdip.PixelFormat16bppRGB555:
+								case Gdip.PixelFormat16bppRGB565: depth = 16; break;
+								case Gdip.PixelFormat24bppRGB: depth = 24; break;
+								case Gdip.PixelFormat32bppRGB:
+								case Gdip.PixelFormat32bppARGB: depth = 32; break;
+							}
+							if (depth != 0) {
+								PaletteData paletteData = null;
 								switch (bitmapData.PixelFormat) {
-									case Gdip.PixelFormat1bppIndexed: depth = 1; break;
-									case Gdip.PixelFormat4bppIndexed: depth = 4; break;
-									case Gdip.PixelFormat8bppIndexed: depth = 8; break;
+									case Gdip.PixelFormat1bppIndexed:
+									case Gdip.PixelFormat4bppIndexed:
+									case Gdip.PixelFormat8bppIndexed:
+										int paletteSize = Gdip.Image_GetPaletteSize(bitmap);
+										int /*long*/ hHeap = OS.GetProcessHeap();
+										int /*long*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);
+										if (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);
+										Gdip.Image_GetPalette(bitmap, palette, paletteSize);
+										ColorPalette colorPalette = new ColorPalette();
+										Gdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);
+										int[] entries = new int[colorPalette.Count];
+										OS.MoveMemory(entries, palette + 8, entries.length * 4);
+										OS.HeapFree(hHeap, 0, palette);
+										RGB[] rgbs = new RGB[colorPalette.Count];
+										paletteData = new PaletteData(rgbs);
+										for (int i = 0; i < entries.length; i++) {
+											if (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {
+												transparentPixel = i;
+											}
+											rgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));
+										}
+										break;
 									case Gdip.PixelFormat16bppARGB1555:
-									case Gdip.PixelFormat16bppRGB555:
-									case Gdip.PixelFormat16bppRGB565: depth = 16; break;
-									case Gdip.PixelFormat24bppRGB: depth = 24; break;
+									case Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;
+									case Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;
+									case Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;
 									case Gdip.PixelFormat32bppRGB:
-									case Gdip.PixelFormat32bppARGB: depth = 32; break;
+									case Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;
 								}
-								if (depth != 0) {
-									PaletteData paletteData = null;
-									switch (bitmapData.PixelFormat) {
-										case Gdip.PixelFormat1bppIndexed:
-										case Gdip.PixelFormat4bppIndexed:
-										case Gdip.PixelFormat8bppIndexed:
-											int paletteSize = Gdip.Image_GetPaletteSize(bitmap);
-											int /*long*/ hHeap = OS.GetProcessHeap();
-											int /*long*/ palette = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, paletteSize);
-											if (palette == 0) SWT.error(SWT.ERROR_NO_HANDLES);
-											Gdip.Image_GetPalette(bitmap, palette, paletteSize);
-											ColorPalette colorPalette = new ColorPalette();
-											Gdip.MoveMemory(colorPalette, palette, ColorPalette.sizeof);
-											int[] entries = new int[colorPalette.Count];
-											OS.MoveMemory(entries, palette + 8, entries.length * 4);
-											OS.HeapFree(hHeap, 0, palette);
-											RGB[] rgbs = new RGB[colorPalette.Count];
-											paletteData = new PaletteData(rgbs);
-											for (int i = 0; i < entries.length; i++) {
-												if (((entries[i] >> 24) & 0xFF) == 0 && (colorPalette.Flags & Gdip.PaletteFlagsHasAlpha) != 0) {
-													transparentPixel = i;
-												}
-												rgbs[i] = new RGB(((entries[i] & 0xFF0000) >> 16), ((entries[i] & 0xFF00) >> 8), ((entries[i] & 0xFF) >> 0));
-											}
-											break;
-										case Gdip.PixelFormat16bppARGB1555:
-										case Gdip.PixelFormat16bppRGB555: paletteData = new PaletteData(0x7C00, 0x3E0, 0x1F); break;
-										case Gdip.PixelFormat16bppRGB565: paletteData = new PaletteData(0xF800, 0x7E0, 0x1F); break;
-										case Gdip.PixelFormat24bppRGB: paletteData = new PaletteData(0xFF, 0xFF00, 0xFF0000); break;
-										case Gdip.PixelFormat32bppRGB:
-										case Gdip.PixelFormat32bppARGB: paletteData = new PaletteData(0xFF00, 0xFF0000, 0xFF000000); break;
-									}
-									byte[] data = new byte[stride * height], alphaData = null;
-									OS.MoveMemory(data, pixels, data.length);
-									switch (bitmapData.PixelFormat) {
-										case Gdip.PixelFormat16bppARGB1555:
-							 		 		alphaData = new byte[width * height];
-							 		 		for (int i = 1, j = 0; i < data.length; i += 2, j++) {
-							 		 			alphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);
-							 		 		}
-											break;
-										case Gdip.PixelFormat32bppARGB:
-							 		 		alphaData = new byte[width * height];
-							 		 		for (int i = 3, j = 0; i < data.length; i += 4, j++) {
-							 		 			alphaData[j] = data[i];
-							 		 		}
-											break;
-									}
-									ImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);
-									img.transparentPixel = transparentPixel;
-									img.alphaData = alphaData;
-									init(img);
+								byte[] data = new byte[stride * height], alphaData = null;
+								OS.MoveMemory(data, pixels, data.length);
+								switch (bitmapData.PixelFormat) {
+									case Gdip.PixelFormat16bppARGB1555:
+						 		 		alphaData = new byte[width * height];
+						 		 		for (int i = 1, j = 0; i < data.length; i += 2, j++) {
+						 		 			alphaData[j] = (byte)((data[i] & 0x80) != 0 ? 255 : 0);
+						 		 		}
+										break;
+									case Gdip.PixelFormat32bppARGB:
+						 		 		alphaData = new byte[width * height];
+						 		 		for (int i = 3, j = 0; i < data.length; i += 4, j++) {
+						 		 			alphaData[j] = data[i];
+						 		 		}
+										break;
 								}
+								ImageData img = new ImageData(width, height, depth, paletteData, scanlinePad, data);
+								img.transparentPixel = transparentPixel;
+								img.alphaData = alphaData;
+								init(img);
+							}
 				 		 		Gdip.Bitmap_UnlockBits(bitmap, lockedBitmapData);
 							} else {
 								error = SWT.ERROR_INVALID_IMAGE;								
@@ -1010,9 +1010,9 @@
 				for (int y = 0, dp = 3; y < imgHeight; ++y) {
 					for (int x = 0; x < imgWidth; ++x) {
 						if (srcData[dp] == 0) {
-							if (OS.GetPixel(srcHdc, x, y) != 0) {
+						if (OS.GetPixel(srcHdc, x, y) != 0) {
 								srcData[dp] = (byte)0;
-							} else {
+						} else {
 								srcData[dp] = (byte)0xFF;
 							}
 						}
@@ -1638,7 +1638,7 @@
 	info.hbmMask = result[1];
 }
 
-static int /*long*/ [] init(Device device, Image image, ImageData i) {	
+static int /*long*/ [] init(Device device, Image image, ImageData i) {
 	/*
 	 * BUG in Windows 98:
 	 * A monochrome DIBSection will display as solid black
@@ -2002,7 +2002,7 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data
+ * @param data the platform specific GC data 
  * 
  * @noreference This method is not intended to be referenced by clients.
  */
Index: org/eclipse/swt/graphics/TextLayout.java
===================================================================
--- org/eclipse/swt/graphics/TextLayout.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/TextLayout.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -247,21 +247,21 @@
 	for (int i=0; i<allRuns.length - 1; i++) {
 		StyleItem run = allRuns[i];
 		if (tabs != null && run.tab) {
-			int tabsLength = tabs.length, j;
-			for (j = 0; j < tabsLength; j++) {
-				if (tabs[j] > lineWidth) {
-					run.width = tabs[j] - lineWidth;
-					break;
-				}
-			}
-			if (j == tabsLength) {
-				int tabX = tabs[tabsLength-1];
-				int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
-				if (lastTabWidth > 0) {
-					while (tabX <= lineWidth) tabX += lastTabWidth;
-					run.width = tabX - lineWidth;
-				}
-			}
+					int tabsLength = tabs.length, j;
+					for (j = 0; j < tabsLength; j++) {
+						if (tabs[j] > lineWidth) {
+							run.width = tabs[j] - lineWidth;
+							break;
+						}
+					}
+					if (j == tabsLength) {
+						int tabX = tabs[tabsLength-1];
+						int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
+						if (lastTabWidth > 0) {
+							while (tabX <= lineWidth) tabX += lastTabWidth;
+							run.width = tabX - lineWidth;
+						}
+					}
 			int length = run.length;
 			if (length > 1) {
 				int stop = j + length - 1;
@@ -271,7 +271,7 @@
 					if (j < tabsLength) {
 						run.width += tabs[tabsLength - 1] - tabs[j];
 						length -= (tabsLength - 1) - j;
-					}
+				}
 					int lastTabWidth = tabsLength > 1 ? tabs[tabsLength-1] - tabs[tabsLength-2] : tabs[0];
 					run.width += lastTabWidth * (length - 1);
 				}
@@ -657,8 +657,8 @@
 		if (hasSelection) {
 			selectionStart = translateOffset(Math.min(Math.max(0, selectionStart), length - 1));
 			selectionEnd = translateOffset(Math.min(Math.max(0, selectionEnd), length - 1));
-		}
 	}
+	}
 	RECT rect = new RECT();
 	OS.SetBkMode(hdc, OS.TRANSPARENT);
 	for (int line=0; line<runs.length; line++) {
@@ -950,20 +950,20 @@
 }
 
 void drawRunBackground(StyleItem run, int /*long*/ hdc, RECT rect, int selectionStart, int selectionEnd, int /*long*/ selBrush, boolean hasSelection) {
-	int end = run.start + run.length - 1;
-	boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
-	if (fullSelection) {
-		OS.SelectObject(hdc, selBrush);
+					int end = run.start + run.length - 1;
+					boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
+					if (fullSelection) {
+							OS.SelectObject(hdc, selBrush);
 		OS.PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, OS.PATCOPY);
-	} else {
-		if (run.style != null && run.style.background != null) {
-			int bg = run.style.background.handle;
-			int /*long*/ hBrush = OS.CreateSolidBrush (bg);
-			int /*long*/ oldBrush = OS.SelectObject(hdc, hBrush);
+					} else {
+						if (run.style != null && run.style.background != null) {
+							int bg = run.style.background.handle;
+								int /*long*/ hBrush = OS.CreateSolidBrush (bg);
+								int /*long*/ oldBrush = OS.SelectObject(hdc, hBrush);
 			OS.PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, OS.PATCOPY);
-			OS.SelectObject(hdc, oldBrush);
-			OS.DeleteObject(hBrush);
-		}
+								OS.SelectObject(hdc, oldBrush);
+								OS.DeleteObject(hBrush);
+							}
 		boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
 		if (partialSelection) {
 			getPartialSelection(run, selectionStart, selectionEnd, rect);
@@ -983,18 +983,18 @@
 			int /*long*/ brush = createGdipBrush(run.style.background, alpha);
 			Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 			Gdip.SolidBrush_delete(brush);
-		}
-		boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
-		if (partialSelection) {
+						}
+						boolean partialSelection = hasSelection && !(selectionStart > end || run.start > selectionEnd);
+						if (partialSelection) {
 			getPartialSelection(run, selectionStart, selectionEnd, rect);
-			if (rect.left > rect.right) {
-				int tmp = rect.left;
-				rect.left = rect.right;
-				rect.right = tmp;
-			}
+								if (rect.left > rect.right) {
+									int tmp = rect.left;
+									rect.left = rect.right;
+									rect.right = tmp;
+								}
 			Gdip.Graphics_FillRectangle(graphics, selBrush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
-		}
-	}
+							}
+						}
 }
 
 RECT drawRunText(int /*long*/ hdc, StyleItem run, RECT rect, int baseline, int color, int selectionColor, int selectionStart, int selectionEnd) {
@@ -1012,8 +1012,8 @@
 	} else {
 		if (run.style != null && run.style.foreground != null) {
 			color = run.style.foreground.handle;
-		}
-	}
+					}
+				}
 	OS.SetTextColor(hdc, color);
 	OS.ScriptTextOut(hdc, run.psc, x, y, 0, null, run.analysis , 0, 0, run.glyphs, run.glyphCount, run.advances, run.justify, run.goffsets);
 	if (partialSelection) {
@@ -1020,35 +1020,35 @@
 		getPartialSelection(run, selectionStart, selectionEnd, rect);
 		OS.SetTextColor(hdc, selectionColor);
 		OS.ScriptTextOut(hdc, run.psc, x, y, OS.ETO_CLIPPED, rect, run.analysis , 0, 0, run.glyphs, run.glyphCount, run.advances, run.justify, run.goffsets);
-	}
+			}
 	return fullSelection || partialSelection ? rect : null;
 }
 
 RECT drawRunTextGDIP(int /*long*/ graphics, StyleItem run, RECT rect, int /*long*/ gdipFont, int baseline, int /*long*/ color, int /*long*/ selectionColor, int selectionStart, int selectionEnd, int alpha) {
-	int end = run.start + run.length - 1;
+					int end = run.start + run.length - 1;
 	boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
-	boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
-	boolean partialSelection = hasSelection && !fullSelection && !(selectionStart > end || run.start > selectionEnd);
+					boolean fullSelection = hasSelection && selectionStart <= run.start && selectionEnd >= end;
+					boolean partialSelection = hasSelection && !fullSelection && !(selectionStart > end || run.start > selectionEnd);
 	int drawY = rect.top + baseline;
 	if (run.style != null && run.style.rise != 0) drawY -= run.style.rise;
 	int drawX = rect.left;
 	int /*long*/ brush = color;
-	if (fullSelection) {
+						if (fullSelection) {
 		brush = selectionColor;
-	} else {
-		if (run.style != null && run.style.foreground != null) {
+						} else {
+							if (run.style != null && run.style.foreground != null) {
 			brush = createGdipBrush(run.style.foreground, alpha);
-		}
-	}
-	int gstate = 0;
+							}
+						}
+						int gstate = 0;
 	Rect gdipRect = null;
-	if (partialSelection) {
+						if (partialSelection) {
 		gdipRect = new Rect();
 		getPartialSelection(run, selectionStart, selectionEnd, rect);
-		gdipRect.X = rect.left;
-		gdipRect.Y = rect.top;
-		gdipRect.Width = rect.right - rect.left;
-		gdipRect.Height = rect.bottom - rect.top;
+							gdipRect.X = rect.left;
+							gdipRect.Y = rect.top;
+							gdipRect.Width = rect.right - rect.left;
+							gdipRect.Height = rect.bottom - rect.top;
 		gstate = Gdip.Graphics_Save(graphics);
 		Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
 	}
@@ -1102,9 +1102,9 @@
 			case Gdip.BrushTypeTextureFill:
 				Gdip.TextureBrush_ResetTransform(brush);
 				break;
-		}
+						}
 		Gdip.Graphics_Restore(graphics, gstateMirrored);
-	}
+						}
 	if (brush != selectionColor && brush != color) Gdip.SolidBrush_delete(brush);
 	return fullSelection || partialSelection ? rect : null;
 }
@@ -1127,7 +1127,7 @@
 	if (!Gdip.Matrix_IsIdentity(matrix)) {
 		lpXform = new float[6];
 		Gdip.Matrix_GetElements(matrix, lpXform);
-	}
+						}
 	Gdip.Matrix_delete(matrix);
 	int /*long*/ hdc = Gdip.Graphics_GetHDC(graphics);
 	int state = OS.SaveDC(hdc);
@@ -1134,14 +1134,14 @@
 	if (lpXform != null) {
 		OS.SetGraphicsMode(hdc, OS.GM_ADVANCED);
 		OS.SetWorldTransform(hdc, lpXform);
-	}
+						}
 	if (clipRgn != 0) {
 		OS.SelectClipRgn(hdc, clipRgn);
 		OS.DeleteObject(clipRgn);
-	}
+							}
 	if ((orientation & SWT.RIGHT_TO_LEFT) != 0) {
 		OS.SetLayout(hdc, OS.GetLayout(hdc) | OS.LAYOUT_RTL);
-	}
+							}
 	OS.SetBkMode(hdc, OS.TRANSPARENT);
 	RECT pRect = drawRunText(hdc, run, rect, baseline, color, selectionColor, selectionStart, selectionEnd);
 	OS.RestoreDC(hdc, state);
@@ -1164,22 +1164,22 @@
 			left = line[i - 1].x;
 			start = Math.min(start, line[i - 1].start);
 			end = Math.max(end, line[i - 1].start + line[i - 1].length - 1);
-		}
+						}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
 		if (style.strikeoutColor != null) {
 			color = style.strikeoutColor.handle;
 			clipRect = null;
-		} else {
-			if (fullSelection) {
+					}  else {
+						if (fullSelection) {
 				color = selectionColor;
 				clipRect = null;
-			} else {
+						} else {
 				if (style.foreground != null) {
 					color = style.foreground.handle;
-				}
-			}
-		}
+						}
+						}
+					}
 		RECT rect = new RECT();
 		OS.SetRect(rect, x + left, baseline - run.strikeoutPos - style.rise, x + run.x + run.width, baseline - run.strikeoutPos + run.strikeoutThickness - style.rise);
 		int /*long*/ brush = OS.CreateSolidBrush(color);
@@ -1192,7 +1192,7 @@
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
 			OS.FillRect(hdc, clipRect, selBrush);
 			OS.DeleteObject(selBrush);
-		}
+				}
 		return null;
 	}
 	return clipRect;
@@ -1227,9 +1227,9 @@
 			} else {
 				if (style.foreground != null) {
 					brush = createGdipBrush(style.foreground, alpha);
-				}
 			}
 		}
+	}
 		if (clipRect != null) {
 			int gstate = Gdip.Graphics_Save(graphics);
 			if (clipRect.left == -1) clipRect.left = 0;
@@ -1246,7 +1246,7 @@
 			Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
 			Gdip.Graphics_FillRectangle(graphics, selectionColor, x + left, baseline - run.strikeoutPos - style.rise, run.x + run.width - left, run.strikeoutThickness);
 			Gdip.Graphics_Restore(graphics, gstate);
-		} else {
+	} else {
 			Gdip.Graphics_FillRectangle(graphics, brush, x + left, baseline - run.strikeoutPos - style.rise, run.x + run.width - left, run.strikeoutThickness);
 		}
 		if (brush != selectionColor && brush != color) Gdip.SolidBrush_delete(brush);
@@ -1266,11 +1266,11 @@
 		int left = run.x;
 		int start = run.start;
 		int end = run.start + run.length - 1;
-		for (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {
+					for (int i = index; i > 0 && style.isAdherentUnderline(line[i - 1].style); i--) {
 			left = line[i - 1].x;
 			start = Math.min(start, line[i - 1].start);
 			end = Math.max(end, line[i - 1].start + line[i - 1].length - 1);
-		}
+					}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
 		if (style.underlineColor != null) {
@@ -1292,12 +1292,12 @@
 			if (clipRect.left == -1) clipRect.left = 0;
 			if (clipRect.right == -1) clipRect.right = 0x7ffff;
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
-		}
-		switch (style.underlineStyle) {
-			case SWT.UNDERLINE_SQUIGGLE:
-			case SWT.UNDERLINE_ERROR: {
-				int squigglyThickness = 1;
-				int squigglyHeight = 2 * squigglyThickness;
+			}
+			switch (style.underlineStyle) {
+				case SWT.UNDERLINE_SQUIGGLE:
+				case SWT.UNDERLINE_ERROR: {
+					int squigglyThickness = 1;
+					int squigglyHeight = 2 * squigglyThickness;
 				int squigglyY = Math.min(rect.top - squigglyHeight / 2, lineBottom - squigglyHeight - 1);
 				int[] points = computePolyline(rect.left, squigglyY, rect.right, squigglyY + squigglyHeight);
 				int /*long*/ pen = OS.CreatePen(OS.PS_SOLID, squigglyThickness, color);
@@ -1308,11 +1308,11 @@
 				int length = points.length;
 				if (length >= 2 && squigglyThickness <= 1) {
 					OS.SetPixel (hdc, points[length - 2], points[length - 1], color);
-				}
+					}
 				OS.SelectObject(hdc, oldPen);
 				OS.DeleteObject(pen);
 				OS.RestoreDC(hdc, state);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					pen = OS.CreatePen(OS.PS_SOLID, squigglyThickness, selectionColor);
 					oldPen = OS.SelectObject(hdc, pen);
 					state = OS.SaveDC(hdc);
@@ -1325,10 +1325,10 @@
 					OS.DeleteObject(pen);
 					OS.RestoreDC(hdc, state);
 				}
-				break;
-			}
-			case SWT.UNDERLINE_SINGLE:
-			case SWT.UNDERLINE_DOUBLE:
+					break;
+				}
+				case SWT.UNDERLINE_SINGLE:
+				case SWT.UNDERLINE_DOUBLE:
 			case SWT.UNDERLINE_LINK:
 			case UNDERLINE_IME_THICK:
 				if (style.underlineStyle == UNDERLINE_IME_THICK) {
@@ -1345,9 +1345,9 @@
 				if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 					OS.SetRect(rect, rect.left, rect.top + run.underlineThickness * 2, rect.right, rect.bottom + run.underlineThickness * 2);
 					OS.FillRect(hdc, rect, brush);
-				}
+					}
 				OS.DeleteObject(brush);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					int /*long*/ selBrush = OS.CreateSolidBrush(selectionColor);
 					OS.FillRect(hdc, clipRect, selBrush);
 					if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
@@ -1355,11 +1355,11 @@
 						OS.FillRect(hdc, clipRect, selBrush);
 					}
 					OS.DeleteObject(selBrush);
-				}
-				break;
-			case UNDERLINE_IME_DASH:
-			case UNDERLINE_IME_DOT: {
-				int penStyle = style.underlineStyle == UNDERLINE_IME_DASH ? OS.PS_DASH : OS.PS_DOT;
+					}
+					break;
+				case UNDERLINE_IME_DASH:
+				case UNDERLINE_IME_DOT: {
+					int penStyle = style.underlineStyle == UNDERLINE_IME_DASH ? OS.PS_DASH : OS.PS_DOT;
 				int /*long*/ pen = OS.CreatePen(penStyle, 1, color);
 				int /*long*/ oldPen = OS.SelectObject(hdc, pen);
 				OS.SetRect(rect, rect.left, baseline + run.descent, rect.right, baseline + run.descent + run.underlineThickness);
@@ -1367,7 +1367,7 @@
 				OS.LineTo(hdc, rect.right, rect.top);
 				OS.SelectObject(hdc, oldPen);
 				OS.DeleteObject(pen);
-				if (clipRect != null) {
+					if (clipRect != null) {
 					pen = OS.CreatePen(penStyle, 1, selectionColor);
 					oldPen = OS.SelectObject(hdc, pen);
 					OS.SetRect(clipRect, clipRect.left, rect.top, clipRect.right, rect.bottom);
@@ -1375,17 +1375,17 @@
 					OS.LineTo(hdc, clipRect.right, clipRect.top);
 					OS.SelectObject(hdc, oldPen);
 					OS.DeleteObject(pen);
+					}
+					break;
 				}
-				break;
 			}
+		return null;
 		}
-		return null;
-	}
 	return clipRect;
 }
 
 RECT drawUnderlineGDIP (int /*long*/ graphics, int x, int baseline, int lineUnderlinePos, int lineBottom, StyleItem[] line, int index, int /*long*/ color, int /*long*/ selectionColor, RECT clipRect, RECT pRect, int selectionStart, int selectionEnd, int alpha, Rectangle drawClip) {
-	StyleItem run = line[index];
+	StyleItem run = line[index]; 
 	TextStyle style = run.style;
 	if (style == null) return null;
 	if (!style.underline) return null;
@@ -1402,7 +1402,7 @@
 		}
 		boolean hasSelection = selectionStart <= selectionEnd && selectionStart != -1 && selectionEnd != -1;
 		boolean fullSelection = hasSelection && selectionStart <= start && end <= selectionEnd;
-		int /*long*/ brush = color;
+			int /*long*/ brush = color;
 		if (style.underlineColor != null) {
 			brush = createGdipBrush(style.underlineColor, alpha);
 			clipRect = null;
@@ -1414,20 +1414,20 @@
 				if (style.foreground != null) {
 					brush = createGdipBrush(style.foreground, alpha);
 				}
+				}
 			}
-		}
 		RECT rect = new RECT();
 		OS.SetRect(rect, x + left, baseline - lineUnderlinePos - style.rise, x + run.x + run.width, baseline - lineUnderlinePos + run.underlineThickness - style.rise);
 		Rect gdipRect = null;
 		if (clipRect != null) {
-			if (clipRect.left == -1) clipRect.left = 0;
-			if (clipRect.right == -1) clipRect.right = 0x7ffff;
+				if (clipRect.left == -1) clipRect.left = 0;
+				if (clipRect.right == -1) clipRect.right = 0x7ffff;
 			OS.SetRect(clipRect, Math.max(rect.left, clipRect.left), rect.top, Math.min(rect.right, clipRect.right), rect.bottom);
 			gdipRect = new Rect();
-			gdipRect.X = clipRect.left;
-			gdipRect.Y = clipRect.top;
-			gdipRect.Width = clipRect.right - clipRect.left;
-			gdipRect.Height = clipRect.bottom - clipRect.top;
+				gdipRect.X = clipRect.left;
+				gdipRect.Y = clipRect.top;
+				gdipRect.Width = clipRect.right - clipRect.left;
+				gdipRect.Height = clipRect.bottom - clipRect.top;
 		}
 		int gstate = 0;
 		Gdip.Graphics_SetPixelOffsetMode(graphics, Gdip.PixelOffsetModeNone);
@@ -1443,7 +1443,7 @@
 				int /*long*/ pen = Gdip.Pen_new(brush, squigglyThickness);
 				gstate = Gdip.Graphics_Save(graphics);
 				if (gdipRect != null) {
-					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
+				Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
 				} else {
 					Rect r = new Rect();
 					r.X = rect.left;
@@ -1455,11 +1455,11 @@
 				Gdip.Graphics_DrawLines(graphics, pen, points, points.length / 2);
 				if (gdipRect != null) {
 					int /*long*/ selPen = Gdip.Pen_new(selectionColor, squigglyThickness);
-					Gdip.Graphics_Restore(graphics, gstate);
-					gstate = Gdip.Graphics_Save(graphics);
-					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
+				Gdip.Graphics_Restore(graphics, gstate);
+				gstate = Gdip.Graphics_Save(graphics);
+				Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeIntersect);
 					Gdip.Graphics_DrawLines(graphics, selPen, points, points.length / 2);
-					Gdip.Pen_delete(selPen);
+				Gdip.Pen_delete(selPen);
 				}
 				Gdip.Graphics_Restore(graphics, gstate);
 				Gdip.Pen_delete(pen);
@@ -1491,7 +1491,7 @@
 				Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 				if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 					Gdip.Graphics_FillRectangle(graphics, brush, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);
-				}
+			}
 				if (gdipRect != null) {
 					Gdip.Graphics_Restore(graphics, gstate);
 					gstate = Gdip.Graphics_Save(graphics);
@@ -1499,7 +1499,7 @@
 					Gdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
 					if (style.underlineStyle == SWT.UNDERLINE_DOUBLE) {
 						Gdip.Graphics_FillRectangle(graphics, selectionColor, rect.left, rect.top + run.underlineThickness * 2, rect.right - rect.left, rect.bottom - rect.top);
-					}
+				}
 					Gdip.Graphics_Restore(graphics, gstate);
 				}
 				break;
@@ -1511,7 +1511,7 @@
 				if (gdipRect != null) {
 					gstate = Gdip.Graphics_Save(graphics);
 					Gdip.Graphics_SetClip(graphics, gdipRect, Gdip.CombineModeExclude);
-				}
+			}
 				Gdip.Graphics_DrawLine(graphics, pen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);
 				if (gdipRect != null) {
 					Gdip.Graphics_Restore(graphics, gstate);
@@ -1522,7 +1522,7 @@
 					Gdip.Graphics_DrawLine(graphics, selPen, rect.left, baseline + run.descent, run.width - run.length, baseline + run.descent);
 					Gdip.Graphics_Restore(graphics, gstate);
 					Gdip.Pen_delete(selPen);
-				}
+			}
 				Gdip.Pen_delete(pen);
 				break;
 			}
@@ -2284,7 +2284,7 @@
 					}
 				}
 			} else {
-				if (trailing != null) trailing[0] = piTrailing[0];
+			if (trailing != null) trailing[0] = piTrailing[0];
 			}
 			return untranslateOffset(offset);
 		}
@@ -2422,10 +2422,10 @@
 	if (nSegments == 0) return text;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return text;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return text;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return text;
 	}
+	}
 	char[] oldChars = new char[length];
 	text.getChars(0, length, oldChars, 0);
 	char[] newChars = new char[length + nSegments];
@@ -3164,7 +3164,7 @@
  * returns without doing anything if the new text is the same as 
  * the current text.
  * </p>
- * 
+ *
  * @param text the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -3323,41 +3323,41 @@
 			}
 		}
 		if (count > 0) {
-			int /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());
-			int /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);
-			int /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);
-			int flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;
+		int /*long*/ ssa = OS.HeapAlloc(hHeap, OS.HEAP_ZERO_MEMORY, OS.SCRIPT_STRING_ANALYSIS_sizeof());
+		int /*long*/ metaFileDc = OS.CreateEnhMetaFile(hdc, null, null, null);
+		int /*long*/ oldMetaFont = OS.SelectObject(metaFileDc, hFont);
+		int flags = OS.SSA_METAFILE | OS.SSA_FALLBACK | OS.SSA_GLYPHS | OS.SSA_LINK;
 			if (OS.ScriptStringAnalyse(metaFileDc, sampleChars, count, 0, -1, flags, 0, null, null, 0, 0, 0, ssa) == OS.S_OK) {
-				OS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);
-				OS.ScriptStringFree(ssa);
-			}
-			OS.HeapFree(hHeap, 0, ssa);
-			OS.SelectObject(metaFileDc, oldMetaFont);
-			int /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);
-			final EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();
-			class MetaFileEnumProc {
-				int /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {
-					OS.MoveMemory(emr.emr, record, EMR.sizeof);
-					switch (emr.emr.iType) {
-						case OS.EMR_EXTCREATEFONTINDIRECTW:
-							OS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);
-							break;
-						case OS.EMR_EXTTEXTOUTW:
-							return 0;
-					}
-					return 1;
+			OS.ScriptStringOut(ssa, 0, 0, 0, null, 0, 0, false);
+			OS.ScriptStringFree(ssa);
+		}
+		OS.HeapFree(hHeap, 0, ssa);
+		OS.SelectObject(metaFileDc, oldMetaFont);
+		int /*long*/ metaFile = OS.CloseEnhMetaFile(metaFileDc);
+		final EMREXTCREATEFONTINDIRECTW emr = new EMREXTCREATEFONTINDIRECTW();
+		class MetaFileEnumProc {
+			int /*long*/ metaFileEnumProc (int /*long*/ hDC, int /*long*/ table, int /*long*/ record, int /*long*/ nObj, int /*long*/ lpData) {
+				OS.MoveMemory(emr.emr, record, EMR.sizeof);
+				switch (emr.emr.iType) {
+					case OS.EMR_EXTCREATEFONTINDIRECTW:
+						OS.MoveMemory(emr, record, EMREXTCREATEFONTINDIRECTW.sizeof);
+						break;
+					case OS.EMR_EXTTEXTOUTW:
+						return 0;
 				}
+				return 1;
 			}
-			MetaFileEnumProc object = new MetaFileEnumProc();
-			/* Avoid compiler warnings */
-			boolean compilerWarningWorkaround = false;
-			if (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);
-			Callback callback = new Callback(object, "metaFileEnumProc", 5);
-			int /*long*/ address = callback.getAddress();
-			if (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);
-			OS.EnumEnhMetaFile(0, metaFile, address, 0, null);
-			OS.DeleteEnhMetaFile(metaFile);
-			callback.dispose();
+			}
+		MetaFileEnumProc object = new MetaFileEnumProc();
+		/* Avoid compiler warnings */
+		boolean compilerWarningWorkaround = false;
+		if (compilerWarningWorkaround) object.metaFileEnumProc(0, 0, 0, 0, 0);
+		Callback callback = new Callback(object, "metaFileEnumProc", 5);
+		int /*long*/ address = callback.getAddress();
+		if (address == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);
+		OS.EnumEnhMetaFile(0, metaFile, address, 0, null);
+		OS.DeleteEnhMetaFile(metaFile);
+		callback.dispose();
 			newFont = OS.CreateFontIndirectW(emr.elfw.elfLogFont);
 		} else {
 			/*
@@ -3385,12 +3385,12 @@
 								OS.SelectObject(hdc, getItemFont(nRun));
 								shape(hdc, nRun);
 								int /*long*/ nFont = getItemFont(nRun);
-								LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();
+									LOGFONT logFont = OS.IsUnicode ? (LOGFONT)new LOGFONTW() : new LOGFONTA();
 								OS.GetObject(nFont, LOGFONT.sizeof, logFont);
-								newFont = OS.CreateFontIndirect(logFont);
+									newFont = OS.CreateFontIndirect(logFont);
+								}
 							}
 						}
-					}
 					break;
 				}
 				index++;
@@ -3397,11 +3397,11 @@
 			}
 		}
 		if (newFont != 0) {
-			OS.SelectObject(hdc, newFont);
-			if (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {
-				run.fallbackFont = newFont;
-			}
+		OS.SelectObject(hdc, newFont);
+		if (shapeSucceed = shape(hdc, run, chars, buffer,  maxGlyphs, sp)) {
+			run.fallbackFont = newFont;
 		}
+		}
 		if (!shapeSucceed) {
 			if (!sp.fComplex) {
 				run.analysis.fNoGlyphIndex = true;
@@ -3533,10 +3533,10 @@
 	if (nSegments == 0) return offset;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return offset;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return offset;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return offset;
 	}
+	}
 	for (int i = 0; i < nSegments && offset - i >= segments[i]; i++) {
 		offset++;
 	}	
@@ -3551,10 +3551,10 @@
 	if (nSegments == 0) return offset;
 	if (segmentsChars == null) {
 		if (nSegments == 1) return offset;
-		if (nSegments == 2) {
-			if (segments[0] == 0 && segments[1] == length) return offset;
-		}
+	if (nSegments == 2) {
+		if (segments[0] == 0 && segments[1] == length) return offset;
 	}
+	}
 	for (int i = 0; i < nSegments && offset > segments[i]; i++) {
 		offset--;
 	}
Index: org/eclipse/swt/graphics/GC.java
===================================================================
--- org/eclipse/swt/graphics/GC.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/graphics/GC.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -308,8 +308,8 @@
 			int /*long*/[] hFont = new int /*long*/[1];
 			int /*long*/ gdipFont = createGdipFont(handle, font.handle, gdipGraphics, device.fontCollection, null, hFont);
 			if (hFont[0] != 0) OS.SelectObject(handle, hFont[0]);
-			if (data.hGDIFont != 0) OS.DeleteObject(data.hGDIFont);
-			data.hGDIFont = hFont[0];
+				if (data.hGDIFont != 0) OS.DeleteObject(data.hGDIFont);
+				data.hGDIFont = hFont[0];
 			if (data.gdipFont != 0) Gdip.Font_delete(data.gdipFont);
 			data.gdipFont = gdipFont;
 		}
@@ -592,7 +592,7 @@
 		if (family != 0) {
 			font = Gdip.Font_new(family, size, style, Gdip.UnitPixel);
 		} else {
-			font = Gdip.Font_new(buffer, size, style, Gdip.UnitPixel, 0);
+		font = Gdip.Font_new(buffer, size, style, Gdip.UnitPixel, 0);
 		}
 		if (outFont != null && font != 0) {
 			int /*long*/ hHeap = OS.GetProcessHeap();
@@ -648,7 +648,7 @@
 	if (gdip && (data.style & SWT.MIRRORED) != 0) {
 		OS.SetLayout(handle, OS.GetLayout(handle) | OS.LAYOUT_RTL);
 	}
-	
+
 	/* Select stock pen and brush objects and free resources */
 	if (data.hPen != 0) {
 		OS.SelectObject(handle, OS.GetStockObject(OS.NULL_PEN));
@@ -2063,30 +2063,30 @@
 	if (naw == 0 || nah == 0) {
 		Gdip.Graphics_DrawRectangle(gdipGraphics, data.gdipPen, x, y, width, height);
 	} else {
-		int /*long*/ path = Gdip.GraphicsPath_new(Gdip.FillModeAlternate);
-		if (path == 0) SWT.error(SWT.ERROR_NO_HANDLES);
-		if (nw > naw) {
-			if (nh > nah) {
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nah, 0, -90);
-				Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nah, -90, -90);
-				Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, naw, nah, -180, -90);
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);
-			} else {
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nh, -270, -180);
-				Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nh, -90, -180);
-			}
+	int /*long*/ path = Gdip.GraphicsPath_new(Gdip.FillModeAlternate);
+	if (path == 0) SWT.error(SWT.ERROR_NO_HANDLES);
+	if (nw > naw) {
+		if (nh > nah) {
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nah, 0, -90);
+			Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nah, -90, -90);
+			Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, naw, nah, -180, -90);
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);
 		} else {
-			if (nh > nah) {
-				Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nah, 0, -180);
-				Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, nw, nah, -180, -180);
-			} else {
-				Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nh, 0, 360);
-			}
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nh, -270, -180);
+			Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nh, -90, -180);
 		}
-		Gdip.GraphicsPath_CloseFigure(path);
-		Gdip.Graphics_DrawPath(gdipGraphics, pen, path);
-		Gdip.GraphicsPath_delete(path);
+	} else {
+		if (nh > nah) {
+			Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nah, 0, -180);
+			Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, nw, nah, -180, -180);
+		} else {
+			Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nh, 0, 360);
+		}
 	}
+	Gdip.GraphicsPath_CloseFigure(path);
+	Gdip.Graphics_DrawPath(gdipGraphics, pen, path);
+	Gdip.GraphicsPath_delete(path);
+	}
 	Gdip.Graphics_TranslateTransform(gdipGraphics, -data.gdipXOffset, -data.gdipYOffset, Gdip.MatrixOrderPrepend);
 }
 
@@ -3106,30 +3106,30 @@
 	if (naw == 0 || nah == 0) {
 		Gdip.Graphics_FillRectangle(data.gdipGraphics, data.gdipBrush, x, y, width, height);
 	} else {
-		int /*long*/ path = Gdip.GraphicsPath_new(Gdip.FillModeAlternate);
-		if (path == 0) SWT.error(SWT.ERROR_NO_HANDLES);
-		if (nw > naw) {
-			if (nh > nah) {
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nah, 0, -90);
-				Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nah, -90, -90);
-				Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, naw, nah, -180, -90);
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);
-			} else {
-				Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nh, -270, -180);
-				Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nh, -90, -180);
-			}
+	int /*long*/ path = Gdip.GraphicsPath_new(Gdip.FillModeAlternate);
+	if (path == 0) SWT.error(SWT.ERROR_NO_HANDLES);
+	if (nw > naw) {
+		if (nh > nah) {
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nah, 0, -90);
+			Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nah, -90, -90);
+			Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, naw, nah, -180, -90);
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny + nh - nah, naw, nah, -270, -90);
 		} else {
-			if (nh > nah) {
-				Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nah, 0, -180);
-				Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, nw, nah, -180, -180);
-			} else {
-				Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nh, 0, 360);
-			}
+			Gdip.GraphicsPath_AddArc(path, nx + nw - naw, ny, naw, nh, -270, -180);
+			Gdip.GraphicsPath_AddArc(path, nx, ny, naw, nh, -90, -180);
 		}
-		Gdip.GraphicsPath_CloseFigure(path);
-		Gdip.Graphics_FillPath(gdipGraphics, brush, path);
-		Gdip.GraphicsPath_delete(path);
+	} else {
+		if (nh > nah) {
+			Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nah, 0, -180);
+			Gdip.GraphicsPath_AddArc(path, nx, ny + nh - nah, nw, nah, -180, -180);
+		} else {
+			Gdip.GraphicsPath_AddArc(path, nx, ny, nw, nh, 0, 360);
+		}
 	}
+	Gdip.GraphicsPath_CloseFigure(path);
+	Gdip.Graphics_FillPath(gdipGraphics, brush, path);
+	Gdip.GraphicsPath_delete(path);
+	}
 }
 
 void flush () {
@@ -3399,7 +3399,7 @@
 				OS.GetWindowOrgEx (handle, pt);
 				OS.OffsetRgn (hRgn, pt.x, pt.y);
 			}
-			OS.CombineRgn(region.handle, hRgn, 0, OS.RGN_COPY);			
+			OS.CombineRgn(region.handle, hRgn, 0, OS.RGN_COPY);
 			OS.DeleteObject(hRgn);
 		}
 		Gdip.Region_delete(rgn);
@@ -3890,17 +3890,17 @@
 		if (technology == OS.DT_RASPRINTER) {
 			width = OS.GetDeviceCaps(handle, OS.PHYSICALWIDTH);
 		} else {
-			Image image = data.image;
-			if (image != null) {
-				BITMAP bm = new BITMAP();
-				OS.GetObject(image.handle, BITMAP.sizeof, bm);
-				width = bm.bmWidth;
+		Image image = data.image;
+		if (image != null) {
+			BITMAP bm = new BITMAP();
+			OS.GetObject(image.handle, BITMAP.sizeof, bm);
+			width = bm.bmWidth;
 			} else {
 				int /*long*/ hwnd = OS.IsWinCE ? data.hwnd : OS.WindowFromDC(handle);
 				if (hwnd != 0) {
-					RECT rect = new RECT();
+			RECT rect = new RECT();
 					OS.GetClientRect(hwnd, rect);
-					width = rect.right - rect.left;
+			width = rect.right - rect.left;
 				} else {
 					int /*long*/ hBitmap = OS.GetCurrentObject(handle, OS.OBJ_BITMAP);
 					BITMAP bm = new BITMAP();
Index: org/eclipse/swt/events/GestureEvent.java
===================================================================
--- org/eclipse/swt/events/GestureEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/events/GestureEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -23,7 +23,7 @@
  * @since 3.7
  */
 public class GestureEvent extends TypedEvent {
-
+	
 	/**
 	 * The state of the keyboard modifier keys and mouse masks
 	 * at the time the event was generated.
@@ -32,7 +32,7 @@
 	 * @see org.eclipse.swt.SWT#BUTTON_MASK
 	 */
 	public int stateMask;
-
+	
 	/**
 	 * The gesture type.
 	 * <p><ul>
@@ -55,13 +55,13 @@
 	 * gesture was performed. 
 	 */
 	public int x;
-
+	
 	/**
 	 * The meaning of this field is dependent on the value of the <code>detail</code> field
 	 * and the platform.  It can represent either the y coordinate of the centroid of the
 	 * touches that make up the gesture, or the y coordinate of the cursor at the time the
 	 * gesture was performed. 
-	 */
+	 */	
 	public int y;
 
 	/**
@@ -114,9 +114,9 @@
 	 * Setting it to <code>false</code> will cancel the operation.
 	 */
 	public boolean doit;
-
+	
 	static final long serialVersionUID = -8348741538373572182L;
-
+	
 /**
  * Constructs a new instance of this class based on the
  * information in the given untyped event.
Index: org/eclipse/swt/events/TouchEvent.java
===================================================================
--- org/eclipse/swt/events/TouchEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/events/TouchEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -23,7 +23,7 @@
  * @since 3.7
  */
 public class TouchEvent extends TypedEvent {
-
+	
 	/**
 	 * The set of touches representing the state of all contacts with touch input
 	 * device at the time the event was generated.
@@ -40,19 +40,19 @@
 	 * @see org.eclipse.swt.SWT#BUTTON_MASK
 	 */
 	public int stateMask;
-
+	
 	/**
 	 * The widget-relative x coordinate of the pointer
 	 * at the time the touch occurred.
 	 */
 	public int x;
-
+	
 	/**
 	 * The widget-relative y coordinate of the pointer
 	 * at the time the touch occurred.
 	 */	
 	public int y;
-
+	
 	static final long serialVersionUID = -8348741538373572182L;
 	
 /**
Index: org/eclipse/swt/events/SegmentEvent.java
===================================================================
--- org/eclipse/swt/events/SegmentEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/events/SegmentEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,100 +1,100 @@
-/*******************************************************************************
+/*******************************************************************************
  * Copyright (c) 2000, 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.swt.events;
-
-import org.eclipse.swt.widgets.Event;
-
-/**
- * This event is sent to SegmentListeners when a text content is to be modified.
- * The segments field can be used in conjunction with the segmentsChars field or
- * by itself. Setting only the segmentsChars field has no effect. When used by
- * itself, the segments field specify text ranges that should be treated as
- * separate segments.
- * <p>
- * The elements in the segments field specify the start offset of a segment
- * relative to the start of the text. They must follow the following rules:
- * <ul>
- * <li>elements must be in ascending order and must not have duplicates
- * <li>elements must not exceed the text length
- * </ul>
- * In addition, the first element may be set to zero and the last element may 
- * be set to the end of the line but this is not required.
- *
- * The segments field may be left null if the entire text content doesn't
- * require segmentation.
- * </p>
- * A SegmentListener may be used when adjacent segments of right-to-left text
- * should not be reordered relative to each other. For example, within a Java
- * editor, you may wish multiple right-to-left string literals to be reordered
- * differently than the bidi algorithm specifies.  
- *
- * Example:
- * <pre>
- * 	stored text = "R1R2R3" + "R4R5R6"
- *		R1 to R6 are right-to-left characters. The quotation marks
- * 		are part of the text. The text is 13 characters long.
- * 
- * 	segments = null: 
- * 		entire text content will be reordered and thus the two R2L segments 
- * 		swapped (as per the bidi algorithm). 
- *		visual display (rendered on screen) = "R6R5R4" + "R3R2R1"
- * 
- * 	segments = [0, 5, 8]	
- * 		"R1R2R3" will be reordered, followed by [blank]+[blank] and 
- * 		"R4R5R6". 
- *		visual display = "R3R2R1" + "R6R5R4"
- * </pre>
- * 
- * <p>
- * The segments and segementsChars fields can be used together to obtain different
- * types of bidi reordering and text display. The application can use these two fields
- * to insert Unicode Control Characters in specific offsets in the text, the character
- * at segmentsChars[i] is inserted at the offset specified by segments[i]. When both fields 
- * are set, the rules for the segments field are less restrictive:
- * <ul>
- * <li>elements must be in ascending order, duplicates are allowed
- * <li>elements must not exceed the text length
- * </ul>
- * </p>
- *
- * @since 3.8
- */
-
-public class SegmentEvent extends TypedEvent {
-
-	/** 
-	 * The start offset of the <code>lineText</code> relative to text (always zero for single line widget) 
-	 */
-	public int lineOffset;
-	
-	/** 
-	 * Text used to calculate the segments 
-	 */			
-	public String lineText;
-
-	/**
-	 * Text ranges that should be treated as separate segments (e.g. for bidi reordering)
-	 */
-	public int[] segments;
-
-	/**
-	 * Characters to be used in the segment boundaries (optional)
-	 */
-	public char[] segmentsChars;
-
-	static final long serialVersionUID = -2414889726745247762L;
-	
-	public SegmentEvent(Event e) {
-		super(e);
-		lineText = e.text;
-		lineOffset = e.detail;
-	}
-}
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.swt.events;
+
+import org.eclipse.swt.widgets.Event;
+
+/**
+ * This event is sent to SegmentListeners when a text content is to be modified.
+ * The segments field can be used in conjunction with the segmentsChars field or
+ * by itself. Setting only the segmentsChars field has no effect. When used by
+ * itself, the segments field specify text ranges that should be treated as
+ * separate segments.
+ * <p>
+ * The elements in the segments field specify the start offset of a segment
+ * relative to the start of the text. They must follow the following rules:
+ * <ul>
+ * <li>elements must be in ascending order and must not have duplicates
+ * <li>elements must not exceed the text length
+ * </ul>
+ * In addition, the first element may be set to zero and the last element may 
+ * be set to the end of the line but this is not required.
+ *
+ * The segments field may be left null if the entire text content doesn't
+ * require segmentation.
+ * </p>
+ * A SegmentListener may be used when adjacent segments of right-to-left text
+ * should not be reordered relative to each other. For example, within a Java
+ * editor, you may wish multiple right-to-left string literals to be reordered
+ * differently than the bidi algorithm specifies.  
+ *
+ * Example:
+ * <pre>
+ * 	stored text = "R1R2R3" + "R4R5R6"
+ *		R1 to R6 are right-to-left characters. The quotation marks
+ * 		are part of the text. The text is 13 characters long.
+ * 
+ * 	segments = null: 
+ * 		entire text content will be reordered and thus the two R2L segments 
+ * 		swapped (as per the bidi algorithm). 
+ *		visual display (rendered on screen) = "R6R5R4" + "R3R2R1"
+ * 
+ * 	segments = [0, 5, 8]	
+ * 		"R1R2R3" will be reordered, followed by [blank]+[blank] and 
+ * 		"R4R5R6". 
+ *		visual display = "R3R2R1" + "R6R5R4"
+ * </pre>
+ * 
+ * <p>
+ * The segments and segementsChars fields can be used together to obtain different
+ * types of bidi reordering and text display. The application can use these two fields
+ * to insert Unicode Control Characters in specific offsets in the text, the character
+ * at segmentsChars[i] is inserted at the offset specified by segments[i]. When both fields 
+ * are set, the rules for the segments field are less restrictive:
+ * <ul>
+ * <li>elements must be in ascending order, duplicates are allowed
+ * <li>elements must not exceed the text length
+ * </ul>
+ * </p>
+ *
+ * @since 3.8
+ */
+
+public class SegmentEvent extends TypedEvent {
+
+	/** 
+	 * The start offset of the <code>lineText</code> relative to text (always zero for single line widget) 
+	 */
+	public int lineOffset;
+	
+	/** 
+	 * Text used to calculate the segments 
+	 */			
+	public String lineText;
+
+	/**
+	 * Text ranges that should be treated as separate segments (e.g. for bidi reordering)
+	 */
+	public int[] segments;
+
+	/**
+	 * Characters to be used in the segment boundaries (optional)
+	 */
+	public char[] segmentsChars;
+
+	static final long serialVersionUID = -2414889726745247762L;
+	
+	public SegmentEvent(Event e) {
+		super(e);
+		lineText = e.text;
+		lineOffset = e.detail;
+	}
+}
Index: org/eclipse/swt/events/SegmentListener.java
===================================================================
--- org/eclipse/swt/events/SegmentListener.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/events/SegmentListener.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,38 +1,38 @@
-/*******************************************************************************
+/*******************************************************************************
  * Copyright (c) 2000, 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.swt.events;
+
+import org.eclipse.swt.internal.SWTEventListener;
+
+/**
+ * This listener interface may be implemented in order to receive
+ * SegmentEvents.
+ * @see SegmentEvent
  *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.swt.events;
-
-import org.eclipse.swt.internal.SWTEventListener;
-
-/**
- * This listener interface may be implemented in order to receive
- * SegmentEvents.
- * @see SegmentEvent
- *
  * @since 3.8
- */
-public interface SegmentListener extends SWTEventListener {
-
-/**
- * This method is called when text content is being modified. 
- * <p>
- * The following event fields are used:<ul>
- * <li>event.text text content (input)</li>
- * <li>event.segmentsChars characters that should be inserted (output)</li>
- * <li>event.segments text offsets for segment characters (output)</li>
- * </ul>
- *
- * @param event the given event
- * @see SegmentEvent
- */
-public void getSegments(SegmentEvent event);
-
-}
+ */
+public interface SegmentListener extends SWTEventListener {
+
+/**
+ * This method is called when text content is being modified. 
+ * <p>
+ * The following event fields are used:<ul>
+ * <li>event.text text content (input)</li>
+ * <li>event.segmentsChars characters that should be inserted (output)</li>
+ * <li>event.segments text offsets for segment characters (output)</li>
+ * </ul>
+ *
+ * @param event the given event
+ * @see SegmentEvent
+ */
+public void getSegments(SegmentEvent event);
+
+}
Index: org/eclipse/swt/dnd/Clipboard.java
===================================================================
--- org/eclipse/swt/dnd/Clipboard.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/Clipboard.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -650,9 +650,9 @@
 		this.transferAgents = new Transfer[0];
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 
Index: org/eclipse/swt/dnd/DND.java
===================================================================
--- org/eclipse/swt/dnd/DND.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DND.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -162,7 +162,7 @@
 	
 	/**
 	 * DropTarget drag under effect: The widget is scrolled up or down to allow the user to drop on items that 
-	 * are not currently visible; applies to tables and trees (value is 8).
+	 * are not currently visible;  applies to tables and trees (value is 8).
 	 */	
 	public static final int FEEDBACK_SCROLL = 8;
 	
Index: org/eclipse/swt/dnd/URLTransfer.java
===================================================================
--- org/eclipse/swt/dnd/URLTransfer.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/URLTransfer.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -77,24 +77,24 @@
 		transferData.stgmedium.pUnkForRelease = 0;
 		transferData.result = COM.S_OK;
 	} else if (transferData.type == CFSTR_INETURLID) {
-		int count = url.length();
-		char[] chars = new char[count + 1];
-		url.getChars(0, count, chars, 0);
-		int codePage = OS.GetACP();
-		int cchMultiByte = OS.WideCharToMultiByte(codePage, 0, chars, -1, null, 0, null, null);
-		if (cchMultiByte == 0) {
-			transferData.stgmedium = new STGMEDIUM();
-			transferData.result = COM.DV_E_STGMEDIUM;
-			return;
-		}
-		int /*long*/ lpMultiByteStr = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, cchMultiByte);
-		OS.WideCharToMultiByte(codePage, 0, chars, -1, lpMultiByteStr, cchMultiByte, null, null);
+	int count = url.length();
+	char[] chars = new char[count + 1];
+	url.getChars(0, count, chars, 0);
+	int codePage = OS.GetACP();
+	int cchMultiByte = OS.WideCharToMultiByte(codePage, 0, chars, -1, null, 0, null, null);
+	if (cchMultiByte == 0) {
 		transferData.stgmedium = new STGMEDIUM();
-		transferData.stgmedium.tymed = COM.TYMED_HGLOBAL;
-		transferData.stgmedium.unionField = lpMultiByteStr;
-		transferData.stgmedium.pUnkForRelease = 0;
-		transferData.result = COM.S_OK;
+		transferData.result = COM.DV_E_STGMEDIUM;
+		return;
 	}
+	int /*long*/ lpMultiByteStr = OS.GlobalAlloc(OS.GMEM_FIXED | OS.GMEM_ZEROINIT, cchMultiByte);
+	OS.WideCharToMultiByte(codePage, 0, chars, -1, lpMultiByteStr, cchMultiByte, null, null);
+	transferData.stgmedium = new STGMEDIUM();
+	transferData.stgmedium.tymed = COM.TYMED_HGLOBAL;
+	transferData.stgmedium.unionField = lpMultiByteStr;
+	transferData.stgmedium.pUnkForRelease = 0;
+	transferData.result = COM.S_OK;
+	}
 }
 
 /**
@@ -140,19 +140,19 @@
 				OS.GlobalUnlock(hMem);	
 			}
 		} else if (transferData.type == CFSTR_INETURLID) {
-			int /*long*/ lpMultiByteStr = OS.GlobalLock(hMem);
-			if (lpMultiByteStr == 0) return null;
-			try {
-				int codePage = OS.GetACP();
-				int cchWideChar  = OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, null, 0);
-				if (cchWideChar == 0) return null;
-				char[] lpWideCharStr = new char [cchWideChar - 1];
-				OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, lpWideCharStr, lpWideCharStr.length);
-				return new String(lpWideCharStr);
-			} finally {
-				OS.GlobalUnlock(hMem);
-			}
+		int /*long*/ lpMultiByteStr = OS.GlobalLock(hMem);
+		if (lpMultiByteStr == 0) return null;
+		try {
+			int codePage = OS.GetACP();
+			int cchWideChar  = OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, null, 0);
+			if (cchWideChar == 0) return null;
+			char[] lpWideCharStr = new char [cchWideChar - 1];
+			OS.MultiByteToWideChar (codePage, OS.MB_PRECOMPOSED, lpMultiByteStr, -1, lpWideCharStr, lpWideCharStr.length);
+			return new String(lpWideCharStr);
+		} finally {
+			OS.GlobalUnlock(hMem);
 		}
+		}
 	} finally {
 		OS.GlobalFree(hMem);
 	}
Index: org/eclipse/swt/dnd/OleEnumFORMATETC.java
===================================================================
--- org/eclipse/swt/dnd/OleEnumFORMATETC.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/OleEnumFORMATETC.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -134,9 +134,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	
 	return refCount;
 }
Index: org/eclipse/swt/dnd/DropTarget.java
===================================================================
--- org/eclipse/swt/dnd/DropTarget.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DropTarget.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.dnd;
 
@@ -166,6 +167,9 @@
 	} else if (control instanceof Tree) {
 		dropEffect = new TreeDropTargetEffect((Tree) control);
 	}
+        // <QFS>
+        getDisplay().runDNDCreationHooks(this);
+        // </QFS>
 }
 
 static int checkStyle (int style) {
@@ -572,7 +576,7 @@
 	iDataObject = null;
 	
 	if (COM.FreeUnusedLibraries) {
-		COM.CoFreeUnusedLibraries();
+	COM.CoFreeUnusedLibraries();
 	}
 }
 
@@ -630,9 +634,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	
 	return refCount;
 }
Index: org/eclipse/swt/dnd/TableDragSourceEffect.java
===================================================================
--- org/eclipse/swt/dnd/TableDragSourceEffect.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/TableDragSourceEffect.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -77,7 +77,7 @@
 	
 	Image getDragSourceImage(DragSourceEvent event) {
 		if (dragSourceImage != null) dragSourceImage.dispose();
-		dragSourceImage = null;
+		dragSourceImage = null;		
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (5, 1)) {
 			SHDRAGIMAGE shdi = new SHDRAGIMAGE();
 			int DI_GETDRAGIMAGE = OS.RegisterWindowMessage (new TCHAR (0, "ShellGetDragImage", true)); //$NON-NLS-1$
Index: org/eclipse/swt/dnd/DropTargetEffect.java
===================================================================
--- org/eclipse/swt/dnd/DropTargetEffect.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DropTargetEffect.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -100,7 +100,7 @@
 		coordinates = table.toControl(coordinates);
 		TableItem item = table.getItem(coordinates);
 		if (item != null) return item;
-		Rectangle area = table.getClientArea();
+			Rectangle area = table.getClientArea();
 		int tableBottom = area.y + area.height;
 		int itemCount = table.getItemCount();
 		for (int i=table.getTopIndex(); i<itemCount; i++) {
@@ -110,7 +110,7 @@
 			rect.width = area.width;
 			if (rect.contains(coordinates)) return item;
 			if (rect.y > tableBottom) break;
-		}
+					}
 		return null;
 	}
 	
Index: org/eclipse/swt/dnd/TreeDragSourceEffect.java
===================================================================
--- org/eclipse/swt/dnd/TreeDragSourceEffect.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/TreeDragSourceEffect.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -76,7 +76,7 @@
 
 	Image getDragSourceImage(DragSourceEvent event) {
 		if (dragSourceImage != null) dragSourceImage.dispose();
-		dragSourceImage = null;
+		dragSourceImage = null;		
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (5, 1)) {
 			SHDRAGIMAGE shdi = new SHDRAGIMAGE();
 			int DI_GETDRAGIMAGE = OS.RegisterWindowMessage (new TCHAR (0, "ShellGetDragImage", true)); //$NON-NLS-1$
Index: org/eclipse/swt/dnd/DragSource.java
===================================================================
--- org/eclipse/swt/dnd/DragSource.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/dnd/DragSource.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.dnd;
 
- 
+
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.widgets.*;
@@ -23,34 +24,34 @@
  * <code>DragSource</code> defines the source object for a drag and drop transfer.
  *
  * <p>IMPORTANT: This class is <em>not</em> intended to be subclassed.</p>
- *  
- * <p>A drag source is the object which originates a drag and drop operation. For the specified widget, 
- * it defines the type of data that is available for dragging and the set of operations that can 
- * be performed on that data.  The operations can be any bit-wise combination of DND.MOVE, DND.COPY or 
- * DND.LINK.  The type of data that can be transferred is specified by subclasses of Transfer such as 
- * TextTransfer or FileTransfer.  The type of data transferred can be a predefined system type or it 
+ *
+ * <p>A drag source is the object which originates a drag and drop operation. For the specified widget,
+ * it defines the type of data that is available for dragging and the set of operations that can
+ * be performed on that data.  The operations can be any bit-wise combination of DND.MOVE, DND.COPY or
+ * DND.LINK.  The type of data that can be transferred is specified by subclasses of Transfer such as
+ * TextTransfer or FileTransfer.  The type of data transferred can be a predefined system type or it
  * can be a type defined by the application.  For instructions on how to define your own transfer type,
  * refer to <code>ByteArrayTransfer</code>.</p>
  *
- * <p>You may have several DragSources in an application but you can only have one DragSource 
- * per Control.  Data dragged from this DragSource can be dropped on a site within this application 
+ * <p>You may have several DragSources in an application but you can only have one DragSource
+ * per Control.  Data dragged from this DragSource can be dropped on a site within this application
  * or it can be dropped on another application such as an external Text editor.</p>
- * 
+ *
  * <p>The application supplies the content of the data being transferred by implementing the
  * <code>DragSourceListener</code> and associating it with the DragSource via DragSource#addDragListener.</p>
- * 
- * <p>When a successful move operation occurs, the application is required to take the appropriate 
+ *
+ * <p>When a successful move operation occurs, the application is required to take the appropriate
  * action to remove the data from its display and remove any associated operating system resources or
- * internal references.  Typically in a move operation, the drop target makes a copy of the data 
- * and the drag source deletes the original.  However, sometimes copying the data can take a long 
- * time (such as copying a large file).  Therefore, on some platforms, the drop target may actually 
- * move the data in the operating system rather than make a copy.  This is usually only done in 
+ * internal references.  Typically in a move operation, the drop target makes a copy of the data
+ * and the drag source deletes the original.  However, sometimes copying the data can take a long
+ * time (such as copying a large file).  Therefore, on some platforms, the drop target may actually
+ * move the data in the operating system rather than make a copy.  This is usually only done in
  * file transfers.  In this case, the drag source is informed in the DragEnd event that a
- * DROP_TARGET_MOVE was performed.  It is the responsibility of the drag source at this point to clean 
+ * DROP_TARGET_MOVE was performed.  It is the responsibility of the drag source at this point to clean
  * up its displayed information.  No action needs to be taken on the operating system resources.</p>
  *
  * <p> The following example shows a Label widget that allows text to be dragged from it.</p>
- * 
+ *
  * <code><pre>
  *	// Enable a label as a Drag Source
  *	Label label = new Label(shell, SWT.NONE);
@@ -58,7 +59,7 @@
  *	Transfer[] types = new Transfer[] {TextTransfer.getInstance()};
  *	// This example will allow the text to be copied or moved to the drop target
  *	int operations = DND.DROP_MOVE | DND.DROP_COPY;
- *	
+ *
  *	DragSource source = new DragSource(label, operations);
  *	source.setTransfer(types);
  *	source.addDragListener(new DragSourceListener() {
@@ -70,10 +71,10 @@
  *			}
  *		};
  *		public void dragSetData(DragSourceEvent event) {
- *			// A drop has been performed, so provide the data of the 
+ *			// A drop has been performed, so provide the data of the
  *			// requested type.
- *			// (Checking the type of the requested data is only 
- *			// necessary if the drag source supports more than 
+ *			// (Checking the type of the requested data is only
+ *			// necessary if the drag source supports more than
  *			// one data type but is shown here as an example).
  *			if (TextTransfer.getInstance().isSupportedType(event.dataType)){
  *				event.data = label.getText();
@@ -108,15 +109,15 @@
 	DragSourceEffect dragEffect;
 	Composite topControl;
 	int /*long*/ hwndDrag;
-	
+
 	// ole interfaces
 	COMObject iDropSource;
 	COMObject iDataObject;
 	int refCount;
-	
+
 	//workaround - track the operation performed by the drop target for DragEnd event
-	int dataEffect = DND.DROP_NONE;	
-	
+	int dataEffect = DND.DROP_NONE;
+
 	static final String DEFAULT_DRAG_SOURCE_EFFECT = "DEFAULT_DRAG_SOURCE_EFFECT"; //$NON-NLS-1$
 	static final int CFSTR_PERFORMEDDROPEFFECT  = Transfer.registerType("Performed DropEffect");	 //$NON-NLS-1$
 	static final TCHAR WindowClass = new TCHAR (0, "#32770", true);
@@ -123,13 +124,13 @@
 
 /**
  * Creates a new <code>DragSource</code> to handle dragging from the specified <code>Control</code>.
- * Creating an instance of a DragSource may cause system resources to be allocated depending on the platform.  
+ * Creating an instance of a DragSource may cause system resources to be allocated depending on the platform.
  * It is therefore mandatory that the DragSource instance be disposed when no longer required.
  *
  * @param control the <code>Control</code> that the user clicks on to initiate the drag
- * @param style the bitwise OR'ing of allowed operations; this may be a combination of any of 
+ * @param style the bitwise OR'ing of allowed operations; this may be a combination of any of
  *					DND.DROP_NONE, DND.DROP_COPY, DND.DROP_MOVE, DND.DROP_LINK
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
@@ -139,10 +140,10 @@
  *        drag source is created for a control or if the operating system will not allow the creation
  *        of the drag source</li>
  * </ul>
- * 
+ *
  * <p>NOTE: ERROR_CANNOT_INIT_DRAG should be an SWTException, since it is a
  * recoverable error, but can not be changed due to backward compatibility.</p>
- * 
+ *
  * @see Widget#dispose
  * @see DragSource#checkSubclass
  * @see DND#DROP_NONE
@@ -176,7 +177,7 @@
 	};
 	control.addListener(SWT.Dispose, controlListener);
 	control.addListener(SWT.DragDetect, controlListener);
-	
+
 	this.addListener(SWT.Dispose, new Listener() {
 		public void handleEvent(Event e) {
 			DragSource.this.onDispose();
@@ -191,6 +192,9 @@
 	} else if (control instanceof Table) {
 		dragEffect = new TableDragSourceEffect((Table) control);
 	}
+        // <QFS>
+        getDisplay().runDNDCreationHooks(this);
+        // </QFS>
 }
 
 static int checkStyle(int style) {
@@ -203,13 +207,13 @@
  * be notified when a drag and drop operation is in progress, by sending
  * it one of the messages defined in the <code>DragSourceListener</code>
  * interface.
- * 
+ *
  * <p><ul>
- * <li><code>dragStart</code> is called when the user has begun the actions required to drag the widget. 
+ * <li><code>dragStart</code> is called when the user has begun the actions required to drag the widget.
  * This event gives the application the chance to decide if a drag should be started.
  * <li><code>dragSetData</code> is called when the data is required from the drag source.
- * <li><code>dragFinished</code> is called when the drop has successfully completed (mouse up 
- * over a valid target) or has been terminated (such as hitting the ESC key). Perform cleanup 
+ * <li><code>dragFinished</code> is called when the drop has successfully completed (mouse up
+ * over a valid target) or has been terminated (such as hitting the ESC key). Perform cleanup
  * such as removing data from the source side on a successful move operation.
  * </ul></p>
  *
@@ -251,7 +255,7 @@
 		public int /*long*/ method3(int /*long*/[] args) {return QueryContinueDrag((int)/*64*/args[0], (int)/*64*/args[1]);}
 		public int /*long*/ method4(int /*long*/[] args) {return GiveFeedback((int)/*64*/args[0]);}
 	};
-	
+
 	iDataObject = new COMObject(new int[]{2, 0, 0, 2, 2, 1, 2, 3, 2, 4, 1, 1}){
 		public int /*long*/ method0(int /*long*/[] args) {return QueryInterface(args[0], args[1]);}
 		public int /*long*/ method1(int /*long*/[] args) {return AddRef();}
@@ -295,7 +299,7 @@
 	event.doit = true;
 	notifyListeners(DND.DragStart,event);
 	if (!event.doit || transferAgents == null || transferAgents.length == 0 ) return;
-	
+
 	int[] pdwEffect = new int[1];
 	int operations = opToOs(getStyle());
 	Display display = control.getDisplay();
@@ -365,14 +369,14 @@
 		// ensure that we don't leave transparent window around
 		if (hwndDrag != 0) {
 			OS.ImageList_DragLeave(hwndDrag);
-			OS.ImageList_EndDrag();
-			imagelist.dispose();
+		OS.ImageList_EndDrag();
+		imagelist.dispose();
 			if (hwndDrag != topControl.handle) OS.DestroyWindow(hwndDrag);
 			hwndDrag = 0;
-			topControl = null;
-		}
-		display.setData(key, oldValue);
+		topControl = null;
 	}
+	display.setData(key, oldValue);
+	}
 	int operation = osToOp(pdwEffect[0]);
 	if (dataEffect == DND.DROP_MOVE) {
 		operation = (operation == DND.DROP_NONE || operation == DND.DROP_COPY) ? DND.DROP_TARGET_MOVE : DND.DROP_MOVE;
@@ -389,9 +393,9 @@
 	notifyListeners(DND.DragEnd,event);
 	dataEffect = DND.DROP_NONE;
 }
-/* 
+/*
  * EnumFormatEtc([in] dwDirection, [out] ppenumFormatetc)
- * Ownership of ppenumFormatetc transfers from callee to caller so reference count on ppenumFormatetc 
+ * Ownership of ppenumFormatetc transfers from callee to caller so reference count on ppenumFormatetc
  * must be incremented before returning.  Caller is responsible for releasing ppenumFormatetc.
  */
 private int EnumFormatEtc(int dwDirection, int /*long*/ ppenumFormatetc) {
@@ -410,21 +414,21 @@
 			allowedDataTypes = newAllowedDataTypes;
 		}
 	}
-	
+
 	OleEnumFORMATETC enumFORMATETC = new OleEnumFORMATETC();
 	enumFORMATETC.AddRef();
-	
+
 	FORMATETC[] formats = new FORMATETC[allowedDataTypes.length];
 	for (int i = 0; i < formats.length; i++){
 		formats[i] = allowedDataTypes[i].formatetc;
 	}
 	enumFORMATETC.setFormats(formats);
-	
+
 	OS.MoveMemory(ppenumFormatetc, new int /*long*/[] {enumFORMATETC.getAddress()}, OS.PTR_SIZEOF);
 	return COM.S_OK;
 }
 /**
- * Returns the Control which is registered for this DragSource.  This is the control that the 
+ * Returns the Control which is registered for this DragSource.  This is the control that the
  * user clicks in to initiate dragging.
  *
  * @return the Control which is registered for this DragSource
@@ -434,9 +438,9 @@
 }
 
 private int GetData(int /*long*/ pFormatetc, int /*long*/ pmedium) {
-	/* Called by a data consumer to obtain data from a source data object. 
-	   The GetData method renders the data described in the specified FORMATETC 
-	   structure and transfers it through the specified STGMEDIUM structure. 
+	/* Called by a data consumer to obtain data from a source data object.
+	   The GetData method renders the data described in the specified FORMATETC
+	   structure and transfers it through the specified STGMEDIUM structure.
 	   The caller then assumes responsibility for releasing the STGMEDIUM structure.
 	*/
 	if (pFormatetc == 0 || pmedium == 0) return COM.E_INVALIDARG;
@@ -449,13 +453,13 @@
 	transferData.type = transferData.formatetc.cfFormat;
 	transferData.stgmedium = new STGMEDIUM();
 	transferData.result = COM.E_FAIL;
-	
+
 	DNDEvent event = new DNDEvent();
 	event.widget = this;
 	event.time = OS.GetMessageTime();
 	event.dataType = transferData;
 	notifyListeners(DND.DragSetData,event);
-	
+
 	if (!event.doit) return COM.E_FAIL;
 	
 	// get matching transfer agent to perform conversion
@@ -467,7 +471,7 @@
 			break;
 		}
 	}
-	
+
 	if (transfer == null) return COM.DV_E_FORMATETC;
 	transfer.javaToNative(event.data, transferData);
 	if (transferData.result != COM.S_OK) return transferData.result;
@@ -518,7 +522,7 @@
  * effect will be used during a drag and drop operation.
  *
  * @return the drag effect that is registered for this DragSource
- * 
+ *
  * @since 3.3
  */
 public DragSourceEffect getDragSourceEffect() {
@@ -556,7 +560,7 @@
 		if (hwndDrag != 0) OS.ImageList_DragLeave(hwndDrag);
 		return COM.DRAGDROP_S_DROP;
 	}
-	
+
 	if (hwndDrag != 0) {
 		POINT pt = new POINT ();
 		OS.GetCursorPos (pt);
@@ -621,12 +625,12 @@
 		if (transfer != null && transfer.isSupportedType(transferData))
 			return COM.S_OK;
 	}
-	
+
 	return COM.DV_E_FORMATETC;
 }
 
 /* QueryInterface([in] riid, [out] ppvObject)
- * Ownership of ppvObject transfers from callee to caller so reference count on ppvObject 
+ * Ownership of ppvObject transfers from callee to caller so reference count on ppvObject
  * must be incremented before returning.  Caller is responsible for releasing ppvObject.
  */
 private int QueryInterface(int /*long*/ riid, int /*long*/ ppvObject) {
@@ -634,7 +638,7 @@
 		return COM.E_INVALIDARG;
 	GUID guid = new GUID();
 	COM.MoveMemory(guid, riid, GUID.sizeof);
-	
+
 	if (COM.IsEqualGUID(guid, COM.IIDIUnknown) || COM.IsEqualGUID(guid, COM.IIDIDropSource)) {
 		OS.MoveMemory(ppvObject, new int /*long*/[] {iDropSource.getAddress()}, OS.PTR_SIZEOF);
 		AddRef();
@@ -646,7 +650,7 @@
 		AddRef();
 		return COM.S_OK;
 	}
-	
+
 	OS.MoveMemory(ppvObject, new int /*long*/[] {0}, OS.PTR_SIZEOF);
 	return COM.E_NOINTERFACE;
 }
@@ -656,9 +660,9 @@
 	if (refCount == 0) {
 		disposeCOMInterfaces();
 		if (COM.FreeUnusedLibraries) {
-			COM.CoFreeUnusedLibraries();
-		}
+		COM.CoFreeUnusedLibraries();
 	}
+	}
 	return refCount;
 }
 
@@ -708,11 +712,11 @@
 }
 
 /**
- * Specifies the drag effect for this DragSource.  This drag effect will be 
+ * Specifies the drag effect for this DragSource.  This drag effect will be
  * used during a drag and drop operation.
  *
  * @param effect the drag effect that is registered for this DragSource
- * 
+ *
  * @since 3.3
  */
 public void setDragSourceEffect(DragSourceEffect effect) {
@@ -723,7 +727,7 @@
  * Specifies the list of data types that can be transferred by this DragSource.
  * The application must be able to provide data to match each of these types when
  * a successful drop has occurred.
- * 
+ *
  * @param transferAgents a list of Transfer objects which define the types of data that can be
  * dragged from this source
  */
Index: org/eclipse/swt/widgets/Tree.java
===================================================================
--- org/eclipse/swt/widgets/Tree.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Tree.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -126,7 +126,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -168,7 +168,7 @@
 	* applications have consistent scroll bar behavior.
 	*/
 	if ((style & SWT.NO_SCROLL) == 0) {
-		style |= SWT.H_SCROLL | SWT.V_SCROLL;
+	style |= SWT.H_SCROLL | SWT.V_SCROLL;
 	}
 	/*
 	* Note: Windows only supports TVS_NOSCROLL and TVS_NOHSCROLL.
@@ -272,12 +272,12 @@
 
 		/* Set the background color */
 		OS.SendMessage (handle, OS.TVM_SETBKCOLOR, 0, newPixel);
-		
+
 		/*
 		* Feature in Windows.  When TVM_SETBKCOLOR is used to
 		* set the background color of a tree, the plus/minus
 		* animation draws badly.  The fix is to clear the effect.
-		*/	
+		*/
 		if (explorerTheme && ENABLE_TVS_EX_FADEINOUTEXPANDOS) {
 			int bits2 = (int)/*64*/OS.SendMessage (handle, OS.TVM_GETEXTENDEDSTYLE, 0, 0);
 			if (newPixel == -1 && findImageControl () == null) {
@@ -353,7 +353,7 @@
 	TypedListener typedListener = new TypedListener (listener);
 	addListener (SWT.Expand, typedListener);
 	addListener (SWT.Collapse, typedListener);
-} 
+}
 
 int /*long*/ borderHandle () {
 	return hwndParent != 0 ? hwndParent : handle;
@@ -365,7 +365,7 @@
 	int /*long*/ hDC = nmcd.hdc;
 	OS.RestoreDC (hDC, -1);
 	TreeItem item = getItem (nmcd);
-	
+
 	/*
 	* Feature in Windows.  When a new tree item is inserted
 	* using TVM_INSERTITEM and the tree is using custom draw,
@@ -372,7 +372,7 @@
 	* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns
 	* and before the item is added to the items array.  The
 	* fix is to check for null.
-	* 
+	*
 	* NOTE: This only happens on XP with the version 6.00 of
 	* COMCTL32.DLL,
 	*/
@@ -384,7 +384,7 @@
 	* not a problem providing that graphics do not occur outside
 	* the rectangle.  The fix is to test for the rectangle and
 	* draw nothing.
-	* 
+	*
 	* NOTE:  This seems to happen when both I_IMAGECALLBACK
 	* and LPSTR_TEXTCALLBACK are used at the same time with
 	* TVM_SETITEM.
@@ -480,7 +480,7 @@
 						int /*long*/ hTheme = OS.OpenThemeData (handle, Display.TREEVIEW);
 						int iStateId = selected ? OS.TREIS_SELECTED : OS.TREIS_HOT;
 						if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.TREIS_SELECTEDNOTFOCUS;
-						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);	
+						OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, pClipRect);
 						OS.CloseThemeData (hTheme);
 					}
 					if (draw) fillBackground (hDC, OS.GetBkColor (hDC), pClipRect);
@@ -695,7 +695,7 @@
 										int /*long*/ hTheme = OS.OpenThemeData (handle, Display.TREEVIEW);
 										int iStateId = selected ? OS.TREIS_SELECTED : OS.TREIS_HOT;
 										if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.TREIS_SELECTEDNOTFOCUS;
-										OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, backgroundRect);	
+										OS.DrawThemeBackground (hTheme, hDC, OS.TVP_TREEITEM, iStateId, pRect, backgroundRect);
 										OS.CloseThemeData (hTheme);
 									}
 								}
@@ -842,7 +842,7 @@
 							}
 						}
 					}
-				}				
+				}
 				event.x = itemRect.left;
 				event.y = itemRect.top;
 				event.width = itemRect.right - itemRect.left;
@@ -865,14 +865,14 @@
 	if (linesVisible) {
 		if ((style & SWT.FULL_SELECTION) != 0) {
 			if (columnCount != 0) {
-				HDITEM hdItem = new HDITEM ();
-				hdItem.mask = OS.HDI_WIDTH;
-				OS.SendMessage (hwndHeader, OS.HDM_GETITEM, 0, hdItem);
-				RECT rect = new RECT ();
-				OS.SetRect (rect, nmcd.left + hdItem.cxy, nmcd.top, nmcd.right, nmcd.bottom);
-				OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
+					HDITEM hdItem = new HDITEM ();
+					hdItem.mask = OS.HDI_WIDTH;
+					OS.SendMessage (hwndHeader, OS.HDM_GETITEM, 0, hdItem);
+					RECT rect = new RECT ();
+					OS.SetRect (rect, nmcd.left + hdItem.cxy, nmcd.top, nmcd.right, nmcd.bottom);
+					OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
+				}
 			}
-		}
 		RECT rect = new RECT ();
 		OS.SetRect (rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);
 		OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
@@ -881,25 +881,24 @@
 		OS.DrawFocusRect (hDC, focusRect);
 		focusRect = null;
 	} else {
-		if (!explorerTheme) {
-			if (handle == OS.GetFocus ()) {
-				int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
-				if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
-					int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
-					if (hItem == item.handle) {
-						if (!ignoreDrawFocus && findImageControl () != null) {
-							if ((style & SWT.FULL_SELECTION) != 0) {
-								RECT focusRect = new RECT ();
+	if (!explorerTheme) {
+		if (handle == OS.GetFocus ()) {
+			int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
+			if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
+				int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
+				if (hItem == item.handle) {
+					if (!ignoreDrawFocus && findImageControl () != null) {
+						if ((style & SWT.FULL_SELECTION) != 0) {
+							RECT focusRect = new RECT ();
 								OS.SetRect (focusRect, 0, nmcd.top, clientRect.right + 1, nmcd.bottom);
-								OS.DrawFocusRect (hDC, focusRect);
-							} else {
-								int index = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, 0, 0);
-								RECT focusRect = item.getBounds (index, true, false, false, false, false, hDC);
-								RECT clipRect = item.getBounds (index, true, false, false, false, true, hDC);
-								OS.IntersectClipRect (hDC, clipRect.left, clipRect.top, clipRect.right, clipRect.bottom);
-								OS.DrawFocusRect (hDC, focusRect);
-								OS.SelectClipRgn (hDC, 0);
-							}
+							OS.DrawFocusRect (hDC, focusRect);
+						} else {
+							int index = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, 0, 0);
+							RECT focusRect = item.getBounds (index, true, false, false, false, false, hDC);
+							RECT clipRect = item.getBounds (index, true, false, false, false, true, hDC);
+							OS.IntersectClipRect (hDC, clipRect.left, clipRect.top, clipRect.right, clipRect.bottom);
+							OS.DrawFocusRect (hDC, focusRect);
+							OS.SelectClipRgn (hDC, 0);
 						}
 					}
 				}
@@ -906,6 +905,7 @@
 			}
 		}
 	}
+	}
 	return new LRESULT (OS.CDRF_DODEFAULT);
 }
 
@@ -922,7 +922,7 @@
 	* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns
 	* and before the item is added to the items array.  The
 	* fix is to check for null.
-	* 
+	*
 	* NOTE: This only happens on XP with the version 6.00 of
 	* COMCTL32.DLL,
 	*/
@@ -936,18 +936,18 @@
 	}
 	RECT clipRect = null;
 	if (columnCount != 0) {
-		boolean clip = !printClient;
-		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
-			clip = true;
+			boolean clip = !printClient;
+			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
+				clip = true;
+			}
+			if (clip) {
+				clipRect = new RECT ();
+				HDITEM hdItem = new HDITEM ();
+				hdItem.mask = OS.HDI_WIDTH;
+				OS.SendMessage (hwndHeader, OS.HDM_GETITEM, index, hdItem);
+				OS.SetRect (clipRect, nmcd.left, nmcd.top, nmcd.left + hdItem.cxy, nmcd.bottom);
+			}
 		}
-		if (clip) {
-			clipRect = new RECT ();
-			HDITEM hdItem = new HDITEM ();
-			hdItem.mask = OS.HDI_WIDTH;
-			OS.SendMessage (hwndHeader, OS.HDM_GETITEM, index, hdItem);
-			OS.SetRect (clipRect, nmcd.left, nmcd.top, nmcd.left + hdItem.cxy, nmcd.bottom);
-		}
-	}
 	int clrText = -1, clrTextBk = -1;
 	if (OS.IsWindowEnabled (handle)) {
 		clrText = item.cellForeground != null ? item.cellForeground [index] : -1;
@@ -961,7 +961,7 @@
 			if (findImageControl () == null) {
 				if (indexOf (sortColumn) == index) {
 					clrSortBk = getSortColumnPixel ();
-					if (clrTextBk == -1) clrTextBk = clrSortBk; 
+					if (clrTextBk == -1) clrTextBk = clrSortBk;
 				}
 			}
 		}
@@ -991,12 +991,12 @@
 			if (clrSortBk != -1) {
 				drawBackground (hDC, cellRect, clrSortBk, 0, 0);
 			} else {
-				if (OS.IsWindowEnabled (handle) || findImageControl () != null) {
-					drawBackground (hDC, rect);
-				} else {
-					fillBackground (hDC, OS.GetBkColor (hDC), rect);
-				}
+			if (OS.IsWindowEnabled (handle) || findImageControl () != null) {
+				drawBackground (hDC, rect);
+			} else {
+				fillBackground (hDC, OS.GetBkColor (hDC), rect);
 			}
+			}
 			int nSavedDC = OS.SaveDC (hDC);
 			GCData data = new GCData ();
 			data.device = display;
@@ -1021,11 +1021,11 @@
 			if (clrTextBk != -1) event.detail |= SWT.BACKGROUND;
 			if (hot) event.detail |= SWT.HOT;
 			if (selected) event.detail |= SWT.SELECTED;
-			//if ((nmcd.uItemState & OS.CDIS_FOCUS) != 0) {
-			if (OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0) == nmcd.dwItemSpec) {
-				if (handle == OS.GetFocus ()) {
-					int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
-					if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
+				//if ((nmcd.uItemState & OS.CDIS_FOCUS) != 0) {
+				if (OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0) == nmcd.dwItemSpec) {
+					if (handle == OS.GetFocus ()) {
+						int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
+						if ((uiState & OS.UISF_HIDEFOCUS) == 0) {
 						if (!explorerTheme || !selected) {
 							focused = true;
 							event.detail |= SWT.FOCUSED;
@@ -1194,7 +1194,7 @@
 	}
 	LRESULT result = null;
 	if (clrText == -1 && clrTextBk == -1 && hFont == -1) {
-		result = new LRESULT (OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);	
+		result = new LRESULT (OS.CDRF_DODEFAULT | OS.CDRF_NOTIFYPOSTPAINT);
 	} else {
 		result = new LRESULT (OS.CDRF_NEWFONT | OS.CDRF_NOTIFYPOSTPAINT);
 		if (hFont != -1) OS.SelectObject (hDC, hFont);
@@ -1222,8 +1222,8 @@
 						if ((style & SWT.FULL_SELECTION) != 0) {
 							if (!selected) fillBackground (hDC, clrTextBk, rect);
 						} else {
-							fillBackground (hDC, clrTextBk, rect);
-						}
+								fillBackground (hDC, clrTextBk, rect);
+							}
 					} else {
 						if ((style & SWT.FULL_SELECTION) != 0) {
 							RECT rect = new RECT ();
@@ -1336,7 +1336,7 @@
 						* child.  The fix is to use the bottom partially
 						* visible item rather than the last possible item
 						* that could be visible.
-						* 
+						*
 						* NOTE: This problem only happens on Vista during
 						* WM_NOTIFY with NM_CUSTOMDRAW and CDDS_POSTPAINT.
 						*/
@@ -1392,7 +1392,7 @@
 			* child.  The fix is to use the bottom partially
 			* visible item rather than the last possible item
 			* that could be visible.
-			* 
+			*
 			* NOTE: This problem only happens on Vista during
 			* WM_NOTIFY with NM_CUSTOMDRAW and CDDS_POSTPAINT.
 			*/
@@ -1414,14 +1414,14 @@
 				OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
 			}
 			if (height != 0) {
-				while (rect.bottom < nmcd.bottom) {
-					int top = rect.top + height;
-					OS.SetRect (rect, rect.left, top, rect.right, top + height);
-					OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
-				}
+			while (rect.bottom < nmcd.bottom) {
+				int top = rect.top + height;
+				OS.SetRect (rect, rect.left, top, rect.right, top + height);
+				OS.DrawEdge (hDC, rect, OS.BDR_SUNKENINNER, OS.BF_BOTTOM);
 			}
 		}
 	}
+	}
 	return new LRESULT (OS.CDRF_DODEFAULT);
 }
 
@@ -1474,7 +1474,7 @@
 				}
 			}
 			break;
-		}	
+		}
 	}
 	int /*long*/ hItem = 0;
 	boolean redraw = false;
@@ -1490,18 +1490,18 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-			
+
 		/* Resize messages */
 		case OS.WM_SIZE:
 			redraw = findImageControl () != null && getDrawing () && OS.IsWindowVisible (handle);
 			if (redraw) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -1520,7 +1520,7 @@
 		case OS.WM_XBUTTONDOWN:
 		case OS.WM_XBUTTONUP:
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -1544,12 +1544,12 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-			
+
 		/* Resize messages */
 		case OS.WM_SIZE:
 			if (redraw) {
@@ -1558,7 +1558,7 @@
 				if (hwndHeader != 0) OS.InvalidateRect (hwndHeader, null, true);
 			}
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -1577,7 +1577,7 @@
 		case OS.WM_XBUTTONDOWN:
 		case OS.WM_XBUTTONUP:
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -1589,7 +1589,7 @@
 			updateScrollBar ();
 			break;
 		}
-		
+
 		case OS.WM_PAINT:
 			painted = true;
 			break;
@@ -1614,8 +1614,8 @@
 boolean checkData (TreeItem item, boolean redraw) {
 	if ((style & SWT.VIRTUAL) == 0) return true;
 	if (!item.cached) {
-		TreeItem parentItem = item.getParentItem ();
-		return checkData (item, parentItem == null ? indexOf (item) : parentItem.indexOf (item), redraw);
+	TreeItem parentItem = item.getParentItem ();
+	return checkData (item, parentItem == null ? indexOf (item) : parentItem.indexOf (item), redraw);
 	}
 	return true;
 }
@@ -1654,13 +1654,13 @@
 
 boolean checkScroll (int /*long*/ hItem) {
 	/*
-	* Feature in Windows.  If redraw is turned off using WM_SETREDRAW 
+	* Feature in Windows.  If redraw is turned off using WM_SETREDRAW
 	* and a tree item that is not a child of the first root is selected or
 	* scrolled using TVM_SELECTITEM or TVM_ENSUREVISIBLE, then scrolling
 	* does not occur.  The fix is to detect this case, and make sure
 	* that redraw is temporarily enabled.  To avoid flashing, DefWindowProc()
 	* is called to disable redrawing.
-	* 
+	*
 	* NOTE:  The code that actually works around the problem is in the
 	* callers of this method.
 	*/
@@ -1694,10 +1694,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.2
  */
 public void clear (int index, boolean all) {
@@ -1733,7 +1733,7 @@
  * attributes of the items are set to their default values. If the
  * tree was created with the <code>SWT.VIRTUAL</code> style, these
  * attributes are requested again as needed.
- * 
+ *
  * @param all <code>true</code> if all child items should be cleared
  * recursively, and <code>false</code> otherwise
  *
@@ -1741,10 +1741,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.2
  */
 public void clearAll (boolean all) {
@@ -1762,9 +1762,9 @@
 		}
 		if (redraw) OS.InvalidateRect (handle, null, true);
 	} else {
-		TVITEM tvItem = new TVITEM ();
-		tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;
-		clearAll (hItem, tvItem, all);
+	TVITEM tvItem = new TVITEM ();
+	tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM;
+	clearAll (hItem, tvItem, all);
 	}
 }
 
@@ -1772,7 +1772,7 @@
 	while (hItem != 0) {
 		clear (hItem, tvItem);
 		if (all) {
-			int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
+		int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
 			clearAll (hFirstItem, tvItem, all);
 		}
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
@@ -1795,7 +1795,7 @@
 			OS.SendMessage (hwndHeader, OS.HDM_GETITEM, i, hdItem);
 			width += hdItem.cxy;
 		}
-		RECT rect = new RECT ();					
+		RECT rect = new RECT ();
 		OS.GetWindowRect (hwndHeader, rect);
 		height += rect.bottom - rect.top;
 	}
@@ -1874,10 +1874,10 @@
 			OS.SendMessage (handle, OS.CCM_SETVERSION, 5, 0);
 		}
 	}
-		
+
 	/* Set the checkbox image list */
 	if ((style & SWT.CHECK) != 0) setCheckboxImageList ();
-	
+
 	/*
 	* Feature in Windows.  When the control is created,
 	* it does not use the default system font.  A new HFONT
@@ -1990,7 +1990,7 @@
 	}
 	System.arraycopy (columns, index, columns, index + 1, columnCount++ - index);
 	columns [index] = column;
-	
+
 	/*
 	* Bug in Windows.  For some reason, when HDM_INSERTITEM
 	* is used to insert an item into a header without text,
@@ -2007,14 +2007,14 @@
 	if ((column.style & SWT.RIGHT) == SWT.RIGHT) hdItem.fmt = OS.HDF_RIGHT;
 	OS.SendMessage (hwndHeader, OS.HDM_INSERTITEM, index, hdItem);
 	if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
-	
+
 	/* When the first column is created, hide the horizontal scroll bar */
 	if (columnCount == 1) {
 		scrollWidth = 0;
 		if ((style & SWT.H_SCROLL) != 0) {
-			int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
-			bits |= OS.TVS_NOHSCROLL;
-			OS.SetWindowLong (handle, OS.GWL_STYLE, bits);
+		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
+		bits |= OS.TVS_NOHSCROLL;
+		OS.SetWindowLong (handle, OS.GWL_STYLE, bits);
 		}
 		/*
 		* Bug in Windows.  When TVS_NOHSCROLL is set after items
@@ -2034,12 +2034,12 @@
 	setScrollWidth ();
 	updateImageList ();
 	updateScrollBar ();
-	
+
 	/* Redraw to hide the items when the first column is created */
 	if (columnCount == 1 && OS.SendMessage (handle, OS.TVM_GETCOUNT, 0, 0) != 0) {
 		OS.InvalidateRect (handle, null, true);
 	}
-	
+
 	/* Add the tool tip item for the header */
 	if (headerToolTipHandle != 0) {
 		RECT rect = new RECT ();
@@ -2125,8 +2125,8 @@
 	}
 	if (hFirstItem == 0) {
 		if (hInsertAfter == OS.TVI_FIRST || hInsertAfter == OS.TVI_LAST) {
-			hFirstIndexOf = hLastIndexOf = hFirstItem = hNewItem;
-			itemCount = lastIndexOf = 0;
+				hFirstIndexOf = hLastIndexOf = hFirstItem = hNewItem;
+				itemCount = lastIndexOf = 0;
 		}
 	}
 	if (hFirstItem == hFirstIndexOf && itemCount != -1) itemCount++;
@@ -2236,9 +2236,9 @@
 		super.windowClass (),
 		null,
 		newStyle,
-		rect.left, 
-		rect.top, 
-		rect.right - rect.left, 
+		rect.left,
+		rect.top,
+		rect.right - rect.left,
 		rect.bottom - rect.top,
 		parent.handle,
 		0,
@@ -2266,7 +2266,7 @@
 	if (OS.IsDBLocale) {
 		int /*long*/ hIMC = OS.ImmGetContext (handle);
 		OS.ImmAssociateContext (hwndParent, hIMC);
-		OS.ImmAssociateContext (hwndHeader, hIMC);		
+		OS.ImmAssociateContext (hwndHeader, hIMC);
 		OS.ImmReleaseContext (handle, hIMC);
 	}
 	//This code is intentionally commented
@@ -2519,7 +2519,7 @@
 		for (int i=orderIndex; i<newOrder.length; i++) {
 			newColumns [i - orderIndex] = columns [newOrder [i]];
 			newColumns [i - orderIndex].updateToolTip (newOrder [i]);
-		}	
+		}
 		for (int i=0; i<newColumns.length; i++) {
 			if (!newColumns [i].isDisposed ()) {
 				newColumns [i].sendEvent (SWT.Move);
@@ -2548,7 +2548,7 @@
 	* force the widget to be fully painted, turn off redraw, remove
 	* the item and validate the damage caused by the removing of
 	* the item.
-	* 
+	*
 	* NOTE: This fix is not necessary when double buffering and
 	* can cause problems for virtual trees due to the call to
 	* UpdateWindow() that flushes outstanding WM_PAINT events,
@@ -2583,7 +2583,7 @@
 	* multiple items are deleted, the tool tip flashes, showing
 	* each new item in the tool tip as it is scrolled into view.
 	* The fix is to hide tool tips when any item is deleted.
-	* 
+	*
 	* NOTE:  This only happens on Vista.
 	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -2590,7 +2590,7 @@
 		int /*long*/ hwndToolTip = OS.SendMessage (handle, OS.TVM_GETTOOLTIPS, 0, 0);
 		if (hwndToolTip != 0) OS.SendMessage (hwndToolTip, OS.TTM_POP, 0 ,0);
 	}
-	
+
 	shrink = ignoreShrink = true;
 	OS.SendMessage (handle, OS.TVM_DELETEITEM, 0, hItem);
 	ignoreShrink = false;
@@ -2648,7 +2648,7 @@
 void enableDrag (boolean enabled) {
 	int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 	if (enabled && hooks (SWT.DragDetect)) {
-		bits &= ~OS.TVS_DISABLEDRAGDROP;		
+		bits &= ~OS.TVS_DISABLEDRAGDROP;
 	} else {
 		bits |= OS.TVS_DISABLEDRAGDROP;
 	}
@@ -2852,7 +2852,7 @@
 		}
 		return 0;
 	}
-	int nextIndex = 0; 
+	int nextIndex = 0;
 	int /*long*/ hNextItem = hFirstItem;
 	while (hNextItem != 0 && nextIndex < index) {
 		hNextItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hNextItem);
@@ -2877,12 +2877,12 @@
  * Returns the width in pixels of a grid line.
  *
  * @return the width of a grid line in pixels
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int getGridLineWidth () {
@@ -2891,7 +2891,7 @@
 }
 
 /**
- * Returns the height of the receiver's header 
+ * Returns the height of the receiver's header
  *
  * @return the height of the header or zero if the header is not visible
  *
@@ -2899,13 +2899,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
- * @since 3.1 
+ *
+ * @since 3.1
  */
 public int getHeaderHeight () {
 	checkWidget ();
 	if (hwndHeader == 0) return 0;
-	RECT rect = new RECT ();					
+	RECT rect = new RECT ();
 	OS.GetWindowRect (hwndHeader, rect);
 	return rect.bottom - rect.top;
 }
@@ -2926,7 +2926,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public boolean getHeaderVisible () {
@@ -2974,13 +2974,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public TreeColumn getColumn (int index) {
@@ -3002,7 +3002,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int getColumnCount () {
@@ -3021,7 +3021,7 @@
  * </p><p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the current visual order of the receiver's items
@@ -3030,12 +3030,12 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.2
  */
 public int[] getColumnOrder () {
@@ -3057,7 +3057,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -3066,13 +3066,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see Tree#setColumnOrder(int[])
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public TreeColumn [] getColumns () {
@@ -3096,7 +3096,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public TreeItem getItem (int index) {
@@ -3137,8 +3137,8 @@
  * coordinate system of the receiver.
  * <p>
  * The item that is returned represents an item that could be selected by the user.
- * For example, if selection only occurs in items in the first column, then null is 
- * returned if the point is outside of the item. 
+ * For example, if selection only occurs in items in the first column, then null is
+ * returned if the point is outside of the item.
  * Note that the SWT.FULL_SELECTION style hint, which specifies the selection policy,
  * determines the extent of the selection.
  * </p>
@@ -3171,8 +3171,8 @@
 				if (hitTestSelection (lpht.hItem, lpht.x, lpht.y)) {
 					lpht.flags |= OS.TVHT_ONITEMICON | OS.TVHT_ONITEMLABEL;
 				}
-			}
 		}
+		}
 		if ((lpht.flags & flags) != 0) return _getItem (lpht.hItem);
 	}
 	return null;
@@ -3237,7 +3237,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items
@@ -3255,7 +3255,7 @@
 }
 
 TreeItem [] getItems (int /*long*/ hTreeItem) {
-	int count = 0; 
+	int count = 0;
 	int /*long*/ hItem = hTreeItem;
 	while (hItem != 0) {
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
@@ -3304,7 +3304,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public boolean getLinesVisible () {
@@ -3376,11 +3376,11 @@
 		if (index == count) break;
 		if (all) {
 			if (expanded) {
-				int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
-				if ((index = getSelection (hFirstItem, tvItem, selection, index, count, bigSelection, all)) == count) {
-					break;
-				}
+			int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
+			if ((index = getSelection (hFirstItem, tvItem, selection, index, count, bigSelection, all)) == count) {
+				break;
 			}
+			}
 			hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
 		} else {
 			hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);
@@ -3392,11 +3392,11 @@
 /**
  * Returns an array of <code>TreeItem</code>s that are currently
  * selected in the receiver. The order of the items is unspecified.
- * An empty array indicates that no items are selected. 
+ * An empty array indicates that no items are selected.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return an array representing the selection
  *
@@ -3536,15 +3536,15 @@
  * the receiver. The value may be null if no column shows
  * the sort indicator.
  *
- * @return the sort indicator 
+ * @return the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortColumn(TreeColumn)
- * 
+ *
  * @since 3.2
  */
 public TreeColumn getSortColumn () {
@@ -3570,8 +3570,8 @@
 }
 
 /**
- * Returns the direction of the sort indicator for the receiver. 
- * The value will be one of <code>UP</code>, <code>DOWN</code> 
+ * Returns the direction of the sort indicator for the receiver.
+ * The value will be one of <code>UP</code>, <code>DOWN</code>
  * or <code>NONE</code>.
  *
  * @return the sort direction
@@ -3580,9 +3580,9 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortDirection(int)
- * 
+ *
  * @since 3.2
  */
 public int getSortDirection () {
@@ -3595,13 +3595,13 @@
  * This item can change when items are expanded, collapsed, scrolled
  * or new items are added or removed.
  *
- * @return the item at the top of the receiver 
- * 
+ * @return the item at the top of the receiver
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public TreeItem getTopItem () {
@@ -3681,7 +3681,7 @@
 
 /**
  * Searches the receiver's list starting at the first column
- * (index 0) until a column is found that is equal to the 
+ * (index 0) until a column is found that is equal to the
  * argument, and returns the index of that column. If no column
  * is found, returns -1.
  *
@@ -3695,7 +3695,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int indexOf (TreeColumn column) {
@@ -3710,7 +3710,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -3725,7 +3725,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public int indexOf (TreeItem item) {
@@ -3760,7 +3760,7 @@
 			* not draw with the correct background until the mouse is
 			* moved.  The fix is to test for the selection colors and
 			* guess that the item is not selected.
-			* 
+			*
 			* NOTE: This code does not work when the foreground and
 			* background of the tree are set to the selection colors
 			* but this does not happen in a regular application.
@@ -3788,7 +3788,7 @@
 				* will not draw the entire row selected until the user
 				* moves the mouse.  The fix is to test for the selection
 				* colors and guess that the item is selected.
-				* 
+				*
 				* NOTE: This code does not work when the foreground and
 				* background of the tree are set to the selection colors
 				* but this does not happen in a regular application.
@@ -3810,9 +3810,9 @@
 		if (hItem != 0) {
 			RECT rect = new RECT ();
 			if (OS.TreeView_GetItemRect (handle, hItem, rect, false)) {
-				OS.InvalidateRect (handle, rect, true);
-			}
+			OS.InvalidateRect (handle, rect, true);
 		}
+		}
 	} else {
 		int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);
 		if (hItem != 0) {
@@ -3834,9 +3834,9 @@
 				}
 				if ((state & OS.TVIS_SELECTED) != 0) {
 					if (OS.TreeView_GetItemRect (handle, hItem, rect, false)) {
-						OS.InvalidateRect (handle, rect, true);
-					}
+					OS.InvalidateRect (handle, rect, true);
 				}
+				}
 				hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXTVISIBLE, hItem);
 				index++;
 			}
@@ -3910,7 +3910,7 @@
 	* messages.  This behavior is unwanted when the tree is being
 	* disposed.  The fix is to ignore NM_CUSTOMDRAW messages by
 	* clearing the custom draw flag.
-	* 
+	*
 	* NOTE: This only happens on Windows XP.
 	*/
 	customDraw = false;
@@ -3935,7 +3935,7 @@
 
 /**
  * Removes all of the items from the receiver.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3958,7 +3958,7 @@
 	int /*long*/ result = OS.SendMessage (handle, OS.TVM_DELETEITEM, 0, OS.TVI_ROOT);
 	ignoreShrink = false;
 	if (redraw) {
-		OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);	
+		OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 		OS.InvalidateRect (handle, null, true);
 	}
 	ignoreDeselect = ignoreSelect = false;
@@ -4002,7 +4002,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection, listener);	
+	eventTable.unhook (SWT.DefaultSelection, listener);
 }
 
 /**
@@ -4049,11 +4049,11 @@
 
 /**
  * Display a mark indicating the point at which an item will be inserted.
- * The drop insert item has a visual hint to show where a dragged item 
+ * The drop insert item has a visual hint to show where a dragged item
  * will be inserted when dropped on the tree.
- * 
+ *
  * @param item the insert item.  Null will clear the insertion mark.
- * @param before true places the insert mark above 'item'. false places 
+ * @param before true places the insert mark above 'item'. false places
  *	the insert mark below 'item'.
  *
  * @exception IllegalArgumentException <ul>
@@ -4170,7 +4170,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 /*public*/ void setItemHeight (int itemHeight) {
@@ -4195,7 +4195,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setLinesVisible (boolean show) {
@@ -4217,8 +4217,8 @@
 		OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
 		int state = (int)/*64*/OS.SendMessage (handle, OS.TVM_GETITEMSTATE, hItem, OS.TVIS_EXPANDED);
 		if ((state & OS.TVIS_EXPANDED) != 0) {
-			int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
-			select (hFirstItem, tvItem);
+		int /*long*/ hFirstItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CHILD, hItem);
+		select (hFirstItem, tvItem);
 		}
 
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_NEXT, hItem);
@@ -4346,8 +4346,8 @@
 	tvItem.stateMask = OS.TVIS_SELECTED;
 	int /*long*/ oldProc = OS.GetWindowLongPtr (handle, OS.GWLP_WNDPROC);
 	OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, TreeProc);
-	int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);
-	select (hItem, tvItem);
+		int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_ROOT, 0);
+		select (hItem, tvItem);
 	OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, oldProc);
 }
 
@@ -4508,7 +4508,7 @@
 	* is sent from SendMessage(), Windows GP's in the window proc for
 	* the tree.  The fix is to avoid calling the tree window proc and
 	* set the cursor for the tree outside of WM_SETCURSOR.
-	* 
+	*
 	* NOTE:  This code assumes that the default cursor for the tree
 	* is IDC_ARROW.
 	*/
@@ -4518,7 +4518,7 @@
 }
 
 /**
- * Sets the order that the items in the receiver should 
+ * Sets the order that the items in the receiver should
  * be displayed in to the given argument which is described
  * in terms of the zero-relative ordering of when the items
  * were added.
@@ -4533,12 +4533,12 @@
  *    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>
  *    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>
  * </ul>
- * 
+ *
  * @see Tree#getColumnOrder()
  * @see TreeColumn#getMoveable()
  * @see TreeColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.2
  */
 public void setColumnOrder (int [] order) {
@@ -4701,7 +4701,7 @@
 
 /**
  * Marks the receiver's header as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -4714,7 +4714,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setHeaderVisible (boolean show) {
@@ -4747,7 +4747,7 @@
 	* turn off redraw, the scroll bars are updated when
 	* items are added and removed.  The fix is to call
 	* the default window proc to stop all drawing.
-	* 
+	*
 	* Bug in Windows.  For some reason, when WM_SETREDRAW
 	* is used to turn redraw on for a tree and the tree
 	* contains no items, the last item in the tree does
@@ -4813,16 +4813,16 @@
 		OS.SetScrollInfo (hwndParent, OS.SB_VERT, info, true);
 	} else {
 		if ((style & SWT.H_SCROLL) != 0) {
-			OS.GetClientRect (hwndParent, rect);
-			OS.GetScrollInfo (hwndParent, OS.SB_HORZ, info);
-			info.nMax = width;
-			info.nPage = rect.right - rect.left + 1;
-			OS.SetScrollInfo (hwndParent, OS.SB_HORZ, info, true);
-			info.fMask = OS.SIF_POS;
-			OS.GetScrollInfo (hwndParent, OS.SB_HORZ, info);
-			left = info.nPos;
-		}
+		OS.GetClientRect (hwndParent, rect);
+		OS.GetScrollInfo (hwndParent, OS.SB_HORZ, info);
+		info.nMax = width;
+		info.nPage = rect.right - rect.left + 1;
+		OS.SetScrollInfo (hwndParent, OS.SB_HORZ, info, true);
+		info.fMask = OS.SIF_POS;
+		OS.GetScrollInfo (hwndParent, OS.SB_HORZ, info);
+		left = info.nPos;
 	}
+	}
 	if (horizontalBar != null) {
 		horizontalBar.setIncrement (INCREMENT);
 		horizontalBar.setPageIncrement (info.nPage);
@@ -4894,7 +4894,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSelection (TreeItem item) {
@@ -4933,7 +4933,7 @@
 		deselectAll();
 		return;
 	}
-		
+
 	/* Select/deselect the first item */
 	TreeItem item = items [0];
 	if (item != null) {
@@ -4940,7 +4940,7 @@
 		if (item.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
 		int /*long*/ hOldItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 		int /*long*/ hNewItem = hAnchor = item.handle;
-		
+
 		/*
 		* Bug in Windows.  When TVM_SELECTITEM is used to select and
 		* scroll an item to be visible and the client area of the tree
@@ -4949,7 +4949,7 @@
 		* instead of making the desired item visible.  The fix is to
 		* detect the case when the client area is too small and make
 		* the desired visible item be the top item in the tree.
-		* 
+		*
 		* Note that TVM_SELECTITEM when called with TVGN_FIRSTVISIBLE
 		* also requires the work around for scrolling.
 		*/
@@ -4970,7 +4970,7 @@
 			OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 			OS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);
 		}
-		
+
 		/*
 		* Feature in Windows.  When the old and new focused item
 		* are the same, Windows does not check to make sure that
@@ -5041,19 +5041,19 @@
 
 /**
  * Sets the column used by the sort indicator for the receiver. A null
- * value will clear the sort indicator.  The current sort column is cleared 
+ * value will clear the sort indicator.  The current sort column is cleared
  * before the new column is set.
  *
  * @param column the column used by the sort indicator or <code>null</code>
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortColumn (TreeColumn column) {
@@ -5069,16 +5069,16 @@
 }
 
 /**
- * Sets the direction of the sort indicator for the receiver. The value 
+ * Sets the direction of the sort indicator for the receiver. The value
  * can be one of <code>UP</code>, <code>DOWN</code> or <code>NONE</code>.
  *
- * @param direction the direction of the sort indicator 
+ * @param direction the direction of the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortDirection (int direction) {
@@ -5107,7 +5107,7 @@
  * </ul>
  *
  * @see Tree#getTopItem()
- * 
+ *
  * @since 2.1
  */
 public void setTopItem (TreeItem item) {
@@ -5260,26 +5260,26 @@
 	int index = indexOf (column);
 	if (index == -1) return;
 	if (0 <= index && index < columnCount) {
-		forceResize ();
-		RECT rect = new RECT ();
-		OS.GetClientRect (hwndParent, rect);
-		OS.MapWindowPoints (hwndParent, handle, rect, 2);
-		RECT headerRect = new RECT ();
-		OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, index, headerRect);
-		boolean scroll = headerRect.left < rect.left;
-		if (!scroll) {
-			int width = Math.min (rect.right - rect.left, headerRect.right - headerRect.left);
-			scroll = headerRect.left + width > rect.right;
+			forceResize ();
+			RECT rect = new RECT ();
+			OS.GetClientRect (hwndParent, rect);
+			OS.MapWindowPoints (hwndParent, handle, rect, 2);
+			RECT headerRect = new RECT ();
+			OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, index, headerRect);
+			boolean scroll = headerRect.left < rect.left;
+			if (!scroll) {
+				int width = Math.min (rect.right - rect.left, headerRect.right - headerRect.left);
+				scroll = headerRect.left + width > rect.right;
+			}
+			if (scroll) {
+				SCROLLINFO info = new SCROLLINFO ();
+				info.cbSize = SCROLLINFO.sizeof;
+				info.fMask = OS.SIF_POS;
+				info.nPos = Math.max (0, headerRect.left - Tree.INSET / 2);
+				OS.SetScrollInfo (hwndParent, OS.SB_HORZ, info, true);
+				setScrollWidth ();
+			}
 		}
-		if (scroll) {
-			SCROLLINFO info = new SCROLLINFO ();
-			info.cbSize = SCROLLINFO.sizeof;
-			info.fMask = OS.SIF_POS;
-			info.nPos = Math.max (0, headerRect.left - Tree.INSET / 2);
-			OS.SetScrollInfo (hwndParent, OS.SB_HORZ, info, true);
-			setScrollWidth ();
-		}
-	}
 }
 
 /**
@@ -5322,7 +5322,7 @@
 public void showSelection () {
 	checkWidget ();
 	int /*long*/ hItem = 0;
-	if ((style & SWT.SINGLE) != 0) {	
+	if ((style & SWT.SINGLE) != 0) {
 		hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 		if (hItem == 0) return;
 		int state = 0;
@@ -5440,28 +5440,28 @@
 	}
 	if (itemToolTipHandle == hdr.hwndFrom) {
 		if (toolTipText != null) return "";
-		int pos = OS.GetMessagePos ();
-		POINT pt = new POINT();
+			int pos = OS.GetMessagePos ();
+			POINT pt = new POINT();
 		OS.POINTSTOPOINT (pt, pos);
-		OS.ScreenToClient (handle, pt);
+			OS.ScreenToClient (handle, pt);
 		int [] index = new int [1];
 		TreeItem [] item = new TreeItem [1];
 		RECT [] cellRect = new RECT [1], itemRect = new RECT [1];
 		if (findCell (pt.x, pt.y, item, index, cellRect, itemRect)) {
-			String text = null;
+				String text = null;
 			if (index [0] == 0) {
 				text = item [0].text;
-			} else {
+							} else {
 				String[] strings = item [0].strings;
 				if (strings != null) text = strings [index [0]];
-			}
+							}
 			//TEMPORARY CODE
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 				if (isCustomToolTip ()) text = " ";
+						}
+				if (text != null) return text;
 			}
-			if (text != null) return text;
 		}
-	}
 	return super.toolTipText (hdr);
 }
 
@@ -5667,15 +5667,15 @@
 			} else {
 				OS.GetScrollInfo (handle, OS.SB_VERT, info);
 				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION(4, 10)) {
-					if (info.nPage == 0) {
-						SCROLLBARINFO psbi = new SCROLLBARINFO ();
-						psbi.cbSize = SCROLLBARINFO.sizeof;
-						OS.GetScrollBarInfo (handle, OS.OBJID_VSCROLL, psbi);
-						if ((psbi.rgstate [0] & OS.STATE_SYSTEM_INVISIBLE) != 0) {
-							info.nPage = info.nMax + 1;
-						}
+				if (info.nPage == 0) {
+					SCROLLBARINFO psbi = new SCROLLBARINFO ();
+					psbi.cbSize = SCROLLBARINFO.sizeof;
+					OS.GetScrollBarInfo (handle, OS.OBJID_VSCROLL, psbi);
+					if ((psbi.rgstate [0] & OS.STATE_SYSTEM_INVISIBLE) != 0) {
+						info.nPage = info.nMax + 1;
 					}
 				}
+				}
 				OS.SetScrollInfo (hwndParent, OS.SB_VERT, info, true);
 			}
 		}
@@ -5741,7 +5741,7 @@
 				* the header not notified and NM_RELEASEDCAPTURE is not
 				* sent.  The fix is to redraw the header when the capture
 				* changes to another control.
-				* 
+				*
 				* This does not happen on XP.
 				*/
 				if (OS.COMCTL32_MAJOR < 6) {
@@ -5768,7 +5768,7 @@
 				OS.MoveMemory (hdr, lParam, NMHDR.sizeof);
 				switch (hdr.code) {
 					case OS.TTN_SHOW:
-					case OS.TTN_POP: 
+					case OS.TTN_POP:
 					case OS.TTN_GETDISPINFOA:
 					case OS.TTN_GETDISPINFOW:
 						return OS.SendMessage (handle, msg, wParam, lParam);
@@ -5859,7 +5859,7 @@
 				* Update the nPos field to match the nTrackPos field
 				* so that the tree scrolls when the scroll bar of the
 				* parent is dragged.
-				* 
+				*
 				* NOTE: For some reason, this code is only necessary
 				* on Windows Vista.
 				*/
@@ -6014,12 +6014,13 @@
 						if (OS.COMCTL32_MAJOR >= 6) {
 							id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, hItem, 0);
 						}
-						OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+						OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 					}
 				}
 				tvItem.stateMask = OS.TVIS_SELECTED;
 				OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
-				if ((style & SWT.MULTI) != 0 && OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                                // <QFS/> Changed to getDisplay().GetKeyState
+				if ((style & SWT.MULTI) != 0 && getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 					if ((tvItem.state & OS.TVIS_SELECTED) != 0) {
 						tvItem.state &= ~OS.TVIS_SELECTED;
 					} else {
@@ -6133,7 +6134,8 @@
 			*/
 			return LRESULT.ZERO;
 		case OS.VK_ADD:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				if (hwndHeader != 0) {
 					TreeColumn [] newColumns = new TreeColumn [columnCount];
 					System.arraycopy (columns, 0, newColumns, 0, columnCount);
@@ -6155,7 +6157,8 @@
 			OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
 			if (itemToolTipHandle != 0) OS.ShowWindow (itemToolTipHandle, OS.SW_HIDE);
 			if ((style & SWT.SINGLE) != 0) break;
-			if (OS.GetKeyState (OS.VK_SHIFT) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) {
 				int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 				if (hItem != 0) {
 					if (hAnchor == 0) hAnchor = hItem;
@@ -6166,7 +6169,7 @@
 					TVITEM tvItem = new TVITEM ();
 					tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_STATE;
 					tvItem.stateMask = OS.TVIS_SELECTED;
-					int /*long*/ hDeselectItem = hItem;					
+					int /*long*/ hDeselectItem = hItem;
 					RECT rect1 = new RECT ();
 					if (!OS.TreeView_GetItemRect (handle, hAnchor, rect1, false)) {
 						hAnchor = hItem;
@@ -6201,7 +6204,8 @@
 					return new LRESULT (code);
 				}
 			}
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				int /*long*/ hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 				if (hItem != 0) {
 					TVITEM tvItem = new TVITEM ();
@@ -6228,7 +6232,7 @@
 								hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);
 							}
 							break;
-						case OS.VK_NEXT:			
+						case OS.VK_NEXT:
 							RECT rect = new RECT (), clientRect = new RECT ();
 							OS.GetClientRect (handle, clientRect);
 							hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_FIRSTVISIBLE, 0);
@@ -6302,7 +6306,7 @@
 	* the image is drawn is not erased before it is drawn.
 	* This means that the image gets darker each time.
 	* The fix is to redraw the selection.
-	* 
+	*
 	* Feature in Windows.  When multiple item have
 	* the TVIS_SELECTED state, Windows redraws only
 	* the focused item in the color used to show the
@@ -6348,7 +6352,7 @@
 				OS.SetFocus (handle);
 				TVITEM tvItem = new TVITEM ();
 				tvItem.hItem = lpht.hItem;
-				tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;	
+				tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;
 				tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;
 				OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 				int state = tvItem.state >> 12;
@@ -6359,12 +6363,12 @@
 				}
 				tvItem.state = state << 12;
 				OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
-				if (!OS.IsWinCE) {	
+				if (!OS.IsWinCE) {
 					int /*long*/ id = tvItem.hItem;
 					if (OS.COMCTL32_MAJOR >= 6) {
 						id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);
 					}
-					OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+					OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 				}
 				Event event = new Event ();
 				event.item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -6497,7 +6501,7 @@
 		}
 		return new LRESULT (code);
 	}
-	
+
 	/* Look for check/uncheck */
 	if ((style & SWT.CHECK) != 0) {
 		if ((lpht.flags & OS.TVHT_ONITEMSTATEICON) != 0) {
@@ -6515,7 +6519,7 @@
 			OS.SetFocus (handle);
 			TVITEM tvItem = new TVITEM ();
 			tvItem.hItem = lpht.hItem;
-			tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;	
+			tvItem.mask = OS.TVIF_HANDLE | OS.TVIF_PARAM | OS.TVIF_STATE;
 			tvItem.stateMask = OS.TVIS_STATEIMAGEMASK;
 			OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 			int state = tvItem.state >> 12;
@@ -6531,7 +6535,7 @@
 				if (OS.COMCTL32_MAJOR >= 6) {
 					id = OS.SendMessage (handle, OS.TVM_MAPHTREEITEMTOACCID, tvItem.hItem, 0);
 				}
-				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);	
+				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, (int)/*64*/id);
 			}
 			Event event = new Event ();
 			event.item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -6540,7 +6544,7 @@
 			return LRESULT.ZERO;
 		}
 	}
-	
+
 	/*
 	* Feature in Windows.  When the tree has the style
 	* TVS_FULLROWSELECT, the background color for the
@@ -6596,7 +6600,7 @@
 		OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 		hittestSelected = (tvItem.state & OS.TVIS_SELECTED) != 0;
 	}
-	
+
 	/* Get the selected state of the last selected item */
 	int /*long*/ hOldItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 	if ((style & SWT.MULTI) != 0) {
@@ -6621,7 +6625,7 @@
 			* focus from WM_MOUSEACTIVATE of the shell.  The fix is to
 			* force the WM_UPDATEUISTATE to be sent before disabling
 			* the drawing.
-			* 
+			*
 			* NOTE:  Any redraw of a parent (or sibling) will be dispatched
 			* during the modal drag detect loop.  This code only fixes the
 			* case where the tree causes a redraw from WM_UPDATEUISTATE.
@@ -6632,8 +6636,8 @@
 			if ((uiState & OS.UISF_HIDEFOCUS) != 0) {
 				OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
 			}
-			OS.UpdateWindow (handle);
-			OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);
+				OS.UpdateWindow (handle);
+				OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);
 		} else {
 			deselectAll ();
 		}
@@ -6657,14 +6661,14 @@
 	}
 	int /*long*/ hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
 	if (fakeSelection) {
-		if (hOldItem == 0 || (hNewItem == hOldItem && lpht.hItem != hOldItem)) {
-			OS.SendMessage (handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, lpht.hItem);
-			hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
+				if (hOldItem == 0 || (hNewItem == hOldItem && lpht.hItem != hOldItem)) {
+				OS.SendMessage (handle, OS.TVM_SELECTITEM, OS.TVGN_CARET, lpht.hItem);
+				hNewItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, OS.TVGN_CARET, 0);
+			}
+				if (!dragStarted && (state & DRAG_DETECT) != 0 && hooks (SWT.DragDetect)) {
+				dragStarted = dragDetect (handle, lpht.x, lpht.y, false, null, null);
+			}
 		}
-		if (!dragStarted && (state & DRAG_DETECT) != 0 && hooks (SWT.DragDetect)) {
-			dragStarted = dragDetect (handle, lpht.x, lpht.y, false, null, null);
-		}
-	}
 	ignoreDeselect = ignoreSelect = false;
 	hSelect = 0;
 	if (dragStarted) {
@@ -6690,10 +6694,10 @@
 			OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
 		}
 	}
-	
+
 	/* Reselect the last item that was unselected */
 	if ((style & SWT.MULTI) != 0) {
-		
+
 		/* Check for CONTROL and reselect the last item */
 		if (hittestSelected || (wParam & OS.MK_CONTROL) != 0) {
 			if (hOldItem == hNewItem && hOldItem == lpht.hItem) {
@@ -6715,17 +6719,17 @@
 					}
 				}
 			}
-			RECT rect1 = new RECT (), rect2 = new RECT ();
-			boolean fItemRect = (style & SWT.FULL_SELECTION) == 0;
-			if (hooks (SWT.EraseItem) || hooks (SWT.PaintItem)) fItemRect = false;
-			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) fItemRect = false;
-			OS.TreeView_GetItemRect (handle, hOldItem, rect1, fItemRect);
-			OS.TreeView_GetItemRect (handle, hNewItem, rect2, fItemRect);
-			OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
-			OS.InvalidateRect (handle, rect1, true);
-			OS.InvalidateRect (handle, rect2, true);
-			OS.UpdateWindow (handle);
-		}
+				RECT rect1 = new RECT (), rect2 = new RECT ();
+				boolean fItemRect = (style & SWT.FULL_SELECTION) == 0;
+				if (hooks (SWT.EraseItem) || hooks (SWT.PaintItem)) fItemRect = false;
+				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) fItemRect = false;
+				OS.TreeView_GetItemRect (handle, hOldItem, rect1, fItemRect);
+				OS.TreeView_GetItemRect (handle, hNewItem, rect2, fItemRect);
+				OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
+				OS.InvalidateRect (handle, rect1, true);
+				OS.InvalidateRect (handle, rect2, true);
+				OS.UpdateWindow (handle);
+			}
 
 		/* Check for SHIFT or normal select and deselect/reselect items */
 		if ((wParam & OS.MK_CONTROL) == 0) {
@@ -6755,15 +6759,14 @@
 					if (OS.TreeView_GetItemRect (handle, hAnchor, rect1, false)) {
 						RECT rect2 = new RECT ();
 						if (OS.TreeView_GetItemRect (handle, hNewItem, rect2, false)) {
-							int flags = rect1.top < rect2.top ? OS.TVGN_NEXTVISIBLE : OS.TVGN_PREVIOUSVISIBLE;			
-							tvItem.state = OS.TVIS_SELECTED;
+						int flags = rect1.top < rect2.top ? OS.TVGN_NEXTVISIBLE : OS.TVGN_PREVIOUSVISIBLE;
+						tvItem.state = OS.TVIS_SELECTED;
 							int /*long*/ hItem = tvItem.hItem = hAnchor;
+						OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
+						while (hItem != hNewItem) {
+							tvItem.hItem = hItem;
 							OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
-							while (hItem != hNewItem) {
-								tvItem.hItem = hItem;
-								OS.SendMessage (handle, OS.TVM_SETITEM, 0, tvItem);
-								hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, flags, hItem);
-							}
+							hItem = OS.SendMessage (handle, OS.TVM_GETNEXTITEM, flags, hItem);
 						}
 					}
 				}
@@ -6770,8 +6773,9 @@
 			}
 		}
 	}
+	}
 	if ((wParam & OS.MK_SHIFT) == 0) hAnchor = hNewItem;
-			
+
 	/* Issue notification */
 	if (!gestureCompleted) {
 		tvItem.hItem = hNewItem;
@@ -6782,7 +6786,7 @@
 		sendSelectionEvent (SWT.Selection, event, false);
 	}
 	gestureCompleted = false;
-	
+
 	/*
 	* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,
 	* the widget starts a modal loop to determine if the user wants
@@ -6836,17 +6840,17 @@
 						OS.ShowWindow (itemToolTipHandle, OS.SW_HIDE);
 					}
 				}
-				TOOLINFO lpti = new TOOLINFO ();
-				lpti.cbSize = TOOLINFO.sizeof;
-				lpti.hwnd = handle;
-				lpti.uId = handle;
-				lpti.uFlags = OS.TTF_SUBCLASS | OS.TTF_TRANSPARENT;
+							TOOLINFO lpti = new TOOLINFO ();
+							lpti.cbSize = TOOLINFO.sizeof;
+							lpti.hwnd = handle;
+							lpti.uId = handle;
+							lpti.uFlags = OS.TTF_SUBCLASS | OS.TTF_TRANSPARENT;
 				lpti.left = cellRect [0].left;
 				lpti.top = cellRect [0].top;
 				lpti.right = cellRect [0].right;
 				lpti.bottom = cellRect [0].bottom;
-				OS.SendMessage (itemToolTipHandle, OS.TTM_NEWTOOLRECT, 0, lpti);
-			}
+							OS.SendMessage (itemToolTipHandle, OS.TTM_NEWTOOLRECT, 0, lpti);
+						}
 		}
 	}
 	return result;
@@ -6886,7 +6890,7 @@
 	*/
 //	if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	if (OS.GetFocus () != handle) OS.SetFocus (handle);
-	
+
 	/*
 	* Feature in Windows.  When the user selects a tree item
 	* with the right mouse button, the item remains selected
@@ -6910,7 +6914,7 @@
 			if (hooks (SWT.MeasureItem)) {
 				fakeSelection = hitTestSelection (lpht.hItem, lpht.x, lpht.y);
 			} else {
-				int flags = OS.TVHT_ONITEMICON | OS.TVHT_ONITEMLABEL;
+		int flags = OS.TVHT_ONITEMICON | OS.TVHT_ONITEMLABEL;
 				fakeSelection = (lpht.flags & flags) != 0;
 			}
 		}
@@ -6954,8 +6958,8 @@
 		boolean doubleBuffer = true;
 		if (explorerTheme) {
 			int exStyle = (int)/*64*/OS.SendMessage (handle, OS.TVM_GETEXTENDEDSTYLE, 0, 0);
-			if ((exStyle & OS.TVS_EX_DOUBLEBUFFER) != 0) doubleBuffer = false;
-		}
+				if ((exStyle & OS.TVS_EX_DOUBLEBUFFER) != 0) doubleBuffer = false;
+			}
 		if (doubleBuffer) {
 			GC gc = null;
 			int /*long*/ paintDC = 0;
@@ -7060,7 +7064,7 @@
 	* the image is drawn is not erased before it is drawn.
 	* This means that the image gets darker each time.
 	* The fix is to redraw the selection.
-	* 
+	*
 	* Feature in Windows.  When multiple item have
 	* the TVIS_SELECTED state, Windows redraws only
 	* the focused item in the color used to show the
@@ -7119,7 +7123,7 @@
 	* that is not inside the client area, Windows segment
 	* faults.  The fix is to call the default window proc
 	* rather than the default tree proc.
-	* 
+	*
 	* NOTE:  This problem is intermittent and happens on
 	* Windows Vista running under the theme manager.
 	*/
@@ -7150,8 +7154,8 @@
 	* redraw the entire tree.
 	*/
 	if (explorerTheme && (style & SWT.FULL_SELECTION) != 0) {
-		OS.InvalidateRect (handle, null, false);
-	}
+				OS.InvalidateRect (handle, null, false);
+			}
 	if (ignoreResize) return null;
 	return super.WM_SIZE (wParam, lParam);
 }
@@ -7270,7 +7274,7 @@
 }
 
 LRESULT wmNotifyChild (NMHDR hdr, int /*long*/ wParam, int /*long*/ lParam) {
-	switch (hdr.code) {
+			switch (hdr.code) {
 		case OS.TVN_GETDISPINFOA:
 		case OS.TVN_GETDISPINFOW: {
 			NMTVDISPINFO lptvdi = new NMTVDISPINFO ();
@@ -7281,7 +7285,7 @@
 				* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before
 				* TVM_INSERTITEM returns and before the item is added to
 				* the items array.  The fix is to check for null.
-				* 
+				*
 				* NOTE: This only happens on XP with the version 6.00 of
 				* COMCTL32.DLL.
 				*/
@@ -7301,22 +7305,22 @@
 							checkVisible = false;
 						}
 					}
-				}
+					}
 				if (checkVisible) {
 					if (!getDrawing () || !OS.IsWindowVisible (handle)) break;
 					RECT itemRect = new RECT ();
 					if (!OS.TreeView_GetItemRect (handle, lptvdi.hItem, itemRect, false)) {
-						break;
-					}
-					RECT rect = new RECT ();
+					break;
+				}
+						RECT rect = new RECT ();
 					OS.GetClientRect (handle, rect);
 					if (!OS.IntersectRect (rect, rect, itemRect)) break;
 					if (ignoreShrink) {
 						OS.InvalidateRect (handle, rect, true);
-						break;
+								break;
+							}
 					}
 				}
-			}
 			if (items == null) break;
 			/*
 			* Bug in Windows.  If the lParam field of TVITEM
@@ -7334,24 +7338,24 @@
 					tvItem.hItem = lptvdi.hItem;
 					OS.SendMessage (handle, OS.TVM_GETITEM, 0, tvItem);
 					id = (int)/*64*/tvItem.lParam;
-				}
 			}
+		}
 			TreeItem item = _getItem (lptvdi.hItem, id);
-			/*
+		/*
 			* Feature in Windows.  When a new tree item is inserted
 			* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before
 			* TVM_INSERTITEM returns and before the item is added to
 			* the items array.  The fix is to check for null.
-			* 
+			*
 			* NOTE: This only happens on XP with the version 6.00 of
 			* COMCTL32.DLL.
-			* 
+			*
 			* Feature in Windows.  When TVM_DELETEITEM is called with
 			* TVI_ROOT to remove all items from a tree, under certain
 			* circumstances, the tree sends TVN_GETDISPINFO for items
 			* that are about to be disposed.  The fix is to check for
 			* disposed items.
-			*/
+		*/
 			if (item == null) break;
 			if (item.isDisposed ()) break;
 			if (!item.cached) {
@@ -7414,7 +7418,7 @@
 				}
 			}
 			NMTVCUSTOMDRAW nmcd = new NMTVCUSTOMDRAW ();
-			OS.MoveMemory (nmcd, lParam, NMTVCUSTOMDRAW.sizeof);		
+			OS.MoveMemory (nmcd, lParam, NMTVCUSTOMDRAW.sizeof);
 			switch (nmcd.dwDrawStage) {
 				case OS.CDDS_PREPAINT: return CDDS_PREPAINT (nmcd, wParam, lParam);
 				case OS.CDDS_ITEMPREPAINT: return CDDS_ITEMPREPAINT (nmcd, wParam, lParam);
@@ -7469,7 +7473,7 @@
 						return LRESULT.ONE;
 					}
 				}
-			}			
+			}
 			break;
 		}
 		case OS.TVN_SELCHANGINGA:
@@ -7563,7 +7567,7 @@
 				* is sent from within TVM_DELETEITEM for the tree item
 				* being destroyed.  By the time the message is sent,
 				* the item has already been removed from the list of
-				* items.  The fix is to check for null. 
+				* items.  The fix is to check for null.
 				*/
 				if (items == null) break;
 				TreeItem item = _getItem (tvItem.hItem, (int)/*64*/tvItem.lParam);
@@ -7666,7 +7670,7 @@
 			break;
 		}
 		case OS.NM_RECOGNIZEGESTURE: {
-			/* 
+			/*
 			* Feature in Pocket PC.  The tree and table controls detect the tap
 			* and hold gesture by default. They send a GN_CONTEXTMENU message to show
 			* the popup menu.  This default behaviour is unwanted on Pocket PC 2002
@@ -7723,153 +7727,153 @@
 			TreeColumn column = columns [phdn.iItem];
 			if (column != null && !column.getResizable ()) {
 				return LRESULT.ONE;
+				}
+				ignoreColumnMove = true;
+				switch (hdr.code) {
+					case OS.HDN_DIVIDERDBLCLICKW:
+					case OS.HDN_DIVIDERDBLCLICKA:
+						if (column != null) column.pack ();
+				}
+				break;
 			}
-			ignoreColumnMove = true;
-			switch (hdr.code) {
-				case OS.HDN_DIVIDERDBLCLICKW:
-				case OS.HDN_DIVIDERDBLCLICKA:
-					if (column != null) column.pack ();
-			}
-			break;
-		}
-		case OS.NM_RELEASEDCAPTURE: {
-			if (!ignoreColumnMove) {
+			case OS.NM_RELEASEDCAPTURE: {
+				if (!ignoreColumnMove) {
 				for (int i=0; i<columnCount; i++) {
-					TreeColumn column = columns [i];
-					column.updateToolTip (i);
+						TreeColumn column = columns [i];
+						column.updateToolTip (i);
+					}
+					updateImageList ();
 				}
-				updateImageList ();
+				ignoreColumnMove = false;
+				break;
 			}
-			ignoreColumnMove = false;
-			break;
-		}
-		case OS.HDN_BEGINDRAG: {
-			if (ignoreColumnMove) return LRESULT.ONE;
-			NMHEADER phdn = new NMHEADER ();
-			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
-			if (phdn.iItem != -1) {
-				TreeColumn column = columns [phdn.iItem];
-				if (column != null && !column.getMoveable ()) {
-					ignoreColumnMove = true;
-					return LRESULT.ONE;
+			case OS.HDN_BEGINDRAG: {
+				if (ignoreColumnMove) return LRESULT.ONE;
+				NMHEADER phdn = new NMHEADER ();
+				OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
+				if (phdn.iItem != -1) {
+					TreeColumn column = columns [phdn.iItem];
+					if (column != null && !column.getMoveable ()) {
+						ignoreColumnMove = true;
+						return LRESULT.ONE;
+					}
 				}
+				break;
 			}
-			break;
-		}
-		case OS.HDN_ENDDRAG: {
-			NMHEADER phdn = new NMHEADER ();
-			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
-			if (phdn.iItem != -1 && phdn.pitem != 0) {
-				HDITEM pitem = new HDITEM ();
-				OS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);
-				if ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {
+			case OS.HDN_ENDDRAG: {
+				NMHEADER phdn = new NMHEADER ();
+				OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
+				if (phdn.iItem != -1 && phdn.pitem != 0) {
+					HDITEM pitem = new HDITEM ();
+					OS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);
+					if ((pitem.mask & OS.HDI_ORDER) != 0 && pitem.iOrder != -1) {
 					int [] order = new int [columnCount];
 					OS.SendMessage (hwndHeader, OS.HDM_GETORDERARRAY, columnCount, order);
-					int index = 0;
-					while (index < order.length) {
-					 	if (order [index] == phdn.iItem) break;
-						index++;
-					}
-					if (index == order.length) index = 0;
-					if (index == pitem.iOrder) break;
-					int start = Math.min (index, pitem.iOrder);
-					int end = Math.max (index, pitem.iOrder);
-					RECT rect = new RECT (), headerRect = new RECT ();
-					OS.GetClientRect (handle, rect);
-					OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, order [start], headerRect);
-					rect.left = Math.max (rect.left, headerRect.left);
-					OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, order [end], headerRect);
-					rect.right = Math.min (rect.right, headerRect.right);
-					OS.InvalidateRect (handle, rect, true);
-					ignoreColumnMove = false;
-					for (int i=start; i<=end; i++) {
-						TreeColumn column = columns [order [i]];
-						if (!column.isDisposed ()) {
-							column.postEvent (SWT.Move);
+						int index = 0;
+						while (index < order.length) {
+						 	if (order [index] == phdn.iItem) break;
+							index++;
 						}
+						if (index == order.length) index = 0;
+						if (index == pitem.iOrder) break;
+						int start = Math.min (index, pitem.iOrder);
+						int end = Math.max (index, pitem.iOrder);
+						RECT rect = new RECT (), headerRect = new RECT ();
+						OS.GetClientRect (handle, rect);
+						OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, order [start], headerRect);
+						rect.left = Math.max (rect.left, headerRect.left);
+						OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, order [end], headerRect);
+						rect.right = Math.min (rect.right, headerRect.right);
+						OS.InvalidateRect (handle, rect, true);
+						ignoreColumnMove = false;
+						for (int i=start; i<=end; i++) {
+							TreeColumn column = columns [order [i]];
+							if (!column.isDisposed ()) {
+								column.postEvent (SWT.Move);
+							}
+						}
 					}
 				}
+				break;
 			}
-			break;
-		}
-		case OS.HDN_ITEMCHANGINGW:
-		case OS.HDN_ITEMCHANGINGA: {
-			NMHEADER phdn = new NMHEADER ();
-			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
-			if (phdn.pitem != 0) {
-				HDITEM newItem = new HDITEM ();
-				OS.MoveMemory (newItem, phdn.pitem, HDITEM.sizeof);
-				if ((newItem.mask & OS.HDI_WIDTH) != 0) {
-					RECT rect = new RECT ();
-					OS.GetClientRect (handle, rect);
-					HDITEM oldItem = new HDITEM ();
-					oldItem.mask = OS.HDI_WIDTH;
-					OS.SendMessage (hwndHeader, OS.HDM_GETITEM, phdn.iItem, oldItem);
-					int deltaX = newItem.cxy - oldItem.cxy;
-					RECT headerRect = new RECT ();
-					OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, phdn.iItem, headerRect);
-					int gridWidth = linesVisible ? GRID_WIDTH : 0;
-					rect.left = headerRect.right - gridWidth;
-					int newX = rect.left + deltaX;
-					rect.right = Math.max (rect.right, rect.left + Math.abs (deltaX));
+			case OS.HDN_ITEMCHANGINGW:
+			case OS.HDN_ITEMCHANGINGA: {
+				NMHEADER phdn = new NMHEADER ();
+				OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
+				if (phdn.pitem != 0) {
+					HDITEM newItem = new HDITEM ();
+					OS.MoveMemory (newItem, phdn.pitem, HDITEM.sizeof);
+					if ((newItem.mask & OS.HDI_WIDTH) != 0) {
+						RECT rect = new RECT ();
+						OS.GetClientRect (handle, rect);
+						HDITEM oldItem = new HDITEM ();
+						oldItem.mask = OS.HDI_WIDTH;
+						OS.SendMessage (hwndHeader, OS.HDM_GETITEM, phdn.iItem, oldItem);
+						int deltaX = newItem.cxy - oldItem.cxy;
+						RECT headerRect = new RECT ();
+						OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, phdn.iItem, headerRect);
+						int gridWidth = linesVisible ? GRID_WIDTH : 0;
+						rect.left = headerRect.right - gridWidth;
+						int newX = rect.left + deltaX;
+						rect.right = Math.max (rect.right, rect.left + Math.abs (deltaX));
 					if (explorerTheme || (findImageControl () != null || hooks (SWT.MeasureItem) || hooks (SWT.EraseItem) || hooks (SWT.PaintItem))) {
 						rect.left -= OS.GetSystemMetrics (OS.SM_CXFOCUSBORDER);
-						OS.InvalidateRect (handle, rect, true);
-						OS.OffsetRect (rect, deltaX, 0);
-						OS.InvalidateRect (handle, rect, true);
-					} else {
-						int flags = OS.SW_INVALIDATE | OS.SW_ERASE;
-						OS.ScrollWindowEx (handle, deltaX, 0, rect, null, 0, null, flags);
+							OS.InvalidateRect (handle, rect, true);
+							OS.OffsetRect (rect, deltaX, 0);
+							OS.InvalidateRect (handle, rect, true);
+						} else {
+							int flags = OS.SW_INVALIDATE | OS.SW_ERASE;
+							OS.ScrollWindowEx (handle, deltaX, 0, rect, null, 0, null, flags);
+						}
+						if (OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, phdn.iItem, 0) != 0) {
+							rect.left = headerRect.left;
+							rect.right = newX;
+							OS.InvalidateRect (handle, rect, true);
+						}
+						setScrollWidth ();
 					}
-					if (OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, phdn.iItem, 0) != 0) {
-						rect.left = headerRect.left;
-						rect.right = newX;
-						OS.InvalidateRect (handle, rect, true);
-					}
-					setScrollWidth ();
 				}
+				break;
 			}
-			break;
-		}
-		case OS.HDN_ITEMCHANGEDW:
-		case OS.HDN_ITEMCHANGEDA: {
-			NMHEADER phdn = new NMHEADER ();
-			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
-			if (phdn.pitem != 0) {
-				HDITEM pitem = new HDITEM ();
-				OS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);
-				if ((pitem.mask & OS.HDI_WIDTH) != 0) {
-					if (ignoreColumnMove) {
-						if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
-							int flags = OS.RDW_UPDATENOW | OS.RDW_ALLCHILDREN;
-							OS.RedrawWindow (handle, null, 0, flags);
-						} else {
-							if ((style & SWT.DOUBLE_BUFFERED) == 0) {
-								int oldStyle = style;
-								style |= SWT.DOUBLE_BUFFERED;
-								OS.UpdateWindow (handle);
-								style = oldStyle;
+			case OS.HDN_ITEMCHANGEDW:
+			case OS.HDN_ITEMCHANGEDA: {
+				NMHEADER phdn = new NMHEADER ();
+				OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
+				if (phdn.pitem != 0) {
+					HDITEM pitem = new HDITEM ();
+					OS.MoveMemory (pitem, phdn.pitem, HDITEM.sizeof);
+					if ((pitem.mask & OS.HDI_WIDTH) != 0) {
+						if (ignoreColumnMove) {
+							if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
+								int flags = OS.RDW_UPDATENOW | OS.RDW_ALLCHILDREN;
+								OS.RedrawWindow (handle, null, 0, flags);
+							} else {
+								if ((style & SWT.DOUBLE_BUFFERED) == 0) {
+									int oldStyle = style;
+									style |= SWT.DOUBLE_BUFFERED;
+									OS.UpdateWindow (handle);
+									style = oldStyle;
+								}
 							}
 						}
-					}
-					TreeColumn column = columns [phdn.iItem];
-					if (column != null) {
-						column.updateToolTip (phdn.iItem);
-						column.sendEvent (SWT.Resize);
-						if (isDisposed ()) return LRESULT.ZERO;	
+						TreeColumn column = columns [phdn.iItem];
+						if (column != null) {
+							column.updateToolTip (phdn.iItem);
+							column.sendEvent (SWT.Resize);
+							if (isDisposed ()) return LRESULT.ZERO;
 						TreeColumn [] newColumns = new TreeColumn [columnCount];
 						System.arraycopy (columns, 0, newColumns, 0, columnCount);
 						int [] order = new int [columnCount];
 						OS.SendMessage (hwndHeader, OS.HDM_GETORDERARRAY, columnCount, order);
-						boolean moved = false;
+							boolean moved = false;
 						for (int i=0; i<columnCount; i++) {
-							TreeColumn nextColumn = newColumns [order [i]];
-							if (moved && !nextColumn.isDisposed ()) {
-								nextColumn.updateToolTip (order [i]);
-								nextColumn.sendEvent (SWT.Move);
-							}
+								TreeColumn nextColumn = newColumns [order [i]];
+								if (moved && !nextColumn.isDisposed ()) {
+									nextColumn.updateToolTip (order [i]);
+									nextColumn.sendEvent (SWT.Move);
+								}
 							if (nextColumn == column) moved = true;
-						}
+		}
 					}
 				}
 				setScrollWidth ();
@@ -7883,10 +7887,10 @@
 			TreeColumn column = columns [phdn.iItem];
 			if (column != null) {
 				column.sendSelectionEvent (SWT.Selection);
+				}
+			break;
 			}
-			break;
-		}
-		case OS.HDN_ITEMDBLCLICKW:      
+		case OS.HDN_ITEMDBLCLICKW:
 		case OS.HDN_ITEMDBLCLICKA: {
 			NMHEADER phdn = new NMHEADER ();
 			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
@@ -7896,7 +7900,7 @@
 			}
 			break;
 		}
-	}
+					}
 	return null;
 }
 
@@ -7907,7 +7911,7 @@
 			NMTTCUSTOMDRAW nmcd = new NMTTCUSTOMDRAW ();
 			OS.MoveMemory (nmcd, lParam, NMTTCUSTOMDRAW.sizeof);
 			return wmNotifyToolTip (nmcd, lParam);
-		}
+				}
 		case OS.TTN_SHOW: {
 			LRESULT result = super.wmNotify (hdr, wParam, lParam);
 			if (result != null) return result;
@@ -7927,10 +7931,10 @@
 				if (isCustomToolTip ()) flags &= ~OS.SWP_NOSIZE;
 				SetWindowPos (itemToolTipHandle, 0, toolRect.left, toolRect.top, width, height, flags);
 				return LRESULT.ONE;
+						}
+			return result;
+				}
 			}
-			return result;
-		}
-	}
 	return null;
 }
 
@@ -7946,9 +7950,9 @@
 					OS.SetTextColor (nmcd.hdc, OS.GetSysColor (OS.COLOR_INFOBK));
 				}
 				return new LRESULT (OS.CDRF_NOTIFYPOSTPAINT | OS.CDRF_NEWFONT);
+		}
+			break;
 			}
-			break;
-		}
 		case OS.CDDS_POSTPAINT: {
 			if (!OS.IsWinCE && OS.WIN32_VERSION < OS.VERSION (6, 0)) {
 				OS.SetTextColor (nmcd.hdc, OS.GetSysColor (OS.COLOR_INFOTEXT));
@@ -7978,7 +7982,7 @@
 								drawForeground = (event.detail & SWT.FOREGROUND) != 0;
 							} else {
 								drawForeground = false;
-							}
+			}
 						}
 						if (drawForeground) {
 							int nSavedDC = OS.SaveDC (nmcd.hdc);
@@ -8002,11 +8006,11 @@
 									Rectangle rect = image.getBounds ();
 									gc.drawImage (image, rect.x, rect.y, rect.width, rect.height, x, imageRect.top, size.x, size.y);
 									x += INSET + (index [0] == 0 ? 1 : 0);
-								}
+					}
 								x += size.x;
 							} else {
 								x += INSET;
-							}
+				}
 							String string = item [0].getText (index [0]);
 							if (string != null) {
 								int flags = OS.DT_NOPREFIX | OS.DT_SINGLELINE | OS.DT_VCENTER;
@@ -8014,27 +8018,27 @@
 								if (column != null) {
 									if ((column.style & SWT.CENTER) != 0) flags |= OS.DT_CENTER;
 									if ((column.style & SWT.RIGHT) != 0) flags |= OS.DT_RIGHT;
-								}
+			}
 								TCHAR buffer = new TCHAR (getCodePage (), string, false);
 								RECT textRect = new RECT ();
 								OS.SetRect (textRect, x, cellRect [0].top, cellRect [0].right, cellRect [0].bottom);
 								OS.DrawText (nmcd.hdc, buffer, buffer.length (), textRect, flags);
-							}
+		}
 							gc.dispose ();
 							OS.RestoreDC (nmcd.hdc, nSavedDC);
-						}
+			}
 						if (hooks (SWT.PaintItem)) {
 							itemRect [0] = item [0].getBounds (index [0], true, true, false, false, false, hDC);
 							sendPaintItemEvent (item [0], nmcd, index[0], itemRect [0]);
-						}
+		}
 						OS.SelectObject (hDC, oldFont);
 						OS.ReleaseDC (handle, hDC);
-					}
-					break;
-				}
 			}
 			break;
 		}
+			}
+			break;
+		}
 	}
 	return null;
 }
Index: org/eclipse/swt/widgets/TableColumn.java
===================================================================
--- org/eclipse/swt/widgets/TableColumn.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TableColumn.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -830,7 +830,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -867,7 +867,7 @@
 	if (index == -1) return;
 	int /*long*/ hwnd = parent.handle;
 	if (width != (int)/*64*/OS.SendMessage (hwnd, OS.LVM_GETCOLUMNWIDTH, index, 0)) {
-		OS.SendMessage (hwnd, OS.LVM_SETCOLUMNWIDTH, index, width);
+	OS.SendMessage (hwnd, OS.LVM_SETCOLUMNWIDTH, index, width);
 	}
 }
 
Index: org/eclipse/swt/widgets/Shell.java
===================================================================
--- org/eclipse/swt/widgets/Shell.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Shell.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -20,13 +20,13 @@
  * Instances of this class represent the "windows"
  * which the desktop or "window manager" is managing.
  * Instances that do not have a parent (that is, they
- * are built using the constructor, which takes a 
+ * are built using the constructor, which takes a
  * <code>Display</code> as the argument) are described
  * as <em>top level</em> shells. Instances that do have
  * a parent are described as <em>secondary</em> or
  * <em>dialog</em> shells.
  * <p>
- * Instances are always displayed in one of the maximized, 
+ * Instances are always displayed in one of the maximized,
  * minimized or normal states:
  * <ul>
  * <li>
@@ -33,7 +33,7 @@
  * When an instance is marked as <em>maximized</em>, the
  * window manager will typically resize it to fill the
  * entire visible area of the display, and the instance
- * is usually put in a state where it can not be resized 
+ * is usually put in a state where it can not be resized
  * (even if it has style <code>RESIZE</code>) until it is
  * no longer maximized.
  * </li><li>
@@ -91,19 +91,19 @@
  * <dt><code>SHELL_TRIM</code></dt>
  * <dd>
  * the result of combining the constants which are required
- * to produce a typical application top level shell: (that 
+ * to produce a typical application top level shell: (that
  * is, <code>CLOSE | TITLE | MIN | MAX | RESIZE</code>)
  * </dd>
  * <dt><code>DIALOG_TRIM</code></dt>
  * <dd>
  * the result of combining the constants which are required
- * to produce a typical application dialog shell: (that 
+ * to produce a typical application dialog shell: (that
  * is, <code>TITLE | CLOSE | BORDER</code>)
  * </dd>
  * </dl>
  * </p>
  * <p>
- * Note: Only one of the styles APPLICATION_MODAL, MODELESS, 
+ * Note: Only one of the styles APPLICATION_MODAL, MODELESS,
  * PRIMARY_MODAL and SYSTEM_MODAL may be specified.
  * </p><p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
@@ -166,7 +166,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -179,7 +179,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#BORDER
  * @see SWT#CLOSE
  * @see SWT#MIN
@@ -207,7 +207,7 @@
  * <p>
  * Note: Currently, null can be passed in for the display argument.
  * This has the effect of creating the shell on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * shell is created on a "default" display. <b>Passing in null as
  * the display argument is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -231,7 +231,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -239,7 +239,7 @@
  * </p><p>
  * Note: Currently, null can be passed in for the display argument.
  * This has the effect of creating the shell on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * shell is created on a "default" display. <b>Passing in null as
  * the display argument is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -252,7 +252,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#BORDER
  * @see SWT#CLOSE
  * @see SWT#MIN
@@ -283,7 +283,7 @@
 		error (SWT.ERROR_THREAD_INVALID_ACCESS);
 	}
 	if (parent != null && parent.isDisposed ()) {
-		error (SWT.ERROR_INVALID_ARGUMENT);	
+		error (SWT.ERROR_INVALID_ARGUMENT);
 	}
 	this.center = parent != null && (style & SWT.SHEET) != 0;
 	this.style = checkStyle (parent, style);
@@ -303,7 +303,7 @@
  * <p>
  * Note: Currently, null can be passed in for the parent.
  * This has the effect of creating the shell on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * shell is created on a "default" display. <b>Passing in null as
  * the parent is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -312,7 +312,7 @@
  * @param parent a shell which will be the parent of the new instance
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the parent is disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the parent is disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
@@ -329,7 +329,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -337,7 +337,7 @@
  * </p><p>
  * Note: Currently, null can be passed in for the parent.
  * This has the effect of creating the shell on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * shell is created on a "default" display. <b>Passing in null as
  * the parent is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -347,13 +347,13 @@
  * @param style the style of control to construct
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the parent is disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the parent is disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#BORDER
  * @see SWT#CLOSE
  * @see SWT#MIN
@@ -375,7 +375,7 @@
 	this (parent != null ? parent.display : null, parent, style, 0, false);
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to allocate a new shell
  * that is embedded.
  * <p>
@@ -490,7 +490,7 @@
 	if (parent != null) {
 		switch (msg) {
 			case OS.WM_KILLFOCUS:
-			case OS.WM_SETFOCUS: 
+			case OS.WM_SETFOCUS:
 				return OS.DefWindowProc (hwnd, msg, wParam, lParam);
 		}
 		return OS.CallWindowProc (DialogProc, hwnd, msg, wParam, lParam);
@@ -567,7 +567,7 @@
 
 void createHandle () {
 	boolean embedded = handle != 0 && (state & FOREIGN_HANDLE) == 0;
-	
+
 	/*
 	* On Windows 98 and NT, setting a window to be the
 	* top most window using HWND_TOPMOST can result in a
@@ -589,14 +589,14 @@
 		}
 		windowProc = OS.GetWindowLongPtr (handle, OS.GWL_WNDPROC);
 	}
-	
+
 	/*
 	* The following code is intentionally commented.
 	*/
 //	if ((style & SWT.ON_TOP) != 0)  display.lockActiveWindow = false;
-	
+
 	if (!embedded) {
-		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);	
+		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		bits &= ~(OS.WS_OVERLAPPED | OS.WS_CAPTION);
 		if (!OS.IsWinCE) bits |= OS.WS_POPUP;
 		if ((style & SWT.TITLE) != 0) bits |= OS.WS_CAPTION;
@@ -844,10 +844,10 @@
 }
 
 /**
- * If the receiver is visible, moves it to the top of the 
- * drawing order for the display on which it was created 
- * (so that all other shells on that display, which are not 
- * the receiver's children will be drawn behind it) and forces 
+ * If the receiver is visible, moves it to the top of the
+ * drawing order for the display on which it was created
+ * (so that all other shells on that display, which are not
+ * the receiver's children will be drawn behind it) and forces
  * the window manager to make the shell active.
  *
  * @exception SWTException <ul>
@@ -963,7 +963,7 @@
  * will be the result of bitwise OR'ing together one or
  * more of the following constants defined in class
  * <code>SWT</code>:
- * <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>, 
+ * <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>,
  * <code>PHONETIC</code>, <code>NATIVE</code>, <code>ALPHA</code>.
  *
  * @return the IME mode
@@ -1021,7 +1021,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public Point getMinimumSize () {
@@ -1068,7 +1068,7 @@
  * or <code>null</code> if the shell has the default shape.
  *
  * @return the region that defines the shape of the shell, or <code>null</code>
- *	
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1101,7 +1101,7 @@
 }
 
 /**
- * Returns an array containing all shells which are 
+ * Returns an array containing all shells which are
  * descendants of the receiver.
  * <p>
  * @return the dialog shells
@@ -1178,7 +1178,7 @@
 			0,
 			new TCHAR (0, "MDICLIENT", true),
 			null,
-			widgetStyle, 
+			widgetStyle,
 			0, 0, 0, 0,
 			handle,
 			0,
@@ -1238,7 +1238,7 @@
 	* bar does not get updated.  The fix is to call PeekMessage()
 	* with the flag PM_NOREMOVE and PM_QS_SENDMESSAGE to respond
 	* to a cross thread WM_GETICON.
-	* 
+	*
 	* NOTE: This allows other cross thread messages to be delivered,
 	* most notably WM_ACTIVATE.
 	*/
@@ -1385,11 +1385,11 @@
 }
 
 /**
- * If the receiver is visible, moves it to the top of the 
- * drawing order for the display on which it was created 
- * (so that all other shells on that display, which are not 
- * the receiver's children will be drawn behind it) and asks 
- * the window manager to make the shell active 
+ * If the receiver is visible, moves it to the top of the
+ * drawing order for the display on which it was created
+ * (so that all other shells on that display, which are not
+ * the receiver's children will be drawn behind it) and asks
+ * the window manager to make the shell active
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -1416,7 +1416,7 @@
 	if (control != null && control.isDisposed ()) control = null;
 	if (lastActive != null && lastActive.isDisposed ()) lastActive = null;
 	if (lastActive == control) return;
-	
+
 	/*
 	* Compute the list of controls to be activated and
 	* deactivated by finding the first common parent
@@ -1430,7 +1430,7 @@
 		if (activate [index] != deactivate [index]) break;
 		index++;
 	}
-	
+
 	/*
 	* It is possible (but unlikely), that application
 	* code could have destroyed some of the widgets. If
@@ -1559,10 +1559,10 @@
 }
 
 /**
- * Sets the input method editor mode to the argument which 
+ * Sets the input method editor mode to the argument which
  * should be the result of bitwise OR'ing together one or more
  * of the following constants defined in class <code>SWT</code>:
- * <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>, 
+ * <code>NONE</code>, <code>ROMAN</code>, <code>DBCS</code>,
  * <code>PHONETIC</code>, <code>NATIVE</code>, <code>ALPHA</code>.
  *
  * @param mode the new IME mode
@@ -1632,7 +1632,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setMinimumSize (int width, int height) {
@@ -1650,7 +1650,7 @@
 			OS.AdjustWindowRectEx (rect, bits1, false, bits2);
 			heightLimit = rect.bottom - rect.top;
 		}
-	} 
+	}
 	minWidth = Math.max (widthLimit, width);
 	minHeight = Math.max (heightLimit, height);
 	Point size = getSize ();
@@ -1675,7 +1675,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
 public void setMinimumSize (Point size) {
@@ -1725,7 +1725,7 @@
  *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the region has been disposed</li>
- * </ul>  
+ * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1798,7 +1798,7 @@
 	* is used to set the title of a tool tip, Windows leaks
 	* GDI objects.  This happens even when TTM_SETTITLE is
 	* called with TTI_NONE and NULL.  The documentation
-	* states that Windows copies the icon and that the 
+	* states that Windows copies the icon and that the
 	* programmer must free the copy but does not provide
 	* API to get the icon.  For example, when TTM_SETTITLE
 	* is called with ICON_ERROR, when TTM_GETTITLE is used
@@ -1806,7 +1806,7 @@
 	* field in the TTGETTITLE struct is zero.  The fix
 	* is to remember these values, only set them when then
 	* change and leak less.
-	* 
+	*
 	* NOTE:  This only happens on Vista.
 	*/
 	if (hwndToolTip != toolTipHandle && hwndToolTip != balloonTipHandle) {
@@ -1878,7 +1878,7 @@
 	} else {
 		updateModal ();
 	}
-	
+
 	/*
 	* Bug in Windows.  Calling ShowOwnedPopups() to hide the
 	* child windows of a hidden window causes the application
@@ -1896,11 +1896,11 @@
 	super.setVisible (visible);
 	if (isDisposed ()) return;
 	if (showWithParent != visible) {
-		showWithParent = visible;
-		if (visible) {
-			if (!OS.IsWinCE) OS.ShowOwnedPopups (handle, true);		
-		}
+	showWithParent = visible;
+	if (visible) {
+		if (!OS.IsWinCE) OS.ShowOwnedPopups (handle, true);
 	}
+	}
 	
 	/* Make the foreign window parent appear in the task bar */
 	if (visible) {
@@ -1957,7 +1957,7 @@
 	if (ToolTipProc != 0) {
 		if (toolTipHandle != 0) {
 			OS.SetWindowLongPtr (toolTipHandle, OS.GWLP_WNDPROC, ToolTipProc);
-		}	
+		}
 		if (toolTipHandle != 0) {
 			OS.SetWindowLongPtr (toolTipHandle, OS.GWLP_WNDPROC, ToolTipProc);
 		}
@@ -1984,7 +1984,7 @@
 int widgetExtStyle () {
 	int bits = super.widgetExtStyle () & ~OS.WS_EX_MDICHILD;
 	if ((style & SWT.TOOL) != 0) bits |= OS.WS_EX_TOOLWINDOW;
-	
+
 	/*
 	* Feature in Windows.  When a window that does not have a parent
 	* is created, it is automatically added to the Windows Task Bar,
@@ -2001,7 +2001,7 @@
 			}
 		}
 	}
-	
+
 	/*
 	* Bug in Windows 98 and NT.  Creating a window with the
 	* WS_EX_TOPMOST extended style can result in a dialog shell
@@ -2077,13 +2077,13 @@
 	* Feature in WinCE.  Calling CreateWindowEx () with WS_OVERLAPPED
 	* and a parent window causes the new window to become a WS_CHILD of
 	* the parent instead of a dialog child.  The fix is to use WS_POPUP
-	* for a window with a parent.  
-	* 
+	* for a window with a parent.
+	*
 	* Feature in WinCE PPC.  A window without a parent with WS_POPUP
 	* always shows on top of the Pocket PC 'Today Screen'. The fix
 	* is to not set WS_POPUP for a window without a parent on WinCE
 	* devices.
-	* 
+	*
 	* NOTE: WS_POPUP causes CreateWindowEx () to ignore CW_USEDEFAULT
 	* and causes the default window location and size to be zero.
 	*/
@@ -2091,19 +2091,19 @@
 		if (OS.IsSP) return bits | OS.WS_POPUP;
 		return parent == null ? bits : bits | OS.WS_POPUP;
 	}
-	
+
 	/*
 	* Use WS_OVERLAPPED for all windows, either dialog or top level
 	* so that CreateWindowEx () will respect CW_USEDEFAULT and set
 	* the default window location and size.
-	* 
+	*
 	* NOTE:  When a WS_OVERLAPPED window is created, Windows gives
 	* the new window WS_CAPTION style bits.  These two constants are
 	* as follows:
-	* 
+	*
 	* 	WS_OVERLAPPED = 0
 	* 	WS_CAPTION = WS_BORDER | WS_DLGFRAME
-	* 
+	*
 	*/
 	return bits | OS.WS_OVERLAPPED | OS.WS_CAPTION;
 }
@@ -2124,7 +2124,7 @@
 		/* Restore SIP state when window is activated */
 		if (OS.LOWORD (wParam) != 0) {
 			OS.SHSipPreference (handle, psai.fSipUp == 0 ? OS.SIP_DOWN : OS.SIP_UP);
-		} 
+		}
 	}
 
 	/*
@@ -2140,7 +2140,7 @@
 			}
 		}
 	}
-	
+
 	/* Process WM_ACTIVATE */
 	LRESULT result = super.WM_ACTIVATE (wParam, lParam);
 	if (OS.LOWORD (wParam) == 0) {
@@ -2162,7 +2162,7 @@
 		int loWord = OS.LOWORD (wParam);
 		if (loWord == OS.IDOK && (lParam == 0 || lParam == handle)) {
 			OS.PostMessage (handle, OS.WM_CLOSE, 0, 0);
-			return LRESULT.ZERO;			
+			return LRESULT.ZERO;
 		}
 	}
 	/*
@@ -2183,7 +2183,7 @@
 					return super.WM_COMMAND (wParam, 0);
 				} else {
 					int /*long*/ hwndChild = OS.GetWindow (hwndCB, OS.GW_CHILD);
-					if (lParam == hwndChild) return super.WM_COMMAND (wParam, 0);					
+					if (lParam == hwndChild) return super.WM_COMMAND (wParam, 0);
 				}
 			}
 		}
@@ -2215,7 +2215,7 @@
 	* the resize handles, Windows temporarily fills in black
 	* rectangles where the new contents of the shell should
 	* draw.  The fix is to always draw the background of shells.
-	* 
+	*
 	* NOTE: This only happens on Vista.
 	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -2252,7 +2252,7 @@
 LRESULT WM_MOUSEACTIVATE (int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.WM_MOUSEACTIVATE (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Check for WM_MOUSEACTIVATE when an MDI shell is active
 	* and stop the normal shell activation but allow the mouse
@@ -2285,7 +2285,7 @@
 		}
 	}
 	if (hittest == OS.HTMENU) return null;
-	
+
 	/*
 	* Get the current location of the cursor,
 	* not the location of the cursor when the
@@ -2299,7 +2299,8 @@
 	* embedded widget's event loop.
 	*/
 	POINT pt = new POINT ();
-	if (!OS.GetCursorPos (pt)) {
+        // <QFS/> Get overridden cursor position
+	if (!OS._GetCursorPos (pt)) {
 		int pos = OS.GetMessagePos ();
 		OS.POINTSTOPOINT (pt, pos);
 	}
@@ -2306,7 +2307,7 @@
 	int /*long*/ hwnd = OS.WindowFromPoint (pt);
 	if (hwnd == 0) return null;
 	Control control = display.findControl (hwnd);
-	
+
 	/*
 	* When a shell is created with SWT.ON_TOP and SWT.NO_FOCUS,
 	* do not activate the shell when the user clicks on the
@@ -2323,7 +2324,7 @@
 			}
 		}
 	}
-	
+
 	int /*long*/ code = callWindowProc (handle, OS.WM_MOUSEACTIVATE, wParam, lParam);
 	setActiveControl (control);
 	return new LRESULT (code);
@@ -2472,7 +2473,7 @@
 	if (result != null) return result;
 	if (OS.IsPPC) {
 		if (wParam == OS.SPI_SETSIPINFO) {
-			/* 
+			/*
 			* The SIP is in a new state.  Cache its new value.
 			* Resize the Shell if it has the style SWT.RESIZE.
 			* Note that SHHandleWMSettingChange resizes the
@@ -2485,7 +2486,7 @@
 				SIPINFO pSipInfo = new SIPINFO ();
 				pSipInfo.cbSize = SIPINFO.sizeof;
 				OS.SipGetInfo (pSipInfo);
-				psai.fSipUp = pSipInfo.fdwFlags & OS.SIPF_ON;					
+				psai.fSipUp = pSipInfo.fdwFlags & OS.SIPF_ON;
 			}
 		}
 	}
@@ -2528,7 +2529,7 @@
 	* to intercept WM_SYSCOMMAND looking for SC_MINIMIZE
 	* and use ShowWindow() with SW_SHOWMINIMIZED to minimize
 	* the window, rather than running the default window proc.
-	* 
+	*
 	* NOTE:  The default window proc activates the next
 	* top-level window in the Z-order while ShowWindow()
 	* with SW_SHOWMINIMIZED does not.  There is no fix for
Index: org/eclipse/swt/widgets/List.java
===================================================================
--- org/eclipse/swt/widgets/List.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/List.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -16,7 +16,7 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
-/** 
+/**
  * Instances of this class represent a selectable user interface
  * object that displays a list of strings and issues notification
  * when a string is selected.  A list may be single or multi select.
@@ -55,7 +55,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -236,7 +236,7 @@
 						width = Math.max (width, rect.right - rect.left);
 					}
 				}
-			}	
+			}
 			if (newFont != 0) OS.SelectObject (hDC, oldFont);
 			OS.ReleaseDC (handle, hDC);
 		}
@@ -268,7 +268,7 @@
 
 /**
  * Deselects the items at the given zero-relative indices in the receiver.
- * If the item at the given zero-relative index in the receiver 
+ * If the item at the given zero-relative index in the receiver
  * is selected, it is deselected.  If the item at the index
  * was not selected, it remains deselected. Indices that are out
  * of range and duplicate indices are ignored.
@@ -326,13 +326,13 @@
 		if (oldIndex == OS.LB_ERR) return;
 		if (oldIndex == index) OS.SendMessage (handle, OS.LB_SETCURSEL, -1, 0);
 		return;
-	} 
+	}
 	OS.SendMessage (handle, OS.LB_SETSEL, 0, index);
 }
 
 /**
  * Deselects the items at the given zero-relative indices in the receiver.
- * If the item at the given zero-relative index in the receiver 
+ * If the item at the given zero-relative index in the receiver
  * is selected, it is deselected.  If the item at the index
  * was not selected, it remains deselected.  The range of the
  * indices is inclusive. Indices that are out of range are ignored.
@@ -474,11 +474,11 @@
 
 /**
  * Returns a (possibly empty) array of <code>String</code>s which
- * are the items in the receiver. 
+ * are the items in the receiver.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver's list
@@ -503,7 +503,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return an array representing the selection
  *
@@ -580,7 +580,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return the array of indices of the selected items
  *
@@ -645,7 +645,7 @@
 }
 
 /**
- * Searches the receiver's list starting at the given, 
+ * Searches the receiver's list starting at the given,
  * zero-relative index until an item is found that is equal
  * to the argument, and returns the index of that item. If
  * no item is found or the starting index is out of range,
@@ -666,7 +666,7 @@
 public int indexOf (String string, int start) {
 	checkWidget ();
 	if (string == null) error (SWT.ERROR_NULL_ARGUMENT);
-	
+
 	/*
 	* Bug in Windows.  For some reason, LB_FINDSTRINGEXACT
 	* will not find empty strings even though it is legal
@@ -782,7 +782,7 @@
 	if (topCount > 0) {
 		topIndex -= topCount;
 	}
-	OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
+		OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
 	if (i < newIndices.length) error (SWT.ERROR_ITEM_NOT_REMOVED);
 }
 
@@ -834,7 +834,7 @@
 
 /**
  * Removes the items from the receiver which are
- * between the given zero-relative start and end 
+ * between the given zero-relative start and end
  * indices (inclusive).
  *
  * @param start the start of the range
@@ -858,7 +858,7 @@
 	if (start == 0 && end == count - 1) {
 		removeAll ();
 		return;
-	} 
+	}
 	int topIndex = (int)/*64*/OS.SendMessage (handle, OS.LB_GETTOPINDEX, 0, 0);
 	RECT rect = null;
 	int /*long*/ hDC = 0, oldFont = 0, newFont = 0;
@@ -897,13 +897,13 @@
 	if (end < topIndex) {
 		topIndex -= end - start + 1;
 	}
-	OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
+		OS.SendMessage (handle, OS.LB_SETTOPINDEX, topIndex, 0);
 	if (index <= end) error (SWT.ERROR_ITEM_NOT_REMOVED);
 }
 
 /**
  * Searches the receiver's list starting at the first item
- * until an item is found that is equal to the argument, 
+ * until an item is found that is equal to the argument,
  * and removes that item from the list.
  *
  * @param string the item to remove
@@ -963,7 +963,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -985,7 +985,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see List#setSelection(int[])
  */
 public void select (int [] indices) {
@@ -1009,7 +1009,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver's 
+ * Selects the item at the given zero-relative index in the receiver's
  * list.  If the item at the index was already selected, it remains
  * selected. Indices that are out of range are ignored.
  *
@@ -1033,8 +1033,8 @@
 		if ((style & SWT.SINGLE) != 0) {
 			OS.SendMessage (handle, OS.LB_SETCURSEL, index, 0);
 		} else {
-			OS.SendMessage (handle, OS.LB_SETSEL, 1, index);	
-		}		
+			OS.SendMessage (handle, OS.LB_SETSEL, 1, index);
+		}
 		return;
 	}
 	int topIndex = (int)/*64*/OS.SendMessage (handle, OS.LB_GETTOPINDEX, 0, 0);
@@ -1092,7 +1092,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see List#setSelection(int,int)
  */
 public void select (int start, int end) {
@@ -1121,7 +1121,7 @@
 	OS.SendMessage (handle, OS.LB_SELITEMRANGEEX, start, end);
 	if (scroll) showSelection ();
 }
-	
+
 /**
  * Selects all of the items in the receiver.
  * <p>
@@ -1139,7 +1139,7 @@
 }
 
 void setFocusIndex (int index) {
-//	checkWidget ();	
+//	checkWidget ();
 	int count = (int)/*64*/OS.SendMessage (handle, OS.LB_GETCOUNT, 0, 0);
 	if (!(0 <= index && index < count)) return;
 	OS.SendMessage (handle, OS.LB_SETCARETINDEX, index, 0);
@@ -1390,7 +1390,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver. 
+ * Selects the item at the given zero-relative index in the receiver.
  * If the item at the index was already selected, it remains selected.
  * The current selection is first cleared, then the new item is selected.
  * Indices that are out of range are ignored.
@@ -1572,7 +1572,8 @@
 	* it inaccessible from the keyboard.  The fix is to implement
 	* the key processing.
 	*/
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0 && getDisplay().GetKeyState (OS.VK_SHIFT) >= 0) {
 		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		if ((bits & OS.LBS_EXTENDEDSEL) != 0) {
 			switch ((int)/*64*/wParam) {
@@ -1590,7 +1591,7 @@
 	}
 	return result;
 }
-	
+
 LRESULT WM_KEYDOWN (int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.WM_KEYDOWN (wParam, lParam);
 	if (result != null) return result;
@@ -1600,7 +1601,8 @@
 	* it inaccessible from the keyboard.  The fix is to implement
 	* the key processing.
 	*/
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0 && OS.GetKeyState (OS.VK_SHIFT) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0 && getDisplay().GetKeyState (OS.VK_SHIFT) >= 0) {
 		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		if ((bits & OS.LBS_EXTENDEDSEL) != 0) {
 			int newIndex = -1;
@@ -1665,28 +1667,28 @@
 				}
 			}
 			if (newIndex != -1) {
-				/*
-				* Feature in Windows.  When the user changes focus using
-				* the keyboard, the focus indicator does not draw.  The
-				* fix is to update the UI state for the control whenever
-				* the focus indicator changes as a result of something
-				* the user types.
-				*/
-				int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
-				if ((uiState & OS.UISF_HIDEFOCUS) != 0) {
-					OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
-					/*
-					* Bug in Windows.  When the WM_CHANGEUISTATE is used
-					* to update the UI state for a list that has been
-					* selected using Shift+Arrow, the focus indicator
-					* has pixel corruption.  The fix is to redraw the
+	/*
+	* Feature in Windows.  When the user changes focus using
+	* the keyboard, the focus indicator does not draw.  The
+	* fix is to update the UI state for the control whenever
+	* the focus indicator changes as a result of something
+	* the user types.
+	*/
+	int uiState = (int)/*64*/OS.SendMessage (handle, OS.WM_QUERYUISTATE, 0, 0);
+	if ((uiState & OS.UISF_HIDEFOCUS) != 0) {
+			OS.SendMessage (handle, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
+			/*
+			* Bug in Windows.  When the WM_CHANGEUISTATE is used
+			* to update the UI state for a list that has been
+			* selected using Shift+Arrow, the focus indicator
+			* has pixel corruption.  The fix is to redraw the
 					* control.
-					*/
-					RECT itemRect = new RECT ();
+			*/
+			RECT itemRect = new RECT ();
 					int oldIndex = (int)/*64*/OS.SendMessage (handle, OS.LB_GETCARETINDEX, 0, 0);
 					OS.SendMessage (handle, OS.LB_GETITEMRECT, oldIndex, itemRect);
-					OS.InvalidateRect (handle, itemRect, true);
-				}
+			OS.InvalidateRect (handle, itemRect, true);
+		}
 				OS.SendMessage (handle, OS.LB_SETCARETINDEX, newIndex, 0);
 				return LRESULT.ZERO;
 			}
Index: org/eclipse/swt/widgets/Control.java
===================================================================
--- org/eclipse/swt/widgets/Control.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Control.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -19,6 +20,11 @@
 import org.eclipse.swt.events.*;
 import org.eclipse.swt.accessibility.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Control is the abstract superclass of all windowed user interface classes.
  * <p>
@@ -37,7 +43,7 @@
  * IMPORTANT: This class is intended to be subclassed <em>only</em>
  * within the SWT implementation.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/snippets/#control">Control snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
@@ -46,8 +52,15 @@
 
 public abstract class Control extends Widget implements Drawable {
 
+    // {{{ <QFS> Log
+
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Control");
+    private final static Logger suppresslogger = new Logger("suppress.aus.ab.DBG");
+
+    // }}} </QFS>
+
 	/**
-	 * the handle to the OS resource 
+	 * the handle to the OS resource
 	 * (Warning: This field is platform dependent)
 	 * <p>
 	 * <b>IMPORTANT:</b> This field is <em>not</em> part of the SWT
@@ -55,7 +68,7 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public int /*long*/ handle;
@@ -82,7 +95,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -157,7 +170,7 @@
  *
  * @see DragDetectListener
  * @see #removeDragDetectListener
- * 
+ *
  * @since 3.3
  */
 public void addDragDetectListener (DragDetectListener listener) {
@@ -205,7 +218,7 @@
  * must be invoked on it to specify that gesture events should be
  * sent instead of touch events.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified
  *
  * @exception IllegalArgumentException <ul>
@@ -219,7 +232,7 @@
  * @see GestureListener
  * @see #removeGestureListener
  * @see #setTouchEnabled
- * 
+ *
  * @since 3.7
  */
 public void addGestureListener (GestureListener listener) {
@@ -467,7 +480,7 @@
  * specify that touch events should be sent, which will cause gesture
  * events to not be sent.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified
  *
  * @exception IllegalArgumentException <ul>
@@ -557,7 +570,7 @@
 		}
 		if (composite == shell) break;
 		composite = composite.parent;
-	} while (true);	
+	} while (true);
 }
 
 void checkBorder () {
@@ -590,8 +603,8 @@
  * best be displayed at. The width hint and height hint arguments
  * allow the caller to ask a control questions such as "Given a particular
  * width, how high does the control need to be to show all of the contents?"
- * To indicate that the caller does not wish to constrain a particular 
- * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint. 
+ * To indicate that the caller does not wish to constrain a particular
+ * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.
  * </p>
  *
  * @param wHint the width hint (can be <code>SWT.DEFAULT</code>)
@@ -621,14 +634,14 @@
  * best be displayed at. The width hint and height hint arguments
  * allow the caller to ask a control questions such as "Given a particular
  * width, how high does the control need to be to show all of the contents?"
- * To indicate that the caller does not wish to constrain a particular 
- * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint. 
+ * To indicate that the caller does not wish to constrain a particular
+ * dimension, the constant <code>SWT.DEFAULT</code> is passed for the hint.
  * </p><p>
  * If the changed flag is <code>true</code>, it indicates that the receiver's
  * <em>contents</em> have changed, therefore any caches that a layout manager
  * containing the control may have been keeping need to be flushed. When the
  * control is resized, the changed flag will be <code>false</code>, so layout
- * manager caches can be retained. 
+ * manager caches can be retained.
  * </p>
  *
  * @param wHint the width hint (can be <code>SWT.DEFAULT</code>)
@@ -711,7 +724,7 @@
 		OS.ImmAssociateContext (handle, hIMC);
 		OS.ImmReleaseContext (hwndParent, hIMC);
 	}
-	
+
 }
 
 void checkGesture () {
@@ -732,7 +745,7 @@
 				OS.MoveMemory (pConfigs, config, GESTURECONFIG.sizeof);
 				OS.SetGestureConfig (handle, 0, 1, pConfigs, GESTURECONFIG.sizeof);
 				OS.HeapFree (hHeap, 0, pConfigs);
-			}		
+			}
 		}
 	}
 }
@@ -785,7 +798,7 @@
  * Detects a drag and drop gesture.  This method is used
  * to detect a drag gesture when called from within a mouse
  * down listener.
- * 
+ *
  * <p>By default, a drag is detected when the gesture
  * occurs anywhere within the client area of a control.
  * Some controls, such as tables and trees, override this
@@ -798,7 +811,7 @@
  * </p>
  *
  * @param event the mouse down event
- * 
+ *
  * @return <code>true</code> if the gesture occurred, and <code>false</code> otherwise.
  *
  * @exception IllegalArgumentException <ul>
@@ -808,13 +821,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- *  
+ *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @see #getDragDetect
  * @see #setDragDetect
- * 
+ *
  * @since 3.3
  */
 public boolean dragDetect (Event event) {
@@ -827,7 +840,7 @@
  * Detects a drag and drop gesture.  This method is used
  * to detect a drag gesture when called from within a mouse
  * down listener.
- * 
+ *
  * <p>By default, a drag is detected when the gesture
  * occurs anywhere within the client area of a control.
  * Some controls, such as tables and trees, override this
@@ -840,7 +853,7 @@
  * </p>
  *
  * @param event the mouse down event
- * 
+ *
  * @return <code>true</code> if the gesture occurred, and <code>false</code> otherwise.
  *
  * @exception IllegalArgumentException <ul>
@@ -850,13 +863,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @see #getDragDetect
  * @see #setDragDetect
- * 
+ *
  * @since 3.3
  */
 public boolean dragDetect (MouseEvent event) {
@@ -868,7 +881,8 @@
 boolean dragDetect (int button, int count, int stateMask, int x, int y) {
 	if (button != 1 || count != 1) return false;
 	boolean dragging = dragDetect (handle, x, y, false, null, null);
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	}
 	if (!dragging) {
@@ -885,7 +899,7 @@
 		* mouse down/up pairs or looks for the ESC key will not
 		* function properly.  The fix is to send the missing
 		* events when the drag has not started.
-		* 
+		*
 		* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP
 		* events for the ESC key.  This would require computing
 		* wParam (the key) and lParam (the repeat count, scan code,
@@ -892,7 +906,8 @@
 		* extended-key flag, context code, previous key-state flag,
 		* and transition-state flag) which is non-trivial.
 		*/
-		if (button == 1 && OS.GetKeyState (OS.VK_ESCAPE) >= 0) {
+                // <QFS/> Changed to getDisplay().GetKeyState
+		if (button == 1 && getDisplay().GetKeyState (OS.VK_ESCAPE) >= 0) {
 			int wParam = 0;
 			if ((stateMask & SWT.CTRL) != 0) wParam |= OS.MK_CONTROL;
 			if ((stateMask & SWT.SHIFT) != 0) wParam |= OS.MK_SHIFT;
@@ -1049,7 +1064,7 @@
 	boolean oldFixFocus = display.fixFocus;
 	display.fixFocus = true;
 	try {
-		while (control != shell && (control = control.parent) != null) {
+	while (control != shell && (control = control.parent) != null) {
 				if (control.setFocus ()) return;
 		}
 	} finally {
@@ -1090,7 +1105,7 @@
 	* control will no longer have the focus
 	* and the call to setFocus() will return
 	* false indicating failure.
-	* 
+	*
 	* We are still working on a solution at
 	* this time.
 	*/
@@ -1112,7 +1127,7 @@
 			* This code is intentionally commented.  All widgets that
 			* are created by SWT have WS_CLIPSIBLINGS to ensure that
 			* application code does not draw outside of the control.
-			*/	
+			*/
 //			int count = parent.getChildrenCount ();
 //			if (count > 1) {
 //				int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
@@ -1121,7 +1136,7 @@
 			SetWindowPos (wp.hwnd, 0, wp.x, wp.y, wp.cx, wp.cy, wp.flags);
 			lpwp [i] = null;
 			return;
-		}	
+		}
 	}
 }
 
@@ -1139,10 +1154,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Accessible#addAccessibleListener
  * @see Accessible#addAccessibleControlListener
- * 
+ *
  * @since 2.0
  */
 public Accessible getAccessible () {
@@ -1181,7 +1196,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public Image getBackgroundImage () {
@@ -1288,7 +1303,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public Cursor getCursor () {
@@ -1298,15 +1313,15 @@
 
 /**
  * Returns <code>true</code> if the receiver is detecting
- * drag gestures, and  <code>false</code> otherwise. 
+ * drag gestures, and  <code>false</code> otherwise.
  *
  * @return the receiver's drag detect state
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public boolean getDragDetect () {
@@ -1330,7 +1345,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -1393,8 +1408,8 @@
 /**
  * Returns a point describing the receiver's location relative
  * to its parent (or its display if its parent is null), unless
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @return the receiver's location
  *
@@ -1435,14 +1450,14 @@
 
 /**
  * Returns the receiver's monitor.
- * 
+ *
  * @return the receiver's monitor
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public Monitor getMonitor () {
@@ -1472,12 +1487,12 @@
  * constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public int getOrientation () {
@@ -1519,12 +1534,12 @@
 	return result;
 }
 
-/** 
+/**
  * Returns the region that defines the shape of the control,
  * or null if the control has the default shape.
  *
  * @return the region that defines the shape of the shell (or null)
- *	
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1650,7 +1665,8 @@
 	if (!OS.GetClientRect (handle, rect)) return false;
 	OS.MapWindowPoints (handle, 0, rect, 2);
 	POINT pt = new POINT ();
-	return OS.GetCursorPos (pt) && OS.PtInRect (rect, pt);
+        // <QFS/> Get overridden cursor position
+	return OS._GetCursorPos (pt) && OS.PtInRect (rect, pt);
 }
 
 boolean hasFocus () {
@@ -1670,7 +1686,7 @@
 	return false;
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to allocate a new GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -1680,9 +1696,9 @@
  * application code.
  * </p>
  *
- * @param data the platform specific GC data 
+ * @param data the platform specific GC data
  * @return the platform specific GC handle
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public int /*long*/ internal_new_GC (GCData data) {
@@ -1726,7 +1742,7 @@
 	return hDC;
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to dispose a GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -1737,8 +1753,8 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data 
- * 
+ * @param data the platform specific GC data
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public void internal_dispose_GC (int /*long*/ hDC, GCData data) {
@@ -1803,7 +1819,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -1965,13 +1981,13 @@
  * @param control the sibling control (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Control#moveBelow
  * @see Composite#getChildren
  */
@@ -1995,7 +2011,7 @@
 			hwndAbove = OS.HWND_TOP;
 		}
 	}
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, hwndAbove, 0, 0, 0, 0, flags);
 }
 
@@ -2009,13 +2025,13 @@
  * @param control the sibling control (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Control#moveAbove
  * @see Composite#getChildren
  */
@@ -2037,7 +2053,7 @@
 		*/
 		Shell shell = getShell ();
 		if (this == shell && parent != null) {
-			/* 
+			/*
 			* Bug in Windows.  For some reason, when GetWindow ()
 			* with GW_HWNDPREV is used to query the previous window
 			* in the z-order with the first child, Windows returns
@@ -2055,7 +2071,7 @@
 		}
 	}
 	if (hwndAbove == 0 || hwndAbove == topHandle) return;
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, hwndAbove, 0, 0, 0, 0, flags);
 }
 
@@ -2093,11 +2109,11 @@
  * <em>contents</em> have changed, therefore any caches that a layout manager
  * containing the control may have been keeping need to be flushed. When the
  * control is resized, the changed flag will be <code>false</code>, so layout
- * manager caches can be retained. 
+ * manager caches can be retained.
  * </p>
  *
  * @param changed whether or not the receiver's contents have changed
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -2112,7 +2128,7 @@
 
 /**
  * Prints the receiver and all children.
- * 
+ *
  * @param gc the gc where the drawing occurs
  * @return <code>true</code> if the operation was successful and <code>false</code> otherwise
  *
@@ -2124,7 +2140,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public boolean print (GC gc) {
@@ -2208,9 +2224,9 @@
 		OS.GetWindowRect (hwnd, rect1);
 		boolean fixPrintWindow = !OS.IsWindowVisible(hwnd);
 		if (!fixPrintWindow) {
-			RECT rect2 = new RECT ();
-			OS.GetWindowRect (hwndShell, rect2);
-			OS.IntersectRect (rect2, rect1, rect2);
+		RECT rect2 = new RECT ();
+		OS.GetWindowRect (hwndShell, rect2);
+		OS.IntersectRect (rect2, rect1, rect2);
 			fixPrintWindow = !OS.EqualRect (rect2, rect1);
 		}
 		/*
@@ -2246,12 +2262,12 @@
 		}
 		if (fixPrintWindow) {
 			int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-			int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+			int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 			int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 			int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 			int flags = OS.SWP_NOSIZE | OS.SWP_NOZORDER | OS.SWP_NOACTIVATE | OS.SWP_DRAWFRAME;
 			if ((bits1 & OS.WS_VISIBLE) != 0) {
-				OS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);
+			OS.DefWindowProc (hwnd, OS.WM_SETREDRAW, 0, 0);
 			}
 			SetWindowPos (hwnd, 0, x + width, y + height, 0, 0, flags);
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -2290,7 +2306,7 @@
 			}
 		}
 	}
-	
+
 	/*
 	* Bug in Windows.  For some reason, PrintWindow() fails
 	* when it is called on a push button.  The fix is to
@@ -2341,7 +2357,7 @@
 }
 /**
  * Causes the rectangular area of the receiver specified by
- * the arguments to be marked as needing to be redrawn. 
+ * the arguments to be marked as needing to be redrawn.
  * The next time a paint request is processed, that area of
  * the receiver will be painted, including the background.
  * If the <code>all</code> flag is <code>true</code>, any
@@ -2484,7 +2500,7 @@
  *
  * @see DragDetectListener
  * @see #addDragDetectListener
- * 
+ *
  * @since 3.3
  */
 public void removeDragDetectListener(DragDetectListener listener) {
@@ -2535,7 +2551,7 @@
  *
  * @see GestureListener
  * @see #addGestureListener
- * 
+ *
  * @since 3.7
  */
 public void removeGestureListener (GestureListener listener) {
@@ -2805,7 +2821,7 @@
 
 boolean sendFocusEvent (int type) {
 	Shell shell = getShell ();
-	
+
 	/*
 	* Feature in Windows.  During the processing of WM_KILLFOCUS,
 	* when the focus window is queried using GetFocus(), it has
@@ -2829,7 +2845,7 @@
 	* disposed at this point.  If this happens
 	* don't send the activate and deactivate
 	* events.
-	*/	
+	*/
 	if (!shell.isDisposed ()) {
 		switch (type) {
 			case SWT.FocusIn:
@@ -2870,10 +2886,10 @@
 			}
 
 			/*
-			* The gi.ullArguments is the distance between the fingers. 
+			* The gi.ullArguments is the distance between the fingers.
 			* Scale factor is relative to that original value.
 			*/
-			if (fingerDistance == display.lastDistance && event.detail == SWT.GESTURE_MAGNIFY) return true;			
+			if (fingerDistance == display.lastDistance && event.detail == SWT.GESTURE_MAGNIFY) return true;
 			if (fingerDistance != 0) event.magnification = fingerDistance / display.magStartDistance;
 			display.lastDistance = fingerDistance;
 			break;
@@ -2891,10 +2907,10 @@
 			event.xDirection = point.x - display.lastX;
 			event.yDirection = point.y - display.lastY;
 			display.lastX = point.x;
-			display.lastY = point.y;			
+			display.lastY = point.y;
 			break;
 		case OS.GID_ROTATE:
-			type = SWT.Gesture;			
+			type = SWT.Gesture;
 			event.detail = SWT.GESTURE_ROTATE;
 			double rotationInRadians = OS.GID_ROTATE_ANGLE_FROM_ARGUMENT (OS.LODWORD (gi.ullArguments));
 			if ((gi.dwFlags & OS.GF_BEGIN) != 0) {
@@ -2919,7 +2935,7 @@
 
     if (type == 0) return true;
 	setInputState (event, type);
-	sendEvent (type, event);	
+	sendEvent (type, event);
 	return event.doit;
 }
 
@@ -2980,7 +2996,7 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3011,14 +3027,14 @@
  * @param image the new image (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setBackgroundImage (Image image) {
@@ -3054,9 +3070,9 @@
 
 /**
  * Sets the receiver's size and location to the rectangular
- * area specified by the arguments. The <code>x</code> and 
+ * area specified by the arguments. The <code>x</code> and
  * <code>y</code> arguments are relative to the receiver's
- * parent (or its display if its parent is null), unless 
+ * parent (or its display if its parent is null), unless
  * the receiver is a shell. In this case, the <code>x</code>
  * and <code>y</code> arguments are relative to the display.
  * <p>
@@ -3086,21 +3102,21 @@
 }
 
 void setBounds (int x, int y, int width, int height, int flags, boolean defer) {
-	if (findImageControl () != null) {
+			if (findImageControl () != null) {
 		if (backgroundImage == null) flags |= OS.SWP_NOCOPYBITS;
-	} else {
+			} else {
 		if (OS.GetWindow (handle, OS.GW_CHILD) == 0) {
-			if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {
-				if (findThemeControl () != null) flags |= OS.SWP_NOCOPYBITS;
+				if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {
+					if (findThemeControl () != null) flags |= OS.SWP_NOCOPYBITS;
+				}
 			}
 		}
-	}
 	int /*long*/ topHandle = topHandle ();
 	if (defer && parent != null) {
 		forceResize ();
 		if (parent.lpwp != null) {
 			int index = 0;
-			WINDOWPOS [] lpwp = parent.lpwp;
+		WINDOWPOS [] lpwp = parent.lpwp;
 			while (index < lpwp.length) {
 				if (lpwp [index] == null) break;
 				index ++;
@@ -3120,13 +3136,13 @@
 			lpwp [index] = wp;
 			return;
 		}
-	}
-	SetWindowPos (topHandle, 0, x, y, width, height, flags);
+		}
+		SetWindowPos (topHandle, 0, x, y, width, height, flags);
 }
 
 /**
  * Sets the receiver's size and location to the rectangular
- * area specified by the argument. The <code>x</code> and 
+ * area specified by the argument. The <code>x</code> and
  * <code>y</code> fields of the rectangle are relative to
  * the receiver's parent (or its display if its parent is null).
  * <p>
@@ -3189,7 +3205,7 @@
  * @param cursor the new cursor (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3208,7 +3224,8 @@
 	int /*long*/ hwndCursor = OS.GetCapture ();
 	if (hwndCursor == 0) {
 		POINT pt = new POINT ();
-		if (!OS.GetCursorPos (pt)) return;
+                // <QFS/> Get overridden cursor position
+		if (!OS._GetCursorPos (pt)) return;
 		int /*long*/ hwnd = hwndCursor = OS.WindowFromPoint (pt);
 		while (hwnd != 0 && hwnd != handle) {
 			hwnd = OS.GetParent (hwnd);
@@ -3236,7 +3253,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public void setDragDetect (boolean dragDetect) {
@@ -3284,7 +3301,7 @@
 }
 
 /**
- * Causes the receiver to have the <em>keyboard focus</em>, 
+ * Causes the receiver to have the <em>keyboard focus</em>,
  * such that all keyboard events will be delivered to it.  Focus
  * reassignment will respect applicable platform constraints.
  *
@@ -3311,7 +3328,7 @@
  * @param font the new font (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3321,7 +3338,7 @@
 public void setFont (Font font) {
 	checkWidget ();
 	int /*long*/ hFont = 0;
-	if (font != null) { 
+	if (font != null) {
 		if (font.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
 		hFont = font.handle;
 	}
@@ -3340,7 +3357,7 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3365,9 +3382,9 @@
 
 /**
  * Sets the layout data associated with the receiver to the argument.
- * 
+ *
  * @param layoutData the new layout data for the receiver.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3381,9 +3398,9 @@
 /**
  * Sets the receiver's location to the point specified by
  * the arguments which are relative to the receiver's
- * parent (or its display if its parent is null), unless 
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * parent (or its display if its parent is null), unless
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @param x the new x coordinate for the receiver
  * @param y the new y coordinate for the receiver
@@ -3409,9 +3426,9 @@
 /**
  * Sets the receiver's location to the point specified by
  * the arguments which are relative to the receiver's
- * parent (or its display if its parent is null), unless 
- * the receiver is a shell. In this case, the point is 
- * relative to the display. 
+ * parent (or its display if its parent is null), unless
+ * the receiver is a shell. In this case, the point is
+ * relative to the display.
  *
  * @param location the new location for the receiver
  *
@@ -3444,7 +3461,7 @@
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_MENU_NOT_POP_UP - the menu is not a pop up menu</li>
  *    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -3471,12 +3488,12 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public void setOrientation (int orientation) {
@@ -3519,7 +3536,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #redraw(int, int, int, int, boolean)
  * @see #update()
  */
@@ -3575,7 +3592,7 @@
  *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the region has been disposed</li>
- * </ul>  
+ * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3652,7 +3669,7 @@
 
 /**
  * Sets the receiver's tool tip text to the argument, which
- * may be null indicating that the default tool tip for the 
+ * may be null indicating that the default tool tip for the
  * control will be shown. For a control that has a default
  * tool tip, such as the Tree control on Windows, setting
  * the tool tip text to an empty string replaces the default,
@@ -3659,10 +3676,10 @@
  * causing no tool tip text to be shown.
  * <p>
  * The mnemonic indicator (character '&amp;') is not displayed in a tool tip.
- * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
+ * To display a single '&amp;' in the tool tip, the character '&amp;' can be
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -3685,9 +3702,9 @@
  * Setting this to <code>false</code> causes the receiver to send gesture events
  * instead.  No exception is thrown if a touch-based input device is not
  * detected (this can be determined with <code>Display#getTouchEnabled()</code>).
- * 
+ *
  * @param enabled the new touch-enabled state
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3707,7 +3724,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -3733,7 +3750,7 @@
 		sendEvent (SWT.Show);
 		if (isDisposed ()) return;
 	}
-	
+
 	/*
 	* Feature in Windows.  If the receiver has focus, hiding
 	* the receiver causes no window to have focus.  The fix is
@@ -3798,13 +3815,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public Point toControl (int x, int y) {
 	checkWidget ();
 	POINT pt = new POINT ();
-	pt.x = x;  pt.y = y; 
+	pt.x = x;  pt.y = y;
 	OS.ScreenToClient (handle, pt);
 	return new Point (pt.x, pt.y);
 }
@@ -3844,13 +3861,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public Point toDisplay (int x, int y) {
 	checkWidget ();
 	POINT pt = new POINT ();
-	pt.x = x;  pt.y = y; 
+	pt.x = x;  pt.y = y;
 	OS.ClientToScreen (handle, pt);
 	return new Point (pt.x, pt.y);
 }
@@ -3895,7 +3912,8 @@
 boolean translateMnemonic (MSG msg) {
 	if (msg.wParam < 0x20) return false;
 	int /*long*/ hwnd = msg.hwnd;
-	if (OS.GetKeyState (OS.VK_MENU) >= 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_MENU) >= 0) {
 		int /*long*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 		if ((code & OS.DLGC_WANTALLKEYS) != 0) return false;
 		if ((code & OS.DLGC_BUTTON) == 0) return false;
@@ -3914,11 +3932,18 @@
 }
 
 boolean translateTraversal (MSG msg) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("translateTraversal(MSG)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(msg)).log(Log.MTD);
+    }
+    // </QFS>
 	int /*long*/ hwnd = msg.hwnd;
 	int key = (int)/*64*/msg.wParam;
 	if (key == OS.VK_MENU) {
 		if ((msg.lParam & 0x40000000) == 0) {
-			OS.SendMessage (hwnd, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
+		OS.SendMessage (hwnd, OS.WM_CHANGEUISTATE, OS.UIS_INITIALIZE, 0);
 		}
 		return false;
 	}
@@ -3954,7 +3979,8 @@
 		}
 		case OS.VK_TAB: {
 			lastAscii = '\t';
-			boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 			int /*long*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 			if ((code & (OS.DLGC_WANTTAB | OS.DLGC_WANTALLKEYS)) != 0) {
 				/*
@@ -3966,7 +3992,8 @@
 				* Shift+Tab to the control.
 				*/
 				if ((code & OS.DLGC_HASSETSEL) != 0) {
-					if (next && OS.GetKeyState (OS.VK_CONTROL) >= 0) {
+                                        // <QFS/> Changed to getDisplay().GetKeyState
+					if (next && getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) {
 						doit = false;
 					}
 				} else {
@@ -4002,7 +4029,8 @@
 		case OS.VK_NEXT: {
 			all = true;
 			lastVirtual = true;
-			if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return false;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return false;
 			int /*long*/ code = OS.SendMessage (hwnd, OS.WM_GETDLGCODE, 0, 0);
 			if ((code & OS.DLGC_WANTALLKEYS) != 0) {
 				/*
@@ -4025,7 +4053,15 @@
 	display.lastAscii = lastAscii;
 	display.lastVirtual = lastVirtual;
 	display.lastNull = display.lastDead = false;
-	if (!setKeyState (event, SWT.Traverse, msg.wParam, msg.lParam)) return false;
+	if (!setKeyState (event, SWT.Traverse, msg.wParam, msg.lParam)) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "translateTraversal(MSG)",
+                           "setKeyState returned false");
+            }
+            // </QFS>
+            return false;
+        }
 	Shell shell = getShell ();
 	Control control = this;
 	do {
@@ -4046,7 +4082,7 @@
 	* code could have disposed the widget in the traverse
 	* event.  If this happens, return true to stop further
 	* event processing.
-	*/	
+	*/
 	sendEvent (SWT.Traverse, event);
 	if (isDisposed ()) return true;
 	if (!event.doit) return false;
@@ -4058,7 +4094,7 @@
 		case SWT.TRAVERSE_TAB_PREVIOUS:	return traverseGroup (false);
 		case SWT.TRAVERSE_ARROW_NEXT:		return traverseItem (true);
 		case SWT.TRAVERSE_ARROW_PREVIOUS:	return traverseItem (false);
-		case SWT.TRAVERSE_MNEMONIC:		return traverseMnemonic (event.character);	
+		case SWT.TRAVERSE_MNEMONIC:		return traverseMnemonic (event.character);
 		case SWT.TRAVERSE_PAGE_NEXT:		return traversePage (true);
 		case SWT.TRAVERSE_PAGE_PREVIOUS:	return traversePage (false);
 	}
@@ -4068,8 +4104,8 @@
 /**
  * Based on the argument, perform one of the expected platform
  * traversal action. The argument should be one of the constants:
- * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>, 
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  *
@@ -4091,11 +4127,11 @@
 
 /**
  * Performs a platform traversal action corresponding to a <code>KeyDown</code> event.
- * 
+ *
  * <p>Valid traversal values are
  * <code>SWT.TRAVERSE_NONE</code>, <code>SWT.TRAVERSE_MNEMONIC</code>,
  * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  * If <code>traversal</code> is <code>SWT.TRAVERSE_NONE</code> then the Traverse
@@ -4102,13 +4138,13 @@
  * event is created with standard values based on the KeyDown event.  If
  * <code>traversal</code> is one of the other traversal constants then the Traverse
  * event is created with this detail, and its <code>doit</code> is taken from the
- * KeyDown event. 
+ * KeyDown event.
  * </p>
  *
  * @param traversal the type of traversal, or <code>SWT.TRAVERSE_NONE</code> to compute
  * this from <code>event</code>
  * @param event the KeyDown event
- * 
+ *
  * @return <code>true</code> if the traversal succeeded
  *
  * @exception IllegalArgumentException <ul>
@@ -4129,11 +4165,11 @@
 
 /**
  * Performs a platform traversal action corresponding to a <code>KeyDown</code> event.
- * 
+ *
  * <p>Valid traversal values are
  * <code>SWT.TRAVERSE_NONE</code>, <code>SWT.TRAVERSE_MNEMONIC</code>,
  * <code>SWT.TRAVERSE_ESCAPE</code>, <code>SWT.TRAVERSE_RETURN</code>,
- * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>, 
+ * <code>SWT.TRAVERSE_TAB_NEXT</code>, <code>SWT.TRAVERSE_TAB_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_ARROW_NEXT</code>, <code>SWT.TRAVERSE_ARROW_PREVIOUS</code>,
  * <code>SWT.TRAVERSE_PAGE_NEXT</code> and <code>SWT.TRAVERSE_PAGE_PREVIOUS</code>.
  * If <code>traversal</code> is <code>SWT.TRAVERSE_NONE</code> then the Traverse
@@ -4140,13 +4176,13 @@
  * event is created with standard values based on the KeyDown event.  If
  * <code>traversal</code> is one of the other traversal constants then the Traverse
  * event is created with this detail, and its <code>doit</code> is taken from the
- * KeyDown event. 
+ * KeyDown event.
  * </p>
  *
  * @param traversal the type of traversal, or <code>SWT.TRAVERSE_NONE</code> to compute
  * this from <code>event</code>
  * @param event the KeyDown event
- * 
+ *
  * @return <code>true</code> if the traversal succeeded
  *
  * @exception IllegalArgumentException <ul>
@@ -4443,7 +4479,7 @@
 	*/
 	if (OS.WIN32_VERSION < OS.VERSION (4, 10)) {
 		return bits;
-	} 
+	}
 	bits |= OS.WS_EX_NOINHERITLAYOUT;
 	if ((style & SWT.RIGHT_TO_LEFT) != 0) bits |= OS.WS_EX_LAYOUTRTL;
 	return bits;
@@ -4463,7 +4499,7 @@
 		if ((style & SWT.BORDER) != 0) bits |= OS.WS_BORDER;
 	}
 	return bits;
-	
+
 	/*
 	* This code is intentionally commented.  When clipping
 	* of both siblings and children is not enforced, it is
@@ -4486,7 +4522,7 @@
  *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
- *    <li>ERROR_NULL_ARGUMENT - if the parent is <code>null</code></li> 
+ *    <li>ERROR_NULL_ARGUMENT - if the parent is <code>null</code></li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -4509,7 +4545,7 @@
 	int /*long*/ topHandle = topHandle ();
 	if (OS.SetParent (topHandle, parent.handle) == 0) return false;
 	this.parent = parent;
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (topHandle, OS.HWND_BOTTOM, 0, 0, 0, 0, flags);
 	reskin (SWT.ALL);
 	return true;
@@ -4520,7 +4556,20 @@
 abstract int /*long*/ windowProc ();
 
 int /*long*/ windowProc (int /*long*/ hwnd, int msg, int /*long*/ wParam, int /*long*/ lParam) {
-	LRESULT result = null;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("windowProc(int,int,int,int)");
+        boolean[] hasMatch = new boolean[1];
+        String msgtype = OS.getWinMsgType(msg, hasMatch);
+        (logger.level < Log.MTD ? lb : lb
+         .add("hwnd: ").addHex(hwnd)
+         .add(", class=").add(this.getClass().getName())
+         .add(", msg: ").add(OS.getWinMsgType(msg, null))
+         .add(", wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT result = null;
 	switch (msg) {
 		case OS.WM_ACTIVATE:			result = WM_ACTIVATE (wParam, lParam); break;
 		case OS.WM_CAPTURECHANGED:		result = WM_CAPTURECHANGED (wParam, lParam); break;
@@ -4556,7 +4605,7 @@
 		case OS.WM_IME_ENDCOMPOSITION:	result = WM_IME_ENDCOMPOSITION (wParam, lParam); break;
 		case OS.WM_INITMENUPOPUP:		result = WM_INITMENUPOPUP (wParam, lParam); break;
 		case OS.WM_INPUTLANGCHANGE:		result = WM_INPUTLANGCHANGE (wParam, lParam); break;
-		case OS.WM_HOTKEY:				result = WM_HOTKEY (wParam, lParam); break;		
+		case OS.WM_HOTKEY:				result = WM_HOTKEY (wParam, lParam); break;
 		case OS.WM_KEYDOWN:				result = WM_KEYDOWN (wParam, lParam); break;
 		case OS.WM_KEYUP:				result = WM_KEYUP (wParam, lParam); break;
 		case OS.WM_KILLFOCUS:			result = WM_KILLFOCUS (wParam, lParam); break;
@@ -4649,7 +4698,15 @@
 }
 
 LRESULT WM_COMMAND (int /*long*/ wParam, int /*long*/ lParam) {
-	/*
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_COMMAND(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+        /*
 	* When the WM_COMMAND message is sent from a
 	* menu, the HWND parameter in LPARAM is zero.
 	*/
@@ -4658,6 +4715,12 @@
 		if (shell.isEnabled ()) {
 			int id = OS.LOWORD (wParam);
 			MenuItem item = display.getMenuItem (id);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("WM_COMMAND(int,int)")
+                                .add("item: ").add(item).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (item != null && item.isEnabled ()) {
 				return item.wmCommandChild (wParam, lParam);
 			}
@@ -4732,7 +4795,7 @@
 		if (OS.GetGestureInfo (lParam, gi)) {
 			if (!sendGestureEvent (gi)) {
 				OS.CloseGestureInfoHandle (lParam);
-				return LRESULT.ZERO; 
+				return LRESULT.ZERO;
 			}
 		}
 	}
@@ -4796,6 +4859,14 @@
 }
 
 LRESULT WM_HSCROLL (int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_HSCROLL(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	Control control = display.getControl (lParam);
 	if (control == null) return null;
 	return control.wmScrollChild (wParam, lParam);
@@ -4828,7 +4899,15 @@
 }
 
 LRESULT WM_INITMENUPOPUP (int /*long*/ wParam, int /*long*/ lParam) {
-	
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_INITMENUPOPUP(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+
 	/* Ignore WM_INITMENUPOPUP for an accelerator */
 	if (display.accelKeyHit) return null;
 
@@ -4839,10 +4918,22 @@
 	*/
 	Shell shell = getShell ();
 	Menu oldMenu = shell.activeMenu, newMenu = null;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(int,int)")
+                .add("oldMenu: ").add(oldMenu).log(Log.DBG);
+        }
+        // </QFS>
 	if (OS.HIWORD (lParam) == 0) {
 		newMenu = menuShell ().findMenu (wParam);
 		if (newMenu != null) newMenu.update ();
-	}	
+	}
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(int,int)")
+                .add("newMenu: ").add(newMenu).log(Log.DBG);
+        }
+        // </QFS>
 	Menu menu = newMenu;
 	while (menu != null && menu != oldMenu) {
 		menu = menu.getParentMenu ();
@@ -4867,7 +4958,7 @@
 			if (ancestor != null) break;
 		}
 	}
-	
+
 	/*
 	* The shell and the new menu may be disposed because of
 	* sending the hide event to the ancestor menus but setting
@@ -4875,9 +4966,21 @@
 	*/
 	if (newMenu != null && newMenu.isDisposed ()) newMenu = null;
 	shell.activeMenu = newMenu;
-	
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("WM_INITMENUPOPUP(int,int)")
+                .add("shell.activeMenu: ").add(shell.activeMenu).log(Log.DBG);
+        }
+        // </QFS>
+
 	/* Send the show event */
 	if (newMenu != null && newMenu != oldMenu) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.build("WM_INITMENUPOPUP(int,int)")
+                    .add("show newMenu: ").add(newMenu).log(Log.DBG);
+            }
+            // </QFS>
 		newMenu.sendEvent (SWT.Show);
 		// widget could be disposed at this point
 	}
@@ -4889,11 +4992,43 @@
 }
 
 LRESULT WM_KEYDOWN (int /*long*/ wParam, int /*long*/ lParam) {
-	return wmKeyDown (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_KEYDOWN(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT lresult = wmKeyDown (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTDDETAIL) {
+        logger.log(Log.MTDDETAIL, "WM_KEYDOWN(int,int)",
+                   "lresult="+(lresult == null ? "null" : ""+lresult.value));
+    }
+    // </QFS>
+
+    return lresult;
 }
 
 LRESULT WM_KEYUP (int /*long*/ wParam, int /*long*/ lParam) {
-	return wmKeyUp (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_KEYDOWN(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT lresult = wmKeyUp (handle, wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTDDETAIL) {
+        logger.log(Log.MTDDETAIL, "WM_KEYUP(int,int)",
+                   "lresult="+(lresult == null ? "null" : ""+lresult.value));
+    }
+    // </QFS>
+
+    return lresult;
 }
 
 LRESULT WM_KILLFOCUS (int /*long*/ wParam, int /*long*/ lParam) {
@@ -4956,6 +5091,14 @@
 }
 
 LRESULT WM_MENUSELECT (int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_MENUSELECT(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	int code = OS.HIWORD (wParam);
 	Shell shell = getShell ();
 	if (code == 0xFFFF && lParam == 0) {
@@ -4988,6 +5131,12 @@
 		* to null in a destroyed widget is not harmful.
 		*/
 		shell.activeMenu = null;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("WM_MENUSELECT(int,int)")
+                        .add("shell.activeMenu: ").add(shell.activeMenu).log(Log.DBG);
+                }
+                // </QFS>
 		return null;
 	}
 	if ((code & OS.MF_SYSMENU) != 0) return null;
@@ -5002,7 +5151,7 @@
 			if (OS.GetMenuItemInfo (lParam, index, true, info)) {
 				Menu newMenu = menuShell.findMenu (info.hSubMenu);
 				if (newMenu != null) item = newMenu.cascade;
-			}	
+			}
 		} else {
 			Menu newMenu = menuShell.findMenu (lParam);
 			if (newMenu != null) {
@@ -5189,7 +5338,7 @@
 	* a user menu item that was added to the System menu.
 	* When a user item is added to the System menu,
 	* WM_SYSCOMMAND must always return zero.
-	* 
+	*
 	* NOTE: This is undocumented.
 	*/
 	if ((wParam & 0xF000) == 0) {
@@ -5218,7 +5367,7 @@
 			* moves focus to the System menu but this can be achieved
 			* using Alt+Space.  To allow the application to see F10,
 			* avoid running the default window proc.
-			* 
+			*
 			* NOTE:  When F10 is pressed, WM_SYSCOMMAND is sent to the
 			* shell, not the focus control.  This is undocumented Windows
 			* behavior.
@@ -5245,7 +5394,7 @@
 				* matching the mnemonic character.  To allow the application
 				* to see the keystrokes in this case, avoid running the default
 				* window proc.
-				* 
+				*
 				* NOTE: When the user types Alt+Space, the System menu is
 				* activated.  In this case the application should not see
 				* the keystroke.
@@ -5351,7 +5500,7 @@
 			event.yDirection = 1;
 			break;
 	}
-	
+
 	event.x = fPoint.x;
 	event.y = fPoint.y;
 	event.type = SWT.Gesture;
@@ -5375,7 +5524,7 @@
 					OS.MoveMemory (ti [i], pInputs + i * TOUCHINPUT.sizeof, TOUCHINPUT.sizeof);
 				}
 				sendTouchEvent (ti);
-				OS.CloseTouchInputHandle (lParam); 
+				OS.CloseTouchInputHandle (lParam);
 				result = LRESULT.ZERO;
 			}
 			OS.HeapFree (hHeap, 0, pInputs);
@@ -5397,6 +5546,14 @@
 }
 
 LRESULT WM_VSCROLL (int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_VSCROLL(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	Control control = display.getControl (lParam);
 	if (control == null) return null;
 	return control.wmScrollChild (wParam, lParam);
@@ -5431,9 +5588,9 @@
 				int height = rect.bottom - rect.top;
 				if (width != 0 && height != 0) {
 					int /*long*/ hwndParent = parent == null ? 0 : parent.handle;
-					OS.MapWindowPoints (0, hwndParent, rect, 2);
+				OS.MapWindowPoints (0, hwndParent, rect, 2);
 					if (OS.IsWinCE) {
-						OS.InvalidateRect (hwndParent, rect, true);
+				OS.InvalidateRect (hwndParent, rect, true);
 					} else {
 						int /*long*/ rgn1 = OS.CreateRectRgn (rect.left, rect.top, rect.right, rect.bottom);
 						int /*long*/ rgn2 = OS.CreateRectRgn (lpwp.x, lpwp.y, lpwp.x + lpwp.cx, lpwp.y + lpwp.cy);
Index: org/eclipse/swt/widgets/Event.java
===================================================================
--- org/eclipse/swt/widgets/Event.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Event.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -203,7 +203,7 @@
 	 */
 	public String text;
 
-	/** 
+	/**
 	 * Bidi segment offsets
 	 * @since 3.8
 	 */
Index: org/eclipse/swt/widgets/MenuItem.java
===================================================================
--- org/eclipse/swt/widgets/MenuItem.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/MenuItem.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,18 +7,24 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class represent a selectable user interface object
- * that issues notification when pressed and released. 
+ * that issues notification when pressed and released.
  * <dl>
  * <dt><b>Styles:</b></dt>
  * <dd>CHECK, CASCADE, PUSH, RADIO, SEPARATOR</dd>
@@ -50,6 +56,13 @@
 	*/
 	final static int MARGIN_WIDTH = OS.IsWin95 ? 2 : 1;
 	final static int MARGIN_HEIGHT = OS.IsWin95 ? 2 : 1;
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.MenuItem");
+    // </QFS>
 
 /**
  * Constructs a new instance of this class given its parent
@@ -59,7 +72,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -86,9 +99,9 @@
  * @see Widget#getStyle
  */
 public MenuItem (Menu parent, int style) {
-	super (parent, checkStyle (style));
-	this.parent = parent;
-	parent.createItem (this, parent.getItemCount ());
+        super (parent, checkStyle (style));
+        this.parent = parent;
+        parent.createItem (this, parent.getItemCount ());
 }
 
 /**
@@ -99,7 +112,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -128,17 +141,17 @@
  * @see Widget#getStyle
  */
 public MenuItem (Menu parent, int style, int index) {
-	super (parent, checkStyle (style));
-	this.parent = parent;
-	parent.createItem (this, index);
+        super (parent, checkStyle (style));
+        this.parent = parent;
+        parent.createItem (this, index);
 }
 
 MenuItem (Menu parent, Menu menu, int style, int index) {
-	super (parent, checkStyle (style));
-	this.parent = parent;
-	this.menu = menu;	
-	if (menu != null) menu.cascade = this;
-	display.addMenuItem (this);
+        super (parent, checkStyle (style));
+        this.parent = parent;
+        this.menu = menu;
+        if (menu != null) menu.cascade = this;
+        display.addMenuItem (this);
 }
 
 /**
@@ -161,10 +174,10 @@
  * @see #removeArmListener
  */
 public void addArmListener (ArmListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener (listener);
-	addListener (SWT.Arm, typedListener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        TypedListener typedListener = new TypedListener (listener);
+        addListener (SWT.Arm, typedListener);
 }
 
 /**
@@ -187,10 +200,10 @@
  * @see #removeHelpListener
  */
 public void addHelpListener (HelpListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener (listener);
-	addListener (SWT.Help, typedListener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        TypedListener typedListener = new TypedListener (listener);
+        addListener (SWT.Help, typedListener);
 }
 
 /**
@@ -208,7 +221,7 @@
  * was selected by the user. During <code>widgetSelected</code> the application can use
  * <code>getSelection()</code> to determine the current selected state of the receiver.
  * </p>
- * 
+ *
  * @param listener the listener which should be notified when the menu item is selected by the user
  *
  * @exception IllegalArgumentException <ul>
@@ -224,19 +237,19 @@
  * @see SelectionEvent
  */
 public void addSelectionListener (SelectionListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener(listener);
-	addListener (SWT.Selection,typedListener);
-	addListener (SWT.DefaultSelection,typedListener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        TypedListener typedListener = new TypedListener(listener);
+        addListener (SWT.Selection,typedListener);
+        addListener (SWT.DefaultSelection,typedListener);
 }
 
 protected void checkSubclass () {
-	if (!isValidSubclass ()) error (SWT.ERROR_INVALID_SUBCLASS);
+        if (!isValidSubclass ()) error (SWT.ERROR_INVALID_SUBCLASS);
 }
 
 static int checkStyle (int style) {
-	return checkBits (style, SWT.PUSH, SWT.CHECK, SWT.RADIO, SWT.SEPARATOR, SWT.CASCADE, 0);
+        return checkBits (style, SWT.PUSH, SWT.CHECK, SWT.RADIO, SWT.SEPARATOR, SWT.CASCADE, 0);
 }
 
 void destroyWidget () {
@@ -248,48 +261,48 @@
 	accel.cmd = accel.key = accel.fVirt = 0;
 	if (accelerator == 0 || !getEnabled ()) return false;
 	if ((accelerator & SWT.COMMAND) != 0) return false;
-	int fVirt = OS.FVIRTKEY;
-	int key = accelerator & SWT.KEY_MASK;
-	int vKey = Display.untranslateKey (key);
-	if (vKey != 0) {
-		key = vKey;	
-	} else {
-		switch (key) {
-			/*
-			* Bug in Windows.  For some reason, VkKeyScan
-			* fails to map ESC to VK_ESCAPE and DEL to
-			* VK_DELETE.  The fix is to map these keys
-			* as a special case.
-			*/
-			case 27: key = OS.VK_ESCAPE; break;
-			case 127: key = OS.VK_DELETE; break;
-			default: {
-				key = Display.wcsToMbcs ((char) key);
+        int fVirt = OS.FVIRTKEY;
+        int key = accelerator & SWT.KEY_MASK;
+        int vKey = Display.untranslateKey (key);
+        if (vKey != 0) {
+                key = vKey;
+        } else {
+                switch (key) {
+                        /*
+                        * Bug in Windows.  For some reason, VkKeyScan
+                        * fails to map ESC to VK_ESCAPE and DEL to
+                        * VK_DELETE.  The fix is to map these keys
+                        * as a special case.
+                        */
+                        case 27: key = OS.VK_ESCAPE; break;
+                        case 127: key = OS.VK_DELETE; break;
+                        default: {
+                                key = Display.wcsToMbcs ((char) key);
 				if (key == 0) return false;
-				if (OS.IsWinCE) {
+                                if (OS.IsWinCE) {
 					key = (int)/*64*/OS.CharUpper ((short) key);
-				} else {
-					vKey = OS.VkKeyScan ((short) key) & 0xFF;
-					if (vKey == -1) {
-						fVirt = 0;
-					} else {
-						key = vKey;
-					}
-				}
-			}
-		}
-	}
-	accel.key = (short) key;
-	accel.cmd = (short) id;
-	accel.fVirt = (byte) fVirt;
-	if ((accelerator & SWT.ALT) != 0) accel.fVirt |= OS.FALT;
-	if ((accelerator & SWT.SHIFT) != 0) accel.fVirt |= OS.FSHIFT;
-	if ((accelerator & SWT.CONTROL) != 0) accel.fVirt |= OS.FCONTROL;
+                                } else {
+                                        vKey = OS.VkKeyScan ((short) key) & 0xFF;
+                                        if (vKey == -1) {
+                                                fVirt = 0;
+                                        } else {
+                                                key = vKey;
+                                        }
+                                }
+                        }
+                }
+        }
+        accel.key = (short) key;
+        accel.cmd = (short) id;
+        accel.fVirt = (byte) fVirt;
+        if ((accelerator & SWT.ALT) != 0) accel.fVirt |= OS.FALT;
+        if ((accelerator & SWT.SHIFT) != 0) accel.fVirt |= OS.FSHIFT;
+        if ((accelerator & SWT.CONTROL) != 0) accel.fVirt |= OS.FCONTROL;
 	return true;
 }
 
 void fixMenus (Decorations newParent) {
-	if (menu != null) menu.fixMenus (newParent);
+        if (menu != null) menu.fixMenus (newParent);
 }
 
 /**
@@ -308,8 +321,8 @@
  * </ul>
  */
 public int getAccelerator () {
-	checkWidget ();
-	return accelerator;
+        checkWidget ();
+        return accelerator;
 }
 
 /**
@@ -322,51 +335,58 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
-/*public*/ Rectangle getBounds () {
-	checkWidget ();
-	if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
-	int index = parent.indexOf (this);
-	if (index == -1) return new Rectangle (0, 0, 0, 0);
-	if ((parent.style & SWT.BAR) != 0) {
-		Decorations shell = parent.parent;
-		if (shell.menuBar != parent) {
-			return new Rectangle (0, 0, 0, 0);
-		}
+// <QFS/> Made public.
+public Rectangle getBounds () {
+        checkWidget ();
+        if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
+        int index = parent.indexOf (this);
+        if (index == -1) return new Rectangle (0, 0, 0, 0);
+        if ((parent.style & SWT.BAR) != 0) {
+                Decorations shell = parent.parent;
+                if (shell.menuBar != parent) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
 		int /*long*/ hwndShell = shell.handle;
-		MENUBARINFO info1 = new MENUBARINFO ();
-		info1.cbSize = MENUBARINFO.sizeof;
-		if (!OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, 1, info1)) {
-			return new Rectangle (0, 0, 0, 0);
-		}
-		MENUBARINFO info2 = new MENUBARINFO ();
-		info2.cbSize = MENUBARINFO.sizeof;
-		if (!OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, index + 1, info2)) {
-			return new Rectangle (0, 0, 0, 0);
-		}
-		int x = info2.left - info1.left;
-		int y = info2.top - info1.top;
-		int width = info2.right - info2.left;
-		int height = info2.bottom - info2.top;
-		return new Rectangle (x, y, width, height);
-	} else {
+                MENUBARINFO info1 = new MENUBARINFO ();
+                info1.cbSize = MENUBARINFO.sizeof;
+                if (!OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, 1, info1)) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
+                MENUBARINFO info2 = new MENUBARINFO ();
+                info2.cbSize = MENUBARINFO.sizeof;
+                if (!OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, index + 1, info2)) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
+                int x = info2.left - info1.left;
+                int y = info2.top - info1.top;
+                int width = info2.right - info2.left;
+                int height = info2.bottom - info2.top;
+                return new Rectangle (x, y, width, height);
+        } else {
 		int /*long*/ hMenu = parent.handle;
-		RECT rect1 = new RECT ();
-		if (!OS.GetMenuItemRect (0, hMenu, 0, rect1)) {
-			return new Rectangle (0, 0, 0, 0);
-		}
-		RECT rect2 = new RECT ();
-		if (!OS.GetMenuItemRect (0, hMenu, index, rect2)) {
-			return new Rectangle (0, 0, 0, 0);
-		}
-		int x = rect2.left - rect1.left + 2;
-		int y = rect2.top - rect1.top + 2;
-		int width = rect2.right - rect2.left;
-		int height = rect2.bottom - rect2.top;
-		return new Rectangle (x, y, width, height);
-	}
+                RECT rect1 = new RECT ();
+                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                // Leave unchanged for now
+                // if (!OS.GetMenuItemRect (parent.getShell().handle, hMenu, 0, rect1)) {
+                if (!OS.GetMenuItemRect (0, hMenu, 0, rect1)) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
+                RECT rect2 = new RECT ();
+                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                // Leave unchanged for now
+                // if (!OS.GetMenuItemRect (parent.getShell().handle, hMenu, index, rect2)) {
+                if (!OS.GetMenuItemRect (0, hMenu, index, rect2)) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
+                int x = rect2.left - rect1.left + 2;
+                int y = rect2.top - rect1.top + 2;
+                int width = rect2.right - rect2.left;
+                int height = rect2.bottom - rect2.top;
+                return new Rectangle (x, y, width, height);
+        }
 }
 
 /**
@@ -381,19 +401,19 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
-	checkWidget ();
-	if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {
+        checkWidget ();
+        if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {
 		int /*long*/ hwndCB = parent.hwndCB;
-		TBBUTTONINFO info = new TBBUTTONINFO ();
-		info.cbSize = TBBUTTONINFO.sizeof;
-		info.dwMask = OS.TBIF_STATE;
-		OS.SendMessage (hwndCB, OS.TB_GETBUTTONINFO, id, info);
-		return (info.fsState & OS.TBSTATE_ENABLED) != 0;
-	}
+                TBBUTTONINFO info = new TBBUTTONINFO ();
+                info.cbSize = TBBUTTONINFO.sizeof;
+                info.dwMask = OS.TBIF_STATE;
+                OS.SendMessage (hwndCB, OS.TB_GETBUTTONINFO, id, info);
+                return (info.fsState & OS.TBSTATE_ENABLED) != 0;
+        }
 	/*
 	* Feature in Windows.  For some reason, when the menu item
 	* is a separator, GetMenuItemInfo() always indicates that
@@ -404,19 +424,19 @@
 		return (state & DISABLED) == 0;
 	}
 	int /*long*/ hMenu = parent.handle;
-	MENUITEMINFO info = new MENUITEMINFO ();
-	info.cbSize = MENUITEMINFO.sizeof;
-	info.fMask = OS.MIIM_STATE;
-	boolean success;
-	if (OS.IsWinCE) {
-		int index = parent.indexOf (this);
-		if (index == -1) error (SWT.ERROR_CANNOT_GET_ENABLED);
-		success = OS.GetMenuItemInfo (hMenu, index, true, info);
-	} else {
-		success = OS.GetMenuItemInfo (hMenu, id, false, info);
-	}
-	if (!success) error (SWT.ERROR_CANNOT_GET_ENABLED);
-	return (info.fState & (OS.MFS_DISABLED | OS.MFS_GRAYED)) == 0;
+        MENUITEMINFO info = new MENUITEMINFO ();
+        info.cbSize = MENUITEMINFO.sizeof;
+        info.fMask = OS.MIIM_STATE;
+        boolean success;
+        if (OS.IsWinCE) {
+                int index = parent.indexOf (this);
+                if (index == -1) error (SWT.ERROR_CANNOT_GET_ENABLED);
+                success = OS.GetMenuItemInfo (hMenu, index, true, info);
+        } else {
+                success = OS.GetMenuItemInfo (hMenu, id, false, info);
+        }
+        if (!success) error (SWT.ERROR_CANNOT_GET_ENABLED);
+        return (info.fState & (OS.MFS_DISABLED | OS.MFS_GRAYED)) == 0;
 }
 
 /**
@@ -439,7 +459,7 @@
 /**
  * Returns the receiver's cascade menu if it has one or null
  * if it does not. Only <code>CASCADE</code> menu items can have
- * a pull down menu. The sequence of key strokes, button presses 
+ * a pull down menu. The sequence of key strokes, button presses
  * and/or button releases that are used to request a pull down
  * menu is platform specific.
  *
@@ -451,13 +471,13 @@
  * </ul>
  */
 public Menu getMenu () {
-	checkWidget ();
-	return menu;
+        checkWidget ();
+        return menu;
 }
 
 String getNameText () {
-	if ((style & SWT.SEPARATOR) != 0) return "|";
-	return super.getNameText ();
+        if ((style & SWT.SEPARATOR) != 0) return "|";
+        return super.getNameText ();
 }
 
 /**
@@ -471,8 +491,8 @@
  * </ul>
  */
 public Menu getParent () {
-	checkWidget ();
-	return parent;
+        checkWidget ();
+        return parent;
 }
 
 /**
@@ -490,16 +510,16 @@
  * </ul>
  */
 public boolean getSelection () {
-	checkWidget ();
-	if ((style & (SWT.CHECK | SWT.RADIO)) == 0) return false;
-	if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) return false;
+        checkWidget ();
+        if ((style & (SWT.CHECK | SWT.RADIO)) == 0) return false;
+        if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) return false;
 	int /*long*/ hMenu = parent.handle;
-	MENUITEMINFO info = new MENUITEMINFO ();
-	info.cbSize = MENUITEMINFO.sizeof;
-	info.fMask = OS.MIIM_STATE;
-	boolean success = OS.GetMenuItemInfo (hMenu, id, false, info);
-	if (!success) error (SWT.ERROR_CANNOT_GET_SELECTION);
-	return (info.fState & OS.MFS_CHECKED) !=0;
+        MENUITEMINFO info = new MENUITEMINFO ();
+        info.cbSize = MENUITEMINFO.sizeof;
+        info.fMask = OS.MIIM_STATE;
+        boolean success = OS.GetMenuItemInfo (hMenu, id, false, info);
+        if (!success) error (SWT.ERROR_CANNOT_GET_SELECTION);
+        return (info.fState & OS.MFS_CHECKED) !=0;
 }
 
 /**
@@ -514,11 +534,11 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
-	return getEnabled () && parent.isEnabled ();
+        return getEnabled () && parent.isEnabled ();
 }
 
 void releaseChildren (boolean destroy) {
@@ -570,10 +590,10 @@
  * @see #addArmListener
  */
 public void removeArmListener (ArmListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (eventTable == null) return;
-	eventTable.unhook (SWT.Arm, listener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (eventTable == null) return;
+        eventTable.unhook (SWT.Arm, listener);
 }
 /**
  * Removes the listener from the collection of listeners who will
@@ -593,10 +613,10 @@
  * @see #addHelpListener
  */
 public void removeHelpListener (HelpListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (eventTable == null) return;
-	eventTable.unhook (SWT.Help, listener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (eventTable == null) return;
+        eventTable.unhook (SWT.Help, listener);
 }
 /**
  * Removes the listener from the collection of listeners who will
@@ -616,11 +636,11 @@
  * @see #addSelectionListener
  */
 public void removeSelectionListener (SelectionListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (eventTable == null) return;
-	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (eventTable == null) return;
+        eventTable.unhook (SWT.Selection, listener);
+        eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 
@@ -632,14 +652,14 @@
 }
 
 void selectRadio () {
-	int index = 0;
-	MenuItem [] items = parent.getItems ();
-	while (index < items.length && items [index] != this) index++;
-	int i = index - 1;
-	while (i >= 0 && items [i].setRadioSelection (false)) --i;
-	int j = index + 1;
-	while (j < items.length && items [j].setRadioSelection (false)) j++;
-	setSelection (true);
+        int index = 0;
+        MenuItem [] items = parent.getItems ();
+        while (index < items.length && items [index] != this) index++;
+        int i = index - 1;
+        while (i >= 0 && items [i].setRadioSelection (false)) --i;
+        int j = index + 1;
+        while (j < items.length && items [j].setRadioSelection (false)) j++;
+        setSelection (true);
 }
 
 /**
@@ -659,10 +679,10 @@
  * </ul>
  */
 public void setAccelerator (int accelerator) {
-	checkWidget ();
-	if (this.accelerator == accelerator) return;
-	this.accelerator = accelerator;
-	parent.destroyAccelerators ();
+        checkWidget ();
+        if (this.accelerator == accelerator) return;
+        this.accelerator = accelerator;
+        parent.destroyAccelerators ();
 }
 
 /**
@@ -688,7 +708,7 @@
 		OS.SendMessage (hwndCB, OS.TB_GETBUTTONINFO, id, info);
 		info.fsState &= ~OS.TBSTATE_ENABLED;
 		if (enabled) info.fsState |= OS.TBSTATE_ENABLED;
-		OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, id, info);		
+		OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, id, info);
 	} else {
 		/*
 		* Feature in Windows.  For some reason, when the menu item
@@ -733,7 +753,7 @@
 				* returns a fail code when setting the enabled or
 				* selected state of a default item, but sets the
 				* state anyway.  The fix is to ignore the error.
-				* 
+				*
 				* NOTE:  This only happens on Vista.
 				*/
 				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -846,33 +866,33 @@
  * </ul>
  */
 public void setMenu (Menu menu) {
-	checkWidget ();
+        checkWidget ();
 
-	/* Check to make sure the new menu is valid */
-	if ((style & SWT.CASCADE) == 0) {
-		error (SWT.ERROR_MENUITEM_NOT_CASCADE);
-	}
-	if (menu != null) {
-		if (menu.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
-		if ((menu.style & SWT.DROP_DOWN) == 0) {
-			error (SWT.ERROR_MENU_NOT_DROP_DOWN);
-		}
-		if (menu.parent != parent.parent) {
-			error (SWT.ERROR_INVALID_PARENT);
-		}
-	}
+        /* Check to make sure the new menu is valid */
+        if ((style & SWT.CASCADE) == 0) {
+                error (SWT.ERROR_MENUITEM_NOT_CASCADE);
+        }
+        if (menu != null) {
+                if (menu.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
+                if ((menu.style & SWT.DROP_DOWN) == 0) {
+                        error (SWT.ERROR_MENU_NOT_DROP_DOWN);
+                }
+                if (menu.parent != parent.parent) {
+                        error (SWT.ERROR_INVALID_PARENT);
+                }
+        }
 	setMenu (menu, false);
 }
 
 void setMenu (Menu menu, boolean dispose) {
 
-	/* Assign the new menu */
-	Menu oldMenu = this.menu;
-	if (oldMenu == menu) return;
-	if (oldMenu != null) oldMenu.cascade = null;
-	this.menu = menu;
+        /* Assign the new menu */
+        Menu oldMenu = this.menu;
+        if (oldMenu == menu) return;
+        if (oldMenu != null) oldMenu.cascade = null;
+        this.menu = menu;
 
-	/* Assign the new menu in the OS */		
+	/* Assign the new menu in the OS */
 	if ((OS.IsPPC || OS.IsSP) && parent.hwndCB != 0) {
 		if (OS.IsPPC) {
 			int /*long*/ hwndCB = parent.hwndCB;
@@ -912,12 +932,12 @@
 		info.cch = cch;
 		boolean success = OS.GetMenuItemInfo (hMenu, index, true, info);
 		if (menu != null) {
-			menu.cascade = this; 
+			menu.cascade = this;
 			info.fMask |= OS.MIIM_SUBMENU;
 			info.hSubMenu = menu.handle;
 		}
 		if (OS.IsWinCE) {
-			OS.RemoveMenu (hMenu, index, OS.MF_BYPOSITION);
+		OS.RemoveMenu (hMenu, index, OS.MF_BYPOSITION);
 			/*
 			* On WinCE, InsertMenuItem() is not available.  The fix is to
 			* use SetMenuItemInfo() but this call does not set the menu item
@@ -947,7 +967,7 @@
 			if (dispose || oldMenu == null) {
 				success = OS.SetMenuItemInfo (hMenu, index, true, info);
 			} else {
-				/*
+			/*
 				* Feature in Windows.  When SetMenuItemInfo () is used to
 				* set a submenu and the menu item already has a submenu,
 				* Windows destroys the previous menu.  This is undocumented
@@ -954,7 +974,7 @@
 				* and unexpected but not necessarily wrong.  The fix is to
 				* remove the item with RemoveMenu () which does not destroy
 				* the submenu and then insert the item with InsertMenuItem ().
-				*/
+			*/
 				OS.RemoveMenu (hMenu, index, OS.MF_BYPOSITION);
 				success = OS.InsertMenuItem (hMenu, index, true, info);
 			}
@@ -969,12 +989,12 @@
 }
 
 boolean setRadioSelection (boolean value) {
-	if ((style & SWT.RADIO) == 0) return false;
-	if (getSelection () != value) {
-		setSelection (value);
+        if ((style & SWT.RADIO) == 0) return false;
+        if (getSelection () != value) {
+                setSelection (value);
 		sendSelectionEvent (SWT.Selection);
-	}
-	return true;
+        }
+        return true;
 }
 
 void setOrientation (int orientation) {
@@ -1025,7 +1045,7 @@
 			* returns a fail code when setting the enabled or
 			* selected state of a default item, but sets the
 			* state anyway.  The fix is to ignore the error.
-			* 
+			*
 			* NOTE:  This only happens on Vista.
 			*/
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
@@ -1063,7 +1083,7 @@
  * accelerator key sequence. The accelerator key sequence
  * is installed using #setAccelerator.
  * </p>
- * 
+ *
  * @param string the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -1073,7 +1093,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setAccelerator
  */
 public void setText (String string) {
@@ -1090,7 +1110,7 @@
 		* Bug in WinCE PPC.  Tool items on the menubar don't resize
 		* correctly when the character '&' is used (even when it
 		* is a sequence '&&').  The fix is to remove all '&' from
-		* the string. 
+		* the string.
 		*/
 		if (string.indexOf ('&') != -1) {
 			int length = string.length ();
@@ -1106,7 +1126,7 @@
 		TCHAR buffer = new TCHAR (0, string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount);	
+		OS.MoveMemory (pszText, buffer, byteCount);
 		int /*long*/ hwndCB = parent.hwndCB;
 		TBBUTTONINFO info2 = new TBBUTTONINFO ();
 		info2.cbSize = TBBUTTONINFO.sizeof;
@@ -1117,12 +1137,12 @@
 		MENUITEMINFO info = new MENUITEMINFO ();
 		info.cbSize = MENUITEMINFO.sizeof;
 		int /*long*/ hMenu = parent.handle;
-		
+
 		/* Use the character encoding for the default locale */
 		TCHAR buffer = new TCHAR (0, string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount);	
+		OS.MoveMemory (pszText, buffer, byteCount);
 		/*
 		* Bug in Windows 2000.  For some reason, when MIIM_TYPE is set
 		* on a menu item that also has MIIM_BITMAP, the MIIM_TYPE clears
@@ -1130,13 +1150,13 @@
 		*/
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (4, 10)) {
 			info.fMask = OS.MIIM_STRING;
-		} else {
+				} else {
 			info.fMask = OS.MIIM_TYPE;
 			info.fType = widgetStyle ();
-		}
+				}
 		info.dwTypeData = pszText;
-		success = OS.SetMenuItemInfo (hMenu, id, false, info);
-	}
+				success = OS.SetMenuItemInfo (hMenu, id, false, info);
+			}
 	if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
 	if (!success) {
 		int error = OS.GetLastError();
@@ -1146,36 +1166,44 @@
 }
 
 int widgetStyle () {
-	int bits = 0;
-	Decorations shell = parent.parent;
-	if ((shell.style & SWT.MIRRORED) != 0) {
-		if ((parent.style & SWT.LEFT_TO_RIGHT) != 0) {
-			bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;
-		}
-	} else {
-		if ((parent.style & SWT.RIGHT_TO_LEFT) != 0) {
-			bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;
-		}
-	}
-	if ((style & SWT.SEPARATOR) != 0) return bits | OS.MFT_SEPARATOR;
-	if ((style & SWT.RADIO) != 0) return bits | OS.MFT_RADIOCHECK;
-	return bits | OS.MFT_STRING;
+        int bits = 0;
+        Decorations shell = parent.parent;
+        if ((shell.style & SWT.MIRRORED) != 0) {
+                if ((parent.style & SWT.LEFT_TO_RIGHT) != 0) {
+                        bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;
+                }
+        } else {
+                if ((parent.style & SWT.RIGHT_TO_LEFT) != 0) {
+                        bits |= OS.MFT_RIGHTJUSTIFY | OS.MFT_RIGHTORDER;
+                }
+        }
+        if ((style & SWT.SEPARATOR) != 0) return bits | OS.MFT_SEPARATOR;
+        if ((style & SWT.RADIO) != 0) return bits | OS.MFT_RADIOCHECK;
+        return bits | OS.MFT_STRING;
 }
 
 LRESULT wmCommandChild (int /*long*/ wParam, int /*long*/ lParam) {
-	if ((style & SWT.CHECK) != 0) {
-		setSelection (!getSelection ());
-	} else {
-		if ((style & SWT.RADIO) != 0) {
-			if ((parent.getStyle () & SWT.NO_RADIO_GROUP) != 0) {
-				setSelection (!getSelection ());
-			} else {
-				selectRadio ();
-			}
-		}
-	}
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmCommandChild(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+        if ((style & SWT.CHECK) != 0) {
+                setSelection (!getSelection ());
+        } else {
+                if ((style & SWT.RADIO) != 0) {
+                        if ((parent.getStyle () & SWT.NO_RADIO_GROUP) != 0) {
+                                setSelection (!getSelection ());
+                        } else {
+                                selectRadio ();
+                        }
+                }
+        }
 	sendSelectionEvent (SWT.Selection);
-	return null;
+        return null;
 }
 
 LRESULT wmDrawChild (int /*long*/ wParam, int /*long*/ lParam) {
@@ -1231,7 +1259,7 @@
 				MenuItem item = items [i];
 				if (item.image != null) {
 					Rectangle rect = item.image.getBounds ();
-					width = Math.max (width, rect.width); 
+					width = Math.max (width, rect.width);
 				}
 			}
 		}
Index: org/eclipse/swt/widgets/Text.java
===================================================================
--- org/eclipse/swt/widgets/Text.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Text.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -73,7 +73,7 @@
 	* </p>
 	*/
 	public static final int LIMIT;
-	
+
 	/**
 	* The delimiter used by multi-line text widgets.  When text
 	* is queried and from the widget, it will be delimited using
@@ -80,12 +80,12 @@
 	* this delimiter.
 	*/
 	public static final String DELIMITER;
-	
+
 	/*
 	* This code is intentionally commented.
 	*/
 //	static final char PASSWORD;
-	
+
 	/*
 	* These values can be different on different platforms.
 	* Therefore they are not initialized in the declaration
@@ -95,7 +95,7 @@
 		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;
 		DELIMITER = "\r\n";
 	}
-	
+
 	static final int /*long*/ EditProc;
 	static final TCHAR EditClass = new TCHAR (0, "EDIT", true);
 	static {
@@ -125,7 +125,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -196,13 +196,13 @@
 						hDC = OS.CreateCompatibleDC (paintDC);
 						lpPoint1 = new POINT ();
 						lpPoint2 = new POINT ();
-						OS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);
-						OS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);
+					OS.SetWindowOrgEx (hDC, ps.left, ps.top, lpPoint1);
+					OS.SetBrushOrgEx (hDC, ps.left, ps.top, lpPoint2);
 						hBitmap = OS.CreateCompatibleBitmap (paintDC, width, height);
 						hOldBitmap = OS.SelectObject (hDC, hBitmap);
-						RECT rect = new RECT ();
-						OS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);
-						drawBackground (hDC, rect);
+					RECT rect = new RECT ();
+					OS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);
+					drawBackground (hDC, rect);
 					}
 					
 					OS.CallWindowProc (EditProc, hwnd, OS.WM_PAINT, hDC, lParam);
@@ -243,14 +243,14 @@
 					}
 					
 					if (doubleBuffer) {
-						OS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);
-						OS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);
-						OS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);
-						OS.SelectObject (hDC, hOldBitmap);
-						OS.DeleteObject (hBitmap);
-						OS.DeleteObject (hDC);
-					}
+					OS.SetWindowOrgEx (hDC, lpPoint1.x, lpPoint1.y, null);
+					OS.SetBrushOrgEx (hDC, lpPoint2.x, lpPoint2.y, null);
+					OS.BitBlt (paintDC, ps.left, ps.top, width, height, hDC, 0, 0, OS.SRCCOPY);
+					OS.SelectObject (hDC, hOldBitmap);
+					OS.DeleteObject (hBitmap);
+					OS.DeleteObject (hDC);
 				}
+				}
 				OS.EndPaint (handle, ps);
 				return 0;
 			}
@@ -621,7 +621,7 @@
 		* text to be selected instead of clearing the selection.  The
 		* fix is to set the start of the selection to the  end of the
 		* current selection.
-		*/ 
+		*/
 		int [] end = new int [1];
 		OS.SendMessage (handle, OS.EM_GETSEL, (int []) null, end);
 		OS.SendMessage (handle, OS.EM_SETSEL, end [0], end [0]);
@@ -824,7 +824,7 @@
 	if ((style & SWT.LEFT_TO_RIGHT) != 0) {
 		/*
 		* Bug in Windows 98. When the edit control is created
-		* with the style ES_RIGHT it automatically sets the 
+		* with the style ES_RIGHT it automatically sets the
 		* WS_EX_LEFTSCROLLBAR bit.  The fix is to clear the
 		* bit when the orientation of the control is left
 		* to right.
@@ -850,7 +850,7 @@
 	}
 	if ((style & SWT.CENTER) != 0) {
 		bits2 |= OS.ES_CENTER;
-	}	
+	}
 	OS.SetWindowLong (handle, OS.GWL_EXSTYLE, bits1);
 	OS.SetWindowLong (handle, OS.GWL_STYLE, bits2);
 }
@@ -909,7 +909,7 @@
 	* this is the only time the start of the selection can
 	* be equal to the last character position in the widget.
 	* If EM_POSFROMCHAR fails for any other reason, return
-	* pixel coordinates (0,0). 
+	* pixel coordinates (0,0).
 	*/
 	int position = translateOffset (getCaretPosition ());
 	int /*long*/ caretPos = OS.SendMessage (handle, OS.EM_POSFROMCHAR, position, 0);
@@ -966,7 +966,7 @@
 	* when the selection is not an i-beam.  The best that can be done
 	* is to query the pixel position of the current caret and compare
 	* it to the pixel position of the start and end of the selection.
-	* 
+	*
 	* NOTE:  This does not work when the i-beam belongs to another
 	* control.  In this case, guess that the i-beam is at the start
 	* of the selection.
@@ -1031,7 +1031,7 @@
  * default action of the text widget when the user
  * double clicks.
  * </p>
- * 
+ *
  * @return whether or not double click is enabled
  *
  * @exception SWTException <ul>
@@ -1051,7 +1051,7 @@
  * displayed when the user enters text or the
  * text is changed by the programmer.
  * </p>
- * 
+ *
  * @return the echo character
  *
  * @exception SWTException <ul>
@@ -1058,7 +1058,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setEchoChar
  */
 public char getEchoChar () {
@@ -1072,7 +1072,7 @@
  * Returns the editable state.
  *
  * @return whether or not the receiver is editable
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1108,7 +1108,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #DELIMITER
  */
 public String getLineDelimiter () {
@@ -1144,12 +1144,12 @@
  * constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public int getOrientation () {
@@ -1162,7 +1162,7 @@
  * <p>
  * Typically this is used in conjunction with <code>SWT.SEARCH</code>.
  * </p>
- * 
+ *
  * @return the widget message
  *
  * @exception SWTException <ul>
@@ -1169,7 +1169,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public String getMessage () {
@@ -1191,7 +1191,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 //TODO - Javadoc
@@ -1253,7 +1253,7 @@
  * Gets the selected text, or an empty string if there is no current selection.
  *
  * @return the selected text
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1401,19 +1401,19 @@
 }
 
 /**
- * Returns the maximum number of characters that the receiver is capable of holding. 
+ * Returns the maximum number of characters that the receiver is capable of holding.
  * <p>
  * If this has not been changed by <code>setTextLimit()</code>,
  * it will be the constant <code>Text.LIMIT</code>.
  * </p>
- * 
+ *
  * @return the text limit
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #LIMIT
  */
 public int getTextLimit () {
@@ -1605,7 +1605,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Modify, listener);	
+	eventTable.unhook (SWT.Modify, listener);
 }
 
 /**
@@ -1660,7 +1660,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -1684,7 +1684,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Verify, listener);	
+	eventTable.unhook (SWT.Verify, listener);
 }
 
 /**
@@ -1714,7 +1714,7 @@
 	if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;
 	char key = event.character;
 	int stateMask = event.stateMask;
-	
+
 	/*
 	* Disable all magic keys that could modify the text
 	* and don't send events when Alt, Shift or Ctrl is
@@ -1735,7 +1735,8 @@
 	* is to detect this case and avoid sending a verify
 	* event.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (handle == OS.GetCapture()) return true;
 	}
 
@@ -1894,7 +1895,7 @@
  * Note: This operation is a hint and is not supported on
  * platforms that do not have this concept.
  * </p>
- * 
+ *
  * @param doubleClick the new double click flag
  *
  * @exception SWTException <ul>
@@ -1958,7 +1959,7 @@
 public void setEditable (boolean editable) {
 	checkWidget ();
 	style &= ~SWT.READ_ONLY;
-	if (!editable) style |= SWT.READ_ONLY; 
+	if (!editable) style |= SWT.READ_ONLY;
 	OS.SendMessage (handle, OS.EM_SETREADONLY, editable ? 0 : 1, 0);
 }
 
@@ -1976,7 +1977,7 @@
 	* margins, causing the first character to be clipped.  The
 	* fix is to set the margins to zero.
 	*/
-	if ((style & SWT.SEARCH) != 0) {
+		if ((style & SWT.SEARCH) != 0) {
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 			OS.SendMessage (handle, OS.EM_SETMARGINS, OS.EC_LEFTMARGIN | OS.EC_RIGHTMARGIN, 0);
 		}
@@ -1989,7 +1990,7 @@
  * <p>
  * Typically this is used in conjunction with <code>SWT.SEARCH</code>.
  * </p>
- * 
+ *
  * @param message the new message
  *
  * @exception IllegalArgumentException <ul>
@@ -1999,7 +2000,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public void setMessage (String message) {
@@ -2030,12 +2031,12 @@
  * </p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public void setOrientation (int orientation) {
@@ -2318,7 +2319,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #LIMIT
  */
 public void setTextLimit (int limit) {
@@ -2327,7 +2328,7 @@
 	if (segments != null && limit > 0) {
 		OS.SendMessage (handle, OS.EM_SETLIMITTEXT, limit + Math.min (segments.length, LIMIT - limit), 0);
 	} else {
-		OS.SendMessage (handle, OS.EM_SETLIMITTEXT, limit, 0);
+	OS.SendMessage (handle, OS.EM_SETLIMITTEXT, limit, 0);
 	}
 }
 
@@ -2359,7 +2360,7 @@
  * in the receiver, this method simply returns.  Otherwise,
  * lines are scrolled until the selection is visible.
  * </p>
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -2504,7 +2505,7 @@
 		}
 		return bits;
 	}
-	bits |= OS.ES_MULTILINE | OS.ES_NOHIDESEL | OS.ES_AUTOVSCROLL;	
+	bits |= OS.ES_MULTILINE | OS.ES_NOHIDESEL | OS.ES_AUTOVSCROLL;
 	if ((style & SWT.WRAP) != 0) bits &= ~(OS.WS_HSCROLL | OS.ES_AUTOHSCROLL);
 	return bits;
 }
@@ -2583,7 +2584,7 @@
 	if (ignoreCharacter) return null;
 	LRESULT result = super.WM_CHAR (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Bug in Windows.  When the user types CTRL and BS
 	* in an edit control, a DEL character is generated.
@@ -2593,11 +2594,12 @@
 	*/
 	switch ((int)/*64*/wParam) {
 		case SWT.DEL:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				return LRESULT.ZERO;
 			}
 	}
-	
+
 	/*
 	* Feature in Windows.  For some reason, when the
 	* widget is a single line text widget, when the
@@ -2658,7 +2660,7 @@
 LRESULT WM_GETDLGCODE (int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.WM_GETDLGCODE (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Bug in WinCE PPC.  For some reason, sending WM_GETDLGCODE
 	* to a multi-line edit control causes it to ignore return and
@@ -2674,9 +2676,9 @@
 	/*
 	* Feature in Windows.  Despite the fact that the
 	* edit control is read only, it still returns a
-	* dialog code indicating that it wants all keys.  
+	* dialog code indicating that it wants all keys.
 	* The fix is to detect this case and clear the bits.
-	* 
+	*
 	* NOTE: A read only edit control processes arrow keys
 	* so DLGC_WANTARROWS should not be cleared.
 	*/
@@ -2727,7 +2729,7 @@
 		OS.DispatchMessage (msg);
 	}
 	ignoreCharacter = false;
-	
+
 	sendKeyEvent (SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);
 	// widget could be disposed at this point
 	display.lastKey = display.lastAscii = 0;
@@ -2749,7 +2751,7 @@
 		if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	}
 	if (!doubleClick) return LRESULT.ZERO;
-		
+
 	/*
 	* Bug in Windows.  When the last line of text in the
 	* widget is double clicked and the line is empty, Windows
@@ -2782,7 +2784,7 @@
 		* Note: On WinCE PPC, only attempt to recognize the gesture for
 		* a context menu when the control contains a valid menu or there
 		* are listeners for the MenuDetect event.
-		* 
+		*
 		* Note: On WinCE PPC, the gesture that brings up a popup menu
 		* on the text widget must keep the current text selection.  As a
 		* result, the window proc is only called if the menu is not shown.
@@ -2795,7 +2797,7 @@
 			shrg.cbSize = SHRGINFO.sizeof;
 			shrg.hwndClient = handle;
 			shrg.ptDown_x = x;
-			shrg.ptDown_y = y; 
+			shrg.ptDown_y = y;
 			shrg.dwFlags = OS.SHRG_RETURNCMD;
 			int type = OS.SHRecognizeGesture (shrg);
 			if (type == OS.GN_CONTEXTMENU) {
@@ -2954,8 +2956,8 @@
 				style &= ~SWT.LEFT_TO_RIGHT;
 				style |= SWT.RIGHT_TO_LEFT;
 			} else {
-				style &= ~SWT.RIGHT_TO_LEFT;
-				style |= SWT.LEFT_TO_RIGHT;
+			style &= ~SWT.RIGHT_TO_LEFT;
+			style |= SWT.LEFT_TO_RIGHT;
 			}
 			Event event = new Event();
 			event.doit = true;
@@ -2963,8 +2965,8 @@
 			if (!event.doit) {
 				if (code == OS.EN_ALIGN_LTR_EC) {
 					bits |= (OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR);
-					style &= ~SWT.LEFT_TO_RIGHT;
-					style |= SWT.RIGHT_TO_LEFT;
+			style &= ~SWT.LEFT_TO_RIGHT;
+			style |= SWT.RIGHT_TO_LEFT;
 				} else {
 					bits &= ~(OS.WS_EX_RTLREADING | OS.WS_EX_LEFTSCROLLBAR);
 					style &= ~SWT.RIGHT_TO_LEFT;
Index: org/eclipse/swt/widgets/TabItem.java
===================================================================
--- org/eclipse/swt/widgets/TabItem.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TabItem.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -276,9 +276,9 @@
 				if (selectedControl == newControl) return;
 			}
 			newControl.setVisible(false);
-			return;
-		}
+		return;
 	}
+	}
 	if (newControl != null) {
 		newControl.setBounds (parent.getClientArea ());
 		newControl.setVisible (true);
@@ -356,7 +356,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/widgets/FontDialog.java
===================================================================
--- org/eclipse/swt/widgets/FontDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/FontDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -15,6 +16,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to select a font
  * from all available fonts in the system.
@@ -27,16 +33,23 @@
  * <p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample, Dialog tab</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
  * @noextend This class is not intended to be subclassed by clients.
  */
 public class FontDialog extends Dialog {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.ColorDialog");
+    // </QFS>
 	FontData fontData;
 	RGB rgb;
 	boolean effectsVisible = true;
-	
+
 /**
  * Constructs a new instance of this class given only its parent.
  *
@@ -60,7 +73,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -103,7 +116,7 @@
 /**
  * Returns a FontData object describing the font that was
  * selected in the dialog, or null if none is available.
- * 
+ *
  * @return the FontData for the selected font, or null
  * @deprecated use #getFontList ()
  */
@@ -114,7 +127,7 @@
 /**
  * Returns a FontData set describing the font that was
  * selected in the dialog, or null if none is available.
- * 
+ *
  * @return the FontData for the selected font, or null
  * @since 2.1.1
  */
@@ -132,7 +145,7 @@
  * @return the RGB value for the selected color, or null
  *
  * @see PaletteData#getRGBs
- * 
+ *
  * @since 2.1
  */
 public RGB getRGB () {
@@ -153,11 +166,11 @@
  */
 public FontData open () {
 	if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);
-	
+
 	/* Get the owner HWND for the dialog */
 	int /*long*/ hwndOwner = parent.handle;
 	int /*long*/ hwndParent = parent.handle;
-	
+
 	/*
 	* Feature in Windows.  There is no API to set the orientation of a
 	* font dialog.  It is always inherited from the parent.  The fix is
@@ -185,7 +198,7 @@
 			if (enabled) OS.EnableWindow (hwndParent, false);
 		}
 	}
-		
+
 	/* Open the dialog */
 	int /*long*/ hHeap = OS.GetProcessHeap ();
 	CHOOSEFONT lpcf = new CHOOSEFONT ();
@@ -215,7 +228,7 @@
 		int blue = (rgb.blue << 16) & 0xFF0000;
 		lpcf.rgbColors = red | green | blue;
 	}
-	
+
 	/* Make the parent shell be temporary modal */
 	Dialog oldModal = null;
 	Display display = null;
@@ -224,15 +237,31 @@
 		oldModal = display.getModalDialog ();
 		display.setModalDialog (this);
 	}
-	
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/* Open the dialog */
 	boolean success = OS.ChooseFont (lpcf);
-	
+
 	/* Clear the temporary dialog modal parent */
 	if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
 		display.setModalDialog (oldModal);
 	}
-	
+
 	/* Compute the result */
 	if (success) {
 		LOGFONT logFont = OS.IsUnicode ? (LOGFONT) new LOGFONTW () : new LOGFONTA ();
@@ -244,7 +273,7 @@
 		 */
 		int /*long*/ hDC = OS.GetDC(0);
 		int logPixelsY = OS.GetDeviceCaps(hDC, OS.LOGPIXELSY);
-		int pixels = 0; 
+		int pixels = 0;
 		if (logFont.lfHeight > 0) {
 			/*
 			 * Feature in Windows. If the lfHeight of the LOGFONT structure
@@ -269,13 +298,13 @@
 		float points = pixels * 72f /logPixelsY;
 		fontData = FontData.win32_new (logFont, points);
 		if (effectsVisible) {
-			int red = lpcf.rgbColors & 0xFF;
-			int green = (lpcf.rgbColors >> 8) & 0xFF;
-			int blue = (lpcf.rgbColors >> 16) & 0xFF;
-			rgb = new RGB (red, green, blue);
-		}
+		int red = lpcf.rgbColors & 0xFF;
+		int green = (lpcf.rgbColors >> 8) & 0xFF;
+		int blue = (lpcf.rgbColors >> 16) & 0xFF;
+		rgb = new RGB (red, green, blue);
 	}
-		
+	}
+
 	/* Free the OS memory */
 	if (lpLogFont != 0) OS.HeapFree (hHeap, 0, lpLogFont);
 
@@ -293,7 +322,16 @@
 	* is currently unspecified.
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
-	
+
+        // <QFS>
+        Object[] replaced = (Object[]) _qfGetDisplay().runDialogClosedHooks
+            (this, success ? new Object[] {fontData, rgb} : null);
+        if (replaced != null) {
+            fontData = (FontData) replaced[0];
+            rgb = (RGB) replaced[1];
+            success = true;
+        }
+        // </QFS>
 	if (!success) return null;
 	return fontData;
 }
@@ -318,7 +356,7 @@
  * Sets a FontData object describing the font to be
  * selected by default in the dialog, or null to let
  * the platform choose one.
- * 
+ *
  * @param fontData the FontData to use initially, or null
  * @deprecated use #setFontList (FontData [])
  */
@@ -330,12 +368,12 @@
  * Sets the set of FontData objects describing the font to
  * be selected by default in the dialog, or null to let
  * the platform choose one.
- * 
+ *
  * @param fontData the set of FontData objects to use initially, or null
  *        to let the platform select a default when open() is called
  *
  * @see Font#getFontData
- * 
+ *
  * @since 2.1.1
  */
 public void setFontList (FontData [] fontData) {
@@ -354,7 +392,7 @@
  *        the platform select a default when open() is called
  *
  * @see PaletteData#getRGBs
- * 
+ *
  * @since 2.1
  */
 public void setRGB (RGB rgb) {
Index: org/eclipse/swt/widgets/TaskBar.java
===================================================================
--- org/eclipse/swt/widgets/TaskBar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TaskBar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -189,18 +189,18 @@
 			text = (String)item.getData (ICON_INDEX_KEY);
 			if (text != null) index = Integer.parseInt (text);
 		} else {
-			Image image = item.getImage ();
-			if (image != null && directory != null) {
+		Image image = item.getImage ();
+		if (image != null && directory != null) {
 				icon = directory + "\\menu" + item.id + ".ico" ;
-				ImageData data;
-				if (item.hBitmap != 0) {
-					Image image2 = Image.win32_new (display, SWT.BITMAP, item.hBitmap);
-					data = image2.getImageData ();
-				} else {
-					data = image.getImageData ();
-				}
-				ImageLoader loader = new ImageLoader ();
-				loader.data = new ImageData [] {data};
+			ImageData data;
+			if (item.hBitmap != 0) {
+				Image image2 = Image.win32_new (display, SWT.BITMAP, item.hBitmap);
+				data = image2.getImageData ();
+			} else {
+				data = image.getImageData ();
+			}
+			ImageLoader loader = new ImageLoader ();
+			loader.data = new ImageData [] {data};
 				loader.save (icon, SWT.IMAGE_ICO);
 			}
 		}
Index: org/eclipse/swt/widgets/Table.java
===================================================================
--- org/eclipse/swt/widgets/Table.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Table.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -19,7 +19,7 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
-/** 
+/**
  * Instances of this class implement a selectable user interface
  * object that displays a list of images and strings and issues
  * notification when selected.
@@ -44,7 +44,7 @@
  *          item.setText ("Item " + index);
  *          System.out.println (item.getText ());
  *      }
- *  }); 
+ *  });
  * </pre></code>
  * </p><p>
  * Note that although this class is a subclass of <code>Composite</code>,
@@ -111,7 +111,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -271,8 +271,8 @@
         	}
         	//TODO - _checkGrow() doesn't return a value, check keys == null instead
 	        if (_checkGrow (count)) {
-	    		if (items [index] != null) return items [index];
-	    		return items [index] = new TableItem (this, SWT.NONE, -1, false);
+	if (items [index] != null) return items [index];
+	return items [index] = new TableItem (this, SWT.NONE, -1, false);
 	        }
 	        keyIndex = -keyIndex - 1;
 	        if (keyIndex < keyCount) { 
@@ -456,12 +456,12 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-						
+
 		/* Resize messages */
 		case OS.WM_WINDOWPOSCHANGED:
 			redraw = findImageControl () != null && getDrawing () && OS.IsWindowVisible (handle);
@@ -476,7 +476,7 @@
 				OS.SendMessage (handle, OS.LVM_SETBKCOLOR, 0, 0xFFFFFF);
 			}
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -496,7 +496,7 @@
 		case OS.WM_XBUTTONUP:
 			checkSelection = true;
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -508,7 +508,7 @@
 	boolean oldSelected = wasSelected;
 	if (checkSelection) wasSelected = false;
 	if (checkActivate) ignoreActivate = true;
-	
+
 	/*
 	* Bug in Windows.  For some reason, when the WS_EX_COMPOSITED
 	* style is set in a parent of a table and the header is visible,
@@ -567,7 +567,7 @@
 		int flags = OS.RDW_FRAME | OS.RDW_INVALIDATE;
 		OS.RedrawWindow (handle, null, 0, flags);
 	}
-	
+
 	if (checkActivate) ignoreActivate = false;
 	if (checkSelection) {
 		if (wasSelected || forceSelect) {
@@ -588,12 +588,12 @@
 		case OS.WM_SYSKEYDOWN:
 		case OS.WM_SYSKEYUP:
 			//FALL THROUGH
-			
+
 		/* Scroll messages */
 		case OS.WM_HSCROLL:
 		case OS.WM_VSCROLL:
 			//FALL THROUGH
-			
+
 		/* Resize messages */
 		case OS.WM_WINDOWPOSCHANGED:
 			if (redraw) {
@@ -600,11 +600,11 @@
 				OS.SendMessage (handle, OS.LVM_SETBKCOLOR, 0, OS.CLR_NONE);
 				OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 				OS.InvalidateRect (handle, null, true);
-				int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);	
+				int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 				if (hwndHeader != 0) OS.InvalidateRect (hwndHeader, null, true);
 			}
 			//FALL THROUGH
-			
+
 		/* Mouse messages */
 		case OS.WM_LBUTTONDBLCLK:
 		case OS.WM_LBUTTONDOWN:
@@ -623,7 +623,7 @@
 		case OS.WM_XBUTTONDOWN:
 		case OS.WM_XBUTTONUP:
 			//FALL THROUGH
-			
+
 		/* Other messages */
 		case OS.WM_SETFONT:
 		case OS.WM_TIMER: {
@@ -653,7 +653,7 @@
 	* applications have consistent scroll bar behavior.
 	*/
 	if ((style & SWT.NO_SCROLL) == 0) {
-		style |= SWT.H_SCROLL | SWT.V_SCROLL;
+	style |= SWT.H_SCROLL | SWT.V_SCROLL;
 	}
 	return checkBits (style, SWT.SINGLE, SWT.MULTI, 0, 0, 0, 0);
 }
@@ -673,7 +673,7 @@
 	* a black rectangle around any column that contains an
 	* image.  The fix is clear LVS_EX_FULLROWSELECT during
 	* custom draw.
-	* 
+	*
 	* NOTE: Since CDIS_FOCUS is cleared during custom draw,
 	* it is necessary to draw the focus rectangle after the
 	* item has been drawn.
@@ -727,7 +727,7 @@
 	* a black rectangle around any column that contains an
 	* image.  The fix is clear LVS_EX_FULLROWSELECT during
 	* custom draw.
-	* 
+	*
 	* NOTE: It is also necessary to clear CDIS_FOCUS to stop
 	* the table from drawing the focus rectangle around the
 	* first item instead of the full row.
@@ -951,7 +951,7 @@
 					}
 				}
 			}
-		} 
+		}
 		if (hooks (SWT.PaintItem)) {
 			TableItem item = _getItem ((int)/*64*/nmcd.dwItemSpec);
 			sendPaintItemEvent (item, nmcd);
@@ -1200,10 +1200,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.0
  */
 public void clear (int index) {
@@ -1216,7 +1216,7 @@
 		/*
 		* Bug in Windows.  Despite the fact that every item in the
 		* table always has LPSTR_TEXTCALLBACK, Windows caches the
-		* bounds for the selected items.  This means that 
+		* bounds for the selected items.  This means that
 		* when you change the string to be something else, Windows
 		* correctly asks you for the new string but when the item
 		* is selected, the selection draws using the bounds of the
@@ -1256,10 +1256,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.0
  */
 public void clear (int start, int end) {
@@ -1284,7 +1284,7 @@
 				/*
 				* Bug in Windows.  Despite the fact that every item in the
 				* table always has LPSTR_TEXTCALLBACK, Windows caches the
-				* bounds for the selected items.  This means that 
+				* bounds for the selected items.  This means that
 				* when you change the string to be something else, Windows
 				* correctly asks you for the new string but when the item
 				* is selected, the selection draws using the bounds of the
@@ -1330,10 +1330,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.0
  */
 public void clear (int [] indices) {
@@ -1359,7 +1359,7 @@
 			/*
 			* Bug in Windows.  Despite the fact that every item in the
 			* table always has LPSTR_TEXTCALLBACK, Windows caches the
-			* bounds for the selected items.  This means that 
+			* bounds for the selected items.  This means that
 			* when you change the string to be something else, Windows
 			* correctly asks you for the new string but when the item
 			* is selected, the selection draws using the bounds of the
@@ -1395,10 +1395,10 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT#VIRTUAL
  * @see SWT#SetData
- * 
+ *
  * @since 3.0
  */
 public void clearAll () {
@@ -1416,7 +1416,7 @@
 			/*
 			* Bug in Windows.  Despite the fact that every item in the
 			* table always has LPSTR_TEXTCALLBACK, Windows caches the
-			* bounds for the selected items.  This means that 
+			* bounds for the selected items.  This means that
 			* when you change the string to be something else, Windows
 			* correctly asks you for the new string but when the item
 			* is selected, the selection draws using the bounds of the
@@ -1470,7 +1470,7 @@
 //		}
 //	}
 	int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
-	RECT rect = new RECT ();					
+	RECT rect = new RECT ();
 	OS.GetWindowRect (hwndHeader, rect);
 	int height = rect.bottom - rect.top;
 	int bits = 0;
@@ -1508,7 +1508,7 @@
 void createHandle () {
 	super.createHandle ();
 	state &= ~(CANVAS | THEME_BACKGROUND);
-	
+
 	/* Use the Explorer theme */
 	if (EXPLORER_THEME) {
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0) && OS.IsAppThemed ()) {
@@ -1516,13 +1516,13 @@
 			OS.SetWindowTheme (handle, Display.EXPLORER, null);
 		}
 	}
-	
+
 	/* Get the header window proc */
 	if (HeaderProc == 0) {
 		int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 		HeaderProc = OS.GetWindowLongPtr (hwndHeader, OS.GWLP_WNDPROC);
 	}
-	
+
 	/*
 	* Feature in Windows.  In version 5.8 of COMCTL32.DLL,
 	* if the font is changed for an item, the bounds for the
@@ -1538,13 +1538,13 @@
 			OS.SendMessage (handle, OS.CCM_SETVERSION, 5, 0);
 		}
 	}
-	
-	/* 
+
+	/*
 	* This code is intentionally commented.  According to
 	* the documentation, setting the default item size is
 	* supposed to improve performance.  By experimentation,
 	* this does not seem to have much of an effect.
-	*/	
+	*/
 //	OS.SendMessage (handle, OS.LVM_SETITEMCOUNT, 1024 * 2, 0);
 
 	/* Set the checkbox image list */
@@ -1591,7 +1591,7 @@
 	if ((style & SWT.FULL_SELECTION) != 0) bits1 |= OS.LVS_EX_FULLROWSELECT;
 	if (OS.COMCTL32_MAJOR >= 6) bits1 |= OS.LVS_EX_DOUBLEBUFFER;
 	OS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits1, bits1);
-	
+
 	/*
 	* Feature in Windows.  Windows does not explicitly set the orientation of
 	* the header.  Instead, the orientation is inherited when WS_EX_LAYOUTRTL
@@ -1599,14 +1599,14 @@
 	* and WS_EX_NOINHERITLAYOUT are specified for the table, the header will
 	* not be oriented correctly.  The fix is to explicitly set the orientation
 	* for the header.
-	* 
+	*
 	* NOTE: WS_EX_LAYOUTRTL is not supported on Windows NT.
 	*/
 	if (OS.WIN32_VERSION >= OS.VERSION (4, 10)) {
-		if ((style & SWT.RIGHT_TO_LEFT) != 0) {
-			int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
-			int bits2 = OS.GetWindowLong (hwndHeader, OS.GWL_EXSTYLE);
-			OS.SetWindowLong (hwndHeader, OS.GWL_EXSTYLE, bits2 | OS.WS_EX_LAYOUTRTL);
+	if ((style & SWT.RIGHT_TO_LEFT) != 0) {
+		int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
+		int bits2 = OS.GetWindowLong (hwndHeader, OS.GWL_EXSTYLE);
+		OS.SetWindowLong (hwndHeader, OS.GWL_EXSTYLE, bits2 | OS.WS_EX_LAYOUTRTL);
 			int /*long*/ hwndTooltop = OS.SendMessage (handle, OS.LVM_GETTOOLTIPS, 0, 0);
 			int bits3 = OS.GetWindowLong (hwndTooltop, OS.GWL_EXSTYLE);
 			OS.SetWindowLong (hwndTooltop, OS.GWL_EXSTYLE, bits3 | OS.WS_EX_LAYOUTRTL);
@@ -1718,12 +1718,12 @@
 	*/
 	System.arraycopy (columns, index, columns, index + 1, columnCount++ - index);
 	columns [index] = column;
-	
+
 	/*
 	* Ensure that resize listeners for the table and for columns
 	* within the table are not called.  This can happen when the
 	* first column is inserted into a table or when a new column
-	* is inserted in the first position. 
+	* is inserted in the first position.
 	*/
 	ignoreColumnResize = true;
 	if (index == 0) {
@@ -1785,7 +1785,7 @@
 		OS.SendMessage (handle, OS.LVM_INSERTCOLUMN, index, lvColumn);
 	}
 	ignoreColumnResize = false;
-	
+
 	/* Add the tool tip item for the header */
 	if (headerToolTipHandle != 0) {
 		RECT rect = new RECT ();
@@ -1834,7 +1834,7 @@
 	if (result == -1) error (SWT.ERROR_ITEM_NOT_ADDED);
 	_insertItem (index, item, count);
 	setDeferResize (false);
-	
+
 	/* Resize to show the first item */
 	if (count == 0) setScrollWidth (item, false);
 }
@@ -1858,7 +1858,7 @@
 
 /**
  * Deselects the items at the given zero-relative indices in the receiver.
- * If the item at the given zero-relative index in the receiver 
+ * If the item at the given zero-relative index in the receiver
  * is selected, it is deselected.  If the item at the index
  * was not selected, it remains deselected. Indices that are out
  * of range and duplicate indices are ignored.
@@ -1920,7 +1920,7 @@
 
 /**
  * Deselects the items at the given zero-relative indices in the receiver.
- * If the item at the given zero-relative index in the receiver 
+ * If the item at the given zero-relative index in the receiver
  * is selected, it is deselected.  If the item at the index
  * was not selected, it remains deselected.  The range of the
  * indices is inclusive. Indices that are out of range are ignored.
@@ -2130,7 +2130,7 @@
 	if (columnCount == 0) setScrollWidth (null, true);
 	updateMoveable ();
 	ignoreColumnResize = false;
-	if (columnCount != 0) {	
+	if (columnCount != 0) {
 		/*
 		* Bug in Windows.  When LVM_DELETECOLUMN is used to delete a
 		* column zero when that column is both the first column in the
@@ -2164,13 +2164,13 @@
 			* the column order, the header redraws correctly but the table does
 			* not.  The fix is to force a redraw.
 			*/
-			OS.InvalidateRect (handle, null, true);			
+			OS.InvalidateRect (handle, null, true);
 		}
 		TableColumn [] newColumns = new TableColumn [columnCount - orderIndex];
 		for (int i=orderIndex; i<newOrder.length; i++) {
 			newColumns [i - orderIndex] = columns [newOrder [i]];
 			newColumns [i - orderIndex].updateToolTip (newOrder [i]);
-		}	
+		}
 		for (int i=0; i<newColumns.length; i++) {
 			if (!newColumns [i].isDisposed ()) {
 				newColumns [i].sendEvent (SWT.Move);
@@ -2177,7 +2177,7 @@
 			}
 		}
 	}
-	
+
 	/* Remove the tool tip item for the header */
 	if (headerToolTipHandle != 0) {
 		TOOLINFO lpti = new TOOLINFO ();
@@ -2252,7 +2252,7 @@
 	if (OS.COMCTL32_VERSION >= OS.VERSION (5, 80)) return;
 	int bits = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
 	if ((bits & OS.LVS_EX_GRIDLINES) == 0) return;
-	bits = OS.GetWindowLong (handle, OS.GWL_STYLE);	
+	bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 	if ((bits & OS.LVS_NOCOLUMNHEADER) != 0) return;
 	/*
 	* Bug in Windows.  Making any change to an item that
@@ -2309,7 +2309,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Table#getColumnOrder()
  * @see Table#setColumnOrder(int[])
  * @see TableColumn#getMoveable()
@@ -2352,7 +2352,7 @@
  * </p><p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the current visual order of the receiver's items
@@ -2361,12 +2361,12 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Table#setColumnOrder(int[])
  * @see TableColumn#getMoveable()
  * @see TableColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public int[] getColumnOrder () {
@@ -2388,7 +2388,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -2397,7 +2397,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Table#getColumnOrder()
  * @see Table#setColumnOrder(int[])
  * @see TableColumn#getMoveable()
@@ -2420,7 +2420,7 @@
  * Returns the width in pixels of a grid line.
  *
  * @return the width of a grid line in pixels
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -2432,7 +2432,7 @@
 }
 
 /**
- * Returns the height of the receiver's header 
+ * Returns the height of the receiver's header
  *
  * @return the height of the header or zero if the header is not visible
  *
@@ -2440,14 +2440,14 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
- * @since 2.0 
+ *
+ * @since 2.0
  */
 public int getHeaderHeight () {
 	checkWidget ();
 	int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 	if (hwndHeader == 0) return 0;
-	RECT rect = new RECT ();					
+	RECT rect = new RECT ();
 	OS.GetWindowRect (hwndHeader, rect);
 	return rect.bottom - rect.top;
 }
@@ -2503,8 +2503,8 @@
  * coordinate system of the receiver.
  * <p>
  * The item that is returned represents an item that could be selected by the user.
- * For example, if selection only occurs in items in the first column, then null is 
- * returned if the point is outside of the item. 
+ * For example, if selection only occurs in items in the first column, then null is
+ * returned if the point is outside of the item.
  * Note that the SWT.FULL_SELECTION style hint, which specifies the selection policy,
  * determines the extent of the selection.
  * </p>
@@ -2577,7 +2577,7 @@
 			if ((bits & OS.LVS_NOCOLUMNHEADER) == 0) {
 				int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 				if (hwndHeader != 0) {
-					RECT rect = new RECT ();					
+					RECT rect = new RECT ();
 					OS.GetWindowRect (hwndHeader, rect);
 					POINT pt = new POINT ();
 					pt.x = pinfo.x;
@@ -2628,11 +2628,11 @@
 
 /**
  * Returns a (possibly empty) array of <code>TableItem</code>s which
- * are the items in the receiver. 
+ * are the items in the receiver.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -2687,7 +2687,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return an array representing the selection
  *
@@ -2751,7 +2751,7 @@
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its selection, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  * @return the array of indices of the selected items
  *
@@ -2775,15 +2775,15 @@
  * the receiver. The value may be null if no column shows
  * the sort indicator.
  *
- * @return the sort indicator 
+ * @return the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortColumn(TableColumn)
- * 
+ *
  * @since 3.2
  */
 public TableColumn getSortColumn () {
@@ -2809,8 +2809,8 @@
 }
 
 /**
- * Returns the direction of the sort indicator for the receiver. 
- * The value will be one of <code>UP</code>, <code>DOWN</code> 
+ * Returns the direction of the sort indicator for the receiver.
+ * The value will be one of <code>UP</code>, <code>DOWN</code>
  * or <code>NONE</code>.
  *
  * @return the sort direction
@@ -2819,9 +2819,9 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #setSortDirection(int)
- * 
+ *
  * @since 3.2
  */
 public int getSortDirection () {
@@ -2949,7 +2949,7 @@
 
 /**
  * Searches the receiver's list starting at the first column
- * (index 0) until a column is found that is equal to the 
+ * (index 0) until a column is found that is equal to the
  * argument, and returns the index of that column. If no column
  * is found, returns -1.
  *
@@ -2975,7 +2975,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -2995,20 +2995,20 @@
 	if (item == null) error (SWT.ERROR_NULL_ARGUMENT);
 	//TODO - find other loops that can be optimized
 	if (keys == null) {
-		int count = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETITEMCOUNT, 0, 0);
-		if (1 <= lastIndexOf && lastIndexOf < count - 1) {
+	int count = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETITEMCOUNT, 0, 0);
+	if (1 <= lastIndexOf && lastIndexOf < count - 1) {
 			if (_getItem (lastIndexOf, false) == item) return lastIndexOf;
 			if (_getItem (lastIndexOf + 1, false) == item) return ++lastIndexOf;
 			if (_getItem (lastIndexOf - 1, false) == item) return --lastIndexOf;
+	}
+	if (lastIndexOf < count / 2) {
+		for (int i=0; i<count; i++) {
+				if (_getItem (i, false) == item) return lastIndexOf = i;
 		}
-		if (lastIndexOf < count / 2) {
-			for (int i=0; i<count; i++) {
+	} else {
+		for (int i=count - 1; i>=0; --i) {
 				if (_getItem (i, false) == item) return lastIndexOf = i;
 			}
-		} else {
-			for (int i=count - 1; i>=0; --i) {
-				if (_getItem (i, false) == item) return lastIndexOf = i;
-			}
 		}
 	} else {
 		for (int i=0; i<keyCount; i++) {
@@ -3086,17 +3086,17 @@
 			}
 		} else {
 			if (keys == null) {
-				for (int i=0; i<itemCount; i++) {
+			for (int i=0; i<itemCount; i++) {
 					TableItem item = _getItem (i, false);
 					if (item != null && !item.isDisposed ()) item.release (false);
 				}
 			} else {
 				for (int i=0; i<keyCount; i++) {
-					TableItem item = items [i];
-					if (item != null && !item.isDisposed ()) item.release (false);
-				}
+				TableItem item = items [i];
+				if (item != null && !item.isDisposed ()) item.release (false);
 			}
 		}
+		}
 		_clearItems ();
 	}
 	if (columns != null) {
@@ -3108,7 +3108,7 @@
 	}
 	super.releaseChildren (destroy);
 }
-	
+
 void releaseWidget () {
 	super.releaseWidget ();
 	customDraw = false;
@@ -3210,7 +3210,7 @@
 
 /**
  * Removes the items from the receiver which are
- * between the given zero-relative start and end 
+ * between the given zero-relative start and end
  * indices (inclusive).
  *
  * @param start the start of the range
@@ -3259,7 +3259,7 @@
 
 /**
  * Removes all of the items from the receiver.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -3285,7 +3285,7 @@
 	*
 	* NOTE: LVM_DELETEALLITEMS is also sent by the table
 	* when the table is destroyed.
-	*/	
+	*/
 	setDeferResize (true);
 	if (OS.IsWin95 && columnCount > 1) {
 		boolean redraw = getDrawing () && OS.IsWindowVisible (handle);
@@ -3342,7 +3342,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -3365,7 +3365,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Table#setSelection(int[])
  */
 public void select (int [] indices) {
@@ -3407,7 +3407,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver. 
+ * Selects the item at the given zero-relative index in the receiver.
  * If the item at the index was already selected, it remains
  * selected. Indices that are out of range are ignored.
  *
@@ -3453,7 +3453,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see Table#setSelection(int,int)
  */
 public void select (int start, int end) {
@@ -3657,39 +3657,39 @@
 			}
 		}
 		if (explorerTheme) {
-			if (!ignoreDrawHot || drawDrophilited || (!ignoreDrawSelection && clrSelectionBk != -1)) {
-				RECT pClipRect = new RECT ();
-				OS.SetRect (pClipRect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);
-				RECT rect = new RECT ();
-				OS.SetRect (rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);
-				if ((style & SWT.FULL_SELECTION) != 0) {
-					int count = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);
-					int index = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, count - 1, 0);
-					RECT headerRect = new RECT ();
-					OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, index, headerRect);
-					OS.MapWindowPoints (hwndHeader, handle, headerRect, 2);
-					rect.right = headerRect.right;
+	if (!ignoreDrawHot || (!ignoreDrawSelection && clrSelectionBk != -1)) {
+			boolean hot = drawHot;
+			RECT pClipRect = new RECT ();
+			OS.SetRect (pClipRect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);
+			RECT rect = new RECT ();
+			OS.SetRect (rect, nmcd.left, nmcd.top, nmcd.right, nmcd.bottom);
+			if ((style & SWT.FULL_SELECTION) != 0) {
+				int count = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_GETITEMCOUNT, 0, 0);
+				int index = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, count - 1, 0);
+				RECT headerRect = new RECT ();
+				OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, index, headerRect);
+				OS.MapWindowPoints (hwndHeader, handle, headerRect, 2);
+				rect.right = headerRect.right;
 					index = (int)/*64*/OS.SendMessage (hwndHeader, OS.HDM_ORDERTOINDEX, 0, 0);
 					OS.SendMessage (hwndHeader, OS.HDM_GETITEMRECT, index, headerRect);
 					OS.MapWindowPoints (hwndHeader, handle, headerRect, 2);
 					rect.left = headerRect.left;
-					pClipRect.left = cellRect.left;
-					pClipRect.right += EXPLORER_EXTRA;
-				} else {
-					rect.right += EXPLORER_EXTRA;
-					pClipRect.right += EXPLORER_EXTRA;
-				}
-				int /*long*/ hTheme = OS.OpenThemeData (handle, Display.LISTVIEW);
-				int iStateId = selected ? OS.LISS_SELECTED : OS.LISS_HOT;
-				if (OS.GetFocus () != handle && selected && !drawHot) iStateId = OS.LISS_SELECTEDNOTFOCUS;
-				if (drawDrophilited) iStateId = OS.LISS_SELECTED;
-				OS.DrawThemeBackground (hTheme, hDC, OS.LVP_LISTITEM, iStateId, rect, pClipRect);
-				OS.CloseThemeData (hTheme);
+				pClipRect.left = cellRect.left;
+				pClipRect.right += EXPLORER_EXTRA;
+			} else {
+				rect.right += EXPLORER_EXTRA;
+				pClipRect.right += EXPLORER_EXTRA;
 			}
+			int /*long*/ hTheme = OS.OpenThemeData (handle, Display.LISTVIEW);
+			int iStateId = selected ? OS.LISS_SELECTED : OS.LISS_HOT;
+			if (OS.GetFocus () != handle && selected && !hot) iStateId = OS.LISS_SELECTEDNOTFOCUS;
+			OS.DrawThemeBackground (hTheme, hDC, OS.LVP_LISTITEM, iStateId, rect, pClipRect);
+			OS.CloseThemeData (hTheme);
+			}
 		} else {
 			if (!ignoreDrawSelection && clrSelectionBk != -1) fillBackground (hDC, clrSelectionBk, textRect);
 		}
-	}
+		}
 	if (focused && ignoreDrawFocus) {
 		nmcd.uItemState &= ~OS.CDIS_FOCUS;
 		OS.MoveMemory (lParam, nmcd, NMLVCUSTOMDRAW.sizeof);
@@ -3840,7 +3840,7 @@
 			}
 		}
 	}
-	
+
 	/*
 	* Force the table to have focus so that when the user
 	* reselects the focus item, the LVIS_FOCUSED state bits
@@ -3850,7 +3850,7 @@
 	* below.
 	*/
 	OS.SetFocus (handle);
-		
+
 	/*
 	* Feature in Windows.  When the user selects outside of
 	* a table item, Windows deselects all the items, even
@@ -3866,7 +3866,7 @@
 			return LRESULT.ZERO;
 		}
 	}
-	
+
 	/*
 	* Feature in Windows.  When a table item is reselected
 	* in a single-select table, Windows does not issue a
@@ -4123,7 +4123,7 @@
 	* CLR_NONE to make the table transparent, Windows draws
 	* a black rectangle around the first column.  The fix is
 	* clear LVS_EX_FULLROWSELECT.
-	* 
+	*
 	* Feature in Windows.  When LVM_SETBKCOLOR is used with
 	* CLR_NONE and LVM_SETSELECTEDCOLUMN is used to select
 	* a column, Windows fills the column with the selection
@@ -4142,18 +4142,18 @@
 			OS.SendMessage (handle, OS.LVM_SETBKCOLOR, 0, OS.CLR_NONE);
 			OS.SendMessage (handle, OS.LVM_SETTEXTBKCOLOR, 0, OS.CLR_NONE);
 			OS.InvalidateRect (handle, null, true);
-			
+
 			/* Clear LVS_EX_FULLROWSELECT */
 			if (!explorerTheme && (style & SWT.FULL_SELECTION) != 0) {
 				int bits = OS.LVS_EX_FULLROWSELECT;
 				OS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits, 0);
 			}
-			
+
 			/* Clear LVM_SETSELECTEDCOLUMN */
 			if ((sortDirection & (SWT.UP | SWT.DOWN)) != 0) {
 				if (sortColumn != null && !sortColumn.isDisposed ()) {
 					OS.SendMessage (handle, OS.LVM_SETSELECTEDCOLUMN, -1, 0);
-					/* 
+					/*
 					* Bug in Windows.  When LVM_SETSELECTEDCOLUMN is set, Windows
 					* does not redraw either the new or the previous selected column.
 					* The fix is to force a redraw.
@@ -4173,7 +4173,7 @@
 				if ((style & SWT.CHECK) != 0) fixCheckboxImageListColor (true);
 				OS.InvalidateRect (handle, null, true);
 			}
-			
+
 			/* Set LVS_EX_FULLROWSELECT */
 			if (!explorerTheme && (style & SWT.FULL_SELECTION) != 0) {
 				if (!hooks (SWT.EraseItem) && !hooks (SWT.PaintItem)) {
@@ -4181,7 +4181,7 @@
 					OS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, bits, bits);
 				}
 			}
-			
+
 			/* Set LVM_SETSELECTEDCOLUMN */
 			if ((sortDirection & (SWT.UP | SWT.DOWN)) != 0) {
 				if (sortColumn != null && !sortColumn.isDisposed ()) {
@@ -4188,7 +4188,7 @@
 					int column = indexOf (sortColumn);
 					if (column != -1) {
 						OS.SendMessage (handle, OS.LVM_SETSELECTEDCOLUMN, column, 0);
-						/* 
+						/*
 						* Bug in Windows.  When LVM_SETSELECTEDCOLUMN is set, Windows
 						* does not redraw either the new or the previous selected column.
 						* The fix is to force a redraw.
@@ -4212,7 +4212,7 @@
 	* destroying and recreating the table.  The fix is to send
 	* the resize notification after the size has been changed in
 	* the operating system.
-	* 
+	*
 	* NOTE:  This does not fix the case when the user is resizing
 	* columns dynamically.  There is no fix for this case at this
 	* time.
@@ -4223,7 +4223,7 @@
 }
 
 /**
- * Sets the order that the items in the receiver should 
+ * Sets the order that the items in the receiver should
  * be displayed in to the given argument which is described
  * in terms of the zero-relative ordering of when the items
  * were added.
@@ -4238,12 +4238,12 @@
  *    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>
  *    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>
  * </ul>
- * 
+ *
  * @see Table#getColumnOrder()
  * @see TableColumn#getMoveable()
  * @see TableColumn#setMoveable(boolean)
  * @see SWT#Move
- * 
+ *
  * @since 3.1
  */
 public void setColumnOrder (int [] order) {
@@ -4327,7 +4327,7 @@
 					OS.SendMessage (handle, OS.LVM_SETBKCOLOR, 0, OS.CLR_NONE);
 					OS.DefWindowProc (handle, OS.WM_SETREDRAW, 1, 0);
 					if (OS.IsWinCE) {
-						int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);	
+						int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 						if (hwndHeader != 0) OS.InvalidateRect (hwndHeader, null, true);
 						OS.InvalidateRect (handle, null, true);
 					} else {
@@ -4479,7 +4479,7 @@
 }
 
 void setFocusIndex (int index) {
-//	checkWidget ();	
+//	checkWidget ();
 	/*
 	* An index of -1 will apply the change to all
 	* items.  Ensure that index is greater than -1.
@@ -4524,13 +4524,13 @@
 		setTopIndex (topIndex);
 		setRedraw (true);
 	}
-	
+
 	/*
 	* Bug in Windows.  Setting the font will cause the table
 	* to be redrawn but not the column headers.  The fix is
 	* to force a redraw of the column headers.
 	*/
-	int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);		 
+	int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 	OS.InvalidateRect (hwndHeader, null, true);
 }
 
@@ -4542,7 +4542,7 @@
 	*/
 	if (pixel == -1) pixel = OS.CLR_DEFAULT;
 	OS.SendMessage (handle, OS.LVM_SETTEXTCOLOR, 0, pixel);
-		
+
 	/*
 	* Feature in Windows.  When the foreground color is
 	* changed, the table does not redraw until the next
@@ -4553,7 +4553,7 @@
 
 /**
  * Marks the receiver's header as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -4580,7 +4580,7 @@
 	*/
 	int oldIndex = getTopIndex ();
 	OS.SetWindowLong (handle, OS.GWL_STYLE, newBits);
-	
+
 	/*
 	* Bug in Windows.  Making any change to an item that
 	* changes the item height of a table while the table
@@ -4723,7 +4723,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 /*public*/ void setItemHeight (int itemHeight) {
@@ -4756,7 +4756,7 @@
 	int newBits = show  ? OS.LVS_EX_GRIDLINES : 0;
 	OS.SendMessage (handle, OS.LVM_SETEXTENDEDLISTVIEWSTYLE, OS.LVS_EX_GRIDLINES, newBits);
 	if (show) {
-		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);	
+		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
 		if ((bits & OS.LVS_NOCOLUMNHEADER) == 0) fixItemHeight (true);
 	}
 }
@@ -4787,16 +4787,16 @@
 			* operation can occur when redraw is turned off, even operations
 			* where the table must be subclassed in order to have the correct
 			* behavior or work around a Windows bug.
-			* 
-			* This code is intentionally commented. 
+			*
+			* This code is intentionally commented.
 			*/
 //			subclass ();
-			
+
 			/* Set the width of the horizontal scroll bar */
 			setScrollWidth (null, true);
 
 			/*
-			* Bug in Windows.  For some reason, when WM_SETREDRAW is used 
+			* Bug in Windows.  For some reason, when WM_SETREDRAW is used
 			* to turn redraw back on this may result in a WM_SIZE.  If the
 			* table column widths are adjusted in WM_SIZE, blank lines may
 			* be inserted at the top of the widget.  A call to LVM_GETTOPINDEX
@@ -4806,7 +4806,7 @@
 			*/
 			setDeferResize (true);
 			OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);
-			int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);	
+			int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 			if (hwndHeader != 0) OS.SendMessage (hwndHeader, OS.WM_SETREDRAW, 1, 0);
 			if ((state & HIDDEN) != 0) {
 				state &= ~HIDDEN;
@@ -4829,7 +4829,7 @@
 			OS.SendMessage (handle, OS.WM_SETREDRAW, 0, 0);
 			int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 			if (hwndHeader != 0) OS.SendMessage (hwndHeader, OS.WM_SETREDRAW, 0, 0);
-			
+
 			/*
 			* When many items are added to a table, it is faster to
 			* temporarily unsubclass the window proc so that messages
@@ -4840,7 +4840,7 @@
 			* where the table must be subclassed in order to have the correct
 			* behavior or work around a Windows bug.
 			*
-			* This code is intentionally commented. 
+			* This code is intentionally commented.
 			*/
 //			unsubclass ();
 		}
@@ -5032,7 +5032,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSelection (TableItem  item) {
@@ -5083,7 +5083,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver. 
+ * Selects the item at the given zero-relative index in the receiver.
  * The current selection is first cleared, then the new item is selected.
  *
  * @param index the index of the item to select
@@ -5114,7 +5114,7 @@
  * If the receiver is single-select and there is more than one item in the
  * given range, then all indices are ignored.
  * </p>
- * 
+ *
  * @param start the start index of the items to select
  * @param end the end index of the items to select
  *
@@ -5141,19 +5141,19 @@
 
 /**
  * Sets the column used by the sort indicator for the receiver. A null
- * value will clear the sort indicator.  The current sort column is cleared 
+ * value will clear the sort indicator.  The current sort column is cleared
  * before the new column is set.
  *
  * @param column the column used by the sort indicator or <code>null</code>
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the column is disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortColumn (TableColumn column) {
@@ -5169,16 +5169,16 @@
 }
 
 /**
- * Sets the direction of the sort indicator for the receiver. The value 
+ * Sets the direction of the sort indicator for the receiver. The value
  * can be one of <code>UP</code>, <code>DOWN</code> or <code>NONE</code>.
  *
- * @param direction the direction of the sort indicator 
+ * @param direction the direction of the sort indicator
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setSortDirection (int direction) {
@@ -5250,11 +5250,11 @@
  * </ul>
  */
 public void setTopIndex (int index) {
-	checkWidget (); 
+	checkWidget ();
 	int topIndex = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETTOPINDEX, 0, 0);
 	if (index == topIndex) return;
 	if (!painted && hooks (SWT.MeasureItem)) hitTestSelection (index, 0, 0);
-	
+
 	/*
 	* Bug in Windows.  For some reason, LVM_SCROLL refuses to
 	* scroll a table vertically when the width and height of
@@ -5408,8 +5408,8 @@
 	* Bug in Windows.  For some reason, when there is insufficient space
 	* to show an item, LVM_ENSUREVISIBLE causes blank lines to be
 	* inserted at the top of the widget.  A call to LVM_GETTOPINDEX will
-	* return a negative number (this is an impossible result).  The fix 
-	* is to use LVM_GETCOUNTPERPAGE to detect the case when the number 
+	* return a negative number (this is an impossible result).  The fix
+	* is to use LVM_GETCOUNTPERPAGE to detect the case when the number
 	* of visible items is zero and use LVM_ENSUREVISIBLE with the
 	* fPartialOK flag set to true to scroll the table.
 	*/
@@ -5426,7 +5426,7 @@
 		OS.SendMessage (handle, OS.LVM_ENSUREVISIBLE, index, 1);
 		if (index != OS.SendMessage (handle, OS.LVM_GETTOPINDEX, 0, 0)) {
 			OS.SendMessage (handle, OS.LVM_ENSUREVISIBLE, index, 1);
-		}		
+		}
 	} else {
 		OS.SendMessage (handle, OS.LVM_ENSUREVISIBLE, index, 0);
 	}
@@ -5471,7 +5471,7 @@
  * @see Table#showItem(TableItem)
  */
 public void showSelection () {
-	checkWidget (); 
+	checkWidget ();
 	int index = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETNEXTITEM, -1, OS.LVNI_SELECTED);
 	if (index != -1) showItem (index);
 }
@@ -5556,7 +5556,7 @@
 	* If the application expects to see a paint event or has a child
 	* whose font, foreground or background color might be needed,
 	* the window proc cannot be unsubclassed.
-	* 
+	*
 	* NOTE: The header tooltip can subclass the header proc so the
 	* current proc must be restored or header tooltips stop working.
 	*/
@@ -5763,7 +5763,7 @@
 				* the header not notified and NM_RELEASEDCAPTURE is not
 				* sent.  The fix is to redraw the header when the capture
 				* changes to another control.
-				* 
+				*
 				* This does not happen on XP.
 				*/
 				if (OS.COMCTL32_MAJOR < 6) {
@@ -5791,7 +5791,7 @@
 				OS.MoveMemory (hdr, lParam, NMHDR.sizeof);
 				switch (hdr.code) {
 					case OS.TTN_SHOW:
-					case OS.TTN_POP: 
+					case OS.TTN_POP:
 					case OS.TTN_GETDISPINFOA:
 					case OS.TTN_GETDISPINFOW:
 						return OS.SendMessage (handle, msg, wParam, lParam);
@@ -5963,7 +5963,7 @@
 	* WM_RBUTTONUP.  This causes two context menus requests
 	* to be sent.  The fix is to ignore WM_CONTEXTMENU on
 	* mouse down.
-	* 
+	*
 	* NOTE: This only happens when dragging is disabled.
 	* When the table is detecting drag, the WM_CONTEXTMENU
 	* is not sent WM_RBUTTONUP.
@@ -6009,7 +6009,8 @@
 			*/
 			return LRESULT.ZERO;
 		case OS.VK_ADD:
-			if (OS.GetKeyState (OS.VK_CONTROL) < 0) {
+                        // <QFS/> Changed to getDisplay().GetKeyState
+                        if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) {
 				int index = 0;
 				while (index < columnCount) {
 					if (!columns [index].getResizable ()) break;
@@ -6038,7 +6039,7 @@
 			* so that internal messages are dispatched directly to the table.
 			* If the application expects to see a paint event, the window
 			* proc cannot be unsubclassed or the event will not be seen.
-			* 
+			*
 			* NOTE: The header tooltip can subclass the header proc so the
 			* current proc must be restored or header tooltips stop working.
 			*/
@@ -6104,7 +6105,7 @@
 	if (!display.captureChanged && !isDisposed ()) {
 		if (OS.GetCapture () != handle) OS.SetCapture (handle);
 	}
-	
+
 	/* Look for check/uncheck */
 	if ((style & SWT.CHECK) != 0) {
 		/*
@@ -6121,7 +6122,7 @@
 			if (!OS.IsWinCE) {
 				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, index + 1);
 			}
-		}	
+		}
 	}
 	return LRESULT.ZERO;
 }
@@ -6157,7 +6158,7 @@
 			if (!OS.IsWinCE) {
 				OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, handle, OS.OBJID_CLIENT, index + 1);
 			}
-		}	
+		}
 	}
 	return result;
 }
@@ -6290,7 +6291,7 @@
 	if (imageList != null || (style & SWT.CHECK) != 0) {
 		OS.InvalidateRect (handle, null, false);
 	}
-	
+
 	/*
 	* Bug in Windows.  For some reason, the table does
 	* not set the default focus rectangle to be the first
@@ -6315,7 +6316,7 @@
 LRESULT WM_SETFONT (int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.WM_SETFONT (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Bug in Windows.  When a header has a sort indicator
 	* triangle, Windows resizes the indicator based on the
@@ -6322,7 +6323,7 @@
 	* size of the n-1th font.  The fix is to always make
 	* the n-1th font be the default.  This makes the sort
 	* indicator always be the default size.
-	* 
+	*
 	* NOTE: The table window proc sets the actual font in
 	* the header so that all that is necessary here is to
 	* set the default first.
@@ -6329,7 +6330,7 @@
 	*/
 	int /*long*/ hwndHeader = OS.SendMessage (handle, OS.LVM_GETHEADER, 0, 0);
 	OS.SendMessage (hwndHeader, OS.WM_SETFONT, 0, lParam);
-	
+
 	if (headerToolTipHandle != 0) {
 		OS.SendMessage (headerToolTipHandle, OS.WM_SETFONT, wParam, lParam);
 	}
@@ -6413,7 +6414,7 @@
 		OS.GetScrollInfo (handle, OS.SB_HORZ, info);
 		oldPos = info.nPos;
 	}
-	
+
 	/*
 	* Feature in Windows.  When there are many columns in a table,
 	* scrolling performance can be improved by unsubclassing the
@@ -6421,7 +6422,7 @@
 	* to the table.  If the application expects to see a paint event
 	* or has a child whose font, foreground or background color might
 	* be needed, the window proc cannot be unsubclassed
-	* 
+	*
 	* NOTE: The header tooltip can subclass the header proc so the
 	* current proc must be restored or header tooltips stop working.
 	*/
@@ -6432,7 +6433,7 @@
 		oldTableProc = OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, TableProc);
 		oldHeaderProc = OS.SetWindowLongPtr (hwndHeader, OS.GWLP_WNDPROC, HeaderProc);
 	}
-	
+
 	/*
 	* Feature in Windows.  For some reason, when the table window
 	* proc processes WM_HSCROLL or WM_VSCROLL when there are many
@@ -6488,7 +6489,7 @@
 		OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, oldTableProc);
 		OS.SetWindowLongPtr (hwndHeader, OS.GWLP_WNDPROC, oldHeaderProc);
 	}
-	
+
 	/*
 	* Bug in Windows.  When a table that is drawing grid lines
 	* is slowly scrolled horizontally to the left, the table does
@@ -6547,7 +6548,7 @@
 			if (columnCount > H_SCROLL_LIMIT) {
 				int rowCount = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETCOUNTPERPAGE, 0, 0);
 				if (rowCount > V_SCROLL_LIMIT) fixScroll = getDrawing () && OS.IsWindowVisible (handle);
-			}
+	}
 		}
 	}
 	if (fixScroll) OS.DefWindowProc (handle, OS.WM_SETREDRAW, 0, 0);
@@ -6582,12 +6583,12 @@
 			}
 		}
 	}
-	
+
 	if (fixSubclass) {
 		OS.SetWindowLongPtr (handle, OS.GWLP_WNDPROC, oldTableProc);
 		OS.SetWindowLongPtr (hwndHeader, OS.GWLP_WNDPROC, oldHeaderProc);
 	}
-	
+
 	/*
 	* Bug in Windows.  When a table is drawing grid lines and the
 	* user scrolls vertically up or down by a line or a page, the
@@ -6606,7 +6607,7 @@
 				break;
 			case OS.SB_LINEDOWN:
 			case OS.SB_LINEUP:
-				RECT rect = new RECT ();					
+				RECT rect = new RECT ();
 				OS.GetWindowRect (hwndHeader, rect);
 				int headerHeight = rect.bottom - rect.top;
 				RECT clientRect = new RECT ();
@@ -6660,12 +6661,12 @@
 }
 
 LRESULT wmNotifyChild (NMHDR hdr, int /*long*/ wParam, int /*long*/ lParam) {
-	switch (hdr.code) {
+		switch (hdr.code) {
 		case OS.LVN_ODFINDITEMA:
 		case OS.LVN_ODFINDITEMW: {
 			if ((style & SWT.VIRTUAL) != 0) return new LRESULT (-1);
 			break;
-		}
+				}
 		case OS.LVN_ODSTATECHANGED: {
 			if ((style & SWT.VIRTUAL) != 0) {
 				if (!ignoreSelect) {
@@ -6674,21 +6675,21 @@
 					boolean oldSelected = (lpStateChange.uOldState & OS.LVIS_SELECTED) != 0;
 					boolean newSelected = (lpStateChange.uNewState & OS.LVIS_SELECTED) != 0;
 					if (oldSelected != newSelected) wasSelected = true;
+						}
 				}
+				break;
 			}
-			break;
-		}
 		case OS.LVN_GETDISPINFOA:
 		case OS.LVN_GETDISPINFOW: {
 //			if (drawCount != 0 || !OS.IsWindowVisible (handle)) break;
 			NMLVDISPINFO plvfi = new NMLVDISPINFO ();
 			OS.MoveMemory (plvfi, lParam, NMLVDISPINFO.sizeof);
-			
+
 			boolean [] visible = display.columnVisible;
 			if (visible != null && !visible [plvfi.iSubItem]) {
 				break;
-			}
-			
+					}
+
 			/*
 			* Feature in Windows.  When a new table item is inserted
 			* using LVM_INSERTITEM in a table that is transparent
@@ -6721,7 +6722,7 @@
 				* to be sent before the method returns. For this reason, LVM_REDRAWITEMS
 				* can never be used from a LVN_GETDISPINFO handler. The fix is to 
 				* InvalidateRect() passing the bounds for the entire item.
-				*/
+			*/
 				if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 					RECT rect = new RECT ();
 					rect.left = OS.LVIR_BOUNDS;
@@ -6731,13 +6732,13 @@
 					if (code != 0) OS.InvalidateRect (handle, rect, true);
 					break;
 				} else {
-					if ((style & SWT.VIRTUAL) != 0 && !item.cached) {
-						OS.SendMessage (handle, OS.LVM_REDRAWITEMS, plvfi.iItem, plvfi.iItem);
-						break;
-					}
+			if ((style & SWT.VIRTUAL) != 0 && !item.cached) {
+					OS.SendMessage (handle, OS.LVM_REDRAWITEMS, plvfi.iItem, plvfi.iItem);
+					break;
 				}
 			}
-			
+			}
+
 			/*
 			* The cached flag is used by both virtual and non-virtual
 			* tables to indicate that Windows has asked at least once
@@ -6773,7 +6774,7 @@
 					* The fix is to use a space rather than an empty string
 					* when anything but a tool tip is requested (to avoid
 					* a tool tip that is a single space).
-					* 
+					*
 					* NOTE: This is only a problem for items in the first
 					* column.  Assigning NULL to other columns stops Windows
 					* from drawing the selection when LVS_EX_FULLROWSELECT
@@ -6954,7 +6955,7 @@
 			break;
 		}
 		case OS.NM_RECOGNIZEGESTURE:
-			/* 
+			/*
 			* Feature on Pocket PC.  The tree and table controls detect the tap
 			* and hold gesture by default. They send a GN_CONTEXTMENU message to show
 			* the popup menu.  This default behaviour is unwanted on Pocket PC 2002
@@ -7047,7 +7048,7 @@
 		case OS.HDN_BEGINDRAG: {
 			if (ignoreColumnMove) return LRESULT.ONE;
 			int bits = (int)/*64*/OS.SendMessage (handle, OS.LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
-			if ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break; 
+			if ((bits & OS.LVS_EX_HEADERDRAGDROP) == 0) break;
 			if (columnCount == 0) return LRESULT.ONE;
 			NMHEADER phdn = new NMHEADER ();
 			OS.MoveMemory (phdn, lParam, NMHEADER.sizeof);
@@ -7170,14 +7171,14 @@
 		case OS.NM_CUSTOMDRAW: {
 			if (toolTipText != null) break;
 			if (isCustomToolTip ()) {
-				NMTTCUSTOMDRAW nmcd = new NMTTCUSTOMDRAW ();
-				OS.MoveMemory (nmcd, lParam, NMTTCUSTOMDRAW.sizeof);
-				return wmNotifyToolTip (nmcd, lParam);
-			}
+			NMTTCUSTOMDRAW nmcd = new NMTTCUSTOMDRAW ();
+			OS.MoveMemory (nmcd, lParam, NMTTCUSTOMDRAW.sizeof);
+			return wmNotifyToolTip (nmcd, lParam);
+		}
 			break;
 		}
 		case OS.TTN_GETDISPINFOA:
-		case OS.TTN_GETDISPINFOW: 
+		case OS.TTN_GETDISPINFOW:
 		case OS.TTN_SHOW: {
 			LRESULT result = super.wmNotify (hdr, wParam, lParam);
 			if (result != null) return result;
@@ -7192,7 +7193,7 @@
 				OS.POINTSTOPOINT (pt, pos);
 				OS.ScreenToClient (handle, pt);
 				pinfo.x = pt.x;
-				pinfo.y = pt.y;	
+				pinfo.y = pt.y;
 				/*
 				*  Bug in Windows.  When LVM_SUBITEMHITTEST is used to hittest
 				*  a point that is above the table, instead of returning -1 to
@@ -7262,7 +7263,7 @@
 									}
 								}
 							}
-						}			
+						}
 					}
 					if (hFont != -1) hFont = OS.SelectObject (hDC, hFont);
 					if (newFont != 0) OS.SelectObject (hDC, oldFont);
Index: org/eclipse/swt/widgets/Scale.java
===================================================================
--- org/eclipse/swt/widgets/Scale.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Scale.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -557,27 +557,27 @@
 	}
 
 	if (!ignoreSelection) {
-		Event event = new Event ();
-		/*
-		* This code is intentionally commented.  The event
-		* detail field is not currently supported on all
-		* platforms.
-		*/
-//		switch (code) {
-//			case OS.TB_TOP: 		event.detail = SWT.HOME;  break;
-//			case OS.TB_BOTTOM:		event.detail = SWT.END;  break;
-//			case OS.TB_LINEDOWN:	event.detail = SWT.ARROW_DOWN;  break;
-//			case OS.TB_LINEUP: 		event.detail = SWT.ARROW_UP;  break;
-//			case OS.TB_PAGEDOWN: 	event.detail = SWT.PAGE_DOWN;  break;
-//			case OS.TB_PAGEUP: 		event.detail = SWT.PAGE_UP;  break;
-//		}
-		/*
-		* Send the event because WM_HSCROLL and WM_VSCROLL
-		* are sent from a modal message loop in windows that
-		* is active when the user is scrolling.
-		*/
+	Event event = new Event ();
+	/*
+	* This code is intentionally commented.  The event
+	* detail field is not currently supported on all
+	* platforms.
+	*/
+//	switch (code) {
+//		case OS.TB_TOP: 		event.detail = SWT.HOME;  break;
+//		case OS.TB_BOTTOM:		event.detail = SWT.END;  break;
+//		case OS.TB_LINEDOWN:	event.detail = SWT.ARROW_DOWN;  break;
+//		case OS.TB_LINEUP: 		event.detail = SWT.ARROW_UP;  break;
+//		case OS.TB_PAGEDOWN: 	event.detail = SWT.PAGE_DOWN;  break;
+//		case OS.TB_PAGEUP: 		event.detail = SWT.PAGE_UP;  break;
+//	}
+	/*
+	* Send the event because WM_HSCROLL and WM_VSCROLL
+	* are sent from a modal message loop in windows that
+	* is active when the user is scrolling.
+	*/
 		sendSelectionEvent (SWT.Selection, event, true);
-		// widget could be disposed at this point
+	// widget could be disposed at this point
 	}
 	return null;
 }
Index: org/eclipse/swt/widgets/EventTable.java
===================================================================
--- org/eclipse/swt/widgets/EventTable.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/EventTable.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -14,6 +15,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.internal.SWTEventListener;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class implement a simple
  * look up mechanism that maps an event type
@@ -22,11 +28,17 @@
  */
 
 class EventTable {
+    // <QFS>
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.EventTable");
+    // </QFS>
+
+
 	int [] types;
 	Listener [] listeners;
 	int level;
 	static final int GROW_SIZE = 4;
-	
+
 public Listener [] getListeners (int eventType) {
 	if (types == null) return new Listener [0];
 	int count = 0;
@@ -40,7 +52,7 @@
 		if (types [i] == eventType) {
 			result [count++] = listeners [i];
 		}
-	}
+	}	
 	return result;
 }
 
@@ -74,6 +86,14 @@
 }
 
 public void sendEvent (Event event) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.build("sendEvent(Event)")
+            .add("eventtype=").add(Display.getEventName(event.type))
+            .add(", widget.class: ").add(event.widget == null ? "null" : event.widget.getClass().getName())
+            .log(Log.MTD);
+    }
+    // </QFS>
 	if (types == null) return;
 	level += level >= 0 ? 1 : -1;
 	try {
Index: org/eclipse/swt/widgets/Tracker.java
===================================================================
--- org/eclipse/swt/widgets/Tracker.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Tracker.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.graphics.*;
@@ -17,6 +18,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  *  Instances of this class implement rubber banding rectangles that are
  *  drawn onto a parent <code>Composite</code> or <code>Display</code>.
@@ -23,7 +29,7 @@
  *  These rectangles can be specified to respond to mouse and key events
  *  by either moving or resizing themselves accordingly.  Trackers are
  *  typically used to represent window geometries in a lightweight manner.
- *  
+ *
  * <dl>
  * <dt><b>Styles:</b></dt>
  * <dd>LEFT, RIGHT, UP, DOWN, RESIZE</dd>
@@ -41,6 +47,13 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public class Tracker extends Widget {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Tracker");
+    // </QFS>
 	Control parent;
 	boolean tracking, cancelled, stippled;
 	Rectangle [] rectangles = new Rectangle [0], proportions = rectangles;
@@ -51,7 +64,7 @@
 	boolean inEvent = false;
 	int /*long*/ hwndTransparent, hwndOpaque, oldTransparentProc, oldOpaqueProc;
 	int oldX, oldY;
-	
+
 	static boolean IsVista = !OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0);
 
 	/*
@@ -66,7 +79,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -104,7 +117,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -112,7 +125,7 @@
  * </p><p>
  * Note: Currently, null can be passed in for the display argument.
  * This has the effect of creating the tracker on the currently active
- * display if there is one. If there is no current display, the 
+ * display if there is one. If there is no current display, the
  * tracker is created on a "default" display. <b>Passing in null as
  * the display argument is not considered to be good coding style,
  * and may not be supported in a future release of SWT.</b>
@@ -125,7 +138,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#LEFT
  * @see SWT#RIGHT
  * @see SWT#UP
@@ -284,7 +297,7 @@
 		}
 		resizeCursor = newCursor;
 	}
-		
+
 	return new Point (pt.x, pt.y);
 }
 
@@ -315,16 +328,16 @@
 	int yMin = rectangles [0].y;
 	int xMax = rectangles [0].x + rectangles [0].width;
 	int yMax = rectangles [0].y + rectangles [0].height;
-	
+
 	for (int i = 1; i < rectangles.length; i++) {
 		if (rectangles [i].x < xMin) xMin = rectangles [i].x;
 		if (rectangles [i].y < yMin) yMin = rectangles [i].y;
 		int rectRight = rectangles [i].x + rectangles [i].width;
-		if (rectRight > xMax) xMax = rectRight;		
+		if (rectRight > xMax) xMax = rectRight;
 		int rectBottom = rectangles [i].y + rectangles [i].height;
 		if (rectBottom > yMax) yMax = rectBottom;
 	}
-	
+
 	return new Rectangle (xMin, yMin, xMax - xMin, yMax - yMin);
 }
 
@@ -346,7 +359,7 @@
 			} else {
 				height = 100;
 			}
-			result [i] = new Rectangle (x, y, width, height);			
+			result [i] = new Rectangle (x, y, width, height);
 		}
 	}
 	return result;
@@ -402,7 +415,7 @@
  * coordinates.
  *
  * @return the bounds of the Rectangles being drawn
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -451,9 +464,9 @@
  * Displays the Tracker rectangles for manipulation by the user.  Returns when
  * the user has either finished manipulating the rectangles or has cancelled the
  * Tracker.
- * 
+ *
  * @return <code>true</code> if the user did not cancel the Tracker, <code>false</code> otherwise
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -460,9 +473,35 @@
  * </ul>
  */
 public boolean open () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.dumpStack(Log.MTD, "open()", "");
+    }
+    // </QFS>
 	checkWidget ();
 	cancelled = false;
 	tracking = true;
+        // <QFS>
+        // Check if we're running a eclipse.ui DnD loop and inform the display if necessary.
+        java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream();
+        java.io.PrintWriter pw = new java.io.PrintWriter (os);
+        try {
+            throw new Exception();
+        } catch (Exception ex) {
+            ex.printStackTrace(pw);
+        }
+        pw.close();
+        String dump = os.toString();
+        boolean insideDnD =
+            dump.indexOf("org.eclipse.e4.ui.workbench.addons.dndaddon.DnDManager.startDrag") > 0
+            || dump.indexOf("org.eclipse.ui.internal.dnd.DragUtil.performDrag") > 0;
+        if (logger.level >= Log.DBG) {
+            logger.build("open()").add("insideDnD: ").add(insideDnD).log(Log.DBG);
+        }
+        if (insideDnD) {
+            display.runDNDTrackerHooks(true, false);
+        }
+        // </QFS>
 
 	/*
 	* If exactly one of UP/DOWN is specified as a style then set the cursor
@@ -478,13 +517,14 @@
 	}
 
 	Callback newProc = null;
-	boolean mouseDown = OS.GetKeyState(OS.VK_LBUTTON) < 0;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	boolean mouseDown = getDisplay().GetKeyState(OS.VK_LBUTTON) < 0;
 	/*
 	* Bug in Vista. Drawing directly to the screen with XOR does not
 	* perform well. The fix is to draw on layered window instead.
-	* 
+	*
 	* Note that one window (almost opaque) is used for catching all events and a
-	* second window is used for drawing the rectangles. 
+	* second window is used for drawing the rectangles.
 	*/
 	if (IsVista && parent == null) {
 		Rectangle bounds = display.getBounds();
@@ -500,28 +540,28 @@
 			OS.GetModuleHandle (null),
 			null);
 		OS.SetLayeredWindowAttributes (hwndTransparent, 0, (byte)0x01, OS.LWA_ALPHA);
-		hwndOpaque = OS.CreateWindowEx (
-			OS.WS_EX_LAYERED | OS.WS_EX_NOACTIVATE,
-			display.windowClass,
-			null,
-			OS.WS_POPUP,
+			hwndOpaque = OS.CreateWindowEx (
+				OS.WS_EX_LAYERED | OS.WS_EX_NOACTIVATE,
+				display.windowClass,
+				null,
+				OS.WS_POPUP,
 			bounds.x, bounds.y,
 			bounds.width, bounds.height,
-			hwndTransparent,
-			0,
-			OS.GetModuleHandle (null),
-			null);
-		OS.SetLayeredWindowAttributes (hwndOpaque, 0xFFFFFF, (byte)0xFF, OS.LWA_COLORKEY | OS.LWA_ALPHA);		
+				hwndTransparent,
+				0,
+				OS.GetModuleHandle (null),
+				null);
+		OS.SetLayeredWindowAttributes (hwndOpaque, 0xFFFFFF, (byte)0xFF, OS.LWA_COLORKEY | OS.LWA_ALPHA);
 		newProc = new Callback (this, "transparentProc", 4); //$NON-NLS-1$
 		int /*long*/ newProcAddress = newProc.getAddress ();
 		if (newProcAddress == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
 		oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
 		OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
-		oldOpaqueProc = OS.GetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC);
-		OS.SetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC, newProcAddress);
+			oldOpaqueProc = OS.GetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC);
+			OS.SetWindowLongPtr (hwndOpaque, OS.GWLP_WNDPROC, newProcAddress);
 		OS.ShowWindow (hwndTransparent, OS.SW_SHOWNOACTIVATE);
 		OS.ShowWindow (hwndOpaque, OS.SW_SHOWNOACTIVATE);
-	} else {
+		} else {
 		/*
 		* If this tracker is being created without a mouse drag then
 		* we need to create a transparent window that fills the screen
@@ -544,8 +584,8 @@
 			newProc = new Callback (this, "transparentProc", 4); //$NON-NLS-1$
 			int /*long*/ newProcAddress = newProc.getAddress ();
 			if (newProcAddress == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
-			oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
-			OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
+		oldTransparentProc = OS.GetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC);
+		OS.SetWindowLongPtr (hwndTransparent, OS.GWLP_WNDPROC, newProcAddress);
 			OS.ShowWindow (hwndTransparent, OS.SW_SHOWNOACTIVATE);
 		}
 	}
@@ -555,7 +595,8 @@
 	Point cursorPos = null;
 	if (mouseDown) {
 		POINT pt = new POINT ();
-		OS.GetCursorPos (pt);
+                // <QFS/> Get overridden cursor position
+		OS._GetCursorPos (pt);
 		cursorPos = new Point (pt.x, pt.y);
 	} else {
 		if ((style & SWT.RESIZE) != 0) {
@@ -637,6 +678,11 @@
 		}
 	}
 	tracking = false;
+        // <QFS>
+        if (insideDnD) {
+            display.runDNDTrackerHooks(false, cancelled);
+        }
+        // </QFS>
 	return !cancelled;
 }
 
@@ -715,12 +761,12 @@
 	if (yChange > 0 && ((style & SWT.DOWN) != 0) && ((cursorOrientation & SWT.UP) == 0)) {
 		cursorOrientation |= SWT.DOWN;
 	}
-	
+
 	/*
 	 * If the bounds will flip about the x or y axis then apply the adjustment
 	 * up to the axis (ie.- where bounds width/height becomes 0), change the
 	 * cursor's orientation accordingly, and flip each Rectangle's origin (only
-	 * necessary for > 1 Rectangles) 
+	 * necessary for > 1 Rectangles)
 	 */
 	if ((cursorOrientation & SWT.LEFT) != 0) {
 		if (xChange > bounds.width) {
@@ -782,7 +828,7 @@
 			}
 		}
 	}
-	
+
 	// apply the bounds adjustment
 	if ((cursorOrientation & SWT.LEFT) != 0) {
 		bounds.x += xChange;
@@ -796,7 +842,7 @@
 	} else if ((cursorOrientation & SWT.DOWN) != 0) {
 		bounds.height += yChange;
 	}
-	
+
 	Rectangle [] newRects = new Rectangle [rectangles.length];
 	for (int i = 0; i < rectangles.length; i++) {
 		Rectangle proportion = proportions[i];
@@ -806,7 +852,7 @@
 			proportion.width * bounds.width / 100,
 			proportion.height * bounds.height / 100);
 	}
-	rectangles = newRects;	
+	rectangles = newRects;
 }
 
 /**
@@ -814,7 +860,7 @@
  * then the cursor reverts to the default.
  *
  * @param newCursor the new <code>Cursor</code> to display
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -897,7 +943,7 @@
 			if (hwndOpaque == hwnd) {
 				PAINTSTRUCT ps = new PAINTSTRUCT();
 				int /*long*/ hDC = OS.BeginPaint (hwnd, ps);
-				int /*long*/ hBitmap = 0, hBrush = 0, oldBrush = 0;			
+				int /*long*/ hBitmap = 0, hBrush = 0, oldBrush = 0;
 				int /*long*/ transparentBrush = OS.CreateSolidBrush(0xFFFFFF);
 				oldBrush = OS.SelectObject (hDC, transparentBrush);
 				OS.PatBlt (hDC, ps.left, ps.top, ps.right - ps.left, ps.bottom - ps.top, OS.PATCOPY);
@@ -957,7 +1003,8 @@
 	LRESULT result = super.wmKeyDown (hwnd, wParam, lParam);
 	if (result != null) return result;
 	boolean isMirrored = parent != null && (parent.style & SWT.MIRRORED) != 0;
-	int stepSize = OS.GetKeyState (OS.VK_CONTROL) < 0 ? STEPSIZE_SMALL : STEPSIZE_LARGE;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	int stepSize = getDisplay().GetKeyState (OS.VK_CONTROL) < 0 ? STEPSIZE_SMALL : STEPSIZE_LARGE;
 	int xChange = 0, yChange = 0;
 	switch ((int)/*64*/wParam) {
 		case OS.VK_ESCAPE:
@@ -1090,7 +1137,7 @@
 LRESULT wmSysKeyDown (int /*long*/ hwnd, int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.wmSysKeyDown (hwnd, wParam, lParam);
 	if (result != null) return result;
-	cancelled = true;			
+	cancelled = true;
 	tracking = false;
 	return result;
 }
@@ -1165,8 +1212,8 @@
 			}
 		} else {
 			if (isMirrored) {
-				moveRectangles (oldX - newX, newY - oldY); 
-			} else { 
+				moveRectangles (oldX - newX, newY - oldY);
+			} else {
 				moveRectangles (newX - oldX, newY - oldY);
 			}
 			inEvent = true;
Index: org/eclipse/swt/widgets/DateTime.java
===================================================================
--- org/eclipse/swt/widgets/DateTime.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/DateTime.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -263,12 +263,12 @@
 				width = size.cx;
 				height = size.cy;
 			} else {
-				int /*long*/ newFont, oldFont = 0;
-				int /*long*/ hDC = OS.GetDC (handle);
-				newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
-				if (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);
-				RECT rect = new RECT ();
-				if ((style & SWT.DATE) != 0) {
+			int /*long*/ newFont, oldFont = 0;
+			int /*long*/ hDC = OS.GetDC (handle);
+			newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
+			if (newFont != 0) oldFont = OS.SelectObject (hDC, newFont);
+			RECT rect = new RECT ();
+			if ((style & SWT.DATE) != 0) {
 					int dwFlags = 0;
 					TCHAR lpFormat = null;
 					if ((style & SWT.SHORT) != 0) {
@@ -281,8 +281,8 @@
 						TCHAR buffer = new TCHAR (getCodePage (), size);
 						OS.GetDateFormat(OS.LOCALE_USER_DEFAULT, dwFlags, null, lpFormat, buffer, buffer.length ());
 						OS.DrawText (hDC, buffer, size, rect, OS.DT_CALCRECT | OS.DT_EDITCONTROL);
-					}
-				} else if ((style & SWT.TIME) != 0) {
+				}
+			} else if ((style & SWT.TIME) != 0) {
 					int dwFlags = 0;
 					TCHAR lpFormat = null;
 					if ((style & SWT.SHORT) != 0) {
@@ -294,13 +294,13 @@
 						TCHAR buffer = new TCHAR (getCodePage (), size);
 						OS.GetTimeFormat(OS.LOCALE_USER_DEFAULT, dwFlags, null, lpFormat, buffer, buffer.length ());
 						OS.DrawText (hDC, buffer, size, rect, OS.DT_CALCRECT | OS.DT_EDITCONTROL);
-					}
 				}
+				}
 				width = rect.right - rect.left;
 				height = rect.bottom - rect.top;
-				if (newFont != 0) OS.SelectObject (hDC, oldFont);
-				OS.ReleaseDC (handle, hDC);
-				int upDownWidth = OS.GetSystemMetrics (OS.SM_CXVSCROLL);
+			if (newFont != 0) OS.SelectObject (hDC, oldFont);
+			OS.ReleaseDC (handle, hDC);
+			int upDownWidth = OS.GetSystemMetrics (OS.SM_CXVSCROLL);
 				width += upDownWidth + MARGIN;
 			}
 			int upDownHeight = OS.GetSystemMetrics (OS.SM_CYVSCROLL);
@@ -337,9 +337,9 @@
 }
 
 String getCustomShortDateFormat () {
-	TCHAR tchar = new TCHAR (getCodePage (), 80);
-	int size = OS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, OS.LOCALE_SYEARMONTH, tchar, 80);
-	return size != 0 ? tchar.toString (0, size - 1) : "M/yyyy"; //$NON-NLS-1$
+		TCHAR tchar = new TCHAR (getCodePage (), 80);
+		int size = OS.GetLocaleInfo (OS.LOCALE_USER_DEFAULT, OS.LOCALE_SYEARMONTH, tchar, 80);
+		return size != 0 ? tchar.toString (0, size - 1) : "M/yyyy"; //$NON-NLS-1$
 }
 
 String getCustomShortTimeFormat () {
@@ -817,8 +817,8 @@
 				if ((style & SWT.TIME) == 0) lastSystemTime = systime;
 			}
 			break;
-		}
 	}
+	}
 	return super.wmNotifyChild (hdr, wParam, lParam);
 }
 
Index: org/eclipse/swt/widgets/Group.java
===================================================================
--- org/eclipse/swt/widgets/Group.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Group.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -342,7 +342,7 @@
 			int /*long*/ topHandle = children [i].topHandle();
 			int bits = OS.GetWindowLong (topHandle, OS.GWL_STYLE);
 			if ((bits & OS.WS_VISIBLE) != 0) {
-				children [i].printWidget (topHandle, hdc, gc);
+			children [i].printWidget (topHandle, hdc, gc);
 			}
 			if (graphicsMode == OS.GM_ADVANCED) {
 				float [] lpXform = {1, 0, 0, 1, -location.x, -location.y};
Index: org/eclipse/swt/widgets/Synchronizer.java
===================================================================
--- org/eclipse/swt/widgets/Synchronizer.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Synchronizer.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -14,7 +15,12 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.internal.Compatibility;
- 
+
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class provide synchronization support
  * for displays. A default instance is created automatically
@@ -25,7 +31,7 @@
  * needs to deal with this class. It is provided only to
  * allow applications which require non-standard
  * synchronization behavior to plug in the support they
- * require. <em>Subclasses which override the methods in 
+ * require. <em>Subclasses which override the methods in
  * this class must ensure that the superclass methods are
  * invoked in their implementations</em>
  * </p>
@@ -39,6 +45,12 @@
 	RunnableLock [] messages;
 	Object messageLock = new Object ();
 	Thread syncThread;
+    // <QFS>
+    /**
+     * The logger used for logging.
+     */
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Synchronizer");
+    // </QFS>
 	static final int GROW_SIZE = 4;
 	static final int MESSAGE_LIMIT = 64;
 
@@ -49,13 +61,23 @@
 
 /**
  * Constructs a new instance of this class.
- * 
+ *
  * @param display the display to create the synchronizer on
  */
 public Synchronizer (Display display) {
-	this.display = display;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("Synchronizer(Display)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", display: ").add(display)).log(Log.MTD);
+    }
+    // </QFS>
+
+    this.display = display;
+
 }
-	
+
 void addLast (RunnableLock lock) {
 	boolean wake = false;
 	synchronized (messageLock) {
@@ -67,14 +89,66 @@
 		}
 		messages [messageCount++] = lock;
 		wake = messageCount == 1;
-	}	
+	}
 	if (wake) display.wakeThread ();
 }
 
+    // <QFS> Delegate to asyncExec except for special cases where QF-Test calls must not be
+    // blocked in a derived class.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The caller of this method continues
+     * to run in parallel, and is not notified when the
+     * runnable has completed.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @see #syncExec
+     */
+    protected void internalAsyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("internalAsyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        if (runnable != null
+            && "org.eclipse.ui.internal.UISynchronizer".equals(getClass().getName())
+            && runnable.getClass().getName().startsWith("de.qfs.")) {
+            trueAsyncExec(runnable);
+        } else {
+            asyncExec(runnable);
+        }
+    }
+    // </QFS>
+
+    // <QFS> Delegate to trueAsyncExec.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The caller of this method continues
+     * to run in parallel, and is not notified when the
+     * runnable has completed.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @see #syncExec
+     */
+    protected void asyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("asyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        trueAsyncExec(runnable);
+    }
+    // </QFS>
+
+    // <QFS/> Copy of original asyncExec.
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
- * reasonable opportunity. The caller of this method continues 
+ * be invoked by the user-interface thread at the next
+ * reasonable opportunity. The caller of this method continues
  * to run in parallel, and is not notified when the
  * runnable has completed.
  *
@@ -82,14 +156,22 @@
  *
  * @see #syncExec
  */
-protected void asyncExec (Runnable runnable) {
-	if (runnable == null) {
+void trueAsyncExec (Runnable runnable) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("trueAsyncExec(Runnable)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", runnable: ").add(runnable)).log(Log.MTD);
+    }
+    // </QFS>
+    if (runnable == null) {
 		//TEMPORARY CODE
 		if (!(IS_CARBON || IS_GTK || IS_COCOA)) {
-			display.wake ();
-			return;
-		}
+		display.wake ();
+		return;
 	}
+	}
 	addLast (new RunnableLock (runnable));
 }
 
@@ -124,15 +206,41 @@
 }
 
 boolean runAsyncMessages (boolean all) {
-	boolean run = false;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runAsyncMessages(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", all: ").add(all)).log(Log.MTD);
+    }
+    // </QFS>
+    boolean run = false;
 	do {
 		RunnableLock lock = removeFirst ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("runAsyncMessages(boolean)")
+                        .add("lock: ").add(lock).log(Log.DBG);
+                }
+                // </QFS>
 		if (lock == null) return run;
 		run = true;
 		synchronized (lock) {
 			syncThread = lock.thread;
 			try {
-				lock.run ();
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.log(Log.DBG, "runAsyncMessages(boolean)",
+                                           "Executing lock");
+                            }
+                            // </QFS>
+                            lock.run ();
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.log(Log.DBG, "runAsyncMessages(boolean)",
+                                           "Executing lock... done");
+                            }
+                            // </QFS>
 			} catch (Throwable t) {
 				lock.throwable = t;
 				SWT.error (SWT.ERROR_FAILED_EXEC, t);
@@ -145,9 +253,67 @@
 	return run;
 }
 
+    // <QFS> Delegate to syncExec except for special cases where QF-Test calls must not be
+    // blocked in a derived class.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The thread which calls this method
+     * is suspended until the runnable completes.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @exception SWTException <ul>
+     *    <li>ERROR_FAILED_EXEC - if an exception occurred when executing the runnable</li>
+     * </ul>
+     *
+     * @see #asyncExec
+     */
+    protected void internalSyncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("internalSyncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        if (runnable != null
+            && "org.eclipse.ui.internal.UISynchronizer".equals(getClass().getName())
+            && runnable.getClass().getName().startsWith("de.qfs.")) {
+            trueSyncExec(runnable);
+        } else {
+            syncExec(runnable);
+        }
+    }
+    // </QFS>
+
+    // <QFS> Delegate to trueSyncExec.
+    /**
+     * Causes the <code>run()</code> method of the runnable to
+     * be invoked by the user-interface thread at the next
+     * reasonable opportunity. The thread which calls this method
+     * is suspended until the runnable completes.
+     *
+     * @param runnable code to run on the user-interface thread.
+     *
+     * @exception SWTException <ul>
+     *    <li>ERROR_FAILED_EXEC - if an exception occurred when executing the runnable</li>
+     * </ul>
+     *
+     * @see #asyncExec
+     */
+    protected void syncExec (Runnable runnable) {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("syncExec(Runnable)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("runnable: ").add(runnable)).log(Log.MTD);
+        }
+        trueSyncExec(runnable);
+    }
+    // </QFS>
+
+    // <QFS/> Copy of original syncExec.
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
+ * be invoked by the user-interface thread at the next
  * reasonable opportunity. The thread which calls this method
  * is suspended until the runnable completes.
  *
@@ -159,7 +325,15 @@
  *
  * @see #asyncExec
  */
-protected void syncExec (Runnable runnable) {
+protected void trueSyncExec (Runnable runnable) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("trueSyncExec(Runnable)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", runnable: ").add(runnable)).log(Log.MTD);
+    }
+    // </QFS>
 	RunnableLock lock = null;
 	synchronized (Device.class) {
 		if (display == null || display.isDisposed ()) SWT.error (SWT.ERROR_DEVICE_DISPOSED);
Index: org/eclipse/swt/widgets/Link.java
===================================================================
--- org/eclipse/swt/widgets/Link.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Link.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -18,7 +19,7 @@
 
 /**
  * Instances of this class represent a selectable
- * user interface object that displays a text with 
+ * user interface object that displays a text with
  * links.
  * <p>
  * <dl>
@@ -34,7 +35,7 @@
  * @see <a href="http://www.eclipse.org/swt/snippets/#link">Link snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
- * 
+ *
  * @since 3.1
  * @noextend This class is not intended to be subclassed by clients.
  */
@@ -60,9 +61,9 @@
 			* Feature in Windows.  The SysLink window class
 			* does not include CS_DBLCLKS.  This means that these
 			* controls will not get double click messages such as
-			* WM_LBUTTONDBLCLK.  The fix is to register a new 
+			* WM_LBUTTONDBLCLK.  The fix is to register a new
 			* window class with CS_DBLCLKS.
-			* 
+			*
 			* NOTE:  Screen readers look for the exact class name
 			* of the control in order to provide the correct kind
 			* of assistance.  Therefore, it is critical that the
@@ -88,7 +89,7 @@
 			LinkProc = 0;
 		}
 	}
-	
+
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -95,7 +96,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -184,16 +185,16 @@
 		int /*long*/ newFont = OS.SendMessage (handle, OS.WM_GETFONT, 0, 0);
 		int /*long*/ oldFont = OS.SelectObject (hDC, newFont);
 		if (text.length () > 0) {
-			TCHAR buffer = new TCHAR (getCodePage (), parse (text), false);
-			RECT rect = new RECT ();
-			int flags = OS.DT_CALCRECT | OS.DT_NOPREFIX;
-			if (wHint != SWT.DEFAULT) {
-				flags |= OS.DT_WORDBREAK;
-				rect.right = wHint;
-			}
-			OS.DrawText (hDC, buffer, buffer.length (), rect, flags);
-			width = rect.right - rect.left;
-			height = rect.bottom;
+		TCHAR buffer = new TCHAR (getCodePage (), parse (text), false);
+		RECT rect = new RECT ();
+		int flags = OS.DT_CALCRECT | OS.DT_NOPREFIX;
+		if (wHint != SWT.DEFAULT) {
+			flags |= OS.DT_WORDBREAK;
+			rect.right = wHint;
+		}
+		OS.DrawText (hDC, buffer, buffer.length (), rect, flags);
+		width = rect.right - rect.left;
+		height = rect.bottom;
 		} else {
 			TEXTMETRIC lptm = OS.IsUnicode ? (TEXTMETRIC)new TEXTMETRICW () : new TEXTMETRICA ();
 			OS.GetTextMetrics (hDC, lptm);
@@ -272,7 +273,7 @@
 		Rectangle [] rects = getRectangles (focusIndex);
 		for (int i = 0; i < rects.length; i++) {
 			Rectangle rectangle = rects [i];
-			gc.drawFocus (rectangle.x, rectangle.y, rectangle.width, rectangle.height);					
+			gc.drawFocus (rectangle.x, rectangle.y, rectangle.width, rectangle.height);
 		}
 	}
 	if (hooks (SWT.Paint) || filters (SWT.Paint)) {
@@ -304,7 +305,7 @@
 			layout.setStyle (linkStyle, point.x, point.y);
 		}
 	}
-	redraw ();
+		redraw ();
 	/*
 	* Feature in Windows.  For some reason, setting
 	* LIS_ENABLED state using LM_SETITEM causes the
@@ -311,7 +312,7 @@
 	* SysLink to become enabled.  To be specific,
 	* calling IsWindowEnabled() returns true.  The
 	* fix is disable the SysLink after LM_SETITEM.
-	*/	
+	*/
 	super.enableWidget (enabled);
 }
 
@@ -322,12 +323,12 @@
 			e.result = parse (text);
 		}
 	});
-		
+
 	accessible.addAccessibleControlListener (new AccessibleControlAdapter () {
 		public void getChildAtPoint (AccessibleControlEvent e) {
 			e.childID = ACC.CHILDID_SELF;
 		}
-		
+
 		public void getLocation (AccessibleControlEvent e) {
 			Rectangle rect = display.map (getParent (), null, getBounds ());
 			e.x = rect.x;
@@ -335,28 +336,28 @@
 			e.width = rect.width;
 			e.height = rect.height;
 		}
-		
+
 		public void getChildCount (AccessibleControlEvent e) {
 			e.detail = 0;
 		}
-		
+
 		public void getRole (AccessibleControlEvent e) {
 			e.detail = ACC.ROLE_LINK;
 		}
-		
+
 		public void getState (AccessibleControlEvent e) {
 			e.detail = ACC.STATE_FOCUSABLE;
 			if (hasFocus ()) e.detail |= ACC.STATE_FOCUSED;
 		}
-		
+
 		public void getDefaultAction (AccessibleControlEvent e) {
 			e.result = SWT.getMessage ("SWT_Press"); //$NON-NLS-1$
 		}
-		
+
 		public void getSelection (AccessibleControlEvent e) {
 			if (hasFocus ()) e.childID = ACC.CHILDID_SELF;
 		}
-		
+
 		public void getFocus (AccessibleControlEvent e) {
 			if (hasFocus ()) e.childID = ACC.CHILDID_SELF;
 		}
@@ -392,7 +393,7 @@
 		Rectangle [] tmp = new Rectangle [index];
 		System.arraycopy (rects, 0, tmp, 0, index);
 		rects = tmp;
-	}	
+	}
 	return rects;
 }
 
@@ -480,7 +481,7 @@
 	while (index < length) {
 		char c = Character.toLowerCase (buffer [index]);
 		switch (state) {
-			case 0: 
+			case 0:
 				if (c == '<') {
 					tagStart = index;
 					state++;
@@ -593,7 +594,7 @@
 		ids = newIDs;
 		int [] newMnemonics = new int [linkIndex + 1];
 		System.arraycopy (mnemonics, 0, newMnemonics, 0, linkIndex + 1);
-		mnemonics = newMnemonics;		
+		mnemonics = newMnemonics;
 	}
 	return result.toString ();
 }
@@ -651,7 +652,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection, listener);	
+	eventTable.unhook (SWT.DefaultSelection, listener);
 }
 
 /**
@@ -679,7 +680,7 @@
  * '&amp;' can be escaped by doubling it in the string, causing
  * a single '&amp;' to be displayed.
  * </p> 
- * 
+ *
  * @param string the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -694,7 +695,7 @@
 	checkWidget ();
 	if (string == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (string.equals (text)) return;
-	text = string;	
+	text = string;
 	if (OS.COMCTL32_MAJOR >= 6) {
 		boolean enabled = OS.IsWindowEnabled (handle);
 		/*
@@ -709,7 +710,7 @@
 		parse (text);
 		enableWidget (enabled);
 	} else {
-		layout.setText (parse (text));	
+		layout.setText (parse (text));
 		focusIndex = offsets.length > 0 ? 0 : -1;
 		selection.x = selection.y = -1;
 		int bits = OS.GetWindowLong (handle, OS.GWL_STYLE);
@@ -764,7 +765,8 @@
 				sendSelectionEvent (SWT.Selection, event, true);
 				break;
 			case SWT.TAB:
-				boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+                                // <QFS/> Changed to getDisplay().GetKeyState
+				boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 				if (next) {
 					if (focusIndex < offsets.length - 1) {
 						focusIndex++;
@@ -792,7 +794,7 @@
 				int /*long*/ code = callWindowProc (handle, OS.WM_KEYDOWN, wParam, lParam);
 				return new LRESULT (code);
 		}
-		
+
 	}
 	return result;
 }
@@ -817,12 +819,13 @@
 		code = callWindowProc (handle, OS.WM_GETDLGCODE, wParam, lParam);
 	} else {
 		index = focusIndex;
-		count = offsets.length; 
+		count = offsets.length;
 	}
 	if (count == 0) {
 		return new LRESULT (code | OS.DLGC_STATIC);
 	}
-	boolean next = OS.GetKeyState (OS.VK_SHIFT) >= 0;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	boolean next = getDisplay().GetKeyState (OS.VK_SHIFT) >= 0;
 	if (next && index < count - 1) {
 		return new LRESULT (code | OS.DLGC_WANTTAB);
 	}
@@ -930,7 +933,7 @@
 LRESULT WM_NCHITTEST (int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = super.WM_NCHITTEST (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Feature in Windows. For WM_NCHITTEST, the Syslink window proc
 	* returns HTTRANSPARENT when mouse is over plain text. The fix is
@@ -937,7 +940,7 @@
 	* to always return HTCLIENT.
 	*/
 	if (OS.COMCTL32_MAJOR >= 6) return new LRESULT (OS.HTCLIENT);
-	
+
 	return result;
 }
 
@@ -946,7 +949,8 @@
 	if (OS.COMCTL32_MAJOR < 6) {
 		int x = OS.GET_X_LPARAM (lParam);
 		int y = OS.GET_Y_LPARAM (lParam);
-		if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+                // <QFS/> Changed to getDisplay().GetKeyState
+		if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 			int oldSelection = selection.y;
 			selection.y = layout.getOffset (x, y, null);
 			if (selection.y != oldSelection) {
Index: org/eclipse/swt/widgets/MessageBox.java
===================================================================
--- org/eclipse/swt/widgets/MessageBox.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/MessageBox.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -13,6 +14,10 @@
 
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
 /**
  * Instances of this class are used to inform or warn the user.
@@ -38,8 +43,17 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public  class MessageBox extends Dialog {
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.MessageBox");
+    // </QFS>
+
 	String message = "";
-	
+
 /**
  * Constructs a new instance of this class given only its parent.
  *
@@ -63,7 +77,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -79,7 +93,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#ICON_ERROR
  * @see SWT#ICON_INFORMATION
  * @see SWT#ICON_QUESTION
@@ -169,7 +183,7 @@
 			bits |= OS.MB_RTLREADING | OS.MB_RIGHT;
 		}
 	}
-	
+
 	/*
 	* Feature in Windows.  System modal is not supported
 	* on Windows 95 and NT.  The fix is to convert system
@@ -188,7 +202,7 @@
 	* If the parent is not NULL, MB_TASKMODAL behaves the
 	* same as MB_APPLMODAL.  The fix to set the parent HWND
 	* anyway and not rely on MB_MODAL to work by making the
-	* parent be temporarily modal. 
+	* parent be temporarily modal.
 	*/
 	int /*long*/ hwndOwner = parent != null ? parent.handle : 0;
 	Dialog oldModal = null;
@@ -203,13 +217,29 @@
 	/* Use the character encoding for the default locale */
 	TCHAR buffer1 = new TCHAR (0, message, true);
 	TCHAR buffer2 = new TCHAR (0, title, true);
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	int code = OS.MessageBox (hwndOwner, buffer1, buffer2, bits);
-	
 	/* Clear the temporarily dialog modal parent */
 	if ((bits & OS.MB_TASKMODAL) != 0) {
 		display.setModalDialog (oldModal);
 	}
-	
+
 	/*
 	* This code is intentionally commented.  On some
 	* platforms, the owner window is repainted right
@@ -217,32 +247,54 @@
 	* is currently unspecified.
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
-	
+
+        // <QFS/> Don't return immediately so result can be overridden.
+        int ret;
 	/* Compute and return the result */
 	if (code != 0) {
-		int type = bits & 0x0F;
-		if (type == OS.MB_OK) return SWT.OK;
-		if (type == OS.MB_OKCANCEL) {
-			return (code == OS.IDOK) ? SWT.OK : SWT.CANCEL;
-		}
-		if (type == OS.MB_YESNO) {
-			return (code == OS.IDYES) ? SWT.YES : SWT.NO;
-		}
-		if (type == OS.MB_YESNOCANCEL) {
-			if (code == OS.IDYES) return SWT.YES;
-			if (code == OS.IDNO) return SWT.NO;
-			return SWT.CANCEL;
-		}
-		if (type == OS.MB_RETRYCANCEL) {
-			return (code == OS.IDRETRY) ? SWT.RETRY : SWT.CANCEL;
-		}
-		if (type == OS.MB_ABORTRETRYIGNORE) {
-			if (code == OS.IDRETRY) return SWT.RETRY;
-			if (code == OS.IDABORT) return SWT.ABORT;
-			return SWT.IGNORE;
-		}
-	}
-	return SWT.CANCEL;
+            int type = bits & 0x0F;
+            if (type == OS.MB_OK) {
+                ret = SWT.OK;
+            } else if (type == OS.MB_OKCANCEL) {
+                ret = (code == OS.IDOK) ? SWT.OK : SWT.CANCEL;
+            } else if (type == OS.MB_YESNO) {
+                ret = (code == OS.IDYES) ? SWT.YES : SWT.NO;
+            } else if (type == OS.MB_YESNOCANCEL) {
+                if (code == OS.IDYES) {
+                    ret = SWT.YES;
+                } else if (code == OS.IDNO) {
+                    ret = SWT.NO;
+                } else {
+                    ret = SWT.CANCEL;
+                }
+            } else if (type == OS.MB_RETRYCANCEL) {
+                ret = (code == OS.IDRETRY) ? SWT.RETRY : SWT.CANCEL;
+            } else if (type == OS.MB_ABORTRETRYIGNORE) {
+                if (code == OS.IDRETRY) {
+                    ret = SWT.RETRY;
+                } else if (code == OS.IDABORT) {
+                    ret = SWT.ABORT;
+                } else {
+                    ret = SWT.IGNORE;
+                }
+            } else {
+                ret = SWT.CANCEL;
+            }
+        } else {
+                ret = SWT.CANCEL;
+        }
+
+        // <QFS>
+        Object result = new Integer (ret);
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+        if (logger.level >= Log.DBG) {
+            logger.build("open()").add("result: ").add(result).log(Log.DBG);
+        }
+        if (result instanceof Integer) {
+            ret = ((Integer) result).intValue();
+        }
+        // </QFS>
+        return ret;
 }
 
 /**
@@ -251,7 +303,7 @@
  * visible on the dialog while it is open.
  *
  * @param string the message
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the string is null</li>
  * </ul>
Index: org/eclipse/swt/widgets/Caret.java
===================================================================
--- org/eclipse/swt/widgets/Caret.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Caret.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -292,17 +292,17 @@
 		OS.SetRect (lpCandidate.rcArea, ptCurrentPos.x, ptCurrentPos.y, ptCurrentPos.x + size.x, ptCurrentPos.y + size.y);
 		OS.ImmSetCandidateWindow (hIMC, lpCandidate);
 	} else {
-		RECT rect = new RECT ();
-		OS.GetClientRect (hwnd, rect);
-		COMPOSITIONFORM lpCompForm = new COMPOSITIONFORM ();
-		lpCompForm.dwStyle = OS.CFS_RECT;
-		lpCompForm.x = ptCurrentPos.x;
-		lpCompForm.y = ptCurrentPos.y;
-		lpCompForm.left = rect.left;
-		lpCompForm.right = rect.right;
-		lpCompForm.top = rect.top;
-		lpCompForm.bottom = rect.bottom;
-		OS.ImmSetCompositionWindow (hIMC, lpCompForm);
+	RECT rect = new RECT ();
+	OS.GetClientRect (hwnd, rect);
+	COMPOSITIONFORM lpCompForm = new COMPOSITIONFORM ();
+	lpCompForm.dwStyle = OS.CFS_RECT;
+	lpCompForm.x = ptCurrentPos.x;
+	lpCompForm.y = ptCurrentPos.y;
+	lpCompForm.left = rect.left;
+	lpCompForm.right = rect.right;
+	lpCompForm.top = rect.top;
+	lpCompForm.bottom = rect.bottom;
+	OS.ImmSetCompositionWindow (hIMC, lpCompForm);
 	}
 	OS.ImmReleaseContext (hwnd, hIMC);
 }
Index: org/eclipse/swt/widgets/Dialog.java
===================================================================
--- org/eclipse/swt/widgets/Dialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Dialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,12 +7,18 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
 
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
+
 /**
  * This class is the abstract superclass of the classes
  * that represent the built in platform dialogs.
@@ -27,7 +33,7 @@
  * <pre><code>
  * public class MyDialog extends Dialog {
  *	Object result;
- *		
+ *
  *	public MyDialog (Shell parent, int style) {
  *		super (parent, style);
  *	}
@@ -54,7 +60,7 @@
  * by every subclass on every platform. If a modality style is
  * not supported, it is "upgraded" to a more restrictive modality
  * style that is supported.  For example, if <code>PRIMARY_MODAL</code>
- * is not supported by a particular dialog, it would be upgraded to 
+ * is not supported by a particular dialog, it would be upgraded to
  * <code>APPLICATION_MODAL</code>. In addition, as is the case
  * for shells, the window manager for the desktop on which the
  * instance is visible has ultimate control over the appearance
@@ -69,7 +75,7 @@
  * Note: Only one of the styles APPLICATION_MODAL, PRIMARY_MODAL,
  * and SYSTEM_MODAL may be specified.
  * </p>
- * 
+ *
  * @see Shell
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
@@ -76,7 +82,35 @@
  */
 
 public abstract class Dialog {
-	int style;
+    // <QFS>
+
+    // {{{ Logging
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Dialog");
+
+    // }}}
+
+    // {{{ runDialogShownHooks
+
+    void runDialogShownHooks()
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogShownHooks()");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("this: ").add(this)).log(Log.MTD);
+        }
+        _qfGetDisplay().runDialogShownHooks(this, null);
+    }
+
+    // }}}
+
+    // </QFS>
+
+        int style;
 	Shell parent;
 	String title;
 
@@ -103,7 +137,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -118,7 +152,7 @@
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  * </ul>
- * 
+ *
  * @see SWT#PRIMARY_MODAL
  * @see SWT#APPLICATION_MODAL
  * @see SWT#SYSTEM_MODAL
@@ -128,6 +162,9 @@
 	this.parent = parent;
 	this.style = style;
 	title = "";
+        // <QFS>
+        _qfGetDisplay().runDialogCreationHooks(this);
+        // </QFS>
 }
 
 /**
@@ -198,6 +235,17 @@
 	SWT.error(code);
 }
 
+    // <QFS>
+    /**
+     * Get the display of the dialog.
+     *
+     * @return  The display of the dialog.
+     */
+    protected final Display _qfGetDisplay() {
+        return parent != null ? parent.display : Display.getCurrent ();
+    }
+    // </QFS>
+
 /**
  * Returns the receiver's parent, which must be a <code>Shell</code>
  * or null.
@@ -218,7 +266,7 @@
  * <p>
  * Note that, the value which is returned by this method <em>may
  * not match</em> the value which was provided to the constructor
- * when the receiver was created. 
+ * when the receiver was created.
  * </p>
  *
  * @return the style bits
@@ -235,7 +283,7 @@
 /**
  * Returns the receiver's text, which is the string that the
  * window manager will typically display as the receiver's
- * <em>title</em>. If the text has not previously been set, 
+ * <em>title</em>. If the text has not previously been set,
  * returns an empty string.
  *
  * @return the text
@@ -252,7 +300,7 @@
 /**
  * Sets the receiver's text, which is the string that the
  * window manager will typically display as the receiver's
- * <em>title</em>, to the argument, which must not be null. 
+ * <em>title</em>, to the argument, which must not be null.
  *
  * @param string the new text
  *
Index: org/eclipse/swt/widgets/Combo.java
===================================================================
--- org/eclipse/swt/widgets/Combo.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Combo.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -17,9 +18,14 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are controls that allow the user
- * to choose an item from a list of items, or optionally 
+ * to choose an item from a list of items, or optionally
  * enter a new value by typing it into an editable text
  * field. Often, <code>Combo</code>s are used in the same place
  * where a single selection <code>List</code> widget could
@@ -32,7 +38,7 @@
  * which access one versus the other (compare for example,
  * <code>clearSelection()</code> and <code>deselectAll()</code>).
  * The API documentation is careful to indicate either "the
- * receiver's list" or the "the receiver's text field" to 
+ * receiver's list" or the "the receiver's text field" to
  * distinguish between the two cases.
  * </p><p>
  * Note that although this class is a subclass of <code>Composite</code>,
@@ -58,6 +64,13 @@
  */
 
 public class Combo extends Composite {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Combo");
+    // </QFS>
 	boolean noSelection, ignoreDefaultSelection, ignoreCharacter, ignoreModify, ignoreResize, lockText;
 	int scrollWidth, visibleCount;
 	int /*long*/ cbtHook;
@@ -69,7 +82,7 @@
 	 * that the text field in an instance of this class can hold
 	 */
 	public static final int LIMIT;
-	
+
 	/*
 	 * These values can be different on different platforms.
 	 * Therefore they are not initialized in the declaration
@@ -76,9 +89,9 @@
 	 * to stop the compiler from inlining.
 	 */
 	static {
-		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;	
+		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;
 	}
-	
+
 	/*
 	 * These are the undocumented control id's for the children of
 	 * a combo box.  Since there are no constants for these values,
@@ -88,7 +101,7 @@
 	static final int CBID_LIST = 1000;
 	static final int CBID_EDIT = 1001;
 	static /*final*/ int /*long*/ EditProc, ListProc;
-	
+
 	static final int /*long*/ ComboProc;
 	static final TCHAR ComboClass = new TCHAR (0, "COMBOBOX", true);
 	static {
@@ -96,7 +109,7 @@
 		OS.GetClassInfo (0, ComboClass, lpWndClass);
 		ComboProc = lpWndClass.lpfnWndProc;
 	}
-	
+
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -103,7 +116,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -273,7 +286,7 @@
  *
  * @see VerifyListener
  * @see #removeVerifyListener
- * 
+ *
  * @since 3.1
  */
 public void addVerifyListener (VerifyListener listener) {
@@ -357,7 +370,7 @@
 	 * all platforms.
 	 */
 	style &= ~SWT.BORDER;
-	
+
 	/*
 	 * Even though it is legal to create this widget
 	 * with scroll bars, they serve no useful purpose
@@ -377,7 +390,7 @@
  * text field is editable, this has the effect of placing the
  * i-beam at the start of the text.
  * <p>
- * Note: To clear the selected items in the receiver's list, 
+ * Note: To clear the selected items in the receiver's list,
  * use <code>deselectAll()</code>.
  * </p>
  *
@@ -454,10 +467,10 @@
 	pcbi.cbSize = COMBOBOXINFO.sizeof;
 	if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo (handle, pcbi)) {
 		width += pcbi.itemLeft + (pcbi.buttonRight - pcbi.buttonLeft);
-		height = (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2; 
+		height = (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;
 	} else {
 		int border = OS.GetSystemMetrics (OS.SM_CXEDGE);
-		width += OS.GetSystemMetrics (OS.SM_CXVSCROLL) + border * 2;		
+		width += OS.GetSystemMetrics (OS.SM_CXVSCROLL) + border * 2;
 		int textHeight = (int)/*64*/OS.SendMessage (handle, OS.CB_GETITEMHEIGHT, -1, 0);
 		if ((style & SWT.DROP_DOWN) != 0) {
 			height = textHeight + 6;
@@ -481,7 +494,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void copy () {
@@ -572,7 +585,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void cut () {
@@ -594,7 +607,7 @@
 }
 
 /**
- * Deselects the item at the given zero-relative index in the receiver's 
+ * Deselects the item at the given zero-relative index in the receiver's
  * list.  If the item at the index was already deselected, it remains
  * deselected. Indices that are out of range are ignored.
  *
@@ -848,11 +861,11 @@
 
 /**
  * Returns a (possibly empty) array of <code>String</code>s which are
- * the items in the receiver's list. 
+ * the items in the receiver's list.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver's list
@@ -886,7 +899,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public boolean getListVisible () {
@@ -916,7 +929,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public void setListVisible (boolean visible) {
@@ -928,12 +941,12 @@
  * Returns the orientation of the receiver.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public int getOrientation () {
@@ -1026,7 +1039,7 @@
 	COMBOBOXINFO pcbi = new COMBOBOXINFO ();
 	pcbi.cbSize = COMBOBOXINFO.sizeof;
 	if (((style & SWT.SIMPLE) == 0) && !OS.IsWinCE && OS.GetComboBoxInfo (handle, pcbi)) {
-		return (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2; 
+		return (pcbi.buttonBottom - pcbi.buttonTop) + pcbi.buttonTop * 2;
 	}
 	int result = (int)/*64*/OS.SendMessage (handle, OS.CB_GETITEMHEIGHT, -1, 0);
 	if (result == OS.CB_ERR) error (SWT.ERROR_CANNOT_GET_ITEM_HEIGHT);
@@ -1038,9 +1051,9 @@
  * text field is capable of holding. If this has not been changed
  * by <code>setTextLimit()</code>, it will be the constant
  * <code>Combo.LIMIT</code>.
- * 
+ *
  * @return the text limit
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1069,7 +1082,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public int getVisibleItemCount () {
@@ -1090,7 +1103,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -1110,7 +1123,7 @@
 }
 
 /**
- * Searches the receiver's list starting at the given, 
+ * Searches the receiver's list starting at the given,
  * zero-relative index until an item is found that is equal
  * to the argument, and returns the index of that item. If
  * no item is found or the starting index is out of range,
@@ -1131,7 +1144,7 @@
 public int indexOf (String string, int start) {
 	checkWidget ();
 	if (string == null) error (SWT.ERROR_NULL_ARGUMENT);
-	
+
 	/*
 	* Bug in Windows.  For some reason, CB_FINDSTRINGEXACT
 	* will not find empty strings even though it is legal
@@ -1146,7 +1159,7 @@
 		return -1;
 	}
 
-	/* Use CB_FINDSTRINGEXACT to search for the item */	
+	/* Use CB_FINDSTRINGEXACT to search for the item */
 	int count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 	if (!(0 <= start && start < count)) return -1;
 	int index = start - 1, last = 0;
@@ -1182,7 +1195,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void paste () {
@@ -1254,7 +1267,7 @@
 	* redraw to clear the text area.  The fix is to
 	* force a redraw.
 	*/
-	if ((style & SWT.READ_ONLY) != 0) {		
+	if ((style & SWT.READ_ONLY) != 0) {
 		int count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 		if (count == 0) OS.InvalidateRect (handle, null, true);
 	}
@@ -1262,7 +1275,7 @@
 
 /**
  * Removes the items from the receiver's list which are
- * between the given zero-relative start and end 
+ * between the given zero-relative start and end
  * indices (inclusive).
  *
  * @param start the start of the range
@@ -1327,7 +1340,7 @@
 	* redraw to clear the text area.  The fix is to
 	* force a redraw.
 	*/
-	if ((style & SWT.READ_ONLY) != 0) {		
+	if ((style & SWT.READ_ONLY) != 0) {
 		count = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCOUNT, 0, 0);
 		if (count == 0) OS.InvalidateRect (handle, null, true);
 	}
@@ -1335,7 +1348,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * until an item is found that is equal to the argument, 
+ * until an item is found that is equal to the argument,
  * and removes that item from the list.
  *
  * @param string the item to remove
@@ -1395,7 +1408,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Modify, listener);	
+	eventTable.unhook (SWT.Modify, listener);
 }
 
 /**
@@ -1420,7 +1433,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -1439,7 +1452,7 @@
  *
  * @see VerifyListener
  * @see #addVerifyListener
- * 
+ *
  * @since 3.1
  */
 public void removeVerifyListener (VerifyListener listener) {
@@ -1446,7 +1459,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Verify, listener);	
+	eventTable.unhook (SWT.Verify, listener);
 }
 
 boolean sendKeyEvent (int type, int msg, int /*long*/ wParam, int /*long*/ lParam, Event event) {
@@ -1462,7 +1475,7 @@
 	if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;
 	char key = event.character;
 	int stateMask = event.stateMask;
-	
+
 	/*
 	* Disable all magic keys that could modify the text
 	* and don't send events when Alt, Shift or Ctrl is
@@ -1483,7 +1496,8 @@
 	* is to detect this case and avoid sending a verify
 	* event.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		if (OS.GetDlgItem (handle, CBID_EDIT) == OS.GetCapture()) return true;
 	}
 
@@ -1538,7 +1552,7 @@
 }
 
 /**
- * Selects the item at the given zero-relative index in the receiver's 
+ * Selects the item at the given zero-relative index in the receiver's
  * list.  If the item at the index was already selected, it remains
  * selected. Indices that are out of range are ignored.
  *
@@ -1607,7 +1621,7 @@
 		* the whole area, not just the text field.  The fix is to set the
 		* SWP_NOSIZE bits when the height of text field and the drop down
 		* list is the same as the requested height.
-		* 
+		*
 		* NOTE:  Setting the width of a combo box to zero does not update
 		* the width of the drop down control rect.  If the width of the
 		* combo box is zero, then do not set SWP_NOSIZE.
@@ -1738,12 +1752,12 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public void setOrientation (int orientation) {
@@ -1848,7 +1862,7 @@
  * Sets the selection in the receiver's text field to the
  * range specified by the argument whose x coordinate is the
  * start of the selection and whose y coordinate is the end
- * of the selection. 
+ * of the selection.
  *
  * @param selection a point representing the new selection start and end
  *
@@ -1876,7 +1890,7 @@
  * Sets the contents of the receiver's text field to the
  * given string.
  * <p>
- * This call is ignored when the receiver is read only and 
+ * This call is ignored when the receiver is read only and
  * the given string is not in the receiver's list.
  * </p>
  * <p>
@@ -1883,7 +1897,7 @@
  * Note: The text field in a <code>Combo</code> is typically
  * only capable of displaying a single line of text. Thus,
  * setting the text to a string containing line breaks or
- * other special characters will probably cause it to 
+ * other special characters will probably cause it to
  * display incorrectly.
  * </p>
  *
@@ -1935,7 +1949,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #LIMIT
  */
 public void setTextLimit (int limit) {
@@ -1966,7 +1980,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public void setVisibleItemCount (int count) {
@@ -1984,7 +1998,7 @@
 		OS.SetWindowLongPtr (hwndText, OS.GWLP_WNDPROC, newProc);
 	}
 	int /*long*/ hwndList = OS.GetDlgItem (handle, CBID_LIST);
-	if (hwndList != 0) {	
+	if (hwndList != 0) {
 		OS.SetWindowLongPtr (hwndList, OS.GWLP_WNDPROC, newProc);
 	}
 }
@@ -2180,7 +2194,7 @@
 }
 
 int /*long*/ windowProc (int /*long*/ hwnd, int msg, int /*long*/ wParam, int /*long*/ lParam) {
-	if (handle == 0) return 0;
+    if (handle == 0) return 0;
 	if (hwnd != handle) {
 		int /*long*/ hwndText = OS.GetDlgItem (handle, CBID_EDIT);
 		int /*long*/ hwndList = OS.GetDlgItem (handle, CBID_LIST);
@@ -2220,7 +2234,7 @@
 
 				/* Menu messages */
 				case OS.WM_CONTEXTMENU:		result = wmContextMenu (hwnd, wParam, lParam); break;
-					
+
 				/* Clipboard messages */
 				case OS.WM_CLEAR:
 				case OS.WM_CUT:
@@ -2238,6 +2252,16 @@
 		}
 	}
 	if (msg == OS.CB_SETCURSEL) {
+            // <QFS>
+            if (logger.level >= Log.MTD) {
+                Logger.Builder lb = logger.build("windowProc(int,int,int,int)");
+                (logger.level < Log.MTDDETAIL ? lb : lb
+                 .add("CB_SETCURSEL - hwnd: ").addHex(hwnd)
+                 .add(", msg: ").add(msg)
+                 .add(", wParam: ").addHex(wParam)
+                 .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+            }
+            // </QFS>
 		if ((style & SWT.READ_ONLY) != 0) {
 			if (hooks (SWT.Verify) || filters (SWT.Verify)) {
 				String oldText = getText (), newText = null;
@@ -2281,13 +2305,13 @@
 	* is disposed in CBN_KILLFOCUS, Windows segment faults.
 	* The fix is to send focus from WM_KILLFOCUS instead
 	* of CBN_KILLFOCUS.
-	* 
+	*
 	* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.
 	*/
 	if ((style & SWT.READ_ONLY) != 0) {
 		return super.WM_KILLFOCUS (wParam, lParam);
 	}
-	
+
 	/*
 	* Return NULL - Focus notification is
 	* done in WM_COMMAND by CBN_KILLFOCUS.
@@ -2346,7 +2370,7 @@
 	if ((style & SWT.SIMPLE) != 0) {
 		LRESULT result = super.WM_SIZE (wParam, lParam);
 		if (OS.IsWindowVisible (handle)) {
-			if (OS.IsWinCE) {	
+			if (OS.IsWinCE) {
 				int /*long*/ hwndText = OS.GetDlgItem (handle, CBID_EDIT);
 				if (hwndText != 0) OS.InvalidateRect (hwndText, null, true);
 				int /*long*/ hwndList = OS.GetDlgItem (handle, CBID_LIST);
@@ -2358,7 +2382,7 @@
 		}
 		return result;
 	}
-	
+
 	/*
 	* Feature in Windows.  When an editable drop down combo box
 	* contains text that does not correspond to an item in the
@@ -2378,7 +2402,7 @@
 	* the combo box has been resized.
 	*/
 	if ((style & SWT.H_SCROLL) != 0) setScrollWidth (scrollWidth);
-	return result; 
+	return result;
 }
 
 LRESULT WM_UPDATEUISTATE (int /*long*/ wParam, int /*long*/ lParam) {
@@ -2406,9 +2430,9 @@
 	if (!getDrawing ()) return result;
 	if (!OS.IsWindowVisible (handle)) return result;
 	if (ignoreResize) {
-		WINDOWPOS lpwp = new WINDOWPOS ();
-		OS.MoveMemory (lpwp, lParam, WINDOWPOS.sizeof);
-		if ((lpwp.flags & OS.SWP_NOSIZE) == 0) {
+	WINDOWPOS lpwp = new WINDOWPOS ();
+	OS.MoveMemory (lpwp, lParam, WINDOWPOS.sizeof);
+	if ((lpwp.flags & OS.SWP_NOSIZE) == 0) {
 			lpwp.flags |= OS.SWP_NOREDRAW;
 			OS.MoveMemory (lParam, lpwp, WINDOWPOS.sizeof);
 			OS.InvalidateRect (handle, null, true);
@@ -2450,7 +2474,7 @@
 	* user presses tab, return or escape, Windows beeps.
 	* The fix is to look for these keys and not call
 	* the window proc.
-	* 
+	*
 	* NOTE: This only happens when the drop down list
 	* is not visible.
 	*/
@@ -2532,7 +2556,7 @@
 				int /*long*/ hHeap = OS.GetProcessHeap ();
 				int byteCount = buffer.length () * TCHAR.sizeof;
 				int /*long*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-				OS.MoveMemory (pszText, buffer, byteCount); 
+				OS.MoveMemory (pszText, buffer, byteCount);
 				int /*long*/ code = OS.CallWindowProc (EditProc, hwndText, msg, wParam, pszText);
 				OS.HeapFree (hHeap, 0, pszText);
 				return new LRESULT (code);
@@ -2546,6 +2570,14 @@
 }
 
 LRESULT wmCommandChild (int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmCommandChild(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	int code = OS.HIWORD (wParam);
 	switch (code) {
 		case OS.CBN_EDITCHANGE:
@@ -2575,6 +2607,12 @@
 			* to match the list selection by re-selecting the list item.
 			*/
 			int index = (int)/*64*/OS.SendMessage (handle, OS.CB_GETCURSEL, 0, 0);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("wmCommandChild(int,int)")
+                                .add("index: ").add(index).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (index != OS.CB_ERR) {
 				OS.SendMessage (handle, OS.CB_SETCURSEL, index, 0);
 			}
@@ -2603,7 +2641,7 @@
 			* is disposed in CBN_KILLFOCUS, Windows segment faults.
 			* The fix is to send focus from WM_KILLFOCUS instead
 			* of CBN_KILLFOCUS.
-			* 
+			*
 			* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.
 			*/
 			if ((style & SWT.READ_ONLY) != 0) break;
@@ -2661,7 +2699,7 @@
 		OS.DispatchMessage (msg);
 	}
 	ignoreCharacter = false;
-	
+
 	sendKeyEvent (SWT.KeyUp, OS.WM_IME_CHAR, wParam, lParam);
 	// widget could be disposed at this point
 	display.lastKey = display.lastAscii = 0;
Index: org/eclipse/swt/widgets/FileDialog.java
===================================================================
--- org/eclipse/swt/widgets/FileDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/FileDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -15,6 +16,13 @@
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
 
+// <QFS>
+import java.io.File;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to navigate
  * the file system and select or enter a file name.
@@ -29,7 +37,7 @@
  * </p><p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/snippets/#filedialog">FileDialog snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample, Dialog tab</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
@@ -36,7 +44,16 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 public class FileDialog extends Dialog {
-	String [] filterNames = new String [0];
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.FileDialog");
+    // </QFS>
+
+        String [] filterNames = new String [0];
 	String [] filterExtensions = new String [0];
 	String [] fileNames = new String [0];
 	String filterPath = "", fileName = "";
@@ -82,7 +99,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -99,7 +116,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
  *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
  * </ul>
- * 
+ *
  * @see SWT#SAVE
  * @see SWT#OPEN
  * @see SWT#MULTI
@@ -113,7 +130,7 @@
  * Returns the path of the first file that was
  * selected in the dialog relative to the filter path, or an
  * empty string if no such file has been selected.
- * 
+ *
  * @return the relative path of the file
  */
 public String getFileName () {
@@ -123,7 +140,7 @@
 /**
  * Returns a (possibly empty) array with the paths of all files
  * that were selected in the dialog relative to the filter path.
- * 
+ *
  * @return the relative paths of the files
  */
 public String [] getFileNames () {
@@ -150,10 +167,10 @@
  * </p>
  *
  * @return index the file extension filter index
- * 
+ *
  * @see #getFilterExtensions
  * @see #getFilterNames
- * 
+ *
  * @since 3.4
  */
 public int getFilterIndex () {
@@ -176,7 +193,7 @@
  * in the dialog, filtered according to the filter extensions.
  *
  * @return the directory path string
- * 
+ *
  * @see #setFilterExtensions
  */
 public String getFilterPath () {
@@ -189,7 +206,7 @@
  * overwrite if the selected file already exists.
  *
  * @return true if the dialog will prompt for file overwrite, false otherwise
- * 
+ *
  * @since 3.4
  */
 public boolean getOverwrite () {
@@ -238,11 +255,11 @@
  */
 public String open () {
 	int /*long*/ hHeap = OS.GetProcessHeap ();
-	
+
 	/* Get the owner HWND for the dialog */
 	int /*long*/ hwndOwner = parent.handle;
 	int /*long*/ hwndParent = parent.handle;
-	
+
 	/*
 	* Feature in Windows.  There is no API to set the orientation of a
 	* file dialog.  It is always inherited from the parent.  The fix is
@@ -270,14 +287,14 @@
 			if (enabled) OS.EnableWindow (hwndParent, false);
 		}
 	}
-		
+
 	/* Convert the title and copy it into lpstrTitle */
-	if (title == null) title = "";	
+	if (title == null) title = "";
 	/* Use the character encoding for the default locale */
 	TCHAR buffer3 = new TCHAR (0, title, true);
 	int byteCount3 = buffer3.length () * TCHAR.sizeof;
 	int /*long*/ lpstrTitle = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount3);
-	OS.MoveMemory (lpstrTitle, buffer3, byteCount3); 
+	OS.MoveMemory (lpstrTitle, buffer3, byteCount3);
 
 	/* Compute filters and copy into lpstrFilter */
 	String strFilter = "";
@@ -296,7 +313,7 @@
 	int byteCount4 = buffer4.length () * TCHAR.sizeof;
 	int /*long*/ lpstrFilter = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount4);
 	OS.MoveMemory (lpstrFilter, buffer4, byteCount4);
-	
+
 	/* Convert the fileName and filterName to C strings */
 	if (fileName == null) fileName = "";
 	/* Use the character encoding for the default locale */
@@ -361,7 +378,7 @@
 		lpstrDefExt = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, TCHAR.sizeof);
 		struct.lpstrDefExt = lpstrDefExt;
 	}
-	
+
 	/* Make the parent shell be temporary modal */
 	Dialog oldModal = null;
 	Display display = parent.getDisplay ();
@@ -369,13 +386,29 @@
 		oldModal = display.getModalDialog ();
 		display.setModalDialog (this);
 	}
-	
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/*
 	* Feature in Windows.  For some reason, the WH_MSGFILTER filter
 	* does not run for GetSaveFileName() or GetOpenFileName().  The
 	* fix is to allow async messages to run in the WH_FOREGROUNDIDLE
 	* hook instead.
-	* 
+	*
 	* Bug in Windows 98.  For some reason, when certain operating
 	* system calls such as Shell_NotifyIcon(), GetOpenFileName()
 	* and GetSaveFileName() are made during the WH_FOREGROUNDIDLE
@@ -394,12 +427,12 @@
 			OS.MoveMemory (lpstrFile, new TCHAR (0, "", true), TCHAR.sizeof);
 			success = (save) ? OS.GetSaveFileName (struct) : OS.GetOpenFileName (struct);
 			break;
-		case OS.FNERR_BUFFERTOOSMALL: 
+		case OS.FNERR_BUFFERTOOSMALL:
 			USE_HOOK = true;
 			break;
 	}
 	display.runMessagesInIdle = oldRunMessagesInIdle;
-	
+
 	/* Clear the temporary dialog modal parent */
 	if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
 		display.setModalDialog (oldModal);
@@ -413,12 +446,12 @@
 	fileNames = new String [0];
 	String fullPath = null;
 	if (success) {
-		
+
 		/* Use the character encoding for the default locale */
 		TCHAR buffer = new TCHAR (0, struct.nMaxFile);
 		int byteCount1 = buffer.length () * TCHAR.sizeof;
 		OS.MoveMemory (buffer, lpstrFile, byteCount1);
-		
+
 		/*
 		* Bug in WinCE.  For some reason, nFileOffset and nFileExtension
 		* are always zero on WinCE HPC. nFileOffset is always zero on
@@ -425,12 +458,12 @@
 		* WinCE PPC when using GetSaveFileName().  nFileOffset is correctly
 		* set on WinCE PPC when using OpenFileName().  The fix is to parse
 		* lpstrFile to calculate nFileOffset.
-		* 
+		*
 		* Note: WinCE does not support multi-select file dialogs.
 		*/
 		int nFileOffset = struct.nFileOffset;
 		if (OS.IsWinCE && nFileOffset == 0) {
-			int index = 0; 
+			int index = 0;
 			while (index < buffer.length ()) {
 				int ch = buffer.tcharAt (index);
 				if (ch == 0) break;
@@ -439,13 +472,13 @@
 			}
 		}
 		if (nFileOffset > 0) {
-		
+
 			/* Use the character encoding for the default locale */
 			TCHAR prefix = new TCHAR (0, nFileOffset - 1);
 			int byteCount2 = prefix.length () * TCHAR.sizeof;
 			OS.MoveMemory (prefix, lpstrFile, byteCount2);
 			filterPath = prefix.toString (0, prefix.length ());
-			
+
 			/*
 			* Get each file from the buffer.  Files are delimited
 			* by a NULL character with 2 NULL characters at the end.
@@ -467,7 +500,7 @@
 				if ((style & SWT.MULTI) == 0) break;
 				start++;
 			} while (start < buffer.length () && buffer.tcharAt (start) != 0);
-			
+
 			if (fileNames.length > 0) fileName = fileNames  [0];
 			String separator = "";
 			int length = filterPath.length ();
@@ -483,7 +516,7 @@
 		}
 		filterIndex = struct.nFilterIndex - 1;
 	}
-	
+
 	/* Free the memory that was allocated. */
 	OS.HeapFree (hHeap, 0, lpstrFile);
 	OS.HeapFree (hHeap, 0, lpstrFilter);
@@ -497,7 +530,7 @@
 		OS.SetActiveWindow (hwndParent);
 		OS.DestroyWindow (hwndOwner);
 	}
-	
+
 	/*
 	* This code is intentionally commented.  On some
 	* platforms, the owner window is repainted right
@@ -505,9 +538,15 @@
 	* is currently unspecified.
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
-	
+
 	/* Answer the full path or null */
-	return fullPath;
+        // <QFS>
+        Object result = fullPath;
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+	return (result instanceof String) || result == null
+            ? (String) result
+            : fullPath;
+        // </QFS>
 }
 
 /**
@@ -515,7 +554,7 @@
  * select by default when opened to the argument,
  * which may be null.  The name will be prefixed with
  * the filter path when one is supplied.
- * 
+ *
  * @param string the file name
  */
 public void setFileName (String string) {
@@ -535,7 +574,7 @@
  * </p>
  *
  * @param extensions the file extension filter
- * 
+ *
  * @see #setFilterNames to specify the user-friendly
  * names corresponding to the extensions
  */
@@ -553,10 +592,10 @@
  * </p>
  *
  * @param index the file extension filter index
- * 
+ *
  * @see #setFilterExtensions
  * @see #setFilterNames
- * 
+ *
  * @since 3.4
  */
 public void setFilterIndex (int index) {
@@ -574,7 +613,7 @@
  * </p>
  *
  * @param names the list of filter names, or null for no filter names
- * 
+ *
  * @see #setFilterExtensions
  */
 public void setFilterNames (String [] names) {
@@ -595,7 +634,7 @@
  * </p>
  *
  * @param string the directory path
- * 
+ *
  * @see #setFilterExtensions
  */
 public void setFilterPath (String string) {
@@ -608,7 +647,7 @@
  * overwrite if the selected file already exists.
  *
  * @param overwrite true if the dialog will prompt for file overwrite, false otherwise
- * 
+ *
  * @since 3.4
  */
 public void setOverwrite (boolean overwrite) {
Index: org/eclipse/swt/widgets/Composite.java
===================================================================
--- org/eclipse/swt/widgets/Composite.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Composite.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -236,8 +236,8 @@
 		}
 	} else {
 		size = minimumSize (wHint, hHint, changed);
-		if (size.x == 0) size.x = DEFAULT_WIDTH;
-		if (size.y == 0) size.y = DEFAULT_HEIGHT;
+	if (size.x == 0) size.x = DEFAULT_WIDTH;
+	if (size.y == 0) size.y = DEFAULT_HEIGHT;
 	}
 	if (wHint != SWT.DEFAULT) size.x = wHint;
 	if (hHint != SWT.DEFAULT) size.y = hHint;
@@ -759,45 +759,45 @@
 public void layout (Control [] changed, int flags) {
 	checkWidget ();
 	if (changed != null) {
-		for (int i=0; i<changed.length; i++) {
-			Control control = changed [i];
-			if (control == null) error (SWT.ERROR_INVALID_ARGUMENT);
-			if (control.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
-			boolean ancestor = false;
-			Composite composite = control.parent;
-			while (composite != null) {
-				ancestor = composite == this;
-				if (ancestor) break;
-				composite = composite.parent;
-			}
-			if (!ancestor) error (SWT.ERROR_INVALID_PARENT);
+	for (int i=0; i<changed.length; i++) {
+		Control control = changed [i];
+		if (control == null) error (SWT.ERROR_INVALID_ARGUMENT);
+		if (control.isDisposed ()) error (SWT.ERROR_INVALID_ARGUMENT);
+		boolean ancestor = false;
+		Composite composite = control.parent;
+		while (composite != null) {
+			ancestor = composite == this;
+			if (ancestor) break;
+			composite = composite.parent;
 		}
-		int updateCount = 0;
-		Composite [] update = new Composite [16];
-		for (int i=0; i<changed.length; i++) {
-			Control child = changed [i];
-			Composite composite = child.parent;
-			while (child != this) {
-				if (composite.layout != null) {
-					composite.state |= LAYOUT_NEEDED;
-					if (!composite.layout.flushCache (child)) {
-						composite.state |= LAYOUT_CHANGED;
-					}
+		if (!ancestor) error (SWT.ERROR_INVALID_PARENT);
+	}
+	int updateCount = 0;
+	Composite [] update = new Composite [16];
+	for (int i=0; i<changed.length; i++) {
+		Control child = changed [i];
+		Composite composite = child.parent;
+		while (child != this) {
+			if (composite.layout != null) {
+				composite.state |= LAYOUT_NEEDED;
+				if (!composite.layout.flushCache (child)) {
+					composite.state |= LAYOUT_CHANGED;
 				}
-				if (updateCount == update.length) {
-					Composite [] newUpdate = new Composite [update.length + 16];
-					System.arraycopy (update, 0, newUpdate, 0, update.length);
-					update = newUpdate;
-				}
-				child = update [updateCount++] = composite;
-				composite = child.parent;
 			}
+			if (updateCount == update.length) {
+				Composite [] newUpdate = new Composite [update.length + 16];
+				System.arraycopy (update, 0, newUpdate, 0, update.length);
+				update = newUpdate;
+			}
+			child = update [updateCount++] = composite;
+			composite = child.parent;
 		}
+	}
 		if ((flags & SWT.DEFER) != 0) {
 			setLayoutDeferred (true);
 			display.addLayoutDeferred (this);
 		}
-		for (int i=updateCount-1; i>=0; i--) {
+	for (int i=updateCount-1; i>=0; i--) {
 			update [i].updateLayout (false);
 		}
 	} else {
@@ -1523,7 +1523,7 @@
 					OS.SetBrushOrgEx (gc.handle, ps.left, ps.top, null);
 					if ((style & (SWT.NO_BACKGROUND | SWT.TRANSPARENT)) != 0) {
 						/* This code is intentionally commented because it may be slow to copy bits from the screen */
-						//paintGC.copyArea (image, ps.left, ps.top);						
+						//paintGC.copyArea (image, ps.left, ps.top);
 					} else {
 						RECT rect = new RECT ();
 						OS.SetRect (rect, ps.left, ps.top, ps.right, ps.bottom);
@@ -1655,27 +1655,27 @@
 	if ((state & RESIZE_DEFERRED) != 0) {
 		result = super.WM_SIZE (wParam, lParam);
 	} else {
-		/* Begin deferred window positioning */
-		setResizeChildren (false);
-		
-		/* Resize and Layout */
+	/* Begin deferred window positioning */
+	setResizeChildren (false);
+	
+	/* Resize and Layout */
 		result = super.WM_SIZE (wParam, lParam);
-		/*
-		* It is possible (but unlikely), that application
-		* code could have disposed the widget in the resize
-		* event.  If this happens, end the processing of the
-		* Windows message by returning the result of the
-		* WM_SIZE message.
-		*/
-		if (isDisposed ()) return result;
-		if (layout != null) {
-			markLayout (false, false);
-			updateLayout (false, false);
-		}
-	
-		/* End deferred window positioning */
-		setResizeChildren (true);
+	/*
+	* It is possible (but unlikely), that application
+	* code could have disposed the widget in the resize
+	* event.  If this happens, end the processing of the
+	* Windows message by returning the result of the
+	* WM_SIZE message.
+	*/
+	if (isDisposed ()) return result;
+	if (layout != null) {
+		markLayout (false, false);
+		updateLayout (false, false);
 	}
+
+	/* End deferred window positioning */
+	setResizeChildren (true);
+	}
 	
 	/* Damage the widget to cause a repaint */
 	if (OS.IsWindowVisible (handle)) {
@@ -1763,28 +1763,28 @@
 	if (result != null) return result;
 	int /*long*/ borderHandle = borderHandle ();
 	if ((state & CANVAS) != 0 || (hwnd == borderHandle && handle != borderHandle)) {
-		if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {
-			int bits1 = OS.GetWindowLong (hwnd, OS.GWL_EXSTYLE);
-			if ((bits1 & OS.WS_EX_CLIENTEDGE) != 0) {
-				int /*long*/ code = 0;
-				int bits2 = OS.GetWindowLong (hwnd, OS.GWL_STYLE);
-				if ((bits2 & (OS.WS_HSCROLL | OS.WS_VSCROLL)) != 0) {
-					code = callWindowProc (hwnd, OS.WM_NCPAINT, wParam, lParam);
-				}
-				int /*long*/ hDC = OS.GetWindowDC (hwnd);
-				RECT rect = new RECT ();
-				OS.GetWindowRect (hwnd, rect);
-				rect.right -= rect.left;
-				rect.bottom -= rect.top;
-				rect.left = rect.top = 0;
-				int border = OS.GetSystemMetrics (OS.SM_CXEDGE);
-				OS.ExcludeClipRect (hDC, border, border, rect.right - border, rect.bottom - border);
-				OS.DrawThemeBackground (display.hEditTheme (), hDC, OS.EP_EDITTEXT, OS.ETS_NORMAL, rect, null);
-				OS.ReleaseDC (hwnd, hDC);
-				return new LRESULT (code);
+	if (OS.COMCTL32_MAJOR >= 6 && OS.IsAppThemed ()) {
+		int bits1 = OS.GetWindowLong (hwnd, OS.GWL_EXSTYLE);
+		if ((bits1 & OS.WS_EX_CLIENTEDGE) != 0) {
+			int /*long*/ code = 0;
+			int bits2 = OS.GetWindowLong (hwnd, OS.GWL_STYLE);
+			if ((bits2 & (OS.WS_HSCROLL | OS.WS_VSCROLL)) != 0) {
+				code = callWindowProc (hwnd, OS.WM_NCPAINT, wParam, lParam);
 			}
+			int /*long*/ hDC = OS.GetWindowDC (hwnd);
+			RECT rect = new RECT ();
+			OS.GetWindowRect (hwnd, rect);
+			rect.right -= rect.left;
+			rect.bottom -= rect.top;
+			rect.left = rect.top = 0;
+			int border = OS.GetSystemMetrics (OS.SM_CXEDGE);
+			OS.ExcludeClipRect (hDC, border, border, rect.right - border, rect.bottom - border);
+			OS.DrawThemeBackground (display.hEditTheme (), hDC, OS.EP_EDITTEXT, OS.ETS_NORMAL, rect, null);
+			OS.ReleaseDC (hwnd, hDC);
+			return new LRESULT (code);
 		}
 	}
+	}
 	return result;
 }
 
@@ -1872,11 +1872,11 @@
 					}
 					if (widget != null) {
 						if ((widget.getStyle () & SWT.RIGHT_TO_LEFT) != 0) {
-							lpnmtdi.uFlags |= OS.TTF_RTLREADING;
-						} else {
-							lpnmtdi.uFlags &= ~OS.TTF_RTLREADING;
+								lpnmtdi.uFlags |= OS.TTF_RTLREADING;
+							} else {
+								lpnmtdi.uFlags &= ~OS.TTF_RTLREADING;
+							}
 						}
-					}
 					
 					if (hdr.code == OS.TTN_GETDISPINFOA) {
 						byte [] bytes = new byte [chars.length * 2];
Index: org/eclipse/swt/widgets/ToolBar.java
===================================================================
--- org/eclipse/swt/widgets/ToolBar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ToolBar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -57,13 +57,13 @@
 		OS.GetClassInfo (0, ToolBarClass, lpWndClass);
 		ToolBarProc = lpWndClass.lpfnWndProc;
 	}
-	
+
 	/*
 	* From the Windows SDK for TB_SETBUTTONSIZE:
 	*
 	*   "If an application does not explicitly
 	*	set the button size, the size defaults
-	*	to 24 by 22 pixels". 
+	*	to 24 by 22 pixels".
 	*/
 	static final int DEFAULT_WIDTH = 24;
 	static final int DEFAULT_HEIGHT = 22;
@@ -74,7 +74,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -110,7 +110,7 @@
 	* clear these bits to avoid scroll bars and then reset
 	* the bits using the original style supplied by the
 	* programmer.
-	* 
+	*
 	* NOTE: The CCS_VERT style cannot be applied when the
 	* widget is created because of this conflict.
 	*/
@@ -124,7 +124,7 @@
 		* every button in the tool bar and makes the preferred
 		* height too big.  The fix is to set the TBSTYLE_LIST
 		* when the tool bar contains both text and images.
-		* 
+		*
 		* NOTE: Tool bars with CCS_VERT must have TBSTYLE_LIST
 		* set before any item is added or the tool bar does
 		* not lay out properly.  The work around does not run
@@ -159,13 +159,13 @@
 	* On Windows, only flat tool bars can be traversed.
 	*/
 	if ((style & SWT.FLAT) == 0) style |= SWT.NO_FOCUS;
-	
+
 	/*
 	* A vertical tool bar cannot wrap because TB_SETROWS
 	* fails when the toolbar has TBSTYLE_WRAPABLE.
 	*/
 	if ((style & SWT.VERTICAL) != 0) style &= ~SWT.WRAP;
-		
+
 	/*
 	* Even though it is legal to create this widget
 	* with scroll bars, they serve no useful purpose
@@ -230,13 +230,13 @@
 		if (redraw) OS.ValidateRect (handle, null);
 		ignoreResize = false;
 	}
-	
+
 	/*
 	* From the Windows SDK for TB_SETBUTTONSIZE:
 	*
 	*   "If an application does not explicitly
 	*	set the button size, the size defaults
-	*	to 24 by 22 pixels". 
+	*	to 24 by 22 pixels".
 	*/
 	if (width == 0) width = DEFAULT_WIDTH;
 	if (height == 0) height = DEFAULT_HEIGHT;
@@ -299,13 +299,13 @@
 void createHandle () {
 	super.createHandle ();
 	state &= ~CANVAS;
-	
+
 	/*
 	* Feature in Windows.  When TBSTYLE_FLAT is used to create
 	* a flat toolbar, for some reason TBSTYLE_TRANSPARENT is
 	* also set.  This causes the toolbar to flicker when it is
 	* moved or resized.  The fix is to clear TBSTYLE_TRANSPARENT.
-	* 
+	*
 	* NOTE:  This work around is unnecessary on XP.  There is no
 	* flickering and clearing the TBSTYLE_TRANSPARENT interferes
 	* with the XP theme.
@@ -374,7 +374,7 @@
 	lpButton.idCommand = id;
 	lpButton.fsStyle = (byte) bits;
 	lpButton.fsState = (byte) OS.TBSTATE_ENABLED;
-	
+
 	/*
 	* Bug in Windows.  Despite the fact that the image list
 	* index has never been set for the item, Windows always
@@ -417,7 +417,7 @@
 	* the style BTNS_SEP does not return I_IMAGENONE when queried
 	* for an image index, despite the fact that no attempt has been
 	* made to assign an image to the item.  As a result, operations
-	* on an image list that use the wrong index cause random results.	
+	* on an image list that use the wrong index cause random results.
 	* The fix is to ensure that the tool item is not a separator
 	* before using the image index.  Since separators cannot have
 	* an image and one is never assigned, this is not a problem.
@@ -462,7 +462,7 @@
 	* disabled, the item does not draw using the disabled
 	* image.  The fix is to use the disabled image in all
 	* image lists for the item.
-	* 
+	*
 	* Feature in Windows.  When a tool bar is disabled,
 	* the text draws disabled but the images do not.
 	* The fix is to use the disabled image in all image
@@ -508,7 +508,7 @@
 public ToolItem getItem (int index) {
 	checkWidget ();
 	int count = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
-	if (!(0 <= index && index < count)) error (SWT.ERROR_INVALID_RANGE);	
+	if (!(0 <= index && index < count)) error (SWT.ERROR_INVALID_RANGE);
 	TBBUTTON lpButton = new TBBUTTON ();
 	int /*long*/ result = OS.SendMessage (handle, OS.TB_GETBUTTON, index, lpButton);
 	if (result == 0) error (SWT.ERROR_CANNOT_GET_ITEM);
@@ -559,11 +559,11 @@
 
 /**
  * Returns an array of <code>ToolItem</code>s which are the items
- * in the receiver. 
+ * in the receiver.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -630,7 +630,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -653,7 +653,7 @@
 	return (int)/*64*/OS.SendMessage (handle, OS.TB_COMMANDTOINDEX, item.id, 0);
 }
 
-void layoutItems () {	
+void layoutItems () {
 	/*
 	* Feature in Windows.  When a tool bar has the style
 	* TBSTYLE_LIST and has a drop down item, Window leaves
@@ -661,7 +661,7 @@
 	* every button in the tool bar and makes the preferred
 	* height too big.  The fix is to set the TBSTYLE_LIST
 	* when the tool bar contains both text and images.
-	* 
+	*
 	* NOTE: Tool bars with CCS_VERT must have TBSTYLE_LIST
 	* set before any item is added or the tool bar does
 	* not lay out properly.  The work around does not run
@@ -699,7 +699,7 @@
 			}
 		}
 	}
-	
+
 	if ((style & SWT.WRAP) != 0) {
 		OS.SendMessage (handle, OS.TB_AUTOSIZE, 0, 0);
 	}
@@ -712,29 +712,29 @@
 	if ((style & SWT.VERTICAL) != 0) {
 		int itemCount = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
 		if (itemCount > 1) {
-			TBBUTTONINFO info = new TBBUTTONINFO ();
-			info.cbSize = TBBUTTONINFO.sizeof;
-			info.dwMask = OS.TBIF_SIZE;
-			int /*long*/ size = OS.SendMessage (handle, OS.TB_GETBUTTONSIZE, 0, 0);
-			info.cx = (short) OS.LOWORD (size);
-			int index = 0;
-			while (index < items.length) {
-				ToolItem item = items [index];
-				if (item != null && (item.style & SWT.DROP_DOWN) != 0) break;
-				index++;
+		TBBUTTONINFO info = new TBBUTTONINFO ();
+		info.cbSize = TBBUTTONINFO.sizeof;
+		info.dwMask = OS.TBIF_SIZE;
+		int /*long*/ size = OS.SendMessage (handle, OS.TB_GETBUTTONSIZE, 0, 0);
+		info.cx = (short) OS.LOWORD (size);
+		int index = 0;
+		while (index < items.length) {
+			ToolItem item = items [index];
+			if (item != null && (item.style & SWT.DROP_DOWN) != 0) break;
+			index++;
+		}
+		if (index < items.length) {
+			int /*long*/ padding = OS.SendMessage (handle, OS.TB_GETPADDING, 0, 0);
+			info.cx += OS.LOWORD (padding) * 2;
+		}
+		for (int i=0; i<items.length; i++) {
+			ToolItem item = items [i];
+			if (item != null && (item.style & SWT.SEPARATOR) == 0) {
+				OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
 			}
-			if (index < items.length) {
-				int /*long*/ padding = OS.SendMessage (handle, OS.TB_GETPADDING, 0, 0);
-				info.cx += OS.LOWORD (padding) * 2;
-			}
-			for (int i=0; i<items.length; i++) {
-				ToolItem item = items [i];
-				if (item != null && (item.style & SWT.SEPARATOR) == 0) {
-					OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
-				}
-			}
 		}
 	}
+	}
 
 	/*
 	* Feature on Windows. When SWT.WRAP or SWT.VERTICAL are set
@@ -866,7 +866,7 @@
 	* the image list that include transparency information
 	* do not draw correctly.  The fix is to clear and set
 	* TBSTYLE_TRANSPARENT depending on the background color.
-	* 
+	*
 	* NOTE:  This work around is unnecessary on XP.  The
 	* TBSTYLE_TRANSPARENT style is never cleared on that
 	* platform.
@@ -917,7 +917,7 @@
 	* makes the preferred height too big.  The fix is clear the
 	* BTNS_DROPDOWN before Windows lays out the tool bar and set
 	* the bit afterwards.
-	* 
+	*
 	* NOTE:  This work around only runs when the tool bar contains
 	* only images.
 	*/
@@ -977,7 +977,7 @@
 	int mask = SWT.PUSH | SWT.CHECK | SWT.RADIO | SWT.DROP_DOWN;
 	while (index < items.length) {
 		ToolItem item = items [index];
-		if (item != null && (item.style & mask) != 0) break;		
+		if (item != null && (item.style & mask) != 0) break;
 		index++;
 	}
 	if (index == items.length) {
@@ -1151,9 +1151,9 @@
 		ImageList newImageList = display.getImageListToolBar (style & SWT.RIGHT_TO_LEFT, size.x, size.y);
 		ImageList newHotImageList = display.getImageListToolBarHot (style & SWT.RIGHT_TO_LEFT, size.x, size.y);
 		ImageList newDisabledImageList = display.getImageListToolBarDisabled (style & SWT.RIGHT_TO_LEFT, size.x, size.y);	
-		TBBUTTONINFO info = new TBBUTTONINFO ();
-		info.cbSize = TBBUTTONINFO.sizeof;
-		info.dwMask = OS.TBIF_IMAGE;
+					TBBUTTONINFO info = new TBBUTTONINFO ();
+					info.cbSize = TBBUTTONINFO.sizeof;
+					info.dwMask = OS.TBIF_IMAGE;
 		int count = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
 		for (int i=0; i<count; i++) {
 			ToolItem item = items [i];
@@ -1170,9 +1170,9 @@
 				info.iImage = newImageList.add(image);
 				newHotImageList.add(hot);
 				newDisabledImageList.add(disabled);
-				OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
+					OS.SendMessage (handle, OS.TB_SETBUTTONINFO, item.id, info);
+				}
 			}
-		}
 		display.releaseToolImageList (imageList);
 		display.releaseToolHotImageList (hotImageList);
 		display.releaseToolDisabledImageList (disabledImageList);
@@ -1183,7 +1183,7 @@
 		hotImageList = newHotImageList;
 		disabledImageList = newDisabledImageList;
 		OS.InvalidateRect (handle, null, true);
-	}
+		}
 }
 
 int widgetStyle () {
@@ -1199,7 +1199,7 @@
 	* every button in the tool bar and makes the preferred
 	* height too big.  The fix is to set the TBSTYLE_LIST
 	* when the tool bar contains both text and images.
-	* 
+	*
 	* NOTE: Tool bars with CCS_VERT must have TBSTYLE_LIST
 	* set before any item is added or the tool bar does
 	* not lay out properly.  The work around does not run
@@ -1263,18 +1263,18 @@
 	* Feature in Windows.  When the toolbar window
 	* proc processes WM_COMMAND, it forwards this
 	* message to its parent.  This is done so that
-	* children of this control that send this message 
+	* children of this control that send this message
 	* type to their parent will notify not only
 	* this control but also the parent of this control,
 	* which is typically the application window and
 	* the window that is looking for the message.
-	* If the control did not forward the message, 
-	* applications would have to subclass the control 
+	* If the control did not forward the message,
+	* applications would have to subclass the control
 	* window to see the message. Because the control
 	* window is subclassed by SWT, the message
 	* is delivered twice, once by SWT and once when
 	* the message is forwarded by the window proc.
-	* The fix is to avoid calling the window proc 
+	* The fix is to avoid calling the window proc
 	* for this control.
 	*/
 	LRESULT result = super.WM_COMMAND (wParam, lParam);
@@ -1314,7 +1314,7 @@
 	LRESULT result = super.WM_KEYDOWN (wParam, lParam);
 	if (result != null) return result;
 	switch ((int)/*64*/wParam) {
-		case OS.VK_SPACE:	
+		case OS.VK_SPACE:
 			/*
 			* Ensure that the window proc does not process VK_SPACE
 			* so that it can be handled in WM_CHAR.  This allows the
@@ -1381,18 +1381,18 @@
 	* Feature in Windows.  When the toolbar window
 	* proc processes WM_NOTIFY, it forwards this
 	* message to its parent.  This is done so that
-	* children of this control that send this message 
+	* children of this control that send this message
 	* type to their parent will notify not only
 	* this control but also the parent of this control,
 	* which is typically the application window and
 	* the window that is looking for the message.
-	* If the control did not forward the message, 
-	* applications would have to subclass the control 
+	* If the control did not forward the message,
+	* applications would have to subclass the control
 	* window to see the message. Because the control
 	* window is subclassed by SWT, the message
 	* is delivered twice, once by SWT and once when
 	* the message is forwarded by the window proc.
-	* The fix is to avoid calling the window proc 
+	* The fix is to avoid calling the window proc
 	* for this control.
 	*/
 	LRESULT result = super.WM_NOTIFY (wParam, lParam);
@@ -1430,7 +1430,7 @@
 	if ((style & SWT.BORDER) != 0 && (style & SWT.WRAP) != 0) {
 		RECT windowRect = new RECT ();
 		OS.GetWindowRect (handle, windowRect);
-		int index = 0, border = getBorderWidth () * 2; 
+		int index = 0, border = getBorderWidth () * 2;
 		RECT rect = new RECT ();
 		int count = (int)/*64*/OS.SendMessage (handle, OS.TB_BUTTONCOUNT, 0, 0);
 		while (index < count) {
@@ -1577,7 +1577,7 @@
 						}
 						lastArrowId = lpnmhi.idNew;
 						break;
-					}
+				}
 					default:
 						lastArrowId = -1;
 				}
Index: org/eclipse/swt/widgets/Menu.java
===================================================================
--- org/eclipse/swt/widgets/Menu.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Menu.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
@@ -17,6 +18,11 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are user interface objects that contain
  * menu items.
@@ -41,8 +47,15 @@
  */
 
 public class Menu extends Widget {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Menu");
+    // </QFS>
 	/**
-	 * the handle to the OS resource 
+	 * the handle to the OS resource
 	 * (Warning: This field is platform dependent)
 	 * <p>
 	 * <b>IMPORTANT:</b> This field is <em>not</em> part of the SWT
@@ -50,30 +63,31 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public int /*long*/ handle;
-	
-	int x, y; 
+
+	int x, y;
 	int /*long*/ hBrush, hwndCB;
 	int id0, id1;
 	int foreground = -1, background = -1;
-	Image backgroundImage;	
+	Image backgroundImage;
 	boolean hasLocation;
 	MenuItem cascade;
+    public // <QFS/> temporarily made public
 	Decorations parent;
 	ImageList imageList;
-	
+
 	/* Resource ID for SHMENUBARINFO */
 	static final int ID_PPC = 100;
-	
+
 	/* SmartPhone SoftKeyBar resource ids */
 	static final int ID_SPMM = 102;
 	static final int ID_SPBM = 103;
 	static final int ID_SPMB = 104;
 	static final int ID_SPBB = 105;
-	static final int ID_SPSOFTKEY0 = 106; 
+	static final int ID_SPSOFTKEY0 = 106;
 	static final int ID_SPSOFTKEY1 = 107;
 
 /**
@@ -101,7 +115,7 @@
  * @see Widget#getStyle
  */
 public Menu (Control parent) {
-	this (checkNull (parent).menuShell (), SWT.POP_UP);
+        this (checkNull (parent).menuShell (), SWT.POP_UP);
 }
 
 /**
@@ -111,7 +125,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -142,7 +156,7 @@
  * @see Widget#getStyle
  */
 public Menu (Decorations parent, int style) {
-	this (parent, checkStyle (style), 0);
+        this (parent, checkStyle (style), 0);
 }
 
 /**
@@ -170,7 +184,7 @@
  * @see Widget#getStyle
  */
 public Menu (Menu parentMenu) {
-	this (checkNull (parentMenu).parent, SWT.DROP_DOWN);
+        this (checkNull (parentMenu).parent, SWT.DROP_DOWN);
 }
 
 /**
@@ -198,69 +212,185 @@
  * @see Widget#getStyle
  */
 public Menu (MenuItem parentItem) {
-	this (checkNull (parentItem).parent);
+        this (checkNull (parentItem).parent);
 }
 
 Menu (Decorations parent, int style, int /*long*/ handle) {
-	super (parent, checkStyle (style));
-	this.parent = parent;
-	this.handle = handle;
-	/*
-	* Bug in IBM JVM 1.3.1.  For some reason, when the checkOrientation() is
-	* called from createWidget(), the JVM issues this error:
-	*
-	* JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
-	* 
-	* In addition, on Windows XP, a dialog appears with following error message,
-	* indicating that the problem may be in the JIT:
-	* 
-	* AppName: java.exe	 AppVer: 0.0.0.0	 ModName: jitc.dll
-	* ModVer: 0.0.0.0	 Offset: 000b6912
-	* 
-	* The fix is to call checkOrientation() from here.
-	*/
-	checkOrientation (parent);
-	createWidget ();
+        super (parent, checkStyle (style));
+        this.parent = parent;
+        this.handle = handle;
+        /*
+        * Bug in IBM JVM 1.3.1.  For some reason, when the checkOrientation() is
+        * called from createWidget(), the JVM issues this error:
+        *
+        * JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
+        *
+        * In addition, on Windows XP, a dialog appears with following error message,
+        * indicating that the problem may be in the JIT:
+        *
+        * AppName: java.exe      AppVer: 0.0.0.0         ModName: jitc.dll
+        * ModVer: 0.0.0.0        Offset: 000b6912
+        *
+        * The fix is to call checkOrientation() from here.
+        */
+        checkOrientation (parent);
+        createWidget ();
 }
 
-void _setVisible (boolean visible) {
-	if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
+// <QFS/> made public
+public void _setVisible (boolean visible) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("_setVisible(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add("visible: ").add(visible)).log(Log.MTD);
+    }
+    // </QFS>
+    if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
 	int /*long*/ hwndParent = parent.handle;
-	if (visible) {
-		int flags = OS.TPM_LEFTBUTTON;
-		if (OS.GetKeyState (OS.VK_LBUTTON) >= 0) flags |= OS.TPM_RIGHTBUTTON;
-		if ((style & SWT.RIGHT_TO_LEFT) != 0) flags |= OS.TPM_RIGHTALIGN;
-		if ((parent.style & SWT.MIRRORED) != 0) {
-			flags &= ~OS.TPM_RIGHTALIGN;
-			if ((style & SWT.LEFT_TO_RIGHT) != 0) flags |= OS.TPM_RIGHTALIGN;
-		}
-		int nX = x, nY = y;
-		if (!hasLocation) {
-			int pos = OS.GetMessagePos ();
+    if (visible) {
+        int flags = OS.TPM_LEFTBUTTON;
+        // <QFS/> Changed to getDisplay().GetKeyState
+        if (getDisplay().GetKeyState (OS.VK_LBUTTON) >= 0) flags |= OS.TPM_RIGHTBUTTON;
+        if ((style & SWT.RIGHT_TO_LEFT) != 0) flags |= OS.TPM_RIGHTALIGN;
+        if ((parent.style & SWT.MIRRORED) != 0) {
+            flags &= ~OS.TPM_RIGHTALIGN;
+            if ((style & SWT.LEFT_TO_RIGHT) != 0) flags |= OS.TPM_RIGHTALIGN;
+        }
+        int nX = x, nY = y;
+        if (!hasLocation) {
+            int pos = OS.GetMessagePos ();
 			nX = OS.GET_X_LPARAM (pos);
 			nY = OS.GET_Y_LPARAM (pos);
-		}
+        }
 		hasLocation = false;
-		/*
-		* Feature in Windows.  It is legal use TrackPopupMenu()
-		* to display an empty menu as long as menu items are added
-		* inside of WM_INITPOPUPMENU.  If no items are added, then
-		* TrackPopupMenu() fails and does not send an indication
-		* that the menu has been closed.  This is not strictly a
-		* bug but leads to unwanted behavior when application code
-		* assumes that every WM_INITPOPUPMENU will eventually result
+        /*
+         * Feature in Windows.  It is legal use TrackPopupMenu()
+         * to display an empty menu as long as menu items are added
+         * inside of WM_INITPOPUPMENU.  If no items are added, then
+         * TrackPopupMenu() fails and does not send an indication
+         * that the menu has been closed.  This is not strictly a
+         * bug but leads to unwanted behavior when application code
+         * assumes that every WM_INITPOPUPMENU will eventually result
 		* in a WM_MENUSELECT, wParam=MAKEWPARAM (0, 0xFFFF), lParam=0 to
 		* indicate that the menu has been closed.  The fix is to detect
 		* the case when TrackPopupMenu() fails and the number of items in
-		* the menu is zero and issue a fake WM_MENUSELECT.
-		*/
-		boolean success = OS.TrackPopupMenu (handle, flags, nX, nY, 0, hwndParent, null);
-		if (!success && GetMenuItemCount (handle) == 0) {
+         * the menu is zero and issue a fake WM_MENUSELECT.
+         */
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("_setVisible(boolean)")
+                .add("calling OS.TrackPopupMenu on this: ").add(this)
+                .add(", flags: ").addHex(flags)
+                .add(", handle: ").addHex(handle)
+                .add(", hwndParent: ").addHex(hwndParent)
+                .log(Log.DBG);
+        }
+        // Force pseudo-visibility while TrackPopupMenu is active. Otherwise a call to
+        // Display.readAndDispatch() can cause Display.popups to become null and thus the Menu to
+        // return visible false.
+        Object visCount = getData("qfs:popupvisible");
+        if (visCount instanceof Integer) {
+            setData("qfs:popupvisible", new Integer (((Integer) visCount).intValue() + 1));
+        } else {
+            setData("qfs:popupvisible", new Integer (1));
+        }
+        // </QFS>
+        boolean success = OS.TrackPopupMenu (handle, flags, nX, nY, 0, hwndParent, null);
+        // <QFS>
+        visCount = getData("qfs:popupvisible");
+        if (visCount instanceof Integer) {
+            int count = ((Integer) visCount).intValue() - 1;
+            setData("qfs:popupvisible", count <= 0 ? null : new Integer (count));
+        }
+        int err = -1;
+        if (! success) {
+            err = OS.GetLastError();
+        }
+        if (logger.level >= Log.DBG) {
+            logger.build("_setVisible(boolean)")
+                .add("OS.TrackPopupMenu returned success: ").add(success)
+                .add(", this: ").add(this)
+                .add(", err: ").add(err)
+                .log(Log.DBG);
+        }
+        // Display.(a)syncExec can lead to WM_NULL messages being posted through
+        // Display.wakeThread which in turn can confuse a certain type of modal popup menu because
+        // they turn up just after OS.TrackPopupMenu but before the WM_COMMAND resulting from a
+        // MenuItem selection. Removing all pending WM_NULL messages that come before a pending
+        // WM_COMMAND here prevents that and is safe since we're already on the dispatch thread
+        // anyway.
+        MSG msg = new MSG ();
+        if (OS.PeekMessage(msg, 0, OS.WM_COMMAND, OS.WM_COMMAND,
+                              OS.PM_NOREMOVE | OS.PM_NOYIELD)) {
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "_setVisible(boolean)",
+                           "WM_COMMAND pending");
+            }
+            while (OS.PeekMessage(msg, 0, 0, 0, OS.PM_NOREMOVE | OS.PM_NOYIELD)) {
+                if (msg.message == OS.WM_NULL) {
+                    OS.PeekMessage(msg, 0, OS.WM_NULL, OS.WM_NULL, OS.PM_REMOVE | OS.PM_NOYIELD);
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("removed WM_NULL").log(Log.MSG);
+                    }
+                } else if (msg.message == OS.WM_APP + 89) {
+                    // qftest callback - _very_ special case
+                    OS.PeekMessage(msg, 0, OS.WM_APP + 89, OS.WM_NULL,
+                                   OS.PM_REMOVE | OS.PM_NOYIELD);
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)")
+                            .add("removed qftest callback").log(Log.MSG);
+                    }
+                    if (logger.level >= Log.DBGDETAIL) {
+                        logger.log(Log.DBGDETAIL, "_setVisible(boolean)",
+                                   "now calling OS.TranslateMessage");
+                    }
+                    OS.TranslateMessage (msg);
+                    if (logger.level >= Log.DBGDETAIL) {
+                        logger.log(Log.DBGDETAIL, "_setVisible(boolean)",
+                                   "now calling OS.DispatchMessage");
+                    }
+                    try {
+                        getDisplay().eventProcessedByReadAndDispatch++;
+                        OS.DispatchMessage (msg);
+                    } finally {
+                        getDisplay().eventProcessedByReadAndDispatch--;
+                    }
+                } else if (msg.message == OS.WM_COMMAND) {
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("success, WM_COMMAND now first")
+                            .log(Log.MSG);
+                    }
+                    break;
+                } else {
+                    if (logger.level >= Log.MSG) {
+                        logger.build("_setVisible(boolean)").add("oops, unexpected message: ")
+                            .add(msg.message).log(Log.MSG);
+                    }
+                    break;
+                }
+            }
+        }
+        // </QFS>
+        if (!success && GetMenuItemCount (handle) == 0) {
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.log(Log.DBG, "_setVisible(boolean)",
+                           "now SendMessage WM_MENUSELECT");
+            }
+            // </QFS>
 			OS.SendMessage (hwndParent, OS.WM_MENUSELECT, OS.MAKEWPARAM (0, 0xFFFF), 0);
-		}
-	} else {
-		OS.SendMessage (hwndParent, OS.WM_CANCELMODE, 0, 0);
-	}
+        }
+    } else {
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "_setVisible(boolean)",
+                       "now SendMessage WM_CANCELMODE");
+        }
+        // </QFS>
+        OS.SendMessage (hwndParent, OS.WM_CANCELMODE, 0, 0);
+    }
 	/*
 	* Bug in Windows.  After closing a popup menu, the accessibility focus
 	* is not returned to the focus control.  This causes confusion for AT users.
@@ -270,6 +400,11 @@
 	if (hFocus != 0) {
 		OS.NotifyWinEvent (OS.EVENT_OBJECT_FOCUS, hFocus, OS.OBJID_CLIENT, 0);
 	}
+    // <QFS>
+    if (logger.level >= Log.DBG) {
+        logger.build("_setVisible(boolean)").add("done. this: ").add(this).log(Log.DBG);
+    }
+    // </QFS>
 }
 
 /**
@@ -292,10 +427,10 @@
  * @see #removeHelpListener
  */
 public void addHelpListener (HelpListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener (listener);
-	addListener (SWT.Help, typedListener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        TypedListener typedListener = new TypedListener (listener);
+        addListener (SWT.Help, typedListener);
 }
 
 /**
@@ -318,246 +453,251 @@
  * @see #removeMenuListener
  */
 public void addMenuListener (MenuListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener (listener);
-	addListener (SWT.Hide,typedListener);
-	addListener (SWT.Show,typedListener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        TypedListener typedListener = new TypedListener (listener);
+        addListener (SWT.Hide,typedListener);
+        addListener (SWT.Show,typedListener);
 }
 
 static Control checkNull (Control control) {
-	if (control == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
-	return control;
+        if (control == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
+        return control;
 }
 
 static Menu checkNull (Menu menu) {
-	if (menu == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
-	return menu;
+        if (menu == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
+        return menu;
 }
 
 static MenuItem checkNull (MenuItem item) {
-	if (item == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
-	return item;
+        if (item == null) SWT.error (SWT.ERROR_NULL_ARGUMENT);
+        return item;
 }
 
 static int checkStyle (int style) {
-	return checkBits (style, SWT.POP_UP, SWT.BAR, SWT.DROP_DOWN, 0, 0, 0);
+        return checkBits (style, SWT.POP_UP, SWT.BAR, SWT.DROP_DOWN, 0, 0, 0);
 }
 
 void createHandle () {
-	if (handle != 0) return;
-	if ((style & SWT.BAR) != 0) {
-		if (OS.IsPPC) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "createHandle()", "");
+    }
+    // </QFS>
+    if (handle != 0) return;
+        if ((style & SWT.BAR) != 0) {
+                if (OS.IsPPC) {
 			int /*long*/ hwndShell = parent.handle;
-			SHMENUBARINFO mbi = new SHMENUBARINFO ();
-			mbi.cbSize = SHMENUBARINFO.sizeof;
-			mbi.hwndParent = hwndShell;
-			mbi.dwFlags = OS.SHCMBF_HIDDEN;
-			mbi.nToolBarId = ID_PPC;
-			mbi.hInstRes = OS.GetLibraryHandle ();
-			boolean success = OS.SHCreateMenuBar (mbi);
-			hwndCB = mbi.hwndMB;
-			if (!success) error (SWT.ERROR_NO_HANDLES);
-			/* Remove the item from the resource file */
-			OS.SendMessage (hwndCB, OS.TB_DELETEBUTTON, 0, 0);
-			return;
-		}
-		/*
-		* Note in WinCE SmartPhone.  The SoftBar contains only 2 items.
-		* An item can either be a menu or a button. 
-		* SWT.BAR: creates a SoftBar with 2 menus
-		* SWT.BAR | SWT.BUTTON1: creates a SoftBar with 1 button
-		*    for button1, and a menu for button2
-		* SWT.BAR | SWT.BUTTON1 | SWT.BUTTON2: creates a SoftBar with
-		*    2 buttons
-		*/
-		if (OS.IsSP) {
-			/* Determine type of menubar */
-			int nToolBarId;
-			if ((style & SWT.BUTTON1) != 0) {
-				nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPBB : ID_SPBM;
-			} else {
-				nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPMB : ID_SPMM;
-			}
-			
-			/* Create SHMENUBAR */
-			SHMENUBARINFO mbi = new SHMENUBARINFO ();
-			mbi.cbSize = SHMENUBARINFO.sizeof;
-			mbi.hwndParent = parent.handle;
-			mbi.dwFlags = OS.SHCMBF_HIDDEN;
-			mbi.nToolBarId = nToolBarId; /* as defined in .rc file */
-			mbi.hInstRes = OS.GetLibraryHandle ();
-			if (!OS.SHCreateMenuBar (mbi)) error (SWT.ERROR_NO_HANDLES);
-			hwndCB = mbi.hwndMB;
-			
-			/*
-			* Feature on WinCE SmartPhone.  The SHCMBF_HIDDEN flag causes the
-			* SHMENUBAR to not be drawn. However the keyboard events still go
-			* through it.  The workaround is to also hide the SHMENUBAR with
-			* ShowWindow ().
-			*/
-			OS.ShowWindow (hwndCB, OS.SW_HIDE);
-			
-			TBBUTTONINFO info = new TBBUTTONINFO ();
-			info.cbSize = TBBUTTONINFO.sizeof;
-			info.dwMask = OS.TBIF_COMMAND;
-			MenuItem item;
-			
-			/* Set first item */
-			if (nToolBarId == ID_SPMM || nToolBarId == ID_SPMB) {
+                        SHMENUBARINFO mbi = new SHMENUBARINFO ();
+                        mbi.cbSize = SHMENUBARINFO.sizeof;
+                        mbi.hwndParent = hwndShell;
+                        mbi.dwFlags = OS.SHCMBF_HIDDEN;
+                        mbi.nToolBarId = ID_PPC;
+                        mbi.hInstRes = OS.GetLibraryHandle ();
+                        boolean success = OS.SHCreateMenuBar (mbi);
+                        hwndCB = mbi.hwndMB;
+                        if (!success) error (SWT.ERROR_NO_HANDLES);
+                        /* Remove the item from the resource file */
+                        OS.SendMessage (hwndCB, OS.TB_DELETEBUTTON, 0, 0);
+                        return;
+                }
+                /*
+                * Note in WinCE SmartPhone.  The SoftBar contains only 2 items.
+                * An item can either be a menu or a button.
+                * SWT.BAR: creates a SoftBar with 2 menus
+                * SWT.BAR | SWT.BUTTON1: creates a SoftBar with 1 button
+                *    for button1, and a menu for button2
+                * SWT.BAR | SWT.BUTTON1 | SWT.BUTTON2: creates a SoftBar with
+                *    2 buttons
+                */
+                if (OS.IsSP) {
+                        /* Determine type of menubar */
+                        int nToolBarId;
+                        if ((style & SWT.BUTTON1) != 0) {
+                                nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPBB : ID_SPBM;
+                        } else {
+                                nToolBarId = ((style & SWT.BUTTON2) != 0) ? ID_SPMB : ID_SPMM;
+                        }
+
+                        /* Create SHMENUBAR */
+                        SHMENUBARINFO mbi = new SHMENUBARINFO ();
+                        mbi.cbSize = SHMENUBARINFO.sizeof;
+                        mbi.hwndParent = parent.handle;
+                        mbi.dwFlags = OS.SHCMBF_HIDDEN;
+                        mbi.nToolBarId = nToolBarId; /* as defined in .rc file */
+                        mbi.hInstRes = OS.GetLibraryHandle ();
+                        if (!OS.SHCreateMenuBar (mbi)) error (SWT.ERROR_NO_HANDLES);
+                        hwndCB = mbi.hwndMB;
+
+                        /*
+                        * Feature on WinCE SmartPhone.  The SHCMBF_HIDDEN flag causes the
+                        * SHMENUBAR to not be drawn. However the keyboard events still go
+                        * through it.  The workaround is to also hide the SHMENUBAR with
+                        * ShowWindow ().
+                        */
+                        OS.ShowWindow (hwndCB, OS.SW_HIDE);
+
+                        TBBUTTONINFO info = new TBBUTTONINFO ();
+                        info.cbSize = TBBUTTONINFO.sizeof;
+                        info.dwMask = OS.TBIF_COMMAND;
+                        MenuItem item;
+
+                        /* Set first item */
+                        if (nToolBarId == ID_SPMM || nToolBarId == ID_SPMB) {
 				int /*long*/ hMenu = OS.SendMessage (hwndCB, OS.SHCMBM_GETSUBMENU, 0, ID_SPSOFTKEY0);
-				/* Remove the item from the resource file */
-				OS.RemoveMenu (hMenu, 0, OS.MF_BYPOSITION);
-				Menu menu = new Menu (parent, SWT.DROP_DOWN, hMenu);
-				item = new MenuItem (this, menu, SWT.CASCADE, 0);
-			} else {
-				item = new MenuItem (this, null, SWT.PUSH, 0);
-			}
-			info.idCommand = id0 = item.id;
-			OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY0, info);	
+                                /* Remove the item from the resource file */
+                                OS.RemoveMenu (hMenu, 0, OS.MF_BYPOSITION);
+                                Menu menu = new Menu (parent, SWT.DROP_DOWN, hMenu);
+                                item = new MenuItem (this, menu, SWT.CASCADE, 0);
+                        } else {
+                                item = new MenuItem (this, null, SWT.PUSH, 0);
+                        }
+                        info.idCommand = id0 = item.id;
+                        OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY0, info);
 
-			/* Set second item */
-			if (nToolBarId == ID_SPMM || nToolBarId == ID_SPBM) {
+                        /* Set second item */
+                        if (nToolBarId == ID_SPMM || nToolBarId == ID_SPBM) {
 				int /*long*/ hMenu = OS.SendMessage (hwndCB, OS.SHCMBM_GETSUBMENU, 0, ID_SPSOFTKEY1);
-				OS.RemoveMenu (hMenu, 0, OS.MF_BYPOSITION);
-				Menu menu = new Menu (parent, SWT.DROP_DOWN, hMenu);
-				item = new MenuItem (this, menu, SWT.CASCADE, 1);
-			} else {
-				item = new MenuItem (this, null, SWT.PUSH, 1);
-			}
-			info.idCommand = id1 = item.id;
-			OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY1, info);
+                                OS.RemoveMenu (hMenu, 0, OS.MF_BYPOSITION);
+                                Menu menu = new Menu (parent, SWT.DROP_DOWN, hMenu);
+                                item = new MenuItem (this, menu, SWT.CASCADE, 1);
+                        } else {
+                                item = new MenuItem (this, null, SWT.PUSH, 1);
+                        }
+                        info.idCommand = id1 = item.id;
+                        OS.SendMessage (hwndCB, OS.TB_SETBUTTONINFO, ID_SPSOFTKEY1, info);
 
-			/*
-			* Override the Back key.  For some reason, the owner of the menubar
-			* must be a Dialog or it won't receive the WM_HOTKEY message.  As
-			* a result, Shell on WinCE SP must use the class Dialog.
-			*/
-			int dwMask = OS.SHMBOF_NODEFAULT | OS.SHMBOF_NOTIFY;
+                        /*
+                        * Override the Back key.  For some reason, the owner of the menubar
+                        * must be a Dialog or it won't receive the WM_HOTKEY message.  As
+                        * a result, Shell on WinCE SP must use the class Dialog.
+                        */
+                        int dwMask = OS.SHMBOF_NODEFAULT | OS.SHMBOF_NOTIFY;
 			int /*long*/ lParam = OS.MAKELPARAM (dwMask, dwMask);
-			OS.SendMessage (hwndCB, OS.SHCMBM_OVERRIDEKEY, OS.VK_ESCAPE, lParam);
-			return;
-		}
-		handle = OS.CreateMenu ();
-		if (handle == 0) error (SWT.ERROR_NO_HANDLES);
-		if (OS.IsHPC) {
+                        OS.SendMessage (hwndCB, OS.SHCMBM_OVERRIDEKEY, OS.VK_ESCAPE, lParam);
+                        return;
+                }
+                handle = OS.CreateMenu ();
+                if (handle == 0) error (SWT.ERROR_NO_HANDLES);
+                if (OS.IsHPC) {
 			int /*long*/ hwndShell = parent.handle;
-			hwndCB = OS.CommandBar_Create (OS.GetModuleHandle (null), hwndShell, 1);
-			if (hwndCB == 0) error (SWT.ERROR_NO_HANDLES);
-			OS.CommandBar_Show (hwndCB, false);
-			OS.CommandBar_InsertMenubarEx (hwndCB, 0, handle, 0);
-			/*
-			* The command bar hosts the 'close' button when the window does not
-			* have a caption.
-			*/
-			if ((parent.style & SWT.CLOSE) != 0 && (parent.style & SWT.TITLE) == 0) {
-				OS.CommandBar_AddAdornments (hwndCB, 0, 0);
-			}
-		}
-	} else {
-		handle = OS.CreatePopupMenu ();
-		if (handle == 0) error (SWT.ERROR_NO_HANDLES);
-	}
+                        hwndCB = OS.CommandBar_Create (OS.GetModuleHandle (null), hwndShell, 1);
+                        if (hwndCB == 0) error (SWT.ERROR_NO_HANDLES);
+                        OS.CommandBar_Show (hwndCB, false);
+                        OS.CommandBar_InsertMenubarEx (hwndCB, 0, handle, 0);
+                        /*
+                        * The command bar hosts the 'close' button when the window does not
+                        * have a caption.
+                        */
+                        if ((parent.style & SWT.CLOSE) != 0 && (parent.style & SWT.TITLE) == 0) {
+                                OS.CommandBar_AddAdornments (hwndCB, 0, 0);
+                        }
+                }
+        } else {
+                handle = OS.CreatePopupMenu ();
+                if (handle == 0) error (SWT.ERROR_NO_HANDLES);
+        }
 }
 
 void createItem (MenuItem item, int index) {
-	int count = GetMenuItemCount (handle);
-	if (!(0 <= index && index <= count)) error (SWT.ERROR_INVALID_RANGE);
-	display.addMenuItem (item);
-	boolean success = false;
-	if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
-		if (OS.IsSP) return;
-		TBBUTTON lpButton = new TBBUTTON ();
-		lpButton.idCommand = item.id;
-		lpButton.fsStyle = (byte) OS.TBSTYLE_AUTOSIZE;
-		if ((item.style & SWT.CASCADE) != 0) lpButton.fsStyle |= OS.TBSTYLE_DROPDOWN | 0x80;
-		if ((item.style & SWT.SEPARATOR) != 0) lpButton.fsStyle = (byte) OS.BTNS_SEP;
-		lpButton.fsState = (byte) OS.TBSTATE_ENABLED;
-		lpButton.iBitmap = OS.I_IMAGENONE;
-		success = OS.SendMessage (hwndCB, OS.TB_INSERTBUTTON, index, lpButton) != 0;
-	} else {
-		if (OS.IsWinCE) {
-			int uFlags = OS.MF_BYPOSITION;
-			TCHAR lpNewItem = null;
-			if ((item.style & SWT.SEPARATOR) != 0) {
-				uFlags |= OS.MF_SEPARATOR;
-			} else {
-				lpNewItem = new TCHAR (0, " ", true);
-			}
-			success = OS.InsertMenu (handle, index, uFlags, item.id, lpNewItem);
-			if (success) {
-				MENUITEMINFO info = new MENUITEMINFO ();
-				info.cbSize = MENUITEMINFO.sizeof;
-				info.fMask = OS.MIIM_DATA;
-				info.dwItemData = item.id;
-				success = OS.SetMenuItemInfo (handle, index, true, info);
-			}
-		} else {
-			/*
-			* Bug in Windows.  For some reason, when InsertMenuItem()
-			* is used to insert an item without text, it is not possible
-			* to use SetMenuItemInfo() to set the text at a later time.
-			* The fix is to insert the item with some text.
-			* 
-			* Feature in Windows.  When an empty string is used instead
-			* of a space and InsertMenuItem() is used to set a submenu
-			* before setting text to a non-empty string, the menu item
-			* becomes unexpectedly disabled.  The fix is to insert a
-			* space.
-			*/
+        int count = GetMenuItemCount (handle);
+        if (!(0 <= index && index <= count)) error (SWT.ERROR_INVALID_RANGE);
+        display.addMenuItem (item);
+        boolean success = false;
+        if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
+                if (OS.IsSP) return;
+                TBBUTTON lpButton = new TBBUTTON ();
+                lpButton.idCommand = item.id;
+                lpButton.fsStyle = (byte) OS.TBSTYLE_AUTOSIZE;
+                if ((item.style & SWT.CASCADE) != 0) lpButton.fsStyle |= OS.TBSTYLE_DROPDOWN | 0x80;
+                if ((item.style & SWT.SEPARATOR) != 0) lpButton.fsStyle = (byte) OS.BTNS_SEP;
+                lpButton.fsState = (byte) OS.TBSTATE_ENABLED;
+                lpButton.iBitmap = OS.I_IMAGENONE;
+                success = OS.SendMessage (hwndCB, OS.TB_INSERTBUTTON, index, lpButton) != 0;
+        } else {
+                if (OS.IsWinCE) {
+                        int uFlags = OS.MF_BYPOSITION;
+                        TCHAR lpNewItem = null;
+                        if ((item.style & SWT.SEPARATOR) != 0) {
+                                uFlags |= OS.MF_SEPARATOR;
+                        } else {
+                                lpNewItem = new TCHAR (0, " ", true);
+                        }
+                        success = OS.InsertMenu (handle, index, uFlags, item.id, lpNewItem);
+                        if (success) {
+                                MENUITEMINFO info = new MENUITEMINFO ();
+                                info.cbSize = MENUITEMINFO.sizeof;
+                                info.fMask = OS.MIIM_DATA;
+                                info.dwItemData = item.id;
+                                success = OS.SetMenuItemInfo (handle, index, true, info);
+                        }
+                } else {
+                        /*
+                        * Bug in Windows.  For some reason, when InsertMenuItem()
+                        * is used to insert an item without text, it is not possible
+                        * to use SetMenuItemInfo() to set the text at a later time.
+                        * The fix is to insert the item with some text.
+                        *
+                        * Feature in Windows.  When an empty string is used instead
+                        * of a space and InsertMenuItem() is used to set a submenu
+                        * before setting text to a non-empty string, the menu item
+                        * becomes unexpectedly disabled.  The fix is to insert a
+                        * space.
+                        */
 			int /*long*/ hHeap = OS.GetProcessHeap ();
-			TCHAR buffer = new TCHAR (0, " ", true);
-			int byteCount = buffer.length () * TCHAR.sizeof;
+                        TCHAR buffer = new TCHAR (0, " ", true);
+                        int byteCount = buffer.length () * TCHAR.sizeof;
 			int /*long*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-			OS.MoveMemory (pszText, buffer, byteCount);	
-			MENUITEMINFO info = new MENUITEMINFO ();
-			info.cbSize = MENUITEMINFO.sizeof;
-			info.fMask = OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_DATA;
+                        OS.MoveMemory (pszText, buffer, byteCount);
+                        MENUITEMINFO info = new MENUITEMINFO ();
+                        info.cbSize = MENUITEMINFO.sizeof;
+                        info.fMask = OS.MIIM_ID | OS.MIIM_TYPE | OS.MIIM_DATA;
 			info.wID = item.id;
 			info.dwItemData = item.id;
-			info.fType = item.widgetStyle ();
-			info.dwTypeData = pszText;
-			success = OS.InsertMenuItem (handle, index, true, info);
-			if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
-		}
-	}
-	if (!success) {
-		display.removeMenuItem (item);
-		error (SWT.ERROR_ITEM_NOT_ADDED);
-	}
-	redraw ();
+                        info.fType = item.widgetStyle ();
+                        info.dwTypeData = pszText;
+                        success = OS.InsertMenuItem (handle, index, true, info);
+                        if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
+                }
+        }
+        if (!success) {
+                display.removeMenuItem (item);
+                error (SWT.ERROR_ITEM_NOT_ADDED);
+        }
+        redraw ();
 }
-	
+
 void createWidget () {
-	/*
-	* Bug in IBM JVM 1.3.1.  For some reason, when the following code is called
-	* from this method, the JVM issues this error:
-	*
-	* JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
-	* 
-	* In addition, on Windows XP, a dialog appears with following error message,
-	* indicating that the problem may be in the JIT:
-	* 
-	* AppName: java.exe	 AppVer: 0.0.0.0	 ModName: jitc.dll
-	* ModVer: 0.0.0.0	 Offset: 000b6912
-	* 
-	* The fix is to move the code to the caller of this method.
-	*/
-//	checkOrientation (parent);
-	createHandle ();
-	parent.addMenu (this);
+        /*
+        * Bug in IBM JVM 1.3.1.  For some reason, when the following code is called
+        * from this method, the JVM issues this error:
+        *
+        * JVM Exception 0x2 (subcode 0x0) occurred in thread "main" (TID:0x9F19D8)
+        *
+        * In addition, on Windows XP, a dialog appears with following error message,
+        * indicating that the problem may be in the JIT:
+        *
+        * AppName: java.exe      AppVer: 0.0.0.0         ModName: jitc.dll
+        * ModVer: 0.0.0.0        Offset: 000b6912
+        *
+        * The fix is to move the code to the caller of this method.
+        */
+//      checkOrientation (parent);
+        createHandle ();
+        parent.addMenu (this);
 }
 
 int defaultBackground () {
-	return OS.GetSysColor (OS.COLOR_MENU);
+        return OS.GetSysColor (OS.COLOR_MENU);
 }
 
 int defaultForeground () {
-	return OS.GetSysColor (OS.COLOR_MENUTEXT);
+        return OS.GetSysColor (OS.COLOR_MENUTEXT);
 }
 
 void destroyAccelerators () {
-	parent.destroyAccelerators ();
+        parent.destroyAccelerators ();
 }
 
 void destroyItem (MenuItem item) {
@@ -590,7 +730,7 @@
 			}
 			if (info.dwItemData != item.id) {
 				error (SWT.ERROR_ITEM_NOT_REMOVED);
-			}	
+			}
 			if (!OS.DeleteMenu (handle, index, OS.MF_BYPOSITION)) {
 				error (SWT.ERROR_ITEM_NOT_REMOVED);
 			}
@@ -606,26 +746,26 @@
 void destroyWidget () {
 	MenuItem cascade = this.cascade;
 	int /*long*/ hMenu = handle, hCB = hwndCB;
-	releaseHandle ();
-	if (OS.IsWinCE && hCB != 0) {
-		OS.CommandBar_Destroy (hCB);
-	} else {
+        releaseHandle ();
+        if (OS.IsWinCE && hCB != 0) {
+                OS.CommandBar_Destroy (hCB);
+        } else {
 		if (cascade != null) {
 			if (!OS.IsSP) cascade.setMenu (null, true);
 		} else {
-			if (hMenu != 0) OS.DestroyMenu (hMenu);
-		}
+                if (hMenu != 0) OS.DestroyMenu (hMenu);
+        }
 	}
 }
 
 void fixMenus (Decorations newParent) {
-	MenuItem [] items = getItems ();
-	for (int i=0; i<items.length; i++) {
-		items [i].fixMenus (newParent);
-	}
-	parent.removeMenu (this);
-	newParent.addMenu (this);
-	this.parent = newParent;
+        MenuItem [] items = getItems ();
+        for (int i=0; i<items.length; i++) {
+                items [i].fixMenus (newParent);
+        }
+        parent.removeMenu (this);
+        newParent.addMenu (this);
+        this.parent = newParent;
 }
 
 /**
@@ -637,7 +777,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ Color getBackground () {
@@ -654,7 +794,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ Image getBackgroundImage () {
@@ -679,40 +819,64 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.1
  */
-/*public*/ Rectangle getBounds () {
-	checkWidget ();
-	if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
-	if ((style & SWT.BAR) != 0) {
-		if (parent.menuBar != this) {
-			return new Rectangle (0, 0, 0, 0);
-		}
+// <QFS/> Made public.
+public Rectangle getBounds () {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "getBounds()", "");
+    }
+    // </QFS>
+    checkWidget ();
+        if (OS.IsWinCE) return new Rectangle (0, 0, 0, 0);
+        if ((style & SWT.BAR) != 0) {
+                if (parent.menuBar != this) {
+                        return new Rectangle (0, 0, 0, 0);
+                }
 		int /*long*/ hwndShell = parent.handle;
-		MENUBARINFO info = new MENUBARINFO ();
-		info.cbSize = MENUBARINFO.sizeof;
-		if (OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, 0, info)) {
-			int width = info.right - info.left;
-			int height = info.bottom - info.top;
-			return new Rectangle (info.left, info.top, width, height);
-		}
-	} else {
-		int count = GetMenuItemCount (handle);
-		if (count != 0) {
-			RECT rect1 = new RECT ();
-			if (OS.GetMenuItemRect (0, handle, 0, rect1)) {
-				RECT rect2 = new RECT ();
-				if (OS.GetMenuItemRect (0, handle, count - 1, rect2)) {
-					int x = rect1.left - 2, y = rect1.top - 2;
-					int width = (rect2.right - rect2.left) + 4;
-					int height = (rect2.bottom - rect1.top) + 4;
-					return new Rectangle (x, y, width, height);
-				}
-			}
-		}
-	}
-	return new Rectangle (0, 0, 0, 0);
+                MENUBARINFO info = new MENUBARINFO ();
+                info.cbSize = MENUBARINFO.sizeof;
+                if (OS.GetMenuBarInfo (hwndShell, OS.OBJID_MENU, 0, info)) {
+                        int width = info.right - info.left;
+                        int height = info.bottom - info.top;
+                        return new Rectangle (info.left, info.top, width, height);
+                }
+        } else {
+                int count = GetMenuItemCount (handle);
+                if (count != 0) {
+                        RECT rect1 = new RECT ();
+                        // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                        // Leave unchanged for now
+                        // if (OS.GetMenuItemRect (getShell().handle, handle, 0, rect1)) {
+                        if (OS.GetMenuItemRect (0, handle, 0, rect1)) {
+                            // <QFS>
+                            if (logger.level >= Log.DBG) {
+                                logger.build("getBounds()")
+                                    .add("rect1: ").add(rect1).log(Log.DBG);
+                            }
+                            // </QFS>
+                                RECT rect2 = new RECT ();
+                                // <QFS/> Bug? Need getShell.handle instead of 0 ???
+                                // Leave unchanged for now
+                                // if (OS.GetMenuItemRect (getShell().handle, handle, count - 1, rect2)) {
+                                if (OS.GetMenuItemRect (0, handle, count - 1, rect2)) {
+                                    // <QFS>
+                                    if (logger.level >= Log.DBG) {
+                                        logger.build("getBounds()")
+                                            .add("rect2: ").add(rect2).log(Log.DBG);
+                                    }
+                                    // </QFS>
+                                        int x = rect1.left - 2, y = rect1.top - 2;
+                                        int width = (rect2.right - rect2.left) + 4;
+                                        int height = (rect2.bottom - rect1.top) + 4;
+                                        return new Rectangle (x, y, width, height);
+                                }
+                        }
+                }
+        }
+        return new Rectangle (0, 0, 0, 0);
 }
 
 /**
@@ -728,17 +892,17 @@
  * </ul>
  */
 public MenuItem getDefaultItem () {
-	checkWidget ();
-	if (OS.IsWinCE) return null;
-	int id = OS.GetMenuDefaultItem (handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);
-	if (id == -1) return null;
-	MENUITEMINFO info = new MENUITEMINFO ();
-	info.cbSize = MENUITEMINFO.sizeof;
-	info.fMask = OS.MIIM_ID;
-	if (OS.GetMenuItemInfo (handle, id, false, info)) {
-		return display.getMenuItem (info.wID);
-	}
-	return null;
+        checkWidget ();
+        if (OS.IsWinCE) return null;
+        int id = OS.GetMenuDefaultItem (handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);
+        if (id == -1) return null;
+        MENUITEMINFO info = new MENUITEMINFO ();
+        info.cbSize = MENUITEMINFO.sizeof;
+        info.fMask = OS.MIIM_ID;
+        if (OS.GetMenuItemInfo (handle, id, false, info)) {
+                return display.getMenuItem (info.wID);
+        }
+        return null;
 }
 
 /**
@@ -753,12 +917,12 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
-	checkWidget ();
-	return (state & DISABLED) == 0;
+        checkWidget ();
+        return (state & DISABLED) == 0;
 }
 
 /**
@@ -792,29 +956,29 @@
  * </ul>
  */
 public MenuItem getItem (int index) {
-	checkWidget ();
-	int id = 0;
-	if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
-		if (OS.IsPPC) {
-			TBBUTTON lpButton = new TBBUTTON ();
+        checkWidget ();
+        int id = 0;
+        if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
+                if (OS.IsPPC) {
+                        TBBUTTON lpButton = new TBBUTTON ();
 			int /*long*/ result = OS.SendMessage (hwndCB, OS.TB_GETBUTTON, index, lpButton);
-			if (result == 0) error (SWT.ERROR_CANNOT_GET_ITEM);
-			id = lpButton.idCommand;
-		}
-		if (OS.IsSP) {
-			if (!(0 <= index && index <= 1)) error (SWT.ERROR_CANNOT_GET_ITEM);
-			id = index == 0 ? id0 : id1;
-		}
-	} else {
-		MENUITEMINFO info = new MENUITEMINFO ();
-		info.cbSize = MENUITEMINFO.sizeof;
-		info.fMask = OS.MIIM_DATA;
-		if (!OS.GetMenuItemInfo (handle, index, true, info)) {
-			error (SWT.ERROR_INVALID_RANGE);
-		}
+                        if (result == 0) error (SWT.ERROR_CANNOT_GET_ITEM);
+                        id = lpButton.idCommand;
+                }
+                if (OS.IsSP) {
+                        if (!(0 <= index && index <= 1)) error (SWT.ERROR_CANNOT_GET_ITEM);
+                        id = index == 0 ? id0 : id1;
+                }
+        } else {
+                MENUITEMINFO info = new MENUITEMINFO ();
+                info.cbSize = MENUITEMINFO.sizeof;
+                info.fMask = OS.MIIM_DATA;
+                if (!OS.GetMenuItemInfo (handle, index, true, info)) {
+                        error (SWT.ERROR_INVALID_RANGE);
+                }
 		id = (int)/*64*/info.dwItemData;
-	}
-	return display.getMenuItem (id);
+        }
+        return display.getMenuItem (id);
 }
 
 /**
@@ -828,17 +992,17 @@
  * </ul>
  */
 public int getItemCount () {
-	checkWidget ();
-	return GetMenuItemCount (handle);
+        checkWidget ();
+        return GetMenuItemCount (handle);
 }
 
 /**
  * Returns a (possibly empty) array of <code>MenuItem</code>s which
- * are the items in the receiver. 
+ * are the items in the receiver.
  * <p>
  * Note: This is not the actual structure used by the receiver
  * to maintain its list of items, so modifying the array will
- * not affect the receiver. 
+ * not affect the receiver.
  * </p>
  *
  * @return the items in the receiver
@@ -893,30 +1057,30 @@
 }
 
 int GetMenuItemCount (int /*long*/ handle) {
-	if (OS.IsWinCE) {
-		if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
+        if (OS.IsWinCE) {
+                if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
 			return OS.IsSP ? 2 : (int)/*64*/OS.SendMessage (hwndCB, OS.TB_BUTTONCOUNT, 0, 0);
-		}
-		int count = 0;
-		MENUITEMINFO info = new MENUITEMINFO ();
-		info.cbSize = MENUITEMINFO.sizeof;
-		while (OS.GetMenuItemInfo (handle, count, true, info)) count++;
-		return count;
-	}
-	return OS.GetMenuItemCount (handle);
+                }
+                int count = 0;
+                MENUITEMINFO info = new MENUITEMINFO ();
+                info.cbSize = MENUITEMINFO.sizeof;
+                while (OS.GetMenuItemInfo (handle, count, true, info)) count++;
+                return count;
+        }
+        return OS.GetMenuItemCount (handle);
 }
 
 String getNameText () {
-	String result = "";
-	MenuItem [] items = getItems ();
-	int length = items.length;
-	if (length > 0) {
-		for (int i=0; i<length-1; i++) {
-			result = result + items [i].getNameText() + ", ";
-		}
-		result = result + items [length-1].getNameText ();
-	}
-	return result;
+        String result = "";
+        MenuItem [] items = getItems ();
+        int length = items.length;
+        if (length > 0) {
+                for (int i=0; i<length-1; i++) {
+                        result = result + items [i].getNameText() + ", ";
+                }
+                result = result + items [length-1].getNameText ();
+        }
+        return result;
 }
 
 /**
@@ -924,12 +1088,12 @@
  * constants <code>SWT.LEFT_TO_RIGHT</code> or <code>SWT.RIGHT_TO_LEFT</code>.
  *
  * @return the orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.7
  */
 public int getOrientation () {
@@ -948,8 +1112,8 @@
  * </ul>
  */
 public Decorations getParent () {
-	checkWidget ();
-	return parent;
+        checkWidget ();
+        return parent;
 }
 
 /**
@@ -965,8 +1129,8 @@
  * </ul>
  */
 public MenuItem getParentItem () {
-	checkWidget ();
-	return cascade;
+        checkWidget ();
+        return cascade;
 }
 
 /**
@@ -982,9 +1146,9 @@
  * </ul>
  */
 public Menu getParentMenu () {
-	checkWidget ();
-	if (cascade != null) return cascade.parent;
-	return null;
+        checkWidget ();
+        if (cascade != null) return cascade.parent;
+        return null;
 }
 
 /**
@@ -1003,8 +1167,8 @@
  * @see #getParent
  */
 public Shell getShell () {
-	checkWidget ();
-	return parent.getShell ();
+        checkWidget ();
+        return parent.getShell ();
 }
 
 /**
@@ -1025,23 +1189,52 @@
  * </ul>
  */
 public boolean getVisible () {
-	checkWidget ();
-	if ((style & SWT.BAR) != 0) {
-		return this == parent.menuShell ().menuBar;
-	}
-	if ((style & SWT.POP_UP) != 0) {
-		Menu [] popups = display.popups;
-		if (popups == null) return false;
-		for (int i=0; i<popups.length; i++) {
-			if (popups [i] == this) return true;
-		}
-	}
-	Shell shell = getShell ();
-	Menu menu = shell.activeMenu;
-	while (menu != null && menu != this) {
-		menu = menu.getParentMenu ();
-	}
-	return this == menu;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "getVisible()", "");
+    }
+    // </QFS>
+        checkWidget ();
+        if ((style & SWT.BAR) != 0) {
+                return this == parent.menuShell ().menuBar;
+        }
+        if ((style & SWT.POP_UP) != 0) {
+                Menu [] popups = display.popups;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("getVisible()").add("popups: ").addAll(popups).log(Log.DBG);
+                }
+                // </QFS>
+                if (popups == null) return false;
+                for (int i=0; i<popups.length; i++) {
+                    // <QFS>
+                    if (logger.level >= Log.DBG && popups [i] == this) {
+                        logger.log(Log.DBG, "getVisible()",
+                                   "Found me");
+                    }
+                    // </QFS>
+                    if (popups [i] == this) return true;
+                }
+        }
+        Shell shell = getShell ();
+        Menu menu = shell.activeMenu;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("getVisible()").add("shell: ").add(shell)
+                .add(", menu: ").add(menu)
+                .add(", is me: ").add(menu == this).log(Log.DBG);
+        }
+        // </QFS>
+        while (menu != null && menu != this) {
+                menu = menu.getParentMenu ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("getVisible()").add("parent menu: ").add(menu)
+                        .add(", is me: ").add(menu == this).log(Log.DBG);
+                }
+                // </QFS>
+        }
+        return this == menu;
 }
 
 int imageIndex (Image image) {
@@ -1065,7 +1258,7 @@
 
 /**
  * Searches the receiver's list starting at the first item
- * (index 0) until an item is found that is equal to the 
+ * (index 0) until an item is found that is equal to the
  * argument, and returns the index of that item. If no item
  * is found, returns -1.
  *
@@ -1081,29 +1274,29 @@
  * </ul>
  */
 public int indexOf (MenuItem item) {
-	checkWidget ();
-	if (item == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (item.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
-	if (item.parent != this) return -1;
-	if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
-		if (OS.IsPPC) {
+        checkWidget ();
+        if (item == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (item.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
+        if (item.parent != this) return -1;
+        if ((OS.IsPPC || OS.IsSP) && hwndCB != 0) {
+                if (OS.IsPPC) {
 			return (int)/*64*/OS.SendMessage (hwndCB, OS.TB_COMMANDTOINDEX, item.id, 0);
-		}
-		if (OS.IsSP) {
-			if (item.id == id0) return 0;
-			if (item.id == id1) return 1;
-			return -1;
-		}
-	}
-	int index = 0;
-	MENUITEMINFO info = new MENUITEMINFO ();
-	info.cbSize = MENUITEMINFO.sizeof;
-	info.fMask = OS.MIIM_DATA;
-	while (OS.GetMenuItemInfo (handle, index, true, info)) {
-		if (info.dwItemData == item.id) return index;
-		index++;
-	}
-	return -1;
+                }
+                if (OS.IsSP) {
+                        if (item.id == id0) return 0;
+                        if (item.id == id1) return 1;
+                        return -1;
+                }
+        }
+        int index = 0;
+        MENUITEMINFO info = new MENUITEMINFO ();
+        info.cbSize = MENUITEMINFO.sizeof;
+        info.fMask = OS.MIIM_DATA;
+        while (OS.GetMenuItemInfo (handle, index, true, info)) {
+                if (info.dwItemData == item.id) return index;
+                index++;
+        }
+        return -1;
 }
 
 /**
@@ -1118,7 +1311,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -1145,17 +1338,22 @@
  * @see #getVisible
  */
 public boolean isVisible () {
-	checkWidget ();
-	return getVisible ();
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.log(Log.MTD, "isVisible()", "");
+    }
+    // </QFS>
+        checkWidget ();
+        return getVisible ();
 }
 
 void redraw () {
-	if (!isVisible ()) return;
-	if ((style & SWT.BAR) != 0) {
-		display.addBar (this);
-	} else {
-		update ();
-	}
+        if (!isVisible ()) return;
+        if ((style & SWT.BAR) != 0) {
+                display.addBar (this);
+        } else {
+                update ();
+        }
 }
 
 void releaseHandle () {
@@ -1227,10 +1425,10 @@
  * @see #addHelpListener
  */
 public void removeHelpListener (HelpListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (eventTable == null) return;
-	eventTable.unhook (SWT.Help, listener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (eventTable == null) return;
+        eventTable.unhook (SWT.Help, listener);
 }
 
 /**
@@ -1251,11 +1449,11 @@
  * @see #addMenuListener
  */
 public void removeMenuListener (MenuListener listener) {
-	checkWidget ();
-	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
-	if (eventTable == null) return;
-	eventTable.unhook (SWT.Hide, listener);
-	eventTable.unhook (SWT.Show, listener);
+        checkWidget ();
+        if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
+        if (eventTable == null) return;
+        eventTable.unhook (SWT.Hide, listener);
+        eventTable.unhook (SWT.Show, listener);
 }
 
 void reskinChildren (int flags) {
@@ -1275,13 +1473,13 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setBackground (Color color) {
@@ -1305,14 +1503,14 @@
  * @param image the new image (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument is not a bitmap</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setBackgroundImage (Image image) {
@@ -1334,13 +1532,13 @@
  * @param color the new color (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 /*public*/ void setForeground (Color color) {
@@ -1358,11 +1556,11 @@
 /**
  * Sets the default menu item to the argument or removes
  * the default emphasis when the argument is <code>null</code>.
- * 
+ *
  * @param item the default menu item or null
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the menu item has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the menu item has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -1370,18 +1568,18 @@
  * </ul>
  */
 public void setDefaultItem (MenuItem item) {
-	checkWidget ();
-	int newID = -1;
-	if (item != null) {
-		if (item.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
-		if (item.parent != this) return;
-		newID = item.id;
-	}
-	if (OS.IsWinCE) return;
-	int oldID = OS.GetMenuDefaultItem (handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);
-	if (newID == oldID) return;
-	OS.SetMenuDefaultItem (handle, newID, OS.MF_BYCOMMAND);
-	redraw ();
+        checkWidget ();
+        int newID = -1;
+        if (item != null) {
+                if (item.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
+                if (item.parent != this) return;
+                newID = item.id;
+        }
+        if (OS.IsWinCE) return;
+        int oldID = OS.GetMenuDefaultItem (handle, OS.MF_BYCOMMAND, OS.GMDI_USEDISABLED);
+        if (newID == oldID) return;
+        OS.SetMenuDefaultItem (handle, newID, OS.MF_BYCOMMAND);
+        redraw ();
 }
 
 /**
@@ -1398,9 +1596,9 @@
  * </ul>
  */
 public void setEnabled (boolean enabled) {
-	checkWidget ();
-	state &= ~DISABLED;
-	if (!enabled) state |= DISABLED;
+        checkWidget ();
+        state &= ~DISABLED;
+        if (!enabled) state |= DISABLED;
 }
 
 /**
@@ -1424,11 +1622,11 @@
  * </ul>
  */
 public void setLocation (int x, int y) {
-	checkWidget ();
-	if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
-	this.x = x;
-	this.y = y;
-	hasLocation = true;
+        checkWidget ();
+        if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
+        this.x = x;
+        this.y = y;
+        hasLocation = true;
 }
 
 /**
@@ -1452,13 +1650,13 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void setLocation (Point location) {
-	checkWidget ();
+        checkWidget ();
 	if (location == null) error (SWT.ERROR_NULL_ARGUMENT);
-	setLocation (location.x, location.y);
+        setLocation (location.x, location.y);
 }
 
 /**
@@ -1467,15 +1665,15 @@
  * <p>
  *
  * @param orientation new orientation style
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
- * @since 3.7  
+ *
+ * @since 3.7
  */
-public void setOrientation (int orientation) { 
+public void setOrientation (int orientation) {
     checkWidget ();
     if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
     _setOrientation (orientation);
@@ -1496,7 +1694,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -1511,14 +1709,33 @@
  * </ul>
  */
 public void setVisible (boolean visible) {
-	checkWidget ();
-	if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
-	if (visible) {
-		display.addPopup (this);
-	} else {
-		display.removePopup (this);
-		_setVisible (false);
-	}
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("setVisible(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add("visible: ").add(visible)).log(Log.MTD);
+    }
+    // </QFS>
+        checkWidget ();
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.build("setVisible(boolean)").add("style: ").addHex(style).log(Log.DBG);
+        }
+        // </QFS>
+        if ((style & (SWT.BAR | SWT.DROP_DOWN)) != 0) return;
+        if (visible) {
+                display.addPopup (this);
+        } else {
+                display.removePopup (this);
+                _setVisible (false);
+        }
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "setVisible(boolean)",
+                       "done");
+        }
+        // </QFS>
 }
 
 void update () {
@@ -1561,7 +1778,7 @@
 			if ((hasCheck = true) && hasImage) break;
 		}
 	}
-	
+
 	/*
 	* Bug in Windows.  If a menu contains items that have
 	* images and can be checked, Windows does not include
@@ -1571,16 +1788,16 @@
 	* text can overlap.  The fix is to use SetMenuItemInfo()
 	* to indicate that all items have a bitmap and then include
 	* the width of the widest bitmap in WM_MEASURECHILD.
-	* 
+	*
 	* NOTE:  This work around causes problems on Windows 98.
 	* Under certain circumstances that have yet to be isolated,
 	* some menus can become huge and blank.  For now, do not
 	* run the code on Windows 98.
-	* 
+	*
 	* NOTE:  This work around doesn't run on Vista because
 	* WM_MEASURECHILD and WM_DRAWITEM cause Vista to lose
 	* the menu theme.
-	*/	
+	*/
 	if (!OS.IsWin95) {
 		if (OS.WIN32_VERSION < OS.VERSION (6, 0)) {
 			MENUITEMINFO info = new MENUITEMINFO ();
@@ -1598,17 +1815,47 @@
 		}
 	}
 
-	/* Update the menu to hide or show the space for bitmaps */
-	MENUINFO lpcmi = new MENUINFO ();
-	lpcmi.cbSize = MENUINFO.sizeof;
-	lpcmi.fMask = OS.MIM_STYLE;
-	OS.GetMenuInfo (handle, lpcmi);
-	if (hasImage && !hasCheck) {
-		lpcmi.dwStyle |= OS.MNS_CHECKORBMP;
-	} else {
-		lpcmi.dwStyle &= ~OS.MNS_CHECKORBMP;
-	}
-	OS.SetMenuInfo (handle, lpcmi);
+        /*
+        * Bug in Windows.  If a menu contains items that have
+        * images and can be checked, Windows does not include
+        * the width of the image and the width of the check when
+        * computing the width of the menu.  When the longest item
+        * does not have an image, the label and the accelerator
+        * text can overlap.  The fix is to use SetMenuItemInfo()
+        * to indicate that all items have a bitmap and then include
+        * the width of the widest bitmap in WM_MEASURECHILD.
+        *
+        * NOTE:  This work around causes problems on Windows 98.
+        * Under certain circumstances that have yet to be isolated,
+        * some menus can become huge and blank.  For now, do not
+        * run the code on Windows 98.
+        */
+        if (!OS.IsWin95) {
+                MENUITEMINFO info = new MENUITEMINFO ();
+                info.cbSize = MENUITEMINFO.sizeof;
+                info.fMask = OS.MIIM_BITMAP;
+                for (int i=0; i<items.length; i++) {
+                        MenuItem item = items [i];
+                        if ((style & SWT.SEPARATOR) == 0) {
+                                if (item.image == null) {
+                                        info.hbmpItem = hasImage ? OS.HBMMENU_CALLBACK : 0;
+                                        OS.SetMenuItemInfo (handle, item.id, false, info);
+                                }
+                        }
+                }
+        }
+
+        /* Update the menu to hide or show the space for bitmaps */
+        MENUINFO lpcmi = new MENUINFO ();
+        lpcmi.cbSize = MENUINFO.sizeof;
+        lpcmi.fMask = OS.MIM_STYLE;
+        OS.GetMenuInfo (handle, lpcmi);
+        if (hasImage && !hasCheck) {
+                lpcmi.dwStyle |= OS.MNS_CHECKORBMP;
+        } else {
+                lpcmi.dwStyle &= ~OS.MNS_CHECKORBMP;
+        }
+        OS.SetMenuInfo (handle, lpcmi);
 }
 
 void updateBackground () {
Index: org/eclipse/swt/widgets/ExpandBar.java
===================================================================
--- org/eclipse/swt/widgets/ExpandBar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ExpandBar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -267,10 +267,10 @@
 			hCurrentFont = hFont;
 		} else {
 			if (!OS.IsWinCE) {
-				NONCLIENTMETRICS info = OS.IsUnicode ? (NONCLIENTMETRICS) new NONCLIENTMETRICSW () : new NONCLIENTMETRICSA ();
-				info.cbSize = NONCLIENTMETRICS.sizeof;
-				if (OS.SystemParametersInfo (OS.SPI_GETNONCLIENTMETRICS, 0, info, 0)) {
-					LOGFONT logFont = OS.IsUnicode ? (LOGFONT) ((NONCLIENTMETRICSW)info).lfCaptionFont : ((NONCLIENTMETRICSA)info).lfCaptionFont;
+			NONCLIENTMETRICS info = OS.IsUnicode ? (NONCLIENTMETRICS) new NONCLIENTMETRICSW () : new NONCLIENTMETRICSA ();
+			info.cbSize = NONCLIENTMETRICS.sizeof;
+			if (OS.SystemParametersInfo (OS.SPI_GETNONCLIENTMETRICS, 0, info, 0)) {
+				LOGFONT logFont = OS.IsUnicode ? (LOGFONT) ((NONCLIENTMETRICSW)info).lfCaptionFont : ((NONCLIENTMETRICSA)info).lfCaptionFont;
 					hCurrentFont = OS.CreateFontIndirect (logFont);
 				}
 			}
@@ -277,7 +277,7 @@
 		}
 		if (hCurrentFont != 0) {
 			oldFont = OS.SelectObject (gc.handle, hCurrentFont);
-		}
+			}
 		if (foreground != -1) {
 			OS.SetTextColor (gc.handle, foreground);
 		}
Index: org/eclipse/swt/widgets/Display.java
===================================================================
--- org/eclipse/swt/widgets/Display.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Display.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -16,6 +17,21 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import org.eclipse.swt.dnd.DragSource;
+import org.eclipse.swt.dnd.DropTarget;
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Properties;
+import java.util.StringTokenizer;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class are responsible for managing the
  * connection between SWT and the underlying operating
@@ -47,12 +63,12 @@
  * <code>Widget</code> and its subclasses), may only be called
  * from the thread. (To support multi-threaded user-interface
  * applications, class <code>Display</code> provides inter-thread
- * communication methods which allow threads other than the 
+ * communication methods which allow threads other than the
  * user-interface thread to request that it perform operations
  * on their behalf.)
  * </li>
  * <li>
- * The thread is not allowed to construct other 
+ * The thread is not allowed to construct other
  * <code>Display</code>s until that display has been disposed.
  * (Note that, this is in addition to the restriction mentioned
  * above concerning platform support for multiple displays. Thus,
@@ -61,8 +77,8 @@
  * </li>
  * </ul>
  * Enforcing these attributes allows SWT to be implemented directly
- * on the underlying operating system's event model. This has 
- * numerous benefits including smaller footprint, better use of 
+ * on the underlying operating system's event model. This has
+ * numerous benefits including smaller footprint, better use of
  * resources, safer memory management, clearer program logic,
  * better performance, and fewer overall operating system threads
  * required. The down side however, is that care must be taken
@@ -97,6 +113,1406 @@
 
 public class Display extends Device {
 
+    // <QFS>
+    // {{{ Logging
+
+    /**
+     * The logger used for logging.
+     */
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Display");
+
+    // }}}
+
+    /**
+     * Monitor for class level synchronization.
+     */
+    final static Object classLock = new Object ();
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for display creation notification
+    //------------------------------------------------------------------------------------------
+
+    // {{{ interface IDisplayCreationHook
+
+    public interface IDisplayCreationHook {
+        /**
+         * Notify the hook that a new display was created.
+         *
+         * @param       display The newly created Display.
+         */
+        public void displayCreated(Display display);
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    static IDisplayCreationHook[] creationHooks;
+
+    // {{{ addDisplayCreationHook
+
+    public static void addDisplayCreationHook(IDisplayCreationHook hook)
+    {
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                creationHooks = new IDisplayCreationHook[] {hook};
+                return;
+            }
+            // Prevent double registration. If the hook is already registered, move it to the
+            // front.
+            for (int i = 0; i < creationHooks.length; i++) {
+                if (creationHooks[i] == hook) {
+                    if (i == 0) {
+                        return;
+                    }
+                    System.arraycopy(creationHooks, 0, creationHooks, 1, i);
+                    creationHooks[0] = hook;
+                }
+            }
+            // Insert new hook at front
+            IDisplayCreationHook[] tmp = new IDisplayCreationHook[creationHooks.length + 1];
+            tmp[0] = hook;
+            System.arraycopy(creationHooks, 0, tmp, 1, creationHooks.length);
+            creationHooks = tmp;
+        }
+    }
+
+    // }}}
+    // {{{ removeDisplayCreationHook
+
+    public static void removeDisplayCreationHook(IDisplayCreationHook hook)
+    {
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                return;
+            }
+
+            for (int i = 0; i < creationHooks.length; i++) {
+                if (creationHooks[i] == hook) {
+                    if (creationHooks.length == 1) {
+                        creationHooks = null;
+                        return;
+                    }
+                    // Insert new hook at front
+                    IDisplayCreationHook[] tmp =
+                        new IDisplayCreationHook[creationHooks.length - 1];
+                    if (i > 0) {
+                        System.arraycopy(creationHooks, 0, tmp, 0, i - 1);
+                    }
+                    if (i < creationHooks.length - 1) {
+                        System.arraycopy(creationHooks, i + 1, tmp, i,
+                                         creationHooks.length - i - 1);
+                    }
+                    creationHooks = tmp;
+                }
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDisplayCreationHooks
+
+    static void runDisplayCreationHooks(Display display)
+    {
+        IDisplayCreationHook[] tmp;
+        synchronized (classLock) {
+            if (creationHooks == null) {
+                return;
+            }
+            tmp = (IDisplayCreationHook[]) creationHooks.clone();
+        }
+        if (tmp != null) {
+            for (int i = 0; i < tmp.length; i++) {
+                try {
+                    tmp[i].displayCreated(display);
+                } catch (Throwable ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for Dialog creation and showing
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IDialogHook
+
+    public interface IDialogHook {
+        // {{{ dialogCreated
+
+        /**
+         * Notify the hook that a new display was created.
+         *
+         * @param       dialog The dialog that was created.
+         */
+        public void dialogCreated(Dialog dialog);
+
+        // }}}
+        // {{{ dialogShown
+
+        /**
+         * Notify the hook that a dialog is about to be shown.
+         *
+         * @param       dialog The dialog that is about to be shown.
+         * @param       handle System specific handle for the dialog.
+         */
+        public void dialogShown(Dialog dialog, Object handle);
+
+        // }}}
+        // {{{ dialogClosed
+
+        /**
+         * Notify the hook that a dialog was closed.
+         *
+         * @param       dialog The dialog that was closed.
+         * @param       result The result representing the user's choice.
+         *
+         * @return  Optional replacement for the original result.
+         */
+        public Object dialogClosed(Dialog dialog, Object result);
+
+        // }}}
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    private IDialogHook[] dialogHooks;
+
+    // {{{ addDialogHook
+
+    /**
+     * Add a dialog hook.
+     *
+     * @param   hook    The hook to add.
+     */
+    public void addDialogHook(IDialogHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("addDialogHook(IDialogHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            dialogHooks = new IDialogHook[] {hook};
+            return;
+        }
+        // Prevent double registration. If the hook is already registered, move it to the
+        // front.
+        for (int i = 0; i < dialogHooks.length; i++) {
+            if (dialogHooks[i] == hook) {
+                if (i == 0) {
+                    return;
+                }
+                System.arraycopy(dialogHooks, 0, dialogHooks, 1, i);
+                dialogHooks[0] = hook;
+            }
+        }
+        // Insert new hook at front
+        IDialogHook[] tmp = new IDialogHook[dialogHooks.length + 1];
+        tmp[0] = hook;
+        System.arraycopy(dialogHooks, 0, tmp, 1, dialogHooks.length);
+        dialogHooks = tmp;
+    }
+
+    // }}}
+    // {{{ removeDialogHook
+
+    /**
+     * Remove a dialog hook.
+     *
+     * @param   hook    The hook to remove.
+     */
+    public void removeDialogHook(IDialogHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("removeDialogHook(IDialogHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+
+        for (int i = 0; i < dialogHooks.length; i++) {
+            if (dialogHooks[i] == hook) {
+                if (dialogHooks.length == 1) {
+                    dialogHooks = null;
+                    return;
+                }
+                // Insert new hook at front
+                IDialogHook[] tmp = new IDialogHook[dialogHooks.length - 1];
+                if (i > 0) {
+                    System.arraycopy(dialogHooks, 0, tmp, 0, i - 1);
+                }
+                if (i < dialogHooks.length - 1) {
+                    System.arraycopy(dialogHooks, i + 1, tmp, i,
+                                     dialogHooks.length - i - 1);
+                }
+                dialogHooks = tmp;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogCreationHooks
+
+    /**
+     * Notify all hooks about a newly created dialog.
+     *
+     * @param   dialog  The new dialog.
+     */
+    public void runDialogCreationHooks(Dialog dialog)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogCreationHooks(Dialog)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dialogCreated(dialog);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogShownHooks
+
+    /**
+     * Notify all hooks about a dialog being shown.
+     *
+     * @param   dialog  The shown dialog.
+     * @param   handle  The handle for the dialog.
+     */
+    public void runDialogShownHooks(Dialog dialog, Object handle)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogShownHooks(Dialog,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)
+             .add(", handle: ").add(handle)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dialogShown(dialog, handle);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDialogClosedHooks
+
+    /**
+     * Notify all hooks about a dialog being closed.
+     *
+     * @param   dialog  The closed dialog.
+     * @param   result  The result of the operation (depends on the type of dialog).
+     *
+     * @return  Optional replacement for the original result.
+     */
+    public Object runDialogClosedHooks(Dialog dialog, Object result)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDialogClosedHooks(Dialog,Object)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dialog: ").add(dialog)
+             .add(", result: ").add(result)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dialogHooks == null) {
+            return result;
+        }
+        IDialogHook[] tmp = (IDialogHook[]) dialogHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                result = tmp[i].dialogClosed(dialog, result);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+        return result;
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Hooks for DND creation
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IDNDHook
+
+    public interface IDNDHook {
+        // {{{ dragSourceCreated
+
+        /**
+         * Notify the hook that a new DragSource was created.
+         *
+         * @param       dragSource The DragSource that was created.
+         */
+        public void dragSourceCreated(DragSource dragSource);
+
+        // }}}
+        // {{{ dropTargetCreated
+
+        /**
+         * Notify the hook that a new DropTarget was created.
+         *
+         * @param       dropTarget The DropTarget that was created.
+         */
+        public void dropTargetCreated(DropTarget dropTarget);
+
+        // }}}
+        // {{{ trackerDragStarted
+
+        /**
+         * Notify the listener that a Drag involving a Tracker was started.
+         */
+        public void trackerDragStarted();
+
+        // }}}
+        // {{{ trackerDragFinished
+
+        /**
+         * Notify the listener that a Drag involving a Tracker was finished.
+         *
+         * @param   cancelled       Whether the drag was cancelled.
+         */
+        public void trackerDragFinished(boolean cancelled);
+
+        // }}}
+    }
+
+    // }}}
+
+    /**
+     * Registered hooks.
+     */
+    private IDNDHook[] dndHooks;
+
+    // {{{ addDNDHook
+
+    /**
+     * Add a dnd hook.
+     *
+     * @param   hook    The hook to add.
+     */
+    public void addDNDHook(IDNDHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("addDNDHook(IDNDHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            dndHooks = new IDNDHook[] {hook};
+            return;
+        }
+        // Prevent double registration. If the hook is already registered, move it to the
+        // front.
+        for (int i = 0; i < dndHooks.length; i++) {
+            if (dndHooks[i] == hook) {
+                if (i == 0) {
+                    return;
+                }
+                System.arraycopy(dndHooks, 0, dndHooks, 1, i);
+                dndHooks[0] = hook;
+            }
+        }
+        // Insert new hook at front
+        IDNDHook[] tmp = new IDNDHook[dndHooks.length + 1];
+        tmp[0] = hook;
+        System.arraycopy(dndHooks, 0, tmp, 1, dndHooks.length);
+        dndHooks = tmp;
+    }
+
+    // }}}
+    // {{{ removeDNDHook
+
+    /**
+     * Remove a dnd hook.
+     *
+     * @param   hook    The hook to remove.
+     */
+    public void removeDNDHook(IDNDHook hook)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("removeDNDHook(IDNDHook)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hook: ").add(hook)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+
+        for (int i = 0; i < dndHooks.length; i++) {
+            if (dndHooks[i] == hook) {
+                if (dndHooks.length == 1) {
+                    dndHooks = null;
+                    return;
+                }
+                // Insert new hook at front
+                IDNDHook[] tmp = new IDNDHook[dndHooks.length - 1];
+                if (i > 0) {
+                    System.arraycopy(dndHooks, 0, tmp, 0, i - 1);
+                }
+                if (i < dndHooks.length - 1) {
+                    System.arraycopy(dndHooks, i + 1, tmp, i,
+                                     dndHooks.length - i - 1);
+                }
+                dndHooks = tmp;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDCreationHooks
+
+    /**
+     * Notify all hooks about a newly created DragSource or DropTarget.
+     *
+     * @param   dragSource     The new DragSource.
+     */
+    public void runDNDCreationHooks(DragSource dragSource)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDCreationHooks(DragSource)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dragSource: ").add(dragSource)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dragSourceCreated(dragSource);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDCreationHooks
+
+    /**
+     * Notify all hooks about a newly created DropTarget or DropTarget.
+     *
+     * @param   dropTarget     The new DropTarget.
+     */
+    public void runDNDCreationHooks(DropTarget dropTarget)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDCreationHooks(DropTarget)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("dropTarget: ").add(dropTarget)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                tmp[i].dropTargetCreated(dropTarget);
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runDNDTrackerHooks
+
+    /**
+     * Notify all hooks about DnD performed through a Tracker.
+     *
+     * @param   start   True if the DnD is started, false if finished.
+     * @param   cancelled True if the DnD was cancelled.
+     */
+    public void runDNDTrackerHooks(boolean start, boolean cancelled)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runDNDTrackerHooks(boolean,boolean)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("start: ").add(start)
+             .add(", cancelled: ").add(cancelled)).log(Log.MTD);
+        }
+
+        checkDevice();
+
+        if (dndHooks == null) {
+            return;
+        }
+        IDNDHook[] tmp = (IDNDHook[]) dndHooks.clone();
+        for (int i = 0; i < tmp.length; i++) {
+            try {
+                if (start) {
+                    tmp[i].trackerDragStarted();
+                } else {
+                    tmp[i].trackerDragFinished(cancelled);
+                }
+            } catch (Throwable ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Event filter at Win32 level
+    //------------------------------------------------------------------------------------------
+    // {{{ interface IWin32EventFilter
+
+    public interface IWin32EventFilter {
+        /**
+         * Possibly filter a Win32 message.
+         *
+         * @param       hwnd        The window handle.
+         * @param       msg         The message type.
+         * @param       wParam      win32 wParam.
+         * @param       lParam      win32 lParam.
+         *
+         * @return      True to process the event normally, false to filter it. (i.e. "keep it?")
+         */
+        public boolean filterWin32Event(int hwnd, int msg, int wParam, int lParam);
+    }
+
+    // }}}
+
+    /**
+     * Registered Win32 event filters.
+     */
+    IWin32EventFilter[] win32EventFilters;
+    public int eventProcessedByReadAndDispatch = 0;
+
+    // {{{ addWin32EventFilter
+
+    public void addWin32EventFilter(IWin32EventFilter hook)
+    {
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                win32EventFilters = new IWin32EventFilter[] {hook};
+                return;
+            }
+            // Prevent double registration. If the hook is already registered, move it to the
+            // front.
+            for (int i = 0; i < win32EventFilters.length; i++) {
+                if (win32EventFilters[i] == hook) {
+                    if (i == 0) {
+                        return;
+                    }
+                    System.arraycopy(win32EventFilters, 0, win32EventFilters, 1, i);
+                    win32EventFilters[0] = hook;
+                }
+            }
+            // Insert new hook at front
+            IWin32EventFilter[] tmp = new IWin32EventFilter[win32EventFilters.length + 1];
+            tmp[0] = hook;
+            System.arraycopy(win32EventFilters, 0, tmp, 1, win32EventFilters.length);
+            win32EventFilters = tmp;
+        }
+    }
+
+    // }}}
+    // {{{ removeWin32EventFilter
+
+    public void removeWin32EventFilter(IWin32EventFilter hook)
+    {
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                return;
+            }
+
+            for (int i = 0; i < win32EventFilters.length; i++) {
+                if (win32EventFilters[i] == hook) {
+                    if (win32EventFilters.length == 1) {
+                        win32EventFilters = null;
+                        return;
+                    }
+                    // Insert new hook at front
+                    IWin32EventFilter[] tmp =
+                        new IWin32EventFilter[win32EventFilters.length - 1];
+                    if (i > 0) {
+                        System.arraycopy(win32EventFilters, 0, tmp, 0, i - 1);
+                    }
+                    if (i < win32EventFilters.length - 1) {
+                        System.arraycopy(win32EventFilters, i + 1, tmp, i,
+                                         win32EventFilters.length - i - 1);
+                    }
+                    win32EventFilters = tmp;
+                }
+            }
+        }
+    }
+
+    // }}}
+    // {{{ runWin32EventFilters
+
+    /**
+     * Run all registered filters and possibly filter a Win32 message.
+     * Filters are only run until the first one wants to filter it (returns false);
+     *
+     * @param       hwnd        The window handle.
+     * @param       msg         The message type.
+     * @param       wParam      win32 wParam.
+     * @param       lParam      win32 lParam.
+     *
+     * @return      True to process the event normally, false to filter it. (i.e. "keep it?")
+     */
+    protected boolean runWin32EventFilters(int hwnd, int msg, int wParam, int lParam)
+    {
+        // <QFS>
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("runWin32EventFilters(int,int,int,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("hwnd: ").addHex(hwnd)
+             .add(", msg: ").add(msg)
+             .add(", wParam: ").addHex(wParam)
+             .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+        }
+        // </QFS>
+        IWin32EventFilter[] tmp;
+        synchronized (classLock) {
+            if (win32EventFilters == null) {
+                return true;
+            }
+            tmp = (IWin32EventFilter[]) win32EventFilters.clone();
+        }
+        if (tmp != null) {
+            for (int i = 0; i < tmp.length; i++) {
+                try {
+                    if (! tmp[i].filterWin32Event(hwnd, msg, wParam, lParam)) {
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.log(Log.DBG, "runWin32EventFilters(int,int,int,int)",
+                                       "filterWin32Event returned false");
+                        }
+                        // </QFS>
+                        return false;
+                    }
+                } catch (Throwable ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+        return true;
+    }
+
+    // }}}
+
+    /**
+     * Misc
+     */
+    // {{{ logMessage
+
+    public void logMessage(String method,
+                           int hwnd, int msg, int wParam, int lParam,
+                           String preText,
+                           Logger logger,
+                           int fixedloglevel)
+    {
+        // get name of control
+        Control control = getControl(hwnd);
+        String controlClassName = control != null ? control.getClass().getName() : "(unknown control)";
+
+        // determine loglevel
+        int loglevel = Log.MTD;
+        String msgtype = null;
+
+        if (logger.level >= Log.MTD) {
+            boolean[] hasMatch = new boolean[1];
+            msgtype = OS.getWinMsgType(msg, hasMatch);
+            loglevel = OS.isMessageImportant(msg)
+                ? Log.MTD
+                : (OS.isMessageUnimportant(msg) || ! hasMatch[0])
+                ? Log.DBGDETAIL
+                : Log.DBG;
+        }
+        if (fixedloglevel >= 0)
+            loglevel = fixedloglevel;
+
+        // now do the real logging
+        if (logger.level >= loglevel) {
+            Logger.Builder lb = logger.build(method)
+                .add(preText != null ? preText : "")
+                .add("msg: ").add(msgtype)
+                .add(", hwnd: ").addHex(hwnd)
+                .add(", controlclass=").add(controlClassName);
+            switch (msg) {
+            case OS.WM_LBUTTONDOWN:
+            case OS.WM_LBUTTONUP:
+                lb  .add(", keyflags=").addHex(wParam)
+                    .add(", x=").add(lParam & 0xffff)
+                    .add(", y=").add(lParam >> 16)
+                    .log(loglevel);
+                break;
+            default:
+                lb  .add(", wParam: ").addHex(wParam)
+                    .add(", lParam: ").addHex(lParam)
+                    .log(loglevel);
+                break;
+            }
+        }
+    }
+
+    // }}}
+    // {{{ getLastMouse
+
+    public int getLastMouse()
+    {
+        return lastMouse;
+    }
+
+    // }}}
+
+    // {{{ variables
+
+    public final static String[] EVENTS = new String[] {
+        "None", "KeyDown", "KeyUp", "MouseDown", "MouseUp", "MouseMove", "MouseEnter", "MouseExit",
+        "MouseDoubleClick", "Paint", "Move", "Resize", "Dispose", "Selection", "DefaultSelection",
+        "FocusIn", "FocusOut", "Expand", "Collapse", "Iconify", "Deiconify", "Close", "Show",
+        "Hide", "Modify", "Verify", "Activate", "Deactivate", "Help", "DragDetect", "Arm",
+        "Traverse", "MouseHover", "HardKeyDown", "HardKeyUp", "MenuDetect", "SetData"};
+
+    // }}}
+    // {{{ getEventName
+
+    public final static String getEventName(int event)
+    {
+        if (event >= 0 && event <= 36) {
+            return EVENTS[event];
+        }
+        return "Unknown";
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // KeyState override during replay
+    //------------------------------------------------------------------------------------------
+    // {{{ variables
+
+    protected boolean replaying;
+    protected Widget replayTarget;
+    private long replayingUntil;
+    private int replayPos;
+    private int replayFwKeys;
+
+    // }}}
+    // {{{ GetKeyState
+
+    /**
+     * The GetKeyState function retrieves the status of the specified virtual key.
+     * If replaying is false, this is just OS.GetKeyState().
+     * If replaying is true, it returns the replayed keyState.
+     *
+     * @param   nVirtKey
+     *
+     * @return  -1 if key is pressed, 0 if not.
+     */
+    public short GetKeyState(int nVirtKey)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("GetKeyState(int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("nVirtKey: ").add(nVirtKey)).log(Log.MTD);
+        }
+        if (logger.level >= Log.DBG) {
+            logger.dumpStack(Log.DBG, "GetKeyState(int)",
+                       "");
+        }
+
+        if (replaying) {
+            int mask;
+            switch (nVirtKey) {
+            case OS.VK_SHIFT:
+                mask = SWT.SHIFT;
+                break;
+            case OS.VK_CONTROL:
+                mask = SWT.CONTROL;
+                break;
+            case OS.VK_MENU:
+                mask = SWT.ALT;
+                break;
+            case OS.VK_LBUTTON:
+                mask = SWT.BUTTON1;
+                break;
+            case OS.VK_MBUTTON:
+                mask = SWT.BUTTON2;
+                break;
+            case OS.VK_RBUTTON:
+                mask = SWT.BUTTON3;
+                break;
+            default:
+                mask = 0;
+            }
+
+            if (logger.level >= Log.DBG) {
+                logger.build("GetKeyState(int)").add("mask: ").addHex(mask)
+                    .add(", replayFwKeys").addHex(replayFwKeys).log(Log.DBG);
+            }
+            return ((replayFwKeys & mask) != 0) ? (short)-1 : 0;
+        } else {
+            return OS.GetKeyState(nVirtKey);
+        }
+    }
+
+    // }}}
+    // {{{ GetMessagePos
+
+    /**
+     * The GetMessagePos function returns a long value that gives the cursor position in
+     * screen coordinates.
+     *
+     * If replaying is false, this is just OS.GetMessagePos().
+     * If replaying is true, it returns the replayed position.
+     *
+     * @return The return value specifies the x- and y-coordinates of the cursor position.
+     *           The x-coordinate is the low order int and the y-coordinate is the high-order int.
+     *
+     */
+    int GetMessagePos()
+    {
+        if (isReplaying()) {
+            return replayPos;
+        } else {
+            return OS.GetMessagePos();
+        }
+    }
+
+    // }}}
+    // {{{ setReplayState
+
+    public void setReplayState(boolean replaying, long until, int pos, Widget target)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayState(boolean,long,int,Widget)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", until: ").add(until)
+             .add(", pos: ").add(pos)
+             .add(", target: ").add(target)).log(Log.MTD);
+        }
+        this.replaying = replaying;
+        replayingUntil = until;
+        if (replaying) {
+            replayPos = pos;
+            replayTarget = target;
+        }
+    }
+
+    // }}}
+    // {{{ setReplayKeyState
+
+    public void setReplayKeyState(boolean replaying, long until, int keyState)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayKeyState(boolean,long,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", until: ").add(until)
+             .add(", keyState: ").addHex(keyState)).log(Log.MTD);
+        }
+        this.replaying = replaying;
+        replayingUntil = until;
+        if (replaying) {
+            replayFwKeys = keyState;
+        }
+    }
+
+    // }}}
+    // {{{ setReplayKeyStateWnd
+
+    public void setReplayKeyStateWnd(int keyState)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplayKeyStateWnd(int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("keyState: ").add(keyState)).log(Log.MTD);
+        }
+        replayFwKeys = 0;
+        if ((keyState & OS.MK_SHIFT) != 0) {
+            replayFwKeys |= SWT.SHIFT;
+        }
+        if ((keyState & OS.MK_CONTROL) != 0) {
+            replayFwKeys |= SWT.CONTROL;
+        }
+        if ((keyState & OS.MK_LBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON1;
+        }
+        if ((keyState & OS.MK_MBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON2;
+        }
+        if ((keyState & OS.MK_RBUTTON) != 0) {
+            replayFwKeys |= SWT.BUTTON3;
+        }
+    }
+
+    // }}}
+    // {{{ isReplaying
+
+    protected boolean isReplaying()
+    {
+        return replaying
+            || (replayingUntil != 0 && replayingUntil > System.currentTimeMillis());
+    }
+
+    // }}}
+
+    //------------------------------------------------------------------------------------------
+    // Helper class for accessing environment variables
+    //
+    // Doesn't belong here.
+    //------------------------------------------------------------------------------------------
+    // {{{ class Environment
+
+    private static class Environment
+    {
+        // {{{ variables
+
+        /**
+         * Names used by DOS/Windows 95 variants.
+         */
+        private final String[] dosNames = {
+            "Windows 95", "Windows 98", "Windows ME"
+        };
+
+        /**
+         * Whether the JDK is at least version 1.5 so we can use System.getenv.
+         */
+        private final boolean is15 = "1.5".compareTo(System.getProperty("java.version")) <= 0;
+
+        /**
+         * Unknown os.
+         */
+        private final int OS_OTHER = 0;
+
+        /**
+         * Posix variants.
+         */
+        private final int OS_POSIX = 1;
+
+        /**
+         * Windows NT variants.
+         */
+        private final int OS_NT = 2;
+
+        /**
+         * DOS/Windows 95 variants.
+         */
+        private final int OS_DOS = 3;
+
+        /**
+         * MacOS variants < Mac OS-X
+         */
+        private final int OS_MAC = 4;
+
+        /**
+         * The os type.
+         */
+        private int os = OS_OTHER;
+
+        /**
+         * The actual environment.
+         */
+        private Properties environment;
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Constructor
+        //--------------------------------------------------------------------------------------
+        // {{{ Environment
+
+        /**
+         * Create a new Environment.
+         */
+        public Environment ()
+        {
+            determineOS();
+            if (os != OS_OTHER) {
+                initEnvironment();
+            }
+        }
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Public methods
+        //--------------------------------------------------------------------------------------
+        // {{{ isAvaliable
+
+        /**
+         * Test whether the Environment is available.
+         *
+         * @return      Whether the Environment is available.
+         */
+        public boolean isAvaliable()
+        {
+            return os != OS_OTHER;
+        }
+
+        // }}}
+        // {{{ getEnvironment
+
+        /**
+         * Get the whole set of environment variables.
+         *
+         * @return  The environment variables.
+         */
+        public final Properties getEnvironment()
+        {
+            if (os == OS_OTHER) {
+                return null;
+            }
+            synchronized (this) {
+                if (environment == null) {
+                    initEnvironment();
+                }
+            }
+            return environment;
+        }
+
+        // }}}
+        // {{{ setEnvironment
+
+        /**
+         * Set the whole set of environment variables.
+         *
+         * @param   environment     The environment to set.
+         */
+        public final void setEnvironment(Properties environment)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            this.environment = environment;
+        }
+
+
+
+        // }}}
+        // {{{ getEnv
+
+        /**
+         * Get one environment variable.
+         *
+         * @param   name    The name of the environment variable.
+         *
+         * @return  The respective environment value or null if undefined.
+         */
+        public String getEnv(String name)
+        {
+            if (os == OS_OTHER) {
+                return null;
+            }
+            return getEnvironment().getProperty(transformName(name));
+        }
+
+        // }}}
+        // {{{ setEnv
+
+        /**
+         * Set an environment variable value.
+         *
+         * @param   name    The name of the environment variable.
+         * @param   value   The value of the environment variable.
+         */
+        public void setEnv(String name, String value)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            getEnvironment().put(transformName(name), value);
+        }
+
+        // }}}
+        // {{{ unsetEnv
+        /**
+         * Delete an environment variable.
+         *
+         * @param   name    The name of the environment variable.
+         */
+        public void unsetEnv(String name)
+        {
+            if (os == OS_OTHER) {
+                return;
+            }
+            getEnvironment().remove(transformName(name));
+        }
+
+        // }}}
+
+        //--------------------------------------------------------------------------------------
+        // Helper methods
+        //--------------------------------------------------------------------------------------
+        // {{{ determineOS
+
+        /**
+         * Determine the type of the underlying operating system.
+         */
+        private void determineOS()
+        {
+            String osname = System.getProperty("os.name");
+            // debug("osname: " + osname);
+            if (osname == null) {
+                if (is15) {
+                    os = OS_POSIX;
+                    return;
+                }
+                return;
+            }
+
+            if (osname.startsWith("Windows")) {
+                int i;
+                for (i = 0; i < dosNames.length; i++) {
+                    if (dosNames[i].equalsIgnoreCase(osname)) {
+                        os = OS_DOS;
+                    }
+                }
+                if (i == dosNames.length) {
+                    os = OS_NT;
+                }
+            } else if (osname.startsWith("MacOS")) {
+                os = OS_MAC;
+            } else {
+                os = OS_POSIX;
+            }
+            // debug("os: " + os);
+        }
+
+        // }}}
+        // {{{ initEnvironment
+
+        /**
+         * Initialize the environment by executing a subshell.
+         */
+        private void initEnvironment()
+        {
+            environment = new Properties();
+
+            if (is15) {
+                try {
+                    Map env = (Map) System.class.getMethod("getenv", new Class[0])
+                        .invoke(null, new Object[0]);
+                    for (Iterator i = env.entrySet().iterator(); i.hasNext(); ) {
+                        Map.Entry entry = (Map.Entry) i.next();
+                        environment.put(transformName((String) entry.getKey()), entry.getValue());
+                    }
+                    return;
+                } catch (Throwable ex) {
+                    // debug(ex);
+                }
+            }
+            String[] envCommand = null;
+            switch(os) {
+            case OS_POSIX:
+                envCommand = new String[] {"sh", "-c", "env"};
+                break;
+            case OS_NT:
+                envCommand = new String[] {"cmd", "/c", "set"};
+                break;
+            case OS_DOS:
+                envCommand = new String[] {"command.com", "/c", "set"};
+                break;
+            }
+
+            if (envCommand != null) {
+                try {
+                    Process process = Runtime.getRuntime().exec(envCommand);
+                    BufferedReader in = new BufferedReader
+                        (new InputStreamReader(process.getInputStream()));
+                    String line = in.readLine();
+                    if (line.indexOf('=') <= 0) {
+                        terminateProcess(process);
+                        return;
+                    }
+                    StringBuffer sb = new StringBuffer ();
+                    String key = "";
+                    int lines = 0;
+                    while (line != null) {
+                        lines++;
+                        int idx = line.indexOf('=');
+                        if (idx < 0) {
+                            // Belongs to previous line
+                            sb.append("\n");
+                            sb.append(line);
+                        } else {
+                            environment.put(key, sb.toString());
+                            sb.setLength(0);
+                            key = transformName(line.substring(0, idx));
+                            sb.append(line.substring(idx + 1));
+                        }
+                        line = in.readLine();
+                    }
+                    environment.put(key, sb.toString());
+                    terminateProcess(process);
+                    // debug("lines: " + lines);
+                    // debug("environment: " + environment);
+                } catch (Throwable ex) {
+                    // debug(ex);
+                    os = OS_OTHER;
+                }
+            }
+        }
+
+        // }}}
+        // {{{ terminateProcess
+
+        /**
+         * Terminate a process cleanly and make sure its output and error streams are read to
+         * prevent it from blocking.
+         *
+         * @param   process The process to terminate.
+         */
+        private void terminateProcess(final Process process)
+        {
+            final byte[] buf = new byte[32768];
+            // Make sure output stream gets cleared.
+            new Thread() {
+                public void run() {
+                    try {
+                        InputStream in = process.getInputStream();
+                        while (in.read(buf) >= 0) {
+                        }
+                    } catch (Throwable ex) {
+                        // debug(ex);
+                    }
+                }
+            }.start();
+            // Make sure error stream gets cleared.
+            new Thread() {
+                public void run() {
+                    try {
+                        InputStream in = process.getErrorStream();
+                        while (in.read(buf) >= 0) {
+                        }
+                    } catch (Throwable ex) {
+                        // debug(ex);
+                    }
+                }
+            }.start();
+            process.destroy();
+        }
+
+        // }}}
+        // {{{ transformName
+
+        /**
+         * Transform the name of an envrionment variable: On Windows Systems the name is converted
+         * to upper case.
+         *
+         * @param   name    The name of the envrionment variable.
+         *
+         * @return  The transformed name.
+         */
+        private String transformName(String name)
+        {
+            return (os == OS_DOS || os == OS_NT) ? name.toUpperCase() : name;
+        }
+
+        // }}}
+    }
+    // }}}
+
+    /**
+     * Static initialization: Check system properties and environment variables for display
+     * creation hooks.
+     */
+    static {
+        try {
+            String hookClasses = System.getProperty("eclipse.swt.DisplayCreationHooks");
+            String envHooks = new Environment ().getEnv("SWT_DISPLAY_CREATION_HOOKS");
+            if (envHooks != null) {
+                hookClasses = hookClasses == null ? envHooks : (hookClasses + ":" + envHooks);
+            }
+            if (hookClasses != null) {
+                for (StringTokenizer st = new StringTokenizer(hookClasses, ":;, \t\r\n");
+                     st.hasMoreTokens(); ) {
+                    String clName = st.nextToken();
+                    try {
+                        Class cl;
+                        try {
+                            // First try to fall back to the system ClassLoader
+                            cl = ClassLoader.getSystemClassLoader().loadClass(clName);
+                        } catch (Throwable th) {
+                            // Then try the ClassLoader for this code
+                            cl = Display.class.getClassLoader().loadClass(clName);
+                        }
+                        Object o = cl.getConstructor(new Class[] {Class.class})
+                            .newInstance(new Object[] {Display.class});
+                        String buildnumber = null;
+                        try {
+                            java.io.InputStream in = Display.class.getResourceAsStream
+                                ("/org/eclipse/swt/widgets/qfsbuild.properties");
+                            Properties build = new Properties ();
+                            build.load(in);
+                            buildnumber = build.getProperty("buildnumber");
+                        } catch (Throwable th) {
+                            if (logger.level >= Log.WRN) {
+                                logger.log(Log.WRN, "run()", th);
+                            }
+                        }
+                        System.out.println("SWT " + SWT.getVersion() + " build qftest." +
+                                           (buildnumber == null ? "?" : buildnumber));
+                    } catch (Throwable th) {
+                        if (logger.level >= Log.WRN) {
+                            logger.log(Log.WRN, "run()", th);
+                        }
+                        System.err.println("Could not load class " + clName);
+                    }
+                }
+            }
+        } catch (Throwable th) {
+            th.printStackTrace();
+        }
+    }
+// </QFS>
+
 	/**
 	 * the handle to the OS message queue
 	 * (Warning: This field is platform dependent)
@@ -106,7 +1522,7 @@
 	 * within the packages provided by SWT. It is not available on all
 	 * platforms and should never be accessed from application code.
 	 * </p>
-	 * 
+	 *
 	 * @noreference This field is not intended to be referenced by clients.
 	 */
 	public MSG msg = new MSG ();
@@ -113,7 +1529,7 @@
 
 	static String APP_NAME = "SWT"; //$NON-NLS-1$
 	static String APP_VERSION = ""; //$NON-NLS-1$
-	
+
 	/* Windows and Events */
 	Event [] eventQueue;
 	Callback windowCallback;
@@ -143,7 +1559,7 @@
 			SWT_OBJECT_INDEX = 0;
 		}
 	}
-	
+
 	/* Startup info */
 	static STARTUPINFO lpStartupInfo;
 	static {
@@ -153,7 +1569,7 @@
 			OS.GetStartupInfo (lpStartupInfo);
 		}
 	}
-	
+
 	/* XP Themes */
 	int /*long*/ hButtonTheme, hEditTheme, hExplorerBarTheme, hScrollBarTheme, hTabTheme;
 	static final char [] BUTTON = new char [] {'B', 'U', 'T', 'T', 'O', 'N', 0};
@@ -164,35 +1580,35 @@
 	static final char [] LISTVIEW = new char [] {'L', 'I', 'S', 'T', 'V', 'I', 'E', 'W', 0};
 	static final char [] TAB = new char [] {'T', 'A', 'B', 0};
 	static final char [] TREEVIEW = new char [] {'T', 'R', 'E', 'E', 'V', 'I', 'E', 'W', 0};
-	
+
 	/* Focus */
 	int focusEvent;
 	Control focusControl;
 	boolean fixFocus;
-	
+
 	/* Menus */
 	Menu [] bars, popups;
 	MenuItem [] items;
-	
+
 	/*
 	* The start value for WM_COMMAND id's.
 	* Windows reserves the values 0..100.
-	* 
+	*
 	* The SmartPhone SWT resource file reserves
 	* the values 101..107.
 	*/
 	static final int ID_START = 108;
-	
+
 	/* Filter Hook */
 	Callback msgFilterCallback;
 	int /*long*/ msgFilterProc, filterHook;
 	MSG hookMsg = new MSG ();
 	boolean runDragDrop = true, dragCancelled = false;
-	
+
 	/* Idle Hook */
 	Callback foregroundIdleCallback;
 	int /*long*/ foregroundIdleProc, idleHook;
-	
+
 	/* Message Hook and Embedding */
 	boolean ignoreNextKey;
 	Callback getMsgCallback, embeddedCallback;
@@ -211,7 +1627,7 @@
 
 	/* Display Shutdown */
 	Runnable [] disposeList;
-	
+
 	/* Deferred Layout list */
 	Composite[] layoutDeferred;
 	int layoutDeferredCount;
@@ -219,33 +1635,35 @@
 	/* System Tray */
 	Tray tray;
 	int nextTrayId;
-	
+
 	/* TaskBar */
 	TaskBar taskBar;
 	static final String TASKBAR_EVENT = "/SWTINTERNAL_ID"; //$NON-NLS-1$
 	static final String LAUNCHER_PREFIX = "--launcher.openFile "; //$NON-NLS-1$
-	
+
 	/* Timers */
 	int /*long*/ [] timerIds;
 	Runnable [] timerList;
 	int /*long*/ nextTimerId = SETTINGS_ID + 1;
-	
+
 	/* Settings */
 	static final int /*long*/ SETTINGS_ID = 100;
 	static final int SETTINGS_DELAY = 2000;
 	boolean lastHighContrast, sendSettings;
-	
+
 	/* Keyboard and Mouse */
 	RECT clickRect;
 	int clickCount, lastTime, lastButton;
 	int /*long*/ lastClickHwnd;
 	int scrollRemainder, scrollHRemainder;
-	int lastKey, lastMouse, lastAscii;
-	boolean lastVirtual, lastNull, lastDead;
+        // <QFS/> public - TODO provide get-functions instead
+	public int lastKey, lastMouse, lastAscii;
+        // <QFS/> public - TODO provide get-functions instead
+	public boolean lastVirtual, lastNull, lastDead;
 	byte [] keyboard = new byte [256];
 	boolean accelKeyHit, mnemonicKeyHit;
 	boolean lockActiveWindow, captureChanged, xMouse;
-	
+
 	/* Gesture state */
 	double magStartDistance, lastDistance;
 	double rotationAngle;
@@ -256,16 +1674,16 @@
 	
 	/* Tool Tips */
 	int nextToolTipId;
-	
+
 	/* MDI */
 	boolean ignoreRestoreFocus;
 	Control lastHittestControl;
 	int lastHittest;
-	
+
 	/* Message Only Window */
 	Callback messageCallback;
 	int /*long*/ hwndMessage, messageProc;
-	
+
 	/* System Resources */
 	LOGFONT lfSystemFont;
 	Font systemFont;
@@ -274,7 +1692,7 @@
 	Resource [] resources;
 	static final int RESOURCE_SIZE = 1 + 4 + SWT.CURSOR_HAND + 1;
 
-	/* ImageList Cache */	
+	/* ImageList Cache */
 	ImageList[] imageList, toolImageList, toolHotImageList, toolDisabledImageList;
 
 	/* Custom Colors for ChooseColor */
@@ -282,7 +1700,7 @@
 
 	/* Sort Indicators */
 	Image upArrow, downArrow;
-	
+
 	/* Table */
 	char [] tableBuffer;
 	NMHDR hdr = new NMHDR ();
@@ -290,19 +1708,19 @@
 	int /*long*/ hwndParent;
 	int columnCount;
 	boolean [] columnVisible;
-	
+
 	/* Resize and move recursion */
 	int resizeCount;
 	static final int RESIZE_LIMIT = 4;
-	
+
 	/* Display Data */
 	Object data;
 	String [] keys;
 	Object [] values;
-	
+
 	/* Key Mappings */
 	static final int [] [] KeyTable = {
-		
+
 		/* Keyboard and Mouse Masks */
 		{OS.VK_MENU,	SWT.ALT},
 		{OS.VK_SHIFT,	SWT.SHIFT},
@@ -309,11 +1727,11 @@
 		{OS.VK_CONTROL,	SWT.CONTROL},
 //		{OS.VK_????,	SWT.COMMAND},
 
-		/* NOT CURRENTLY USED */		
+		/* NOT CURRENTLY USED */
 //		{OS.VK_LBUTTON, SWT.BUTTON1},
 //		{OS.VK_MBUTTON, SWT.BUTTON3},
 //		{OS.VK_RBUTTON, SWT.BUTTON2},
-		
+
 		/* Non-Numeric Keypad Keys */
 		{OS.VK_UP,		SWT.ARROW_UP},
 		{OS.VK_DOWN,	SWT.ARROW_DOWN},
@@ -332,7 +1750,7 @@
 		{OS.VK_ESCAPE,	SWT.ESC},
 		{OS.VK_RETURN,	SWT.LF},
 		{OS.VK_TAB,		SWT.TAB},
-	
+
 		/* Functions Keys */
 		{OS.VK_F1,	SWT.F1},
 		{OS.VK_F2,	SWT.F2},
@@ -354,7 +1772,7 @@
 		{OS.VK_F18,	SWT.F18},
 		{OS.VK_F19,	SWT.F19},
 		{OS.VK_F20,	SWT.F20},
-		
+
 		/* Numeric Keypad Keys */
 		{OS.VK_MULTIPLY,	SWT.KEYPAD_MULTIPLY},
 		{OS.VK_ADD,			SWT.KEYPAD_ADD},
@@ -382,7 +1800,7 @@
 		{OS.VK_CANCEL,		SWT.BREAK},
 		{OS.VK_SNAPSHOT,	SWT.PRINT_SCREEN},
 //		{OS.VK_????,		SWT.HELP},
-		
+
 	};
 
 	/* Multiple Displays */
@@ -392,7 +1810,7 @@
 	/* Multiple Monitors */
 	Monitor[] monitors = null;
 	int monitorCount = 0;
-	
+
 	/* Modality */
 	Shell [] modalShells;
 	Dialog modalDialog;
@@ -411,14 +1829,14 @@
 	static int SWT_RESTORECARET;
 	static int DI_GETDRAGIMAGE;
 	static int SWT_OPENDOC;
-	
+
 	/* Workaround for Adobe Reader 7.0 */
 	int hitCount;
-	
+
 	/* Skinning support */
 	Widget [] skinList = new Widget [GROW_SIZE];
 	int skinCount;
-	
+
 	/* Package Name */
 	static final String PACKAGE_PREFIX = "org.eclipse.swt.widgets."; //$NON-NLS-1$
 	/*
@@ -448,7 +1866,7 @@
 				setDevice (device);
 			}
 		};
-	}	
+	}
 
 /*
 * TEMPORARY CODE.
@@ -456,12 +1874,12 @@
 static void setDevice (Device device) {
 	CurrentDevice = device;
 }
-	
+
 /**
  * Constructs a new instance of this class.
  * <p>
  * Note: The resulting display is marked as the <em>current</em>
- * display. If this is the first display which has been 
+ * display. If this is the first display which has been
  * constructed since the application started, it is also
  * marked as the <em>default</em> display.
  * </p>
@@ -482,11 +1900,14 @@
 
 /**
  * Constructs a new instance of this class using the parameter.
- * 
+ *
  * @param data the device data
  */
 public Display (DeviceData data) {
 	super (data);
+        // <QFS> Execute display creation hooks
+        runDisplayCreationHooks(this);
+        // </QFS>
 }
 
 Control _getFocusControl () {
@@ -562,7 +1983,7 @@
  * powerful and dangerous. They should generally be avoided for
  * performance, debugging and code maintenance reasons.
  * </p>
- * 
+ *
  * @param eventType the type of event to listen for
  * @param listener the listener which should be notified when the event occurs
  *
@@ -578,8 +1999,8 @@
  * @see SWT
  * @see #removeFilter
  * @see #removeListener
- * 
- * @since 3.0 
+ *
+ * @since 3.0
  */
 public void addFilter (int eventType, Listener listener) {
 	checkDevice ();
@@ -619,8 +2040,8 @@
  * @see Listener
  * @see SWT
  * @see #removeListener
- * 
- * @since 2.0 
+ *
+ * @since 2.0
  */
 public void addListener (int eventType, Listener listener) {
 	checkDevice ();
@@ -646,7 +2067,14 @@
 }
 
 void addPopup (Menu menu) {
-	if (popups == null) popups = new Menu [4];
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("addPopup(Menu)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("menu: ").add(menu)).log(Log.MTD);
+    }
+    // </QFS>
+    if (popups == null) popups = new Menu [4];
 	int length = popups.length;
 	for (int i=0; i<length; i++) {
 		if (popups [i] == menu) return;
@@ -664,13 +2092,14 @@
 	popups [index] = menu;
 }
 
-int asciiKey (int key) {
+// <QFS/> made public
+public int asciiKey (int key) {
 	if (OS.IsWinCE) return 0;
-	
+
 	/* Get the current keyboard. */
 	for (int i=0; i<keyboard.length; i++) keyboard [i] = 0;
 	if (!OS.GetKeyboardState (keyboard)) return 0;
-		
+
 	/* Translate the key to ASCII or UNICODE using the virtual keyboard */
 	if (OS.IsUnicode) {
 		char [] result = new char [1];
@@ -684,13 +2113,13 @@
 
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
- * reasonable opportunity. The caller of this method continues 
+ * be invoked by the user-interface thread at the next
+ * reasonable opportunity. The caller of this method continues
  * to run in parallel, and is not notified when the
  * runnable has completed.  Specifying <code>null</code> as the
  * runnable simply wakes the user-interface thread when run.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
@@ -701,13 +2130,14 @@
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see #syncExec
  */
 public void asyncExec (Runnable runnable) {
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		synchronizer.asyncExec (runnable);
+                if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+                // <QFS/> Redirected to internalAsyncExec.
+                synchronizer.internalAsyncExec (runnable);
 	}
 }
 
@@ -714,7 +2144,7 @@
 /**
  * Causes the system hardware to emit a short sound
  * (if it supports this capability).
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
@@ -755,10 +2185,10 @@
 		* error happens seems to fix the problem.  The
 		* fix is to use operating system calls to verify
 		* that the current thread is not the Display thread.
-		* 
+		*
 		* NOTE: Despite the fact that Thread.currentThread()
 		* is used in other places, the failure has not been
-		* observed in all places where it is called. 
+		* observed in all places where it is called.
 		*/
 		if (threadId != OS.GetCurrentThreadId ()) {
 			error (SWT.ERROR_THREAD_INVALID_ACCESS);
@@ -769,13 +2199,13 @@
 
 static void checkDisplay (Thread thread, boolean multiple) {
 	synchronized (Device.class) {
-		for (int i=0; i<Displays.length; i++) {
-			if (Displays [i] != null) {
+	for (int i=0; i<Displays.length; i++) {
+		if (Displays [i] != null) {
 				if (!multiple) SWT.error (SWT.ERROR_NOT_IMPLEMENTED, null, " [multiple displays]"); //$NON-NLS-1$
-				if (Displays [i].thread == thread) SWT.error (SWT.ERROR_THREAD_INVALID_ACCESS);
-			}
+			if (Displays [i].thread == thread) SWT.error (SWT.ERROR_THREAD_INVALID_ACCESS);
 		}
 	}
+	}
 }
 
 void clearModal (Shell shell) {
@@ -794,7 +2224,8 @@
 	for (int i=0; i<shells.length; i++) shells [i].updateModal ();
 }
 
-int controlKey (int key) {
+// <QFS/> made public
+public int controlKey (int key) {
 	int upper = (int)/*64*/OS.CharUpper ((short) key);
 	if (64 <= upper && upper <= 95) return upper & 0xBF;
 	return key;
@@ -810,7 +2241,7 @@
  * </ul>
  *
  * @see Device#dispose
- * 
+ *
  * @since 2.0
  */
 public void close () {
@@ -1161,10 +2592,10 @@
 
 static void deregister (Display display) {
 	synchronized (Device.class) {
-		for (int i=0; i<Displays.length; i++) {
-			if (display == Displays [i]) Displays [i] = null;
-		}
+	for (int i=0; i<Displays.length; i++) {
+		if (display == Displays [i]) Displays [i] = null;
 	}
+	}
 }
 
 /**
@@ -1193,7 +2624,7 @@
  * is ignored.
  *
  * @param runnable code to run at dispose time.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
@@ -1263,17 +2694,31 @@
 	return false;
 }
 
-boolean filters (int eventType) {
+// <QFS/> make public
+public boolean filters (int eventType) {
 	if (filterTable == null) return false;
 	return filterTable.hooks (eventType);
 }
 
 boolean filterMessage (MSG msg) {
-	int message = msg.message;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("filterMessage(MSG)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(OS.getWinMsgType(msg.message, null))).log(Log.MTD);
+    }
+    // </QFS>
+    int message = msg.message;
 	if (OS.WM_KEYFIRST <= message && message <= OS.WM_KEYLAST) {
 		Control control = findControl (msg.hwnd);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("filterMessage(MSG)")
+                        .add("control: ").add(control).log(Log.DBG);
+                }
+                // </QFS>
 		if (control != null) {
-			if (translateAccelerator (msg, control) || translateMnemonic (msg, control) || translateTraversal (msg, control)) {	
+			if (translateAccelerator (msg, control) || translateMnemonic (msg, control) || translateTraversal (msg, control)) {
 				lastAscii = lastKey = 0;
 				lastVirtual = lastNull = lastDead = false;
 				return true;
@@ -1312,7 +2757,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public Widget findWidget (int /*long*/ handle) {
@@ -1339,9 +2784,9 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
- * 
+ *
  * @since 3.1
  */
 public Widget findWidget (int /*long*/ handle, int /*long*/ id) {
@@ -1365,7 +2810,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.3
  */
 public Widget findWidget (Widget widget, int /*long*/ id) {
@@ -1378,21 +2823,21 @@
 }
 
 int /*long*/ foregroundIdleProc (int /*long*/ code, int /*long*/ wParam, int /*long*/ lParam) {
-	if (code >= 0) {
+		if (code >= 0) {
 		if (runMessages && getMessageCount () != 0) {
-			if (runMessagesInIdle) {
+				if (runMessagesInIdle) {
 				if (runMessagesInMessageProc) {
 					OS.PostMessage (hwndMessage, SWT_RUNASYNC, 0, 0);
 				} else {
 					runAsyncMessages (false);
 				}
-			}
+				}
 			/*
 			* Bug in Windows.  For some reason, input events can be lost
 			* when a message is posted to the queue from a foreground idle
 			* hook.  The fix is to detect that there are outstanding input
 			* events and avoid posting the wake event.
-			* 
+			*
 			* Note that PeekMessage() changes the state of events on the
 			* queue to no longer be considered new. If we peek for input
 			* events and posted messages (PM_QS_INPUT | PM_QS_POSTMESSAGE),
@@ -1403,8 +2848,8 @@
 			MSG msg = new MSG();
 			int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT;
 			if (!OS.PeekMessage (msg, 0, 0, 0, flags)) wakeThread ();
+			}
 		}
-	}
 	return OS.CallNextHookEx (idleHook, (int)/*64*/code, wParam, lParam);
 }
 
@@ -1413,7 +2858,7 @@
  * user-interface thread for, or null if the given thread
  * is not a user-interface thread for any display.  Specifying
  * <code>null</code> as the thread will return <code>null</code>
- * for the display. 
+ * for the display.
  *
  * @param thread the user-interface thread
  * @return the display for the given thread
@@ -1420,14 +2865,14 @@
  */
 public static Display findDisplay (Thread thread) {
 	synchronized (Device.class) {
-		for (int i=0; i<Displays.length; i++) {
-			Display display = Displays [i];
-			if (display != null && display.thread == thread) {
-				return display;
-			}
+	for (int i=0; i<Displays.length; i++) {
+		Display display = Displays [i];
+		if (display != null && display.thread == thread) {
+			return display;
 		}
-		return null;
 	}
+	return null;
+	}
 }
 
 TouchSource findTouchSource (int /*long*/ touchDevice, Monitor monitor) {
@@ -1505,7 +2950,7 @@
 		return new Rectangle (0, 0, width, height);
 	}
 	int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 	int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 	int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 	return new Rectangle (x, y, width, height);
@@ -1554,7 +2999,7 @@
 /**
  * Returns a rectangle which describes the area of the
  * receiver which is capable of displaying data.
- * 
+ *
  * @return the client area
  *
  * @exception SWTException <ul>
@@ -1574,13 +3019,14 @@
 		return new Rectangle (rect.left, rect.top, width, height);
 	}
 	int x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
+	int y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
 	int width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
 	int height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
 	return new Rectangle (x, y, width, height);
 }
 
-Control getControl (int /*long*/ handle) {
+// <QFS/> made public
+public Control getControl (int /*long*/ handle) {
 	if (handle == 0) return null;
 	if (lastControl != null && lastHwnd == handle) {
 		return lastControl;
@@ -1628,7 +3074,8 @@
 public Control getCursorControl () {
 	checkDevice ();
 	POINT pt = new POINT ();
-	if (!OS.GetCursorPos (pt)) return null;
+        // <QFS/> Get overridden cursor position
+	if (!OS._GetCursorPos (pt)) return null;
 	return findControl (OS.WindowFromPoint (pt));
 }
 
@@ -1644,10 +3091,17 @@
  * </ul>
  */
 public Point getCursorLocation () {
-	checkDevice ();
-	POINT pt = new POINT ();
-	OS.GetCursorPos (pt);
-	return new Point (pt.x, pt.y);
+        checkDevice ();
+        POINT pt = new POINT ();
+        // <QFS/> Get overridden cursor position
+        OS._GetCursorPos (pt);
+        // <QFS> Log result
+        Point ret = new Point (pt.x, pt.y);
+        if (logger.level >= Log.DBG) {
+            logger.build("getCursorLocation()").add("ret: ").add(ret).log(Log.DBG);
+        }
+        return ret;
+        // </QFS>
 }
 
 /**
@@ -1659,7 +3113,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public Point [] getCursorSizes () {
@@ -1677,8 +3131,8 @@
  */
 public static Display getDefault () {
 	synchronized (Device.class) {
-		if (Default == null) Default = new Display ();
-		return Default;
+	if (Default == null) Default = new Display ();
+	return Default;
 	}
 }
 
@@ -1739,7 +3193,7 @@
  * Returns the application defined, display specific data
  * associated with the receiver, or null if it has not been
  * set. The <em>display specific data</em> is a single,
- * unnamed field that is stored with every display. 
+ * unnamed field that is stored with every display.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the display specific data needs to
@@ -1777,7 +3231,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public int getDismissalAlignment () {
@@ -1855,7 +3309,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public boolean getHighContrast () {
@@ -1877,7 +3331,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Device#getDepth
  */
 public int getIconDepth () {
@@ -1894,7 +3348,7 @@
 	if (result != 0) return 4;
 	int depth = 4;
 	int [] lpcbData = new int [1];
-	
+
 	/* Use the character encoding for the default locale */
 	TCHAR buffer2 = new TCHAR (0, "Shell Icon BPP", true); //$NON-NLS-1$
 	result = OS.RegQueryValueEx (phkResult [0], buffer2, 0, null, (TCHAR) null, lpcbData);
@@ -1920,9 +3374,9 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Decorations#setImages(Image[])
- * 
+ *
  * @since 3.0
  */
 public Point [] getIconSizes () {
@@ -1930,14 +3384,14 @@
 	return new Point [] {
 		new Point (OS.GetSystemMetrics (OS.SM_CXSMICON), OS.GetSystemMetrics (OS.SM_CYSMICON)),
 		new Point (OS.GetSystemMetrics (OS.SM_CXICON), OS.GetSystemMetrics (OS.SM_CYICON)),
-	};	
+	};
 }
 
 ImageList getImageList (int style, int width, int height) {
 	if (imageList == null) imageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = imageList.length; 
+	int length = imageList.length;
 	while (i < length) {
 		ImageList list = imageList [i];
 		if (list == null) break;
@@ -1950,13 +3404,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (imageList, 0, newList, 0, length);
 		imageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	imageList [i] = list;
 	list.addRef();
@@ -1965,9 +3419,9 @@
 
 ImageList getImageListToolBar (int style, int width, int height) {
 	if (toolImageList == null) toolImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolImageList.length; 
+	int length = toolImageList.length;
 	while (i < length) {
 		ImageList list = toolImageList [i];
 		if (list == null) break;
@@ -1980,13 +3434,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolImageList, 0, newList, 0, length);
 		toolImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolImageList [i] = list;
 	list.addRef();
@@ -1995,9 +3449,9 @@
 
 ImageList getImageListToolBarDisabled (int style, int width, int height) {
 	if (toolDisabledImageList == null) toolDisabledImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolDisabledImageList.length; 
+	int length = toolDisabledImageList.length;
 	while (i < length) {
 		ImageList list = toolDisabledImageList [i];
 		if (list == null) break;
@@ -2010,13 +3464,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolDisabledImageList, 0, newList, 0, length);
 		toolDisabledImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolDisabledImageList [i] = list;
 	list.addRef();
@@ -2025,9 +3479,9 @@
 
 ImageList getImageListToolBarHot (int style, int width, int height) {
 	if (toolHotImageList == null) toolHotImageList = new ImageList [4];
-	
+
 	int i = 0;
-	int length = toolHotImageList.length; 
+	int length = toolHotImageList.length;
 	while (i < length) {
 		ImageList list = toolHotImageList [i];
 		if (list == null) break;
@@ -2040,13 +3494,13 @@
 		}
 		i++;
 	}
-	
+
 	if (i == length) {
 		ImageList [] newList = new ImageList [length + 4];
 		System.arraycopy (toolHotImageList, 0, newList, 0, length);
 		toolHotImageList = newList;
 	}
-	
+
 	ImageList list = new ImageList (style, width, height);
 	toolHotImageList [i] = list;
 	list.addRef();
@@ -2053,7 +3507,8 @@
 	return list;
 }
 
-int getLastEventTime () {
+// <QFS/> made public
+public int getLastEventTime () {
 	return OS.IsWinCE ? OS.GetTickCount () : OS.GetMessageTime ();
 }
 
@@ -2085,9 +3540,9 @@
 
 /**
  * Returns an array of monitors attached to the device.
- * 
+ *
  * @return the array of monitors
- * 
+ *
  * @since 3.0
  */
 public Monitor [] getMonitors () {
@@ -2160,9 +3615,9 @@
 
 /**
  * Returns the primary monitor for that device.
- * 
+ *
  * @return the primary monitor
- * 
+ *
  * @since 3.0
  */
 public Monitor getPrimaryMonitor () {
@@ -2196,11 +3651,11 @@
 		if ((lpmi.dwFlags & OS.MONITORINFOF_PRIMARY) != 0) {
 			result = monitor;
 			break;
-		} 			
+		}
 	}
 	monitors = null;
 	monitorCount = 0;
-	return result;		
+	return result;
 }
 
 /**
@@ -2232,7 +3687,7 @@
 					System.arraycopy (result, 0, newResult, 0, index);
 					result = newResult;
 				}
-				result [index++] = (Shell) control;	
+				result [index++] = (Shell) control;
 			}
 		}
 	}
@@ -2294,12 +3749,12 @@
  * Gets the synchronizer used by the display.
  *
  * @return the receiver's synchronizer
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public Synchronizer getSynchronizer () {
@@ -2317,7 +3772,7 @@
  * </p>
  *
  * @return the receiver's sync-interface thread
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2324,8 +3779,8 @@
  */
 public Thread getSyncThread () {
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		return synchronizer.syncThread;
+	if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+	return synchronizer.syncThread;
 	}
 }
 
@@ -2367,13 +3822,13 @@
 		case SWT.COLOR_INFO_BACKGROUND:		pixel = OS.GetSysColor (OS.COLOR_INFOBK);		break;
 		case SWT.COLOR_TITLE_FOREGROUND: 		pixel = OS.GetSysColor (OS.COLOR_CAPTIONTEXT);	break;
 		case SWT.COLOR_TITLE_BACKGROUND:		pixel = OS.GetSysColor (OS.COLOR_ACTIVECAPTION);		break;
-		case SWT.COLOR_TITLE_BACKGROUND_GRADIENT: 
+		case SWT.COLOR_TITLE_BACKGROUND_GRADIENT:
 			pixel = OS.GetSysColor (OS.COLOR_GRADIENTACTIVECAPTION);
 			if (pixel == 0) pixel = OS.GetSysColor (OS.COLOR_ACTIVECAPTION);
 			break;
 		case SWT.COLOR_TITLE_INACTIVE_FOREGROUND: 		pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTIONTEXT);	break;
 		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND:			pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTION);		break;
-		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT:	
+		case SWT.COLOR_TITLE_INACTIVE_BACKGROUND_GRADIENT:
 			pixel = OS.GetSysColor (OS.COLOR_GRADIENTINACTIVECAPTION);
 			if (pixel == 0) pixel = OS.GetSysColor (OS.COLOR_INACTIVECAPTION);
 			break;
@@ -2390,7 +3845,7 @@
  * not be free'd because it was allocated by the system,
  * not the application.  A value of <code>null</code> will
  * be returned if the supplied constant is not an SWT cursor
- * constant. 
+ * constant.
  *
  * @param id the SWT cursor constant
  * @return the corresponding cursor or <code>null</code>
@@ -2422,7 +3877,7 @@
  * @see SWT#CURSOR_IBEAM
  * @see SWT#CURSOR_NO
  * @see SWT#CURSOR_HAND
- * 
+ *
  * @since 3.0
  */
 public Cursor getSystemCursor (int id) {
@@ -2481,7 +3936,7 @@
  * not the application.  A value of <code>null</code> will
  * be returned either if the supplied constant is not an
  * SWT icon constant or if the platform does not define an
- * image that corresponds to the constant. 
+ * image that corresponds to the constant.
  *
  * @param id the SWT icon constant
  * @return the corresponding image or <code>null</code>
@@ -2496,7 +3951,7 @@
  * @see SWT#ICON_QUESTION
  * @see SWT#ICON_WARNING
  * @see SWT#ICON_WORKING
- * 
+ *
  * @since 3.0
  */
 public Image getSystemImage (int id) {
@@ -2550,7 +4005,7 @@
  * when there is no system taskBar available for the platform.
  *
  * @return the system taskBar or <code>null</code>
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2571,7 +4026,7 @@
  * when there is no system tray available for the platform.
  *
  * @return the system tray or <code>null</code>
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2589,7 +4044,7 @@
  * Returns the user-interface thread for the receiver.
  *
  * @return the receiver's user-interface thread
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2596,8 +4051,8 @@
  */
 public Thread getThread () {
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		return thread;
+	if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+	return thread;
 	}
 }
 
@@ -2645,7 +4100,7 @@
 	return hTabTheme = OS.OpenThemeData (hwndMessage, TAB);
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to allocate a new GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -2655,9 +4110,9 @@
  * application code.
  * </p>
  *
- * @param data the platform specific GC data 
+ * @param data the platform specific GC data
  * @return the platform specific GC handle
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
@@ -2664,7 +4119,7 @@
  * @exception SWTError <ul>
  *    <li>ERROR_NO_HANDLES if a handle could not be obtained for gc creation</li>
  * </ul>
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public int /*long*/ internal_new_GC (GCData data) {
@@ -2690,12 +4145,12 @@
  * <p>
  * This method is called after <code>create</code>.
  * </p>
- * 
+ *
  * @see #create
  */
 protected void init () {
 	super.init ();
-	
+
 	/* Set the application user model ID */
 	char [] appName = null;
 	if (APP_NAME != null) {
@@ -2705,26 +4160,26 @@
 			APP_NAME.getChars (0, length, appName, 0);
 			int /*long*/ [] appID = new int /*long*/ [1];
 			if (OS.GetCurrentProcessExplicitAppUserModelID(appID) != 0) {
-				OS.SetCurrentProcessExplicitAppUserModelID (appName);
-			}
+			OS.SetCurrentProcessExplicitAppUserModelID (appName);
+		}
 			if (appID[0] != 0) OS.CoTaskMemFree(appID[0]);
 		}
 	}
-	
+
 	/* Create the callbacks */
 	windowCallback = new Callback (this, "windowProc", 4); //$NON-NLS-1$
 	windowProc = windowCallback.getAddress ();
 	if (windowProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
-	
+
 	/* Remember the current thread id */
 	threadId = OS.GetCurrentThreadId ();
-	
+
 	/* Use the character encoding for the default locale */
 	windowClass = new TCHAR (0, WindowName + WindowClassCount, true);
 	windowShadowClass = new TCHAR (0, WindowShadowName + WindowClassCount, true);
 	windowOwnDCClass = new TCHAR (0, WindowOwnDCName + WindowClassCount, true);
 	WindowClassCount++;
-	
+
 	/* Register the SWT window class */
 	int /*long*/ hHeap = OS.GetProcessHeap ();
 	int /*long*/ hInstance = OS.GetModuleHandle (null);
@@ -2766,7 +4221,7 @@
 	OS.MoveMemory (lpWndClass.lpszClassName, windowShadowClass, byteCount);
 	OS.RegisterClass (lpWndClass);
 	OS.HeapFree (hHeap, 0, lpWndClass.lpszClassName);
-	
+
 	/* Register the CS_OWNDC window class */
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (5, 1)) {
 		lpWndClass.style |= OS.CS_OWNDC;
@@ -2776,7 +4231,7 @@
 	OS.MoveMemory (lpWndClass.lpszClassName, windowOwnDCClass, byteCount);
 	OS.RegisterClass (lpWndClass);
 	OS.HeapFree (hHeap, 0, lpWndClass.lpszClassName);
-	
+
 	/* Create the message only HWND */
 	hwndMessage = OS.CreateWindowEx (0,
 		windowClass,
@@ -2801,7 +4256,7 @@
 		if (msgFilterProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
 		filterHook = OS.SetWindowsHookEx (OS.WH_MSGFILTER, msgFilterProc, 0, threadId);
 	}
-	
+
 	/* Create the idle hook */
 	if (!OS.IsWinCE) {
 		foregroundIdleCallback = new Callback (this, "foregroundIdleProc", 3); //$NON-NLS-1$
@@ -2809,7 +4264,7 @@
 		if (foregroundIdleProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
 		idleHook = OS.SetWindowsHookEx (OS.WH_FOREGROUNDIDLE, foregroundIdleProc, 0, threadId);
 	}
-	
+
 	/* Register window messages */
 	TASKBARCREATED = OS.RegisterWindowMessage (new TCHAR (0, "TaskbarCreated", true)); //$NON-NLS-1$
 	TASKBARBUTTONCREATED = OS.RegisterWindowMessage (new TCHAR (0, "TaskbarButtonCreated", true)); //$NON-NLS-1$
@@ -2819,7 +4274,7 @@
 
 	/* Initialize OLE */
 	if (!OS.IsWinCE) OS.OleInitialize (0);
-	
+
 	if (appName != null) {
 		/* Delete any old jump list set for the ID */
 		int /*long*/ [] ppv = new int /*long*/ [1];
@@ -2836,18 +4291,18 @@
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)){
 		OS.BufferedPaintInit ();
 	}
-	
+
 	/* Initialize the Widget Table */
 	indexTable = new int [GROW_SIZE];
 	controlTable = new Control [GROW_SIZE];
 	for (int i=0; i<GROW_SIZE-1; i++) indexTable [i] = i + 1;
 	indexTable [GROW_SIZE - 1] = -1;
-	
+
 	/* Remember the last high contrast state */
 	lastHighContrast = getHighContrast ();
 }
 
-/**	 
+/**
  * Invokes platform specific functionality to dispose a GC handle.
  * <p>
  * <b>IMPORTANT:</b> This method is <em>not</em> part of the public
@@ -2858,8 +4313,8 @@
  * </p>
  *
  * @param hDC the platform specific GC handle
- * @param data the platform specific GC data 
- * 
+ * @param data the platform specific GC data
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 public void internal_dispose_GC (int /*long*/ hDC, GCData data) {
@@ -2897,7 +4352,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2907,26 +4362,26 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
- * @param point to be mapped 
- * @return point with mapped coordinates 
- * 
+ * @param point to be mapped
+ * @return point with mapped coordinates
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the point is null</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Point map (Control from, Control to, Point point) {
 	checkDevice ();
-	if (point == null) error (SWT.ERROR_NULL_ARGUMENT);	
+	if (point == null) error (SWT.ERROR_NULL_ARGUMENT);
 	return map (from, to, point.x, point.y);
 }
 
@@ -2939,7 +4394,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2949,21 +4404,21 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param x coordinates to be mapped
  * @param y coordinates to be mapped
  * @return point with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Point map (Control from, Control to, int x, int y) {
@@ -2989,7 +4444,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -2999,26 +4454,26 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param rectangle to be mapped
  * @return rectangle with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the rectangle is null</li>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Rectangle map (Control from, Control to, Rectangle rectangle) {
 	checkDevice ();
-	if (rectangle == null) error (SWT.ERROR_NULL_ARGUMENT);	
+	if (rectangle == null) error (SWT.ERROR_NULL_ARGUMENT);
 	return map (from, to, rectangle.x, rectangle.y, rectangle.width, rectangle.height);
 }
 
@@ -3031,7 +4486,7 @@
  * systems are mirrored, special care needs to be taken
  * when mapping coordinates from one control to another
  * to ensure the result is correctly mirrored.
- * 
+ *
  * Mapping a point that is the origin of a rectangle and
  * then adding the width and height is not equivalent to
  * mapping the rectangle.  When one control is mirrored
@@ -3041,7 +4496,7 @@
  * instead of just one point causes both the origin and
  * the corner of the rectangle to be mapped.
  * </p>
- * 
+ *
  * @param from the source <code>Control</code> or <code>null</code>
  * @param to the destination <code>Control</code> or <code>null</code>
  * @param x coordinates to be mapped
@@ -3049,15 +4504,15 @@
  * @param width coordinates to be mapped
  * @param height coordinates to be mapped
  * @return rectangle with mapped coordinates
- * 
+ *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the Control from or the Control to have been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1.2
  */
 public Rectangle map (Control from, Control to, int x, int y, int width, int height) {
@@ -3064,7 +4519,7 @@
 	checkDevice ();
 	if (from != null && from.isDisposed()) error (SWT.ERROR_INVALID_ARGUMENT);
 	if (to != null && to.isDisposed()) error (SWT.ERROR_INVALID_ARGUMENT);
-	if (from == to) return new Rectangle (x, y, width, height); 
+	if (from == to) return new Rectangle (x, y, width, height);
 	int /*long*/ hwndFrom = from != null ? from.handle : 0;
 	int /*long*/ hwndTo = to != null ? to.handle : 0;
 	RECT rect = new RECT ();
@@ -3084,7 +4539,8 @@
  * @param ch the MBCS character
  * @return the WCS character
  */
-static char mbcsToWcs (int ch) {
+// <QFS/> made public
+public static char mbcsToWcs (int ch) {
 	return mbcsToWcs (ch, 0);
 }
 
@@ -3118,6 +4574,16 @@
 }
 
 int /*long*/ messageProc (int /*long*/ hwnd, int /*long*/ msg, int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("messageProc(int,int,int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").addHex(hwnd)
+         .add(", msg: ").add(OS.getWinMsgType(msg, null))
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
 	switch ((int)/*64*/msg) {
 		case SWT_RUNASYNC: {
 			if (runMessagesInIdle) runAsyncMessages (false);
@@ -3128,6 +4594,12 @@
 			MSG keyMsg = new MSG ();
 			OS.MoveMemory (keyMsg, lParam, MSG.sizeof);
 			Control control = findControl (keyMsg.hwnd);
+                        // <QFS>
+                        if (logger.level >= Log.DBG) {
+                            logger.build("messageProc(int,int,int,int)")
+                                .add("control: ").add(control).log(Log.DBG);
+                        }
+                        // </QFS>
 			if (control != null) {
 				/*
 				* Feature in Windows.  When the user types an accent key such
@@ -3152,7 +4624,7 @@
 								case OS.VK_SCROLL:
 									break;
 								default: {
-									/* 
+									/*
 									* Bug in Windows. The high bit in the result of MapVirtualKey() on
 									* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
 									* They should both be bit 32.  The fix is to test the right bit.
@@ -3165,9 +4637,10 @@
 												int value = OS.VkKeyScan (ACCENTS [i]);
 												if (value != -1 && (value & 0xFF) == keyMsg.wParam) {
 													int state = value >> 8;
-													if ((OS.GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
-														(OS.GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
-														(OS.GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
+                                                                                                        // <QFS/> changed to GetKeyState
+													if ((GetKeyState (OS.VK_SHIFT) < 0) == ((state & 0x1) != 0) &&
+														(GetKeyState (OS.VK_CONTROL) < 0) == ((state & 0x2) != 0) &&
+														(GetKeyState (OS.VK_MENU) < 0) == ((state & 0x4) != 0)) {
 															if ((state & 0x7) != 0) accentKey = true;
 															break;
 													}
@@ -3188,7 +4661,7 @@
 					do {
 						if (!(consumed |= filterMessage (keyMsg))) {
 							OS.TranslateMessage (keyMsg);
-							consumed |= OS.DispatchMessage (keyMsg) == 1;	
+							consumed |= OS.DispatchMessage (keyMsg) == 1;
 						}
 					} while (OS.PeekMessage (keyMsg, keyMsg.hwnd, OS.WM_KEYFIRST, OS.WM_KEYLAST, flags));
 				}
@@ -3256,7 +4729,7 @@
 			* the mouse.  The fix is to look for WM_ACTIVATEAPP
 			* and force the enabled dialog child to the front.
 			* This is typically what the user is expecting.
-			* 
+			*
 			* NOTE: If the modal shell is disabled for any
 			* reason, it should not be brought to the front.
 			*/
@@ -3322,7 +4795,7 @@
 			}
 			if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 				sendSettings = true;
-			} 
+			}
 			switch ((int)/*64*/wParam) {
 				case 0:
 				case 1:
@@ -3333,7 +4806,7 @@
 			}
 			/* Set the initial timer or push the time out period forward */
 			if (sendSettings) {
-				OS.SetTimer (hwndMessage, SETTINGS_ID, SETTINGS_DELAY, 0);
+					OS.SetTimer (hwndMessage, SETTINGS_ID, SETTINGS_DELAY, 0);
 			}
 			break;
 		}
@@ -3379,8 +4852,8 @@
 							item.sendSelectionEvent (SWT.Selection);
 						}
 					} else {
-						Event event = new Event();
-						event.text = filename;
+					Event event = new Event();
+					event.text = filename;
 						sendEvent(SWT.OpenDocument, event);
 					}
 					wakeThread ();
@@ -3402,7 +4875,7 @@
 		OS.DuplicateHandle(processHandle, handle, OS.GetCurrentProcess(), mapHandle, OS.DUPLICATE_SAME_ACCESS, false, OS.DUPLICATE_SAME_ACCESS);
 		OS.CloseHandle(processHandle);
 	}
-	
+
 	int /*long*/ sharedData = OS.MapViewOfFile(mapHandle[0], OS.FILE_MAP_READ, 0, 0, 0);
 	if (sharedData == 0) return null;
 	int length = OS.IsUnicode ? OS.wcslen (sharedData) : OS.strlen (sharedData);
@@ -3469,6 +4942,14 @@
 		case OS.MSGF_SIZE: {
 			if (runMessages) {
 				OS.MoveMemory (hookMsg, lParam, MSG.sizeof);
+                                // <QFS>
+                                boolean filterit = filterMessage (hookMsg); // SWT/Display
+                                logMessage("msgFilterProc(int,int,int)",
+                                           hookMsg.hwnd, hookMsg.message, hookMsg.wParam,
+                                           hookMsg.lParam,
+                                           (filterit ? "would be filtered by SWT/Display: " : ""),
+                                           logger, -1);
+                                // </QFS>
 				if (hookMsg.message == OS.WM_NULL) {
 					MSG msg = new MSG ();
 					int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;
@@ -3483,7 +4964,8 @@
 	return OS.CallNextHookEx (filterHook, (int)/*64*/code, wParam, lParam);
 }
 
-int numpadKey (int key) {
+// <QFS/> made public
+public int numpadKey (int key) {
 	switch (key) {
 		case OS.VK_NUMPAD0:	return '0';
 		case OS.VK_NUMPAD1:	return '1';
@@ -3507,7 +4989,7 @@
 
 /**
  * Generate a low level system event.
- * 
+ *
  * <code>post</code> is used to generate low level keyboard
  * and mouse events. The intent is to enable automated UI
  * testing by simulating the input from the user.  Most
@@ -3550,11 +5032,11 @@
  * <li>(in) count the number of lines or pages to scroll
  * </ul>
  * </dl>
- * 
+ *
  * @param event the event to be generated
- * 
+ *
  * @return true if the event was generated or false otherwise
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the event is null</li>
  * </ul>
@@ -3563,44 +5045,44 @@
  * </ul>
  *
  * @since 3.0
- * 
+ *
  */
 public boolean post (Event event) {
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		if (event == null) error (SWT.ERROR_NULL_ARGUMENT);
-		int type = event.type;
-		switch (type){
-			case SWT.KeyDown:
-			case SWT.KeyUp: {
-				KEYBDINPUT inputs = new KEYBDINPUT ();
-				inputs.wVk = (short) untranslateKey (event.keyCode);
-				if (inputs.wVk == 0) {
-					char key = event.character;
-					switch (key) {
-						case SWT.BS: inputs.wVk = (short) OS.VK_BACK; break;
-						case SWT.CR: inputs.wVk = (short) OS.VK_RETURN; break;
-						case SWT.DEL: inputs.wVk = (short) OS.VK_DELETE; break;
-						case SWT.ESC: inputs.wVk = (short) OS.VK_ESCAPE; break;
-						case SWT.TAB: inputs.wVk = (short) OS.VK_TAB; break;
-						/*
-						* Since there is no LF key on the keyboard, do not attempt
-						* to map LF to CR or attempt to post an LF key.
-						*/
-//						case SWT.LF: inputs.wVk = (short) OS.VK_RETURN; break;
-						case SWT.LF: return false;
-						default: {
-							if (OS.IsWinCE) {
+	if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+	if (event == null) error (SWT.ERROR_NULL_ARGUMENT);
+	int type = event.type;
+	switch (type){
+		case SWT.KeyDown:
+		case SWT.KeyUp: {
+			KEYBDINPUT inputs = new KEYBDINPUT ();
+			inputs.wVk = (short) untranslateKey (event.keyCode);
+			if (inputs.wVk == 0) {
+				char key = event.character;
+				switch (key) {
+					case SWT.BS: inputs.wVk = (short) OS.VK_BACK; break;
+					case SWT.CR: inputs.wVk = (short) OS.VK_RETURN; break;
+					case SWT.DEL: inputs.wVk = (short) OS.VK_DELETE; break;
+					case SWT.ESC: inputs.wVk = (short) OS.VK_ESCAPE; break;
+					case SWT.TAB: inputs.wVk = (short) OS.VK_TAB; break;
+					/*
+					* Since there is no LF key on the keyboard, do not attempt
+					* to map LF to CR or attempt to post an LF key.
+					*/
+//					case SWT.LF: inputs.wVk = (short) OS.VK_RETURN; break;
+					case SWT.LF: return false;
+					default: {
+						if (OS.IsWinCE) {
 								inputs.wVk = (short)/*64*/OS.CharUpper ((short) key);
-							} else {
-								inputs.wVk = OS.VkKeyScan ((short) wcsToMbcs (key, 0));
-								if (inputs.wVk == -1) return false;
-								inputs.wVk &= 0xFF;
-							}
+						} else {
+							inputs.wVk = OS.VkKeyScan ((short) wcsToMbcs (key, 0));
+							if (inputs.wVk == -1) return false;
+							inputs.wVk &= 0xFF;
 						}
 					}
 				}
-				inputs.dwFlags = type == SWT.KeyUp ? OS.KEYEVENTF_KEYUP : 0;
+			}
+			inputs.dwFlags = type == SWT.KeyUp ? OS.KEYEVENTF_KEYUP : 0;
 				switch (inputs.wVk) {
 					case OS.VK_INSERT:
 					case OS.VK_DELETE:
@@ -3620,81 +5102,81 @@
 				}
 				int /*long*/ hHeap = OS.GetProcessHeap ();
 				int /*long*/ pInputs = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, INPUT.sizeof);
-				OS.MoveMemory(pInputs, new int[] {OS.INPUT_KEYBOARD}, 4);
+			OS.MoveMemory(pInputs, new int[] {OS.INPUT_KEYBOARD}, 4);
 				//TODO - DWORD type of INPUT structure aligned to 8 bytes on 64 bit
 				OS.MoveMemory (pInputs + OS.PTR_SIZEOF, inputs, KEYBDINPUT.sizeof);
-				boolean result = OS.SendInput (1, pInputs, INPUT.sizeof) != 0;
-				OS.HeapFree (hHeap, 0, pInputs);
-				return result;
-			}
-			case SWT.MouseDown:
-			case SWT.MouseMove:
-			case SWT.MouseUp:
-			case SWT.MouseWheel: {
-				MOUSEINPUT inputs = new MOUSEINPUT ();
-				if (type == SWT.MouseMove){
-					inputs.dwFlags = OS.MOUSEEVENTF_MOVE | OS.MOUSEEVENTF_ABSOLUTE;
-					int x= 0, y = 0, width = 0, height = 0;
-					if (OS.WIN32_VERSION >= OS.VERSION (5, 0)) {
-						inputs.dwFlags |= OS.MOUSEEVENTF_VIRTUALDESK;
-						x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
-						y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);	
-						width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
-						height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
-					} else {
-						width = OS.GetSystemMetrics (OS.SM_CXSCREEN);
-						height = OS.GetSystemMetrics (OS.SM_CYSCREEN);
+			boolean result = OS.SendInput (1, pInputs, INPUT.sizeof) != 0;
+			OS.HeapFree (hHeap, 0, pInputs);
+			return result;
+		}
+		case SWT.MouseDown:
+		case SWT.MouseMove:
+		case SWT.MouseUp:
+		case SWT.MouseWheel: {
+			MOUSEINPUT inputs = new MOUSEINPUT ();
+			if (type == SWT.MouseMove){
+				inputs.dwFlags = OS.MOUSEEVENTF_MOVE | OS.MOUSEEVENTF_ABSOLUTE;
+				int x= 0, y = 0, width = 0, height = 0;
+				if (OS.WIN32_VERSION >= OS.VERSION (5, 0)) {
+					inputs.dwFlags |= OS.MOUSEEVENTF_VIRTUALDESK;
+					x = OS.GetSystemMetrics (OS.SM_XVIRTUALSCREEN);
+					y = OS.GetSystemMetrics (OS.SM_YVIRTUALSCREEN);
+					width = OS.GetSystemMetrics (OS.SM_CXVIRTUALSCREEN);
+					height = OS.GetSystemMetrics (OS.SM_CYVIRTUALSCREEN);
+				} else {
+					width = OS.GetSystemMetrics (OS.SM_CXSCREEN);
+					height = OS.GetSystemMetrics (OS.SM_CYSCREEN);
+				}
+				inputs.dx = ((event.x - x) * 65535 + width - 2) / (width - 1);
+				inputs.dy = ((event.y - y) * 65535 + height - 2) / (height - 1);
+			} else {
+				if (type == SWT.MouseWheel) {
+					if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
+					inputs.dwFlags = OS.MOUSEEVENTF_WHEEL;
+					switch (event.detail) {
+						case SWT.SCROLL_PAGE:
+							inputs.mouseData = event.count * OS.WHEEL_DELTA;
+							break;
+						case SWT.SCROLL_LINE:
+							int [] value = new int [1];
+							OS.SystemParametersInfo (OS.SPI_GETWHEELSCROLLLINES, 0, value, 0);
+							inputs.mouseData = event.count * OS.WHEEL_DELTA / value [0];
+							break;
+						default: return false;
 					}
-					inputs.dx = ((event.x - x) * 65535 + width - 2) / (width - 1);
-					inputs.dy = ((event.y - y) * 65535 + height - 2) / (height - 1);
 				} else {
-					if (type == SWT.MouseWheel) {
-						if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
-						inputs.dwFlags = OS.MOUSEEVENTF_WHEEL;
-						switch (event.detail) {
-							case SWT.SCROLL_PAGE:
-								inputs.mouseData = event.count * OS.WHEEL_DELTA;
-								break;
-							case SWT.SCROLL_LINE:
-								int [] value = new int [1];
-								OS.SystemParametersInfo (OS.SPI_GETWHEELSCROLLLINES, 0, value, 0);
-								inputs.mouseData = event.count * OS.WHEEL_DELTA / value [0];
-								break;
-							default: return false;
+					switch (event.button) {
+						case 1: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_LEFTDOWN : OS.MOUSEEVENTF_LEFTUP; break;
+						case 2: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_MIDDLEDOWN : OS.MOUSEEVENTF_MIDDLEUP; break;
+						case 3: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_RIGHTDOWN : OS.MOUSEEVENTF_RIGHTUP; break;
+						case 4: {
+							if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
+							inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_XDOWN : OS.MOUSEEVENTF_XUP;
+							inputs.mouseData = OS.XBUTTON1;
+							break;
 						}
-					} else {
-						switch (event.button) {
-							case 1: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_LEFTDOWN : OS.MOUSEEVENTF_LEFTUP; break;
-							case 2: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_MIDDLEDOWN : OS.MOUSEEVENTF_MIDDLEUP; break;
-							case 3: inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_RIGHTDOWN : OS.MOUSEEVENTF_RIGHTUP; break;
-							case 4: {
-								if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
-								inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_XDOWN : OS.MOUSEEVENTF_XUP;
-								inputs.mouseData = OS.XBUTTON1;
-								break;
-							}
-							case 5: {
-								if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
-								inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_XDOWN : OS.MOUSEEVENTF_XUP;
-								inputs.mouseData = OS.XBUTTON2;
-								break;
-							}
-							default: return false;
+						case 5: {
+							if (OS.WIN32_VERSION < OS.VERSION (5, 0)) return false;
+							inputs.dwFlags = type == SWT.MouseDown ? OS.MOUSEEVENTF_XDOWN : OS.MOUSEEVENTF_XUP;
+							inputs.mouseData = OS.XBUTTON2;
+							break;
 						}
+						default: return false;
 					}
 				}
+			}
 				int /*long*/ hHeap = OS.GetProcessHeap ();
 				int /*long*/ pInputs = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, INPUT.sizeof);
-				OS.MoveMemory(pInputs, new int[] {OS.INPUT_MOUSE}, 4);
+			OS.MoveMemory(pInputs, new int[] {OS.INPUT_MOUSE}, 4);
 				//TODO - DWORD type of INPUT structure aligned to 8 bytes on 64 bit
 				OS.MoveMemory (pInputs + OS.PTR_SIZEOF, inputs, MOUSEINPUT.sizeof);
-				boolean result = OS.SendInput (1, pInputs, INPUT.sizeof) != 0;
-				OS.HeapFree (hHeap, 0, pInputs);
-				return result;
-			}
-		} 
-		return false;
+			boolean result = OS.SendInput (1, pInputs, INPUT.sizeof) != 0;
+			OS.HeapFree (hHeap, 0, pInputs);
+			return result;
+		}
 	}
+	return false;
+	}
 }
 
 void postEvent (Event event) {
@@ -3744,36 +5226,77 @@
  * @see #wake
  */
 public boolean readAndDispatch () {
-	checkDevice ();
-	lpStartupInfo = null;
-	drawMenuBars ();
+    // <QFS>
+    if (logger.level >= Log.DBGDETAIL) {
+        logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                   "");
+    }
+    // </QFS>
+    checkDevice ();
+    lpStartupInfo = null;
+    drawMenuBars ();
 	runSkin ();
 	runDeferredLayouts ();
-	runPopups ();
-	if (OS.PeekMessage (msg, 0, 0, 0, OS.PM_REMOVE)) {
-		if (!filterMessage (msg)) {
-			OS.TranslateMessage (msg);
-			OS.DispatchMessage (msg);
-		}
-		runDeferredEvents ();
-		return true;
-	}
+    runPopups ();
+    if (OS.PeekMessage (msg, 0, 0, 0, OS.PM_REMOVE)) {
+        // <QFS>
+        boolean filterit = filterMessage (msg); // SWT/Display
+        this.logMessage("readAndDispatch()",
+                        msg.hwnd, msg.message, msg.wParam, msg.lParam,
+                        (filterit ? "filtered by SWT/Display: " : ""),
+                        logger, -1);
+
+        // ??? runWin32EventFilters only if ( ! filterMessage  ) ???
+        boolean keepit = runWin32EventFilters(msg.hwnd, msg.message,
+                                              msg.wParam, msg.lParam); // filtered by qftest?
+        eventProcessedByReadAndDispatch++;
+        if (logger.level >= Log.DBG) {
+            logger.build("readAndDispatch()")
+                .add("eventProcessedByReadAndDispatch increased to ")
+                .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+        }
+        try {
+
+            if ( keepit && ! filterit ) {
+                if (logger.level >= Log.DBGDETAIL) {
+                    logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                               "now calling OS.TranslateMessage");
+                }
+                OS.TranslateMessage (msg);
+                if (logger.level >= Log.DBGDETAIL) {
+                    logger.log(Log.DBGDETAIL, "readAndDispatch()",
+                               "now calling OS.DispatchMessage");
+                }
+                OS.DispatchMessage (msg);
+            }
+        } finally {
+            eventProcessedByReadAndDispatch--;
+            if (logger.level >= Log.DBG) {
+                logger.build("readAndDispatch()")
+                    .add("eventProcessedByReadAndDispatch decreased to ")
+                    .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+            }
+        }
+        // </QFS>
+        runDeferredEvents ();
+        return true;
+    }
 	return isDisposed () || (runMessages && runAsyncMessages (false));
 }
 
 static void register (Display display) {
 	synchronized (Device.class) {
-		for (int i=0; i<Displays.length; i++) {
-			if (Displays [i] == null) {
-				Displays [i] = display;
-				return;
-			}
+	for (int i=0; i<Displays.length; i++) {
+		if (Displays [i] == null) {
+			Displays [i] = display;
+			return;
 		}
-		Display [] newDisplays = new Display [Displays.length + 4];
-		System.arraycopy (Displays, 0, newDisplays, 0, Displays.length);
-		newDisplays [Displays.length] = display;
-		Displays = newDisplays;
 	}
+	Display [] newDisplays = new Display [Displays.length + 4];
+	System.arraycopy (Displays, 0, newDisplays, 0, Displays.length);
+	newDisplays [Displays.length] = display;
+	Displays = newDisplays;
+	}
 }
 
 /**
@@ -3780,7 +5303,7 @@
  * Releases any internal resources back to the operating
  * system and clears all fields except the device handle.
  * <p>
- * Disposes all shells which are currently open on the display. 
+ * Disposes all shells which are currently open on the display.
  * After this method has been invoked, all related related shells
  * will answer <code>true</code> when sent the message
  * <code>isDisposed()</code>.
@@ -3796,7 +5319,7 @@
  * The handle is needed by <code>destroy</code>.
  * </p>
  * This method is called before <code>destroy</code>.
- * 
+ *
  * @see Device#dispose
  * @see #destroy
  */
@@ -3828,7 +5351,7 @@
 	if (embeddedHwnd != 0) {
 		OS.PostMessage (embeddedHwnd, SWT_DESTROY, 0, 0);
 	}
-	
+
 	/* Release XP Themes */
 	if (OS.COMCTL32_MAJOR >= 6) {
 		if (hButtonTheme != 0) OS.CloseThemeData (hButtonTheme);
@@ -3838,7 +5361,7 @@
 		if (hTabTheme != 0) OS.CloseThemeData (hTabTheme);
 		hButtonTheme = hEditTheme = hExplorerBarTheme = hScrollBarTheme = hTabTheme = 0;
 	}
-	
+
 	/* Unhook the message hook */
 	if (!OS.IsWinCE) {
 		if (msgHook != 0) OS.UnhookWindowsHookEx (msgHook);
@@ -3853,7 +5376,7 @@
 		msgFilterCallback = null;
 		msgFilterProc = 0;
 	}
-	
+
 	/* Unhook the idle hook */
 	if (!OS.IsWinCE) {
 		if (idleHook != 0) OS.UnhookWindowsHookEx (idleHook);
@@ -3862,10 +5385,10 @@
 		foregroundIdleCallback = null;
 		foregroundIdleProc = 0;
 	}
-	
+
 	/* Stop the settings timer */
 	OS.KillTimer (hwndMessage, SETTINGS_ID);
-	
+
 	/* Destroy the message only HWND */
 	if (hwndMessage != 0) OS.DestroyWindow (hwndMessage);
 	hwndMessage = 0;
@@ -3872,12 +5395,12 @@
 	messageCallback.dispose ();
 	messageCallback = null;
 	messageProc = 0;
-	
+
 	/* Unregister the SWT window class */
 	int /*long*/ hHeap = OS.GetProcessHeap ();
 	int /*long*/ hInstance = OS.GetModuleHandle (null);
 	OS.UnregisterClass (windowClass, hInstance);
-	
+
 	/* Unregister the SWT drop shadow and CS_OWNDC window class */
 	OS.UnregisterClass (windowShadowClass, hInstance);
 	OS.UnregisterClass (windowOwnDCClass, hInstance);
@@ -3885,12 +5408,12 @@
 	windowCallback.dispose ();
 	windowCallback = null;
 	windowProc = 0;
-	
+
 	/* Release the System fonts */
 	if (systemFont != null) systemFont.dispose ();
 	systemFont = null;
 	lfSystemFont = null;
-	
+
 	/* Release the System Images */
 	if (errorImage != null) errorImage.dispose ();
 	if (infoImage != null) infoImage.dispose ();
@@ -3897,12 +5420,12 @@
 	if (questionImage != null) questionImage.dispose ();
 	if (warningIcon != null) warningIcon.dispose ();
 	errorImage = infoImage = questionImage = warningIcon = null;
-	
+
 	/* Release Sort Indicators */
 	if (upArrow != null) upArrow.dispose ();
 	if (downArrow != null) downArrow.dispose ();
 	upArrow = downArrow = null;
-	
+
 	/* Release the System Cursors */
 	for (int i = 0; i < cursors.length; i++) {
 		if (cursors [i] != null) cursors [i].dispose ();
@@ -3920,7 +5443,7 @@
 	/* Release Custom Colors for ChooseColor */
 	if (lpCustColors != 0) OS.HeapFree (hHeap, 0, lpCustColors);
 	lpCustColors = 0;
-	
+
 	/* Uninitialize OLE */
 	if (!OS.IsWinCE) OS.OleUninitialize ();
 
@@ -3928,7 +5451,7 @@
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) {
 		OS.BufferedPaintUnInit ();
 	}
-	
+
 	/* Release references */
 	thread = null;
 	msg = hookMsg = null;
@@ -3939,7 +5462,7 @@
 	keys = null;
 	values = null;
 	bars = popups = null;
-	indexTable = null; 
+	indexTable = null;
 	timerIds = null;
 	controlTable = null;
 	lastControl = lastGetControl = lastHittestControl = null;
@@ -3954,7 +5477,7 @@
 	plvfi = null;
 	monitors = null;
 	touchSources = null;
-	
+
 	/* Release handles */
 	threadId = 0;
 }
@@ -3961,7 +5484,7 @@
 
 void releaseImageList (ImageList list) {
 	int i = 0;
-	int length = imageList.length; 
+	int length = imageList.length;
 	while (i < length) {
 		if (imageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -3980,7 +5503,7 @@
 
 void releaseToolImageList (ImageList list) {
 	int i = 0;
-	int length = toolImageList.length; 
+	int length = toolImageList.length;
 	while (i < length) {
 		if (toolImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -3999,7 +5522,7 @@
 
 void releaseToolHotImageList (ImageList list) {
 	int i = 0;
-	int length = toolHotImageList.length; 
+	int length = toolHotImageList.length;
 	while (i < length) {
 		if (toolHotImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -4018,7 +5541,7 @@
 
 void releaseToolDisabledImageList (ImageList list) {
 	int i = 0;
-	int length = toolDisabledImageList.length; 
+	int length = toolDisabledImageList.length;
 	while (i < length) {
 		if (toolDisabledImageList [i] == list) {
 			if (list.removeRef () > 0) return;
@@ -4055,7 +5578,7 @@
  * @see SWT
  * @see #addFilter
  * @see #addListener
- * 
+ *
  * @since 3.0
  */
 public void removeFilter (int eventType, Listener listener) {
@@ -4085,8 +5608,8 @@
  * @see Listener
  * @see SWT
  * @see #addListener
- * 
- * @since 2.0 
+ *
+ * @since 2.0
  */
 public void removeListener (int eventType, Listener listener) {
 	checkDevice ();
@@ -4131,7 +5654,14 @@
 }
 
 void removePopup (Menu menu) {
-	if (popups == null) return;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("removePopup(Menu)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("menu: ").add(menu)).log(Log.MTD);
+    }
+    // </QFS>
+    if (popups == null) return;
 	for (int i=0; i<popups.length; i++) {
 		if (popups [i] == menu) {
 			popups [i] = null;
@@ -4141,7 +5671,14 @@
 }
 
 boolean runAsyncMessages (boolean all) {
-	return synchronizer.runAsyncMessages (all);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runAsyncMessages(boolean)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("all: ").add(all)).log(Log.MTD);
+    }
+    // </QFS>
+    return synchronizer.runAsyncMessages (all);
 }
 
 boolean runDeferredEvents () {
@@ -4152,7 +5689,7 @@
 	* be re-enterant but need not be synchronized.
 	*/
 	while (eventQueue != null) {
-		
+
 		/* Take an event off the queue */
 		Event event = eventQueue [0];
 		if (event == null) break;
@@ -4193,24 +5730,54 @@
 			if (!comp.isDisposed()) comp.setLayoutDeferred (false);
 		}
 		return true;
-	}	
+	}
 	return false;
 }
 
 boolean runPopups () {
-	if (popups == null) return false;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runPopups()");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("popups: ").addAll(popups)).log(Log.MTD);
+    }
+    // </QFS>
+    if (popups == null) return false;
 	boolean result = false;
 	while (popups != null) {
 		Menu menu = popups [0];
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("runPopups()").add("menu: ").add(menu).log(Log.DBG);
+                }
+                // </QFS>
 		if (menu == null) break;
 		int length = popups.length;
 		System.arraycopy (popups, 1, popups, 0, --length);
 		popups [length] = null;
 		runDeferredEvents ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "runPopups()",
+                               "runDeferredEvents done");
+                }
+                // </QFS>
 		if (!menu.isDisposed ()) menu._setVisible (true);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "runPopups()",
+                               "menu._setVisible done");
+                }
+                // </QFS>
 		result = true;
 	}
 	popups = null;
+        // <QFS>
+        if (logger.level >= Log.DBG) {
+            logger.log(Log.DBG, "runPopups()",
+                       "all done");
+        }
+        // </QFS>
 	return result;
 }
 
@@ -4237,8 +5804,8 @@
 
 boolean runSkin () {
 	if (skinCount > 0) {
-		Widget [] oldSkinWidgets = skinList;	
-		int count = skinCount;	
+		Widget [] oldSkinWidgets = skinList;
+		int count = skinCount;
 		skinList = new Widget[GROW_SIZE];
 		skinCount = 0;
 		if (eventTable != null && eventTable.hooks(SWT.Skin)) {
@@ -4254,12 +5821,19 @@
 			}
 		}
 		return true;
-	}	
+	}
 	return false;
 }
-	
+
 boolean runTimer (int /*long*/ id) {
-	if (timerList != null && timerIds != null) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("runTimer(int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("id: ").add(id)).log(Log.MTD);
+    }
+    // </QFS>
+    if (timerList != null && timerIds != null) {
 		int index = 0;
 		while (index <timerIds.length) {
 			if (timerIds [index] == id) {
@@ -4266,6 +5840,12 @@
 				OS.KillTimer (hwndMessage, timerIds [index]);
 				timerIds [index] = 0;
 				Runnable runnable = timerList [index];
+                                // <QFS>
+                                if (logger.level >= Log.MSG) {
+                                    logger.build("runTimer(int)")
+                                        .add("runnable: ").add(runnable).log(Log.MSG);
+                                }
+                                // </QFS>
 				timerList [index] = null;
 				if (runnable != null) runnable.run ();
 				return true;
@@ -4273,6 +5853,12 @@
 			index++;
 		}
 	}
+    // <QFS>
+    if (logger.level >= Log.MSG) {
+        logger.log(Log.MSG, "runTimer(int)",
+                   "No timer for id " + id);
+    }
+    // </QFS>
 	return false;
 }
 
@@ -4340,7 +5926,7 @@
 	event.type = eventType;
 	if (event.time == 0) event.time = getLastEventTime ();
 	if (!filterEvent (event)) {
-		if (eventTable != null) eventTable.sendEvent (event);
+	        if (eventTable != null) eventTable.sendEvent (event);
 	}
 }
 
@@ -4351,12 +5937,12 @@
  *
  * @param x the new x coordinate for the cursor
  * @param y the new y coordinate for the cursor
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.1
  */
 public void setCursorLocation (int x, int y) {
@@ -4370,13 +5956,13 @@
  * program to move the on-screen pointer location.</b>
  *
  * @param point new position
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_NULL_ARGUMENT - if the point is null
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @since 2.0
  */
 public void setCursorLocation (Point point) {
@@ -4455,7 +6041,7 @@
 		}
 		return;
 	}
-	
+
 	/* Add the key/value pair */
 	if (keys == null) {
 		keys = new String [] {key};
@@ -4482,7 +6068,7 @@
  * Sets the application defined, display specific data
  * associated with the receiver, to the argument.
  * The <em>display specific data</em> is a single,
- * unnamed field that is stored with every display. 
+ * unnamed field that is stored with every display.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the display specific data needs to
@@ -4510,9 +6096,9 @@
  * Returns the application name.
  *
  * @return the application name
- * 
+ *
  * @see #setAppName(String)
- * 
+ *
  * @since 3.6
  */
 public static String getAppName () {
@@ -4523,9 +6109,9 @@
  * Returns the application version.
  *
  * @return the application version
- * 
+ *
  * @see #setAppVersion(String)
- * 
+ *
  * @since 3.6
  */
 public static String getAppVersion () {
@@ -4554,7 +6140,7 @@
  * Sets the application version to the argument.
  *
  * @param version the new app version
- * 
+ *
  * @since 3.6
  */
 public static void setAppVersion (String version) {
@@ -4614,9 +6200,10 @@
 	}
 }
 
-int shiftedKey (int key) {
+// <QFS/> made public
+public int shiftedKey (int key) {
 	if (OS.IsWinCE) return 0;
-	
+
 	/* Clear the virtual keyboard and press the shift key */
 	for (int i=0; i<keyboard.length; i++) keyboard [i] = 0;
 	keyboard [OS.VK_SHIFT] |= 0x80;
@@ -4658,17 +6245,17 @@
 
 /**
  * Causes the <code>run()</code> method of the runnable to
- * be invoked by the user-interface thread at the next 
+ * be invoked by the user-interface thread at the next
  * reasonable opportunity. The thread which calls this method
  * is suspended until the runnable completes.  Specifying <code>null</code>
  * as the runnable simply wakes the user-interface thread.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
  * </p>
- * 
+ *
  * @param runnable code to run on the user-interface thread or <code>null</code>
  *
  * @exception SWTException <ul>
@@ -4681,10 +6268,11 @@
 public void syncExec (Runnable runnable) {
 	Synchronizer synchronizer;
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+                if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
 		synchronizer = this.synchronizer;
 	}
-	synchronizer.syncExec (runnable);
+        // <QFS/> Redirected to internalSyncExec.
+        synchronizer.internalSyncExec (runnable);
 }
 
 /**
@@ -4693,7 +6281,7 @@
  * number of milliseconds have elapsed. If milliseconds is less
  * than zero, the runnable is not executed.
  * <p>
- * Note that at the time the runnable is invoked, widgets 
+ * Note that at the time the runnable is invoked, widgets
  * that have the receiver as their display may have been
  * disposed. Therefore, it is necessary to check for this
  * case inside the runnable before accessing the widget.
@@ -4725,7 +6313,7 @@
 	int /*long*/ timerId = 0;
 	if (index != timerList.length) {
 		timerId = timerIds [index];
-		if (milliseconds < 0) {			
+		if (milliseconds < 0) {
 			OS.KillTimer (hwndMessage, timerId);
 			timerList [index] = null;
 			timerIds [index] = 0;
@@ -4762,7 +6350,8 @@
 	return result;
 }
 
-static int translateKey (int key) {
+// <QFS/> Made public.
+public static int translateKey (int key) {
 	for (int i=0; i<KeyTable.length; i++) {
 		if (KeyTable [i] [0] == key) return KeyTable [i] [1];
 	}
@@ -4779,7 +6368,15 @@
 }
 
 boolean translateTraversal (MSG msg, Control control) {
-	switch (msg.message) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("translateTraversal(MSG,Control)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("msg: ").add(OS.getWinMsgType(msg.message, null))
+         .add(", control: ").add(control)).log(Log.MTD);
+    }
+    // </QFS>
+    switch (msg.message) {
 		case OS.WM_KEYDOWN:
 			switch ((int)/*64*/msg.wParam) {
 				case OS.VK_RETURN:
@@ -4804,7 +6401,8 @@
 	return false;
 }
 
-static int untranslateKey (int key) {
+// <QFS/> Made public.
+public static int untranslateKey (int key) {
 	for (int i=0; i<KeyTable.length; i++) {
 		if (KeyTable [i] [1] == key) return KeyTable [i] [0];
 	}
@@ -4819,7 +6417,7 @@
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see Control#update()
  */
 public void update() {
@@ -4833,10 +6431,10 @@
 	* PM_REMOVE to tell Windows that the application is ready
 	* to dispatch events.  Note that the message does not have
 	* to be found or dispatched in order to wake Windows up.
-	* 
+	*
 	* NOTE: This allows other cross thread messages to be delivered,
 	* most notably WM_ACTIVATE.
-	*/	
+	*/
 	if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (4, 10)) {
 		if (OS.IsHungAppWindow (hwndMessage)) {
 			MSG msg = new MSG ();
@@ -4862,26 +6460,31 @@
 }
 
 /**
- * If the receiver's user-interface thread was <code>sleep</code>ing, 
+ * If the receiver's user-interface thread was <code>sleep</code>ing,
  * causes it to be awakened and start running again. Note that this
  * method may be called from any thread.
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_DEVICE_DISPOSED - if the receiver has been disposed</li>
  * </ul>
- * 
+ *
  * @see #sleep
  */
 public void wake () {
 	synchronized (Device.class) {
-		if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
-		if (thread == Thread.currentThread ()) return;
-		wakeThread ();
+	if (isDisposed ()) error (SWT.ERROR_DEVICE_DISPOSED);
+	if (thread == Thread.currentThread ()) return;
+	wakeThread ();
 	}
 }
 
 void wakeThread () {
-	if (OS.IsWinCE) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.dumpStack(Log.MTD, "wakeThread()", "");
+    }
+    // </QFS>
+        if (OS.IsWinCE) {
 		OS.PostMessage (hwndMessage, OS.WM_NULL, 0, 0);
 	} else {
 		OS.PostThreadMessage (threadId, OS.WM_NULL, 0, 0);
@@ -4898,7 +6501,8 @@
  * @param codePage the code page used to convert the character
  * @return the MBCS character
  */
-static int wcsToMbcs (char ch, int codePage) {
+// <QFS/> made public
+public static int wcsToMbcs (char ch, int codePage) {
 	if (OS.IsUnicode) return ch;
 	if (ch <= 0x7F) return ch;
 	TCHAR buffer = new TCHAR (codePage, ch, false);
@@ -4919,6 +6523,17 @@
 }
 
 int /*long*/ windowProc (int /*long*/ hwnd, int /*long*/ msg, int /*long*/ wParam, int /*long*/ lParam) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        logger.build("windowProc(int,int,int,int)")
+            .add("hwnd: ").addHex(hwnd)
+            .add(", msg: ").add(OS.getWinMsgType(msg, null))
+            .add(", wParam: ").addHex(wParam)
+            .add(", lParam: ").addHex(lParam)
+            .log(Log.MTD);
+    }
+    // </QFS>
+
 	/*
 	* Feature in Windows.  On Vista only, it is faster to
 	* compute and answer the data for the visible columns
@@ -4952,7 +6567,7 @@
 			}
 		}
 	}
-	/*
+    /*
 	* Bug in Adobe Reader 7.0.  For some reason, when Adobe
 	* Reader 7.0 is deactivated from within Internet Explorer,
 	* it sends thousands of consecutive WM_NCHITTEST messages
@@ -4960,7 +6575,7 @@
 	* if the control takes some time to respond to the message,
 	* Adobe stops sending them.  The fix is to detect this case
 	* and sleep.
-	* 
+	*
 	* NOTE: Under normal circumstances, Windows will never send
 	* consecutive WM_NCHITTEST messages to the same control without
 	* another message (normally WM_SETCURSOR) in between.
@@ -4972,24 +6587,107 @@
 	} else {
 		hitCount = 0;
 	}
-	if (lastControl != null && lastHwnd == hwnd) {
-		return lastControl.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
-	}
-	int index;
-	if (USE_PROPERTY) {
+        // <QFS>
+        boolean keepit = true;
+        eventProcessedByReadAndDispatch--;
+        if (logger.level >= Log.DBG) {
+            logger.build("windowProc(int,int,int,int)")
+                .add("eventProcessedByReadAndDispatch decreased to ")
+                .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+        }
+        try {
+            // Run filter only if eventProcessedByReadAndDispatch was not > 0 before decrementing.
+            if (eventProcessedByReadAndDispatch < 0) {
+                keepit = runWin32EventFilters(hwnd, msg, wParam, lParam);
+            }
+            if (msg == OS.WM_MOUSEMOVE
+                || msg == OS.WM_LBUTTONDOWN
+                || msg == OS.WM_LBUTTONUP
+                || msg == OS.WM_MBUTTONDOWN
+                || msg == OS.WM_MBUTTONUP
+                || msg == OS.WM_RBUTTONDOWN
+                || msg == OS.WM_RBUTTONUP) {
+                // Save the state of the modifier keys and mouse buttons so that GetKeyState
+                // overriding works.
+                setReplayKeyStateWnd(wParam);
+            }
+            // </QFS>
+            if (lastControl != null && lastHwnd == hwnd) {
+                // <QFS>
+                if (keepit) {
+                // </QFS>
+                    int ret = lastControl.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "windowProc(int,int,int,int)",
+                                   "Control.windowProc returned "+ret
+                                   +" - this will now be returned by this Display.windowProc");
+                    }
+                    return ret;
+                }
+                // </QFS>
+            }
+            int index;
+            if (USE_PROPERTY) {
 		index = (int)/*64*/OS.GetProp (hwnd, SWT_OBJECT_INDEX) - 1;
-	} else {
+            } else {
 		index = (int)/*64*/OS.GetWindowLongPtr (hwnd, OS.GWLP_USERDATA) - 1;
-	}
-	if (0 <= index && index < controlTable.length) {
-		Control control = controlTable [index];
-		if (control != null) {
+            }
+            if (0 <= index && index < controlTable.length) {
+                if (keepit) {
+                    Control control = controlTable [index];
+                    if (control != null) {
 			lastHwnd = hwnd;
 			lastControl = control;
-			return control.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
-		}
-	}
-	return OS.DefWindowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                        int ret = control.windowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+                        // <QFS>
+                        if (logger.level >= Log.MTDDETAIL) {
+                            logger.log(Log.MTDDETAIL, "windowProc(int,int,int,int)",
+                                       "Control.windowProc returned "+ret
+                                       +" - this will now be returned by this Display.windowProc");
+                        }
+                        // Need to run async messages while modal dialogs (e.g. file dialog) are
+                        // displayed.
+                        // if (synchronizer != null) {
+                            // runAsyncMessages(false);
+                        // }
+                        // </QFS>
+                        return ret;
+                    }
+                }
+            }
+            // <QFS>
+            if ( ! keepit) {
+                // Need to run async messages while modal dialogs (e.g. file dialog) are displayed.
+                // if (synchronizer != null) {
+                    // runAsyncMessages(false);
+                // }
+                if (logger.level >= Log.DBG) {
+                    logger.log(Log.DBG, "windowProc(int,int,int,int)",
+                               "keepit == false ie. return 0");
+                }
+                return 0;
+            }
+            // </QFS>
+            int ret = OS.DefWindowProc (hwnd, (int)/*64*/msg, wParam, lParam);
+            // <QFS>
+            if (logger.level >= Log.DBG) {
+                logger.build("windowProc(int,int,int,int)").add("ret: ").add(ret).log(Log.DBG);
+            }
+            // Need to run async messages while modal dialogs (e.g. file dialog) are displayed.
+            // if (synchronizer != null) {
+                // runAsyncMessages(false);
+            // }
+            // </QFS>
+            return ret;
+        } finally {
+            eventProcessedByReadAndDispatch++;
+            if (logger.level >= Log.DBG) {
+                logger.build("windowProc(int,int,int,int)")
+                    .add("eventProcessedByReadAndDispatch increased to ")
+                    .add(eventProcessedByReadAndDispatch).log(Log.DBG);
+            }
+        }
 }
 
 static String withCrLf (String string) {
@@ -4997,7 +6695,7 @@
 	/* If the string is empty, return the string. */
 	int length = string.length ();
 	if (length == 0) return string;
-	
+
 	/*
 	* Check for an LF or CR/LF and assume the rest of
 	* the string is formated that way.  This will not
@@ -5014,7 +6712,7 @@
 	* number of lines and the size of the buffer
 	* needed to hold the result
 	*/
-	i++;	
+	i++;
 	int count = 1;
 	while (i < length) {
 		if ((i = string.indexOf ('\n', i)) == -1) break;
Index: org/eclipse/swt/widgets/Decorations.java
===================================================================
--- org/eclipse/swt/widgets/Decorations.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Decorations.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -27,7 +27,7 @@
  * Instead, the class <code>Shell</code> should be used.
  * </p>
  * <p>
- * Instances are always displayed in one of the maximized, 
+ * Instances are always displayed in one of the maximized,
  * minimized or normal states:
  * <ul>
  * <li>
@@ -34,7 +34,7 @@
  * When an instance is marked as <em>maximized</em>, the
  * window manager will typically resize it to fill the
  * entire visible area of the display, and the instance
- * is usually put in a state where it can not be resized 
+ * is usually put in a state where it can not be resized
  * (even if it has style <code>RESIZE</code>) until it is
  * no longer maximized.
  * </li><li>
@@ -72,13 +72,13 @@
  * <dt><code>SHELL_TRIM</code></dt>
  * <dd>
  * the result of combining the constants which are required
- * to produce a typical application top level shell: (that 
+ * to produce a typical application top level shell: (that
  * is, <code>CLOSE | TITLE | MIN | MAX | RESIZE</code>)
  * </dd>
  * <dt><code>DIALOG_TRIM</code></dt>
  * <dd>
  * the result of combining the constants which are required
- * to produce a typical application dialog shell: (that 
+ * to produce a typical application dialog shell: (that
  * is, <code>TITLE | CLOSE | BORDER</code>)
  * </dd>
  * </dl>
@@ -121,7 +121,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -178,7 +178,7 @@
 				}
 			}
 			int flags = OS.SWP_NOZORDER | OS.SWP_DRAWFRAME | OS.SWP_NOACTIVATE;
-			SetWindowPos (handle, 0, rect.left, rect.top, width, height, flags);	
+			SetWindowPos (handle, 0, rect.left, rect.top, width, height, flags);
 		}
 	} else {
 		if (!OS.IsWindowVisible (handle)) return;
@@ -225,7 +225,7 @@
 	* the problems are fixed.
 	*/
 //	if ((style & SWT.ON_TOP) != 0) {
-//		int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+//		int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 //		OS.SetWindowPos (handle, OS.HWND_TOP, 0, 0, 0, 0, flags);
 //	} else {
 		OS.BringWindowToTop (handle);
@@ -251,7 +251,7 @@
 	if ((style & (SWT.MENU | SWT.MIN | SWT.MAX | SWT.CLOSE)) != 0) {
 		style |= SWT.TITLE;
 	}
-	
+
 	/*
 	* If either WS_MINIMIZEBOX or WS_MAXIMIZEBOX are set,
 	* we must also set WS_SYSMENU or the buttons will not
@@ -258,13 +258,13 @@
 	* appear.
 	*/
 	if ((style & (SWT.MIN | SWT.MAX)) != 0) style |= SWT.CLOSE;
-	
+
 	/*
 	* Both WS_SYSMENU and WS_CAPTION must be set in order
 	* to for the system menu to appear.
 	*/
 	if ((style & SWT.CLOSE) != 0) style |= SWT.TITLE;
-	
+
 	/*
 	* Bug in Windows.  The WS_CAPTION style must be
 	* set when the window is resizable or it does not
@@ -279,7 +279,7 @@
 	* back.
 	*/
 //	if ((style & SWT.RESIZE) != 0) style |= SWT.TITLE;
-	
+
 	return style;
 }
 
@@ -381,7 +381,7 @@
 		maxAccel = OS.IsPPC ? items.length + 1 : items.length;
 	}
 	ACCEL accel = new ACCEL ();
-	byte [] buffer1 = new byte [ACCEL.sizeof];	
+	byte [] buffer1 = new byte [ACCEL.sizeof];
 	byte [] buffer2 = new byte [maxAccel * ACCEL.sizeof];
 	if (menuBar != null && items != null) {
 		for (int i=0; i<items.length; i++) {
@@ -402,7 +402,7 @@
 		}
 	}
 	if (OS.IsPPC) {
-		/* 
+		/*
 		* Note on WinCE PPC.  Close the shell when user taps CTRL-Q.
 		* IDOK represents the "Done Button" which also closes the shell.
 		*/
@@ -411,7 +411,7 @@
 		accel.cmd = (short) OS.IDOK;
 		OS.MoveMemory (buffer1, accel, ACCEL.sizeof);
 		System.arraycopy (buffer1, 0, buffer2, nAccel * ACCEL.sizeof, ACCEL.sizeof);
-		nAccel++;			
+		nAccel++;
 	}
 	if (nAccel != 0) hAccel = OS.CreateAcceleratorTable (buffer2, nAccel);
 }
@@ -501,7 +501,7 @@
 
 public Rectangle getClientArea () {
 	checkWidget ();
-	/* 
+	/*
 	* Note: The CommandBar is part of the client area,
 	* not the trim.  Applications don't expect this so
 	* subtract the height of the CommandBar.
@@ -531,7 +531,7 @@
 			* not compute the client area when the window is minimized.
 			* The fix is to compute it using AdjustWindowRectEx() and
 			* GetSystemMetrics().
-			* 
+			*
 			* NOTE: This code fails to compute the correct client area
 			* for a minimized window where the menu bar would wrap were
 			* the window restored.  There is no fix for this problem at
@@ -572,7 +572,7 @@
 }
 
 /**
- * Returns the receiver's image if it had previously been 
+ * Returns the receiver's image if it had previously been
  * set using <code>setImage()</code>. The image is typically
  * displayed by the window manager when the instance is
  * marked as iconified, and may also be displayed somewhere
@@ -584,7 +584,7 @@
  * access to a window manager provided, "default" image
  * even if one exists.
  * </p>
- * 
+ *
  * @return the image
  *
  * @exception SWTException <ul>
@@ -598,7 +598,7 @@
 }
 
 /**
- * Returns the receiver's images if they had previously been 
+ * Returns the receiver's images if they had previously been
  * set using <code>setImages()</code>. Images are typically
  * displayed by the window manager when the instance is
  * marked as iconified, and may also be displayed somewhere
@@ -607,7 +607,7 @@
  * chooses the icon with the "best" attributes.  It is expected
  * that the array will contain the same icon rendered at different
  * sizes, with different depth and transparency attributes.
- * 
+ *
  * <p>
  * Note: This method will return an empty array if called before
  * <code>setImages()</code> is called. It does not provide
@@ -614,7 +614,7 @@
  * access to a window manager provided, "default" image
  * even if one exists.
  * </p>
- * 
+ *
  * @return the images
  *
  * @exception SWTException <ul>
@@ -621,7 +621,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public Image [] getImages () {
@@ -650,7 +650,7 @@
 
 /**
  * Returns <code>true</code> if the receiver is currently
- * maximized, and false otherwise. 
+ * maximized, and false otherwise.
  * <p>
  *
  * @return the maximized state
@@ -687,7 +687,7 @@
 
 /**
  * Returns <code>true</code> if the receiver is currently
- * minimized, and false otherwise. 
+ * minimized, and false otherwise.
  * <p>
  *
  * @return the minimized state
@@ -733,7 +733,7 @@
 /**
  * Returns the receiver's text, which is the string that the
  * window manager will typically display as the receiver's
- * <em>title</em>. If the text has not previously been set, 
+ * <em>title</em>. If the text has not previously been set,
  * returns an empty string.
  *
  * @return the text
@@ -892,7 +892,7 @@
  * If the argument is not null, sets the receiver's default
  * button to the argument, and if the argument is null, sets
  * the receiver's default button to the first button which
- * was set as the receiver's default button (called the 
+ * was set as the receiver's default button (called the
  * <em>saved default button</em>). If no default button had
  * previously been set, or the saved default button was
  * disposed, the receiver's default button will be set to
@@ -905,7 +905,7 @@
  * @param button the new default button
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the button has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the button has been disposed</li>
  *    <li>ERROR_INVALID_PARENT - if the control is not in the same widget tree</li>
  * </ul>
  * @exception SWTException <ul>
@@ -952,11 +952,11 @@
  * manager when the instance is marked as iconified, and
  * may also be displayed somewhere in the trim when the
  * instance is in normal or maximized states.
- * 
+ *
  * @param image the new image (or null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -977,7 +977,7 @@
 	* that it is possible to set an icon into a window and then
 	* later free the icon, thus freeing the icon for every window.
 	* The fix is to avoid the API.
-	* 
+	*
 	* On WinCE PPC, icons in windows are not displayed.
 	*/
 	if (OS.IsWinCE) return;
@@ -1033,7 +1033,7 @@
 		}
 	}
 	OS.SendMessage (handle, OS.WM_SETICON, OS.ICON_BIG, hLargeIcon);
-	
+
 	/*
 	* Bug in Windows.  When WM_SETICON is used to remove an
 	* icon from the window trimmings for a window with the
@@ -1059,7 +1059,7 @@
  * the "best" attributes. It is expected that the array will
  * contain the same icon rendered at different sizes, with
  * different depth and transparency attributes.
- * 
+ *
  * @param images the new image array
  *
  * @exception IllegalArgumentException <ul>
@@ -1070,7 +1070,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.0
  */
 public void setImages (Image [] images) {
@@ -1119,7 +1119,7 @@
  * @param menu the new menu bar
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the menu has been disposed</li>
  *    <li>ERROR_INVALID_PARENT - if the menu is not in the same widget tree</li>
  * </ul>
  * @exception SWTException <ul>
@@ -1134,7 +1134,7 @@
 		if (menu.isDisposed()) error(SWT.ERROR_INVALID_ARGUMENT);
 		if ((menu.style & SWT.BAR) == 0) error (SWT.ERROR_MENU_NOT_BAR);
 		if (menu.parent != this) error (SWT.ERROR_INVALID_PARENT);
-	}	
+	}
 	if (OS.IsWinCE) {
 		if (OS.IsHPC) {
 			boolean resize = menuBar != menu;
@@ -1167,7 +1167,7 @@
 				menuBar = menu;
 				if (menuBar != null) OS.ShowWindow (menuBar.hwndCB, OS.SW_SHOW);
 			}
-		} 
+		}
 	} else {
 		if (menu != null) display.removeBar (menu);
 		menuBar = menu;
@@ -1237,7 +1237,7 @@
 	bits &= ~OS.WS_CHILD;
 	OS.SetWindowLong (handle, OS.GWL_STYLE, bits | OS.WS_POPUP);
 	OS.SetWindowLongPtr (handle, OS.GWLP_ID, 0);
-	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE; 
+	int flags = OS.SWP_NOSIZE | OS.SWP_NOMOVE | OS.SWP_NOACTIVATE;
 	SetWindowPos (handle, OS.HWND_BOTTOM, 0, 0, 0, 0, flags);
 	display.lockActiveWindow = false;
 }
@@ -1315,7 +1315,7 @@
 		OS.DeleteMenu (hMenu, OS.SC_RESTORE, OS.MF_BYCOMMAND);
 	}
 	int newCount = OS.GetMenuItemCount (hMenu);
-	if ((style & SWT.CLOSE) == 0 || newCount != oldCount) {	
+	if ((style & SWT.CLOSE) == 0 || newCount != oldCount) {
 		OS.DeleteMenu (hMenu, OS.SC_TASKLIST, OS.MF_BYCOMMAND);
 		MENUITEMINFO info = new MENUITEMINFO ();
 		info.cbSize = MENUITEMINFO.sizeof;
@@ -1339,7 +1339,7 @@
 /**
  * Sets the receiver's text, which is the string that the
  * window manager will typically display as the receiver's
- * <em>title</em>, to the argument, which must not be null. 
+ * <em>title</em>, to the argument, which must not be null.
  *
  * @param string the new text
  *
@@ -1365,7 +1365,7 @@
 		OS.DefWindowProc (handle, OS.WM_SETTEXT, 0, pszText);
 		if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
 	} else {
-		OS.SetWindowText (handle, buffer);
+	OS.SetWindowText (handle, buffer);
 	}
 }
 
@@ -1442,10 +1442,10 @@
 				if (OS.IsZoomed (handle)) {
 					swFlags = OS.SW_SHOWMAXIMIZED;
 				} else {
-					swFlags = OS.SW_SHOWNOACTIVATE;
+						swFlags = OS.SW_SHOWNOACTIVATE;
+					}
 				}
 			}
-		}
 		if (!getDrawing()) {
 			state |= HIDDEN;
 		} else {
@@ -1497,7 +1497,8 @@
 			return true;
 		}
 		if (msg.message == OS.WM_KEYDOWN) {
-			if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return false;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return false;
 			switch ((int)/*64*/(msg.wParam)) {
 				case OS.VK_F4:
 					OS.PostMessage (handle, OS.WM_CLOSE, 0, 0);
@@ -1576,13 +1577,13 @@
 }
 
 int widgetStyle () {
-	/* 
+	/*
 	* Clear WS_VISIBLE and WS_TABSTOP.  NOTE: In Windows, WS_TABSTOP
 	* has the same value as WS_MAXIMIZEBOX so these bits cannot be
 	* used to control tabbing.
 	*/
 	int bits = super.widgetStyle () & ~(OS.WS_TABSTOP | OS.WS_VISIBLE);
-	
+
 	/* Set the title bits and no-trim bits */
 	bits &= ~OS.WS_BORDER;
 	if ((style & SWT.NO_TRIM) != 0) {
@@ -1592,11 +1593,11 @@
 		return bits;
 	}
 	if ((style & SWT.TITLE) != 0) bits |= OS.WS_CAPTION;
-	
+
 	/* Set the min and max button bits */
 	if ((style & SWT.MIN) != 0) bits |= OS.WS_MINIMIZEBOX;
 	if ((style & SWT.MAX) != 0) bits |= OS.WS_MAXIMIZEBOX;
-	
+
 	/* Set the resize, dialog border or border bits */
 	if ((style & SWT.RESIZE) != 0) {
 		/*
@@ -1604,7 +1605,7 @@
 		* the Shell according to the state of the IME.
 		* It does not set the WS_THICKFRAME style.
 		*/
-		if (!OS.IsPPC) bits |= OS.WS_THICKFRAME;	
+		if (!OS.IsPPC) bits |= OS.WS_THICKFRAME;
 	} else {
 		if ((style & SWT.BORDER) == 0) bits |= OS.WS_BORDER;
 	}
@@ -1613,7 +1614,7 @@
 	if (!OS.IsPPC && !OS.IsSP) {
 		if ((style & SWT.CLOSE) != 0) bits |= OS.WS_SYSMENU;
 	}
-	
+
 	return bits;
 }
 
@@ -1665,7 +1666,7 @@
 				if (isDisposed ()) return LRESULT.ZERO;
 			}
 		}
-		if (restoreFocus ()) return LRESULT.ZERO;	
+		if (restoreFocus ()) return LRESULT.ZERO;
 	} else {
 		Display display = this.display;
 		boolean lockWindow = display.isXMouseActive ();
@@ -1702,8 +1703,8 @@
 		/*
 		* Feature on WinCE SP.  The Back key is either used to close
 		* the foreground Dialog or used as a regular Back key in an EDIT
-		* control. The article 'Back Key' in MSDN for Smartphone 
-		* describes how an application should handle it.  The 
+		* control. The article 'Back Key' in MSDN for Smartphone
+		* describes how an application should handle it.  The
 		* workaround is to override the Back key when creating
 		* the menubar and handle it based on the style of the Shell.
 		* If the Shell has the SWT.CLOSE style, close the Shell.
Index: org/eclipse/swt/widgets/Canvas.java
===================================================================
--- org/eclipse/swt/widgets/Canvas.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Canvas.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -90,7 +90,7 @@
 	}
 }
 
-/** 
+/**
  * Fills the interior of the rectangle specified by the arguments,
  * with the receiver's background. 
  *
@@ -138,7 +138,7 @@
 	return caret;
 }
 
-/**
+/** 
  * Returns the IME.
  *
  * @return the IME
Index: org/eclipse/swt/widgets/TreeColumn.java
===================================================================
--- org/eclipse/swt/widgets/TreeColumn.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TreeColumn.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -355,9 +355,9 @@
 				itemRight = event.x + event.width;
 			} else {
 				int /*long*/ hFont = item.fontHandle (index);
-				if (hFont != -1) hFont = OS.SelectObject (hDC, hFont);
-				RECT itemRect = item.getBounds (index, true, true, false, false, false, hDC);
-				if (hFont != -1) OS.SelectObject (hDC, hFont);
+			if (hFont != -1) hFont = OS.SelectObject (hDC, hFont);
+			RECT itemRect = item.getBounds (index, true, true, false, false, false, hDC);
+			if (hFont != -1) OS.SelectObject (hDC, hFont);
 				itemRight = itemRect.right;
 			}
 			columnWidth = Math.max (columnWidth, itemRight - headerRect.left);
@@ -687,7 +687,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/widgets/Spinner.java
===================================================================
--- org/eclipse/swt/widgets/Spinner.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Spinner.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -37,7 +38,7 @@
  * @see <a href="http://www.eclipse.org/swt/snippets/#spinner">Spinner snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
- * 
+ *
  * @since 3.1
  * @noextend This class is not intended to be subclassed by clients.
  */
@@ -48,7 +49,7 @@
 	static final int /*long*/ EditProc;
 	static final TCHAR EditClass = new TCHAR (0, "EDIT", true);
 	static final int /*long*/ UpDownProc;
-	static final TCHAR UpDownClass = new TCHAR (0, OS.UPDOWN_CLASS, true);	
+	static final TCHAR UpDownClass = new TCHAR (0, OS.UPDOWN_CLASS, true);
 	static {
 		WNDCLASS lpWndClass = new WNDCLASS ();
 		OS.GetClassInfo (0, EditClass, lpWndClass);
@@ -56,15 +57,15 @@
 		OS.GetClassInfo (0, UpDownClass, lpWndClass);
 		UpDownProc = lpWndClass.lpfnWndProc;
 	}
-	
+
 	/**
 	 * the operating system limit for the number of characters
 	 * that the text field in an instance of this class can hold
-	 * 
+	 *
 	 * @since 3.4
 	 */
 	public static final int LIMIT;
-	
+
 	/*
 	 * These values can be different on different platforms.
 	 * Therefore they are not initialized in the declaration
@@ -71,9 +72,9 @@
 	 * to stop the compiler from inlining.
 	 */
 	static {
-		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;	
+		LIMIT = OS.IsWinNT ? 0x7FFFFFFF : 0x7FFF;
 	}
-	
+
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -80,7 +81,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -185,7 +186,7 @@
 	if (OS.IsDBLocale) {
 		int /*long*/ hIMC = OS.ImmGetContext (handle);
 		OS.ImmAssociateContext (hwndText, hIMC);
-		OS.ImmAssociateContext (hwndUpDown, hIMC);		
+		OS.ImmAssociateContext (hwndUpDown, hIMC);
 		OS.ImmReleaseContext (handle, hIMC);
 	}
 	OS.SendMessage (hwndUpDown, OS.UDM_SETRANGE32, 0, 100);
@@ -334,7 +335,7 @@
 
 public Rectangle computeTrim (int x, int y, int width, int height) {
 	checkWidget ();
-	
+
 	/* Get the trim of the text control */
 	RECT rect = new RECT ();
 	OS.SetRect (rect, x, y, x + width, y + height);
@@ -343,7 +344,7 @@
 	OS.AdjustWindowRectEx (rect, bits0, false, bits1);
 	width = rect.right - rect.left;
 	height = rect.bottom - rect.top;
-	
+
 	/*
 	* The preferred height of a single-line text widget
 	* has been hand-crafted to be the same height as
@@ -513,7 +514,7 @@
 /**
  * Returns the <em>selection</em>, which is the receiver's position.
  *
- * @return the selection 
+ * @return the selection
  *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -583,7 +584,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.4
  */
 public String getText () {
@@ -600,9 +601,9 @@
  * text field is capable of holding. If this has not been changed
  * by <code>setTextLimit()</code>, it will be the constant
  * <code>Spinner.LIMIT</code>.
- * 
+ *
  * @return the text limit
- * 
+ *
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -609,7 +610,7 @@
  * </ul>
  *
  * @see #LIMIT
- * 
+ *
  * @since 3.4
  */
 public int getTextLimit () {
@@ -648,7 +649,7 @@
 
 void register () {
 	super.register ();
-	display.addControl (hwndText, this);	
+	display.addControl (hwndText, this);
 	display.addControl (hwndUpDown, this);
 }
 
@@ -678,7 +679,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Modify, listener);	
+	eventTable.unhook (SWT.Modify, listener);
 }
 
 /**
@@ -703,7 +704,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 /**
@@ -727,7 +728,7 @@
 	checkWidget ();
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
-	eventTable.unhook (SWT.Verify, listener);	
+	eventTable.unhook (SWT.Verify, listener);
 }
 
 boolean sendKeyEvent (int type, int msg, int /*long*/ wParam, int /*long*/ lParam, Event event) {
@@ -743,7 +744,7 @@
 //	if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;
 	char key = event.character;
 	int stateMask = event.stateMask;
-	
+
 	/*
 	* Disable all magic keys that could modify the text
 	* and don't send events when Alt, Shift or Ctrl is
@@ -761,7 +762,8 @@
 	/*
 	* If the left button is down, the text widget refuses the character.
 	*/
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) {
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) {
 		return true;
 	}
 
@@ -827,17 +829,17 @@
  * Sets the number of decimal places used by the receiver.
  * <p>
  * The digit setting is used to allow for floating point values in the receiver.
- * For example, to set the selection to a floating point value of 1.37 call setDigits() with 
+ * For example, to set the selection to a floating point value of 1.37 call setDigits() with
  * a value of 2 and setSelection() with a value of 137. Similarly, if getDigits() has a value
  * of 2 and getSelection() returns 137 this should be interpreted as 1.37. This applies to all
- * numeric APIs. 
+ * numeric APIs.
  * </p>
- * 
+ *
  * @param value the new digits (must be greater than or equal to zero)
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if the value is less than zero</li>
- * </ul> 
+ * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -918,7 +920,7 @@
 	} else {
 		pos = (int)/*64*/OS.SendMessage (hwndUpDown, OS.UDM_GETPOS32, 0, 0);
 	}
-	OS.SendMessage (hwndUpDown , OS.UDM_SETRANGE32, min [0], value);	
+	OS.SendMessage (hwndUpDown , OS.UDM_SETRANGE32, min [0], value);
 	if (pos > value) setSelection (value, true, true, false);
 }
 
@@ -1047,9 +1049,9 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #LIMIT
- * 
+ *
  * @since 3.4
  */
 public void setTextLimit (int limit) {
@@ -1068,7 +1070,7 @@
  * value, digits, increment and page increment all at once.
  * <p>
  * Note: This is similar to setting the values individually
- * using the appropriate methods, but may be implemented in a 
+ * using the appropriate methods, but may be implemented in a
  * more efficient fashion on some platforms.
  * </p>
  *
@@ -1083,7 +1085,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @since 3.2
  */
 public void setValues (int selection, int minimum, int maximum, int digits, int increment, int pageIncrement) {
@@ -1188,7 +1190,7 @@
 			case OS.WM_SYSCHAR:		result = wmSysChar (hwnd, wParam, lParam); break;
 			case OS.WM_SYSKEYDOWN:	result = wmSysKeyDown (hwnd, wParam, lParam); break;
 			case OS.WM_SYSKEYUP:	result = wmSysKeyUp (hwnd, wParam, lParam); break;
-	
+
 			/* Mouse Messages */
 			case OS.WM_CAPTURECHANGED:	result = wmCaptureChanged (hwnd, wParam, lParam); break;
 			case OS.WM_LBUTTONDBLCLK:	result = wmLButtonDblClk (hwnd, wParam, lParam); break;
@@ -1207,18 +1209,18 @@
 			case OS.WM_XBUTTONDBLCLK:	result = wmXButtonDblClk (hwnd, wParam, lParam); break;
 			case OS.WM_XBUTTONDOWN:		result = wmXButtonDown (hwnd, wParam, lParam); break;
 			case OS.WM_XBUTTONUP:		result = wmXButtonUp (hwnd, wParam, lParam); break;
-			
+
 			/* Focus Messages */
 			case OS.WM_SETFOCUS:		result = wmSetFocus (hwnd, wParam, lParam); break;
 			case OS.WM_KILLFOCUS:		result = wmKillFocus (hwnd, wParam, lParam); break;
-	
+
 			/* Paint messages */
 			case OS.WM_PAINT:			result = wmPaint (hwnd, wParam, lParam); break;
-			case OS.WM_PRINT:			result = wmPrint (hwnd, wParam, lParam); break;			
-	
+			case OS.WM_PRINT:			result = wmPrint (hwnd, wParam, lParam); break;
+
 			/* Menu messages */
 			case OS.WM_CONTEXTMENU:		result = wmContextMenu (hwnd, wParam, lParam); break;
-				
+
 			/* Clipboard messages */
 			case OS.WM_CLEAR:
 			case OS.WM_CUT:
@@ -1320,7 +1322,7 @@
 	switch ((int)/*64*/wParam) {
 		case SWT.CR:
 			sendSelectionEvent (SWT.DefaultSelection);
-			// FALL THROUGH		
+			// FALL THROUGH
 		case SWT.TAB:
 		case SWT.ESC: return LRESULT.ZERO;
 	}
@@ -1380,7 +1382,7 @@
 				int /*long*/ hHeap = OS.GetProcessHeap ();
 				int byteCount = buffer.length () * TCHAR.sizeof;
 				int /*long*/ pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-				OS.MoveMemory (pszText, buffer, byteCount); 
+				OS.MoveMemory (pszText, buffer, byteCount);
 				int /*long*/ code = OS.CallWindowProc (EditProc, hwndText, msg, wParam, pszText);
 				OS.HeapFree (hHeap, 0, pszText);
 				return new LRESULT (code);
@@ -1420,7 +1422,7 @@
 	if (ignoreCharacter) return null;
 	LRESULT result = super.wmKeyDown (hwnd, wParam, lParam);
 	if (result != null) return result;
-	
+
 	/* Increment the value */
 	UDACCEL udaccel = new UDACCEL ();
 	OS.SendMessage (hwndUpDown, OS.UDM_GETACCEL, 1, udaccel);
@@ -1451,7 +1453,7 @@
 		newValue = Math.min (Math.max (min [0], newValue), max [0]);
 		if (value != newValue) setSelection (newValue, true, true, true);
 	}
-	
+
 	/*  Stop the edit control from moving the caret */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_UP:
@@ -1469,7 +1471,7 @@
 			value = OS.LOWORD (OS.SendMessage (hwndUpDown, OS.UDM_GETPOS, 0, 0));
 		} else {
 			value = (int)/*64*/OS.SendMessage (hwndUpDown, OS.UDM_GETPOS32, 0, 0);
-		}		
+		}
 		setSelection (value, false, true, false);
 	}
 	return super.wmKillFocus (hwnd, wParam, lParam);
Index: org/eclipse/swt/widgets/Scrollable.java
===================================================================
--- org/eclipse/swt/widgets/Scrollable.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Scrollable.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -15,6 +15,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * This class is the abstract superclass of all classes which
  * represent controls that have standard scroll bars.
@@ -34,6 +39,17 @@
  */
 
 public abstract class Scrollable extends Control {
+
+    // {{{ <QFS> Log
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.Scrollable");
+
+    // }}} </QFS>
+
 	ScrollBar horizontalBar, verticalBar;
 
 /**
@@ -48,7 +64,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -93,7 +109,7 @@
  * rectangle described by the arguments (relative to the
  * receiver's parent).
  * </p>
- * 
+ *
  * @param x the desired x coordinate of the client area
  * @param y the desired y coordinate of the client area
  * @param width the desired width of the client area
@@ -154,7 +170,7 @@
  * Returns a rectangle which describes the area of the
  * receiver which is capable of displaying data (that is,
  * not covered by the "trimmings").
- * 
+ *
  * @return the client area
  *
  * @exception SWTException <ul>
@@ -292,9 +308,20 @@
 }
 
 LRESULT WM_HSCROLL (int /*long*/ wParam, int /*long*/ lParam) {
-	LRESULT result = super.WM_HSCROLL (wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_HSCROLL(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.build("WM_HSCROLL(int,int)").add("state: ").add(state).log(Log.DBG);
+    }
+    // </QFS>
+    LRESULT result = super.WM_HSCROLL (wParam, lParam);
 	if (result != null) return result;
-	
+
 	/*
 	* Bug on WinCE.  lParam should be NULL when the message is not sent
 	* by a scroll bar control, but it contains the handle to the window.
@@ -321,7 +348,18 @@
 }
 
 LRESULT WM_VSCROLL (int /*long*/ wParam, int /*long*/ lParam) {
-	LRESULT result = super.WM_VSCROLL (wParam, lParam);
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("WM_VSCROLL(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.build("WM_VSCROLL(int,int)").add("state: ").add(state).log(Log.DBG);
+    }
+    // </QFS>
+    LRESULT result = super.WM_VSCROLL (wParam, lParam);
 	if (result != null) return result;
 	/*
 	* Bug on WinCE.  lParam should be NULL when the message is not sent
@@ -370,8 +408,8 @@
 					cornerRect.left = trimRect.left;
 					cornerRect.right = cornerRect.left + (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
 				} else {
-					cornerRect.right = windowRect.right - windowRect.left - trimRect.right;
-					cornerRect.left = cornerRect.right - (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
+				cornerRect.right = windowRect.right - windowRect.left - trimRect.right;
+				cornerRect.left = cornerRect.right - (hVisible ? OS.GetSystemMetrics (OS.SM_CXVSCROLL) : 0);
 				}
 				if (cornerRect.left != cornerRect.right && cornerRect.top != cornerRect.bottom) {
 					int /*long*/ hDC = OS.GetWindowDC (hwnd);
@@ -478,7 +516,19 @@
 }
 
 LRESULT wmScroll (ScrollBar bar, boolean update, int /*long*/ hwnd, int msg, int /*long*/ wParam, int /*long*/ lParam) {
-	LRESULT result = null;
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmScroll(ScrollBar,boolean,int,int,int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("bar: ").add(bar)
+         .add(", update: ").add(update)
+         .add(", hwnd: ").addHex(hwnd)
+         .add(", msg: ").add(msg)
+         .add(", wParam: ").addHex(wParam)
+         .add(", lParam: ").addHex(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    LRESULT result = null;
 	if (update) {
 		int type = msg == OS.WM_HSCROLL ? OS.SB_HORZ : OS.SB_VERT;
 		SCROLLINFO info = new SCROLLINFO ();
@@ -485,6 +535,13 @@
 		info.cbSize = SCROLLINFO.sizeof;
 		info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;
 		OS.GetScrollInfo (hwnd, type, info);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmScroll(ScrollBar,boolean,int,int,int,int)")
+                        .add("at method begin: info.nPos: ").add(info.nPos)
+                        .add(", info.nTrackPos: ").add(info.nTrackPos).log(Log.DBG);
+                }
+                // </QFS>
 		info.fMask = OS.SIF_POS;
 		int code = OS.LOWORD (wParam);
 		switch (code) {
@@ -491,7 +548,7 @@
 			case OS.SB_ENDSCROLL:  return null;
 			case OS.SB_THUMBPOSITION:
 			case OS.SB_THUMBTRACK:
-				/* 
+				/*
 				* Note: On WinCE, the value in SB_THUMBPOSITION is relative to nMin.
 				* Same for SB_THUMBPOSITION 'except' for the very first thumb track
 				* message which has the actual value of nMin. This is a problem when
@@ -526,6 +583,18 @@
 		result = code == 0 ? LRESULT.ZERO : new LRESULT (code);
 	}
 	bar.wmScrollChild (wParam, lParam);
+        // <QFS>
+        SCROLLINFO info = new SCROLLINFO ();
+        info.cbSize = org.eclipse.swt.internal.win32.SCROLLINFO.sizeof;
+        info.fMask = OS.SIF_TRACKPOS | OS.SIF_POS | OS.SIF_RANGE;
+        OS.GetScrollInfo (hwnd, OS.SB_HORZ, info);
+        if (logger.level >= Log.DBG) {
+            logger.build("wmScroll(ScrollBar,boolean,int,int,int,int)")
+                .add("at method end: info.nPos: ").add(info.nPos)
+                .add(", info.nTrackPos: ").add(info.nTrackPos).log(Log.DBG);
+        }
+
+        // </QFS>
 	return result;
 }
 
Index: org/eclipse/swt/widgets/Touch.java
===================================================================
--- org/eclipse/swt/widgets/Touch.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Touch.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -21,7 +21,7 @@
  * @since 3.7
  */
 public final class Touch {
-
+	
 	/**
 	 * The unique identity of the touch. Use this value to track changes to a touch
 	 * during the touch's life. Two touches may have the same identity even if they
@@ -28,12 +28,12 @@
 	 * come from different sources.
 	 */
 	public long id;
-
+	
 	/**
 	 * The object representing the input source that generated the touch.
 	 */
 	public TouchSource source;
-
+	
 	/**
 	 * The state of this touch at the time it was generated. If this field is 0
 	 * then the finger is still touching the device but has not moved
@@ -44,7 +44,7 @@
 	 * @see org.eclipse.swt.SWT#TOUCHSTATE_UP
 	 */
 	public int state;
-
+	
 	/**
 	 * A flag indicating that the touch is the first touch from a previous
 	 * state of no touch points. Once designated as such, the touch remains
Index: org/eclipse/swt/widgets/ScrollBar.java
===================================================================
--- org/eclipse/swt/widgets/ScrollBar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ScrollBar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -18,9 +18,9 @@
 
 /**
  * Instances of this class are selectable user interface
- * objects that represent a range of positive, numeric values. 
+ * objects that represent a range of positive, numeric values.
  * <p>
- * At any given moment, a given scroll bar will have a 
+ * At any given moment, a given scroll bar will have a
  * single 'selection' that is considered to be its
  * value, which is constrained to be within the range of
  * values the scroll bar represents (that is, between its
@@ -60,7 +60,7 @@
  * have no operating system resources and are not children of the control.
  * For this reason, scroll bars are treated specially.  To create a control
  * that looks like a scroll bar but has operating system resources, use
- * <code>Slider</code>. 
+ * <code>Slider</code>.
  * </p>
  * <dl>
  * <dt><b>Styles:</b></dt>
@@ -83,7 +83,7 @@
  * @noextend This class is not intended to be subclassed by clients.
  */
 
-public class ScrollBar extends Widget {	
+public class ScrollBar extends Widget {
 	Scrollable parent;
 	int increment, pageIncrement;
 
@@ -93,7 +93,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -231,7 +231,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -530,6 +530,9 @@
 	return (state & HIDDEN) == 0;
 }
 
+    // <QFS>
+    public
+    // </QFS>
 int /*long*/ hwndScrollBar () {
 	return parent.scrolledHandle ();
 }
@@ -546,7 +549,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -606,7 +609,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 int scrollBarType () {
@@ -649,7 +652,7 @@
 /**
  * Sets the amount that the receiver's value will be
  * modified by when the up/down (or right/left) arrows
- * are pressed to the argument, which must be at least 
+ * are pressed to the argument, which must be at least
  * one.
  *
  * @param value the new increment (must be greater than zero)
@@ -750,21 +753,21 @@
 	boolean barVisible = false;
 	boolean visible = getVisible ();
 	
-	/*
-	* This line is intentionally commented.  Currently
-	* always show scrollbar as being enabled and visible.
-	*/
-//	if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);
+		/*
+		* This line is intentionally commented.  Currently
+		* always show scrollbar as being enabled and visible.
+		*/
+//		if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);
 	ScrollBar bar = null;
-	if (!OS.IsWinCE) {
-		switch (flags) {
-			case OS.SB_HORZ:
-				bar = parent.getVerticalBar ();
-				break;
-			case OS.SB_VERT:
-				bar = parent.getHorizontalBar ();
-				break;
-		}
+		if (!OS.IsWinCE) {
+			switch (flags) {
+				case OS.SB_HORZ:
+					bar = parent.getVerticalBar ();
+					break;
+				case OS.SB_VERT:
+					bar = parent.getHorizontalBar ();
+					break;
+			}
 		barVisible = bar != null && bar.getVisible ();
 	}
 	if (!visible || (state & DISABLED) != 0) fRedraw = false;
@@ -806,7 +809,7 @@
 			OS.ShowScrollBar (hwnd, flags == OS.SB_HORZ ? OS.SB_VERT : OS.SB_HORZ, false);
 		}
 	}
-		
+
 	/*
 	* Feature in Windows.  Using SIF_DISABLENOSCROLL,
 	* SetScrollInfo () can change enabled and disabled
@@ -887,7 +890,7 @@
  * value, thumb, increment and page increment all at once.
  * <p>
  * Note: This is similar to setting the values individually
- * using the appropriate methods, but may be implemented in a 
+ * using the appropriate methods, but may be implemented in a
  * more efficient fashion on some platforms.
  * </p>
  *
@@ -910,7 +913,7 @@
 	if (thumb < 1) return;
 	if (increment < 1) return;
 	if (pageIncrement < 1) return;
-	this.increment = increment;	
+	this.increment = increment;
 	this.pageIncrement = pageIncrement;
 	SCROLLINFO info = new SCROLLINFO ();
 	info.cbSize = SCROLLINFO.sizeof;
@@ -927,7 +930,7 @@
 
 /**
  * Marks the receiver as visible if the argument is <code>true</code>,
- * and marks it invisible otherwise. 
+ * and marks it invisible otherwise.
  * <p>
  * If one of the receiver's ancestors is not visible or some
  * other condition makes the receiver not visible, marking
@@ -944,7 +947,7 @@
 public void setVisible (boolean visible) {
 	checkWidget();
 	if (visible == getVisible ()) return;
-	
+
 	/*
 	* On Windows CE, use SIF_DISABLENOSCROLL to show and
 	* hide the scroll bar when the page size is equal to
@@ -961,11 +964,11 @@
 		if (info.nPage == info.nMax - info.nMin + 1) {
 			/*
 			* Bug in Windows.  When the only changed flag to
-			* SetScrollInfo () is OS.SIF_DISABLENOSCROLL, 
+			* SetScrollInfo () is OS.SIF_DISABLENOSCROLL,
 			* Windows does not update the scroll bar state.
 			* The fix is to increase and then decrease the
 			* maximum, causing Windows to honour the flag.
-			*/  
+			*/
 			int max = info.nMax;
 			info.nMax++;
 			OS.SetScrollInfo (hwnd, type, info, false);
@@ -980,7 +983,7 @@
 		}
 		return;
 	}
-	
+
 	/*
 	* Set the state bits before calling ShowScrollBar ()
 	* because hiding and showing the scroll bar can cause
Index: org/eclipse/swt/widgets/Widget.java
===================================================================
--- org/eclipse/swt/widgets/Widget.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Widget.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -17,8 +18,13 @@
 import org.eclipse.swt.graphics.*;
 import org.eclipse.swt.events.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
- * This class is the abstract superclass of all user interface objects.  
+ * This class is the abstract superclass of all user interface objects.
  * Widgets are created, disposed and issue notification to listeners
  * when events occur which affect them.
  * <dl>
@@ -46,11 +52,16 @@
  */
 
 public abstract class Widget {
+    // <QFS>
+    private final static Logger logger = new Logger("org.eclipse.swt.widgets.Widget");
+    private final static Logger suppresslogger = new Logger("suppress.aus.ab.DBG");
+    // </QFS>
+
 	int style, state;
 	Display display;
 	EventTable eventTable;
 	Object data;
-	
+
 	/* Global state flags */
 	static final int DISPOSED		= 1<<0;
 	static final int CANVAS			= 1<<1;
@@ -57,13 +68,13 @@
 	static final int KEYED_DATA		= 1<<2;
 	static final int DISABLED		= 1<<3;
 	static final int HIDDEN			= 1<<4;
-	
+
 	/* A layout was requested on this widget */
 	static final int LAYOUT_NEEDED	= 1<<5;
-	
+
 	/* The preferred size of a child has changed */
 	static final int LAYOUT_CHANGED = 1<<6;
-	
+
 	/* A layout was requested in this widget hierarchy */
 	static final int LAYOUT_CHILD = 1<<7;
 
@@ -71,11 +82,11 @@
 	static final int THEME_BACKGROUND = 1<<8;
 	static final int DRAW_BACKGROUND = 1<<9;
 	static final int PARENT_BACKGROUND = 1<<10;
-	
+
 	/* Dispose and release flags */
 	static final int RELEASED		= 1<<11;
 	static final int DISPOSE_SENT	= 1<<12;
-	
+
 	/* More global widget state flags */
 	static final int TRACK_MOUSE	= 1<<13;
 	static final int FOREIGN_HANDLE	= 1<<14;
@@ -86,13 +97,13 @@
 	static final int MOVE_DEFERRED		= 1<<17;
 	static final int RESIZE_OCCURRED	= 1<<18;
 	static final int RESIZE_DEFERRED	= 1<<19;
-	
+
 	/* Ignore WM_CHANGEUISTATE */
 	static final int IGNORE_WM_CHANGEUISTATE = 1<<20;
-	
+
 	/* Notify of the opportunity to skin this widget */
 	static final int SKIN_NEEDED = 1<<21;
-	
+
 	/* Default size for widgets */
 	static final int DEFAULT_WIDTH	= 64;
 	static final int DEFAULT_HEIGHT	= 64;
@@ -108,7 +119,7 @@
 		}
 		OS.InitCommonControls ();
 	}
-	
+
 /**
  * Prevents uninitialized instances from being created outside the package.
  */
@@ -121,7 +132,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -283,14 +294,14 @@
 /**
  * Checks that this class can be subclassed.
  * <p>
- * The SWT class library is intended to be subclassed 
- * only at specific, controlled points (most notably, 
+ * The SWT class library is intended to be subclassed
+ * only at specific, controlled points (most notably,
  * <code>Composite</code> and <code>Canvas</code> when
  * implementing new widgets). This method enforces this
  * rule unless it is overridden.
  * </p><p>
  * <em>IMPORTANT:</em> By providing an implementation of this
- * method that allows a subclass of a class which does not 
+ * method that allows a subclass of a class which does not
  * normally allow subclassing to be created, the implementer
  * agrees to be fully responsible for the fact that any such
  * subclass will likely fail between SWT releases and will be
@@ -321,7 +332,7 @@
  * widget implementors to enforce the standard SWT invariants.
  * <p>
  * Currently, it is an error to invoke any method (other than
- * <code>isDisposed()</code>) on a widget that has had its 
+ * <code>isDisposed()</code>) on a widget that has had its
  * <code>dispose()</code> method called. It is also an error
  * to call widget methods from any thread that is different
  * from the thread that created the widget.
@@ -350,10 +361,10 @@
 		* error happens seems to fix the problem.  The
 		* fix is to use operating system calls to verify
 		* that the current thread is not the Display thread.
-		* 
+		*
 		* NOTE: Despite the fact that Thread.currentThread()
 		* is used in other places, the failure has not been
-		* observed in all places where it is called. 
+		* observed in all places where it is called.
 		*/
 		if (display.threadId != OS.GetCurrentThreadId ()) {
 			error (SWT.ERROR_THREAD_INVALID_ACCESS);
@@ -378,7 +389,7 @@
  * See also <code>releaseChild()</code>, <code>releaseWidget()</code>
  * and <code>releaseHandle()</code>.
  * </p>
- * 
+ *
  * @see #dispose
  */
 void destroyWidget () {
@@ -503,7 +514,7 @@
  * Returns the application defined widget data associated
  * with the receiver, or null if it has not been set. The
  * <em>widget data</em> is a single, unnamed field that is
- * stored with every widget. 
+ * stored with every widget.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the widget data needs to be notified
@@ -584,8 +595,8 @@
 }
 
 /**
- * Returns an array of listeners who will be notified when an event 
- * of the given type occurs. The event type is one of the event constants 
+ * Returns an array of listeners who will be notified when an event
+ * of the given type occurs. The event type is one of the event constants
  * defined in class <code>SWT</code>.
  *
  * @param eventType the type of event to listen for
@@ -601,7 +612,7 @@
  * @see #addListener(int, Listener)
  * @see #removeListener(int, Listener)
  * @see #notifyListeners
- * 
+ *
  * @since 3.4
  */
 public Listener[] getListeners (int eventType) {
@@ -679,9 +690,10 @@
  *
  * @see #isListening
  */
-boolean hooks (int eventType) {
-	if (eventTable == null) return false;
-	return eventTable.hooks (eventType);
+// <QFS/> made public
+public boolean hooks (int eventType) {
+        if (eventTable == null) return false;
+        return eventTable.hooks (eventType);
 }
 
 /**
@@ -762,7 +774,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see SWT
  * @see #addListener
  * @see #getListeners(int)
@@ -794,9 +806,9 @@
  * this scenario, the children are actually destroyed later,
  * when the operating system destroys the widget tree.
  * </p>
- * 
+ *
  * @param destroy indicates that the receiver should be destroyed
- * 
+ *
  * @see #dispose
  * @see #releaseHandle
  * @see #releaseParent
@@ -861,7 +873,7 @@
  * bar requires that the menu bar first be released from the
  * shell when the menu bar is active.
  * </p>
- * 
+ *
  * @see #dispose
  * @see #releaseChildren
  * @see #releaseWidget
@@ -884,7 +896,7 @@
  * a reference to a disposed widget, all fields except the
  * handle are zero'd.  The handle is needed by <code>destroyWidget</code>.
  * </p>
- * 
+ *
  * @see #dispose
  * @see #releaseChildren
  * @see #releaseHandle
@@ -947,7 +959,7 @@
  *
  * @see Listener
  * @see #addListener
- * 
+ *
  * @noreference This method is not intended to be referenced by clients.
  */
 protected void removeListener (int eventType, SWTEventListener listener) {
@@ -982,14 +994,14 @@
 }
 
 /**
- * Marks the widget to be skinned. 
+ * Marks the widget to be skinned.
  * <p>
  * The skin event is sent to the receiver's display when appropriate (usually before the next event
  * is handled). Widgets are automatically marked for skinning upon creation as well as when its skin
- * id or class changes. The skin id and/or class can be changed by calling <code>Display.setData(String, Object)</code> 
- * with the keys SWT.SKIN_ID and/or SWT.SKIN_CLASS. Once the skin event is sent to a widget, it 
- * will not be sent again unless <code>reskin(int)</code> is called on the widget or on an ancestor 
- * while specifying the <code>SWT.ALL</code> flag.  
+ * id or class changes. The skin id and/or class can be changed by calling <code>Display.setData(String, Object)</code>
+ * with the keys SWT.SKIN_ID and/or SWT.SKIN_CLASS. Once the skin event is sent to a widget, it
+ * will not be sent again unless <code>reskin(int)</code> is called on the widget or on an ancestor
+ * while specifying the <code>SWT.ALL</code> flag.
  * </p>
  * <p>
  * The parameter <code>flags</code> may be either:
@@ -1001,8 +1013,8 @@
  * </dl>
  * </p>
  * @param flags the flags specifying how to reskin
- * 
- * @exception SWTException 
+ *
+ * @exception SWTException
  * <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
@@ -1015,7 +1027,7 @@
 	if ((flags & SWT.ALL) != 0) reskinChildren (flags);
 }
 
-void reskinChildren (int flags) {	
+void reskinChildren (int flags) {
 }
 
 void reskinWidget() {
@@ -1058,8 +1070,9 @@
 	sendEvent (eventType, null, true);
 }
 
-void sendEvent (int eventType, Event event) {
-	sendEvent (eventType, event, true);
+// <QFS/> Made public.
+public void sendEvent (int eventType, Event event) {
+        sendEvent (eventType, event, true);
 }
 
 void sendEvent (int eventType, Event event, boolean send) {
@@ -1148,7 +1161,7 @@
 		/* Check if the delta and the remainder have the same direction (sign) */
 		if ((delta ^ display.scrollHRemainder) >= 0) delta += display.scrollHRemainder;
 		display.scrollHRemainder = delta % OS.WHEEL_DELTA;
-		
+
 		delta = -delta;
 	}
 
@@ -1165,7 +1178,7 @@
  * Sets the application defined widget data associated
  * with the receiver to be the argument. The <em>widget
  * data</em> is a single, unnamed field that is stored
- * with every widget. 
+ * with every widget.
  * <p>
  * Applications may put arbitrary objects in this field. If
  * the object stored in the widget data needs to be notified
@@ -1180,7 +1193,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - when the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - when called from the wrong thread</li>
  * </ul>
- * 
+ *
  * @see #getData()
  */
 public void setData (Object data) {
@@ -1269,12 +1282,13 @@
 }
 
 boolean setInputState (Event event, int type) {
-	if (OS.GetKeyState (OS.VK_MENU) < 0) event.stateMask |= SWT.ALT;
-	if (OS.GetKeyState (OS.VK_SHIFT) < 0) event.stateMask |= SWT.SHIFT;
-	if (OS.GetKeyState (OS.VK_CONTROL) < 0) event.stateMask |= SWT.CONTROL;
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) event.stateMask |= SWT.BUTTON1;
-	if (OS.GetKeyState (OS.VK_MBUTTON) < 0) event.stateMask |= SWT.BUTTON2;
-	if (OS.GetKeyState (OS.VK_RBUTTON) < 0) event.stateMask |= SWT.BUTTON3;
+        // <QFS/> changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_MENU) < 0) event.stateMask |= SWT.ALT;
+	if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) event.stateMask |= SWT.SHIFT;
+	if (getDisplay().GetKeyState (OS.VK_CONTROL) < 0) event.stateMask |= SWT.CONTROL;
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) event.stateMask |= SWT.BUTTON1;
+	if (getDisplay().GetKeyState (OS.VK_MBUTTON) < 0) event.stateMask |= SWT.BUTTON2;
+	if (getDisplay().GetKeyState (OS.VK_RBUTTON) < 0) event.stateMask |= SWT.BUTTON3;
 	/*
 	* Bug in Windows.  On some machines that do not have XBUTTONs,
 	* the MK_XBUTTON1 and OS.MK_XBUTTON2 bits are sometimes set,
@@ -1282,8 +1296,8 @@
 	* for the extra buttons only when they exist.
 	*/
 	if (display.xMouse) {
-		if (OS.GetKeyState (OS.VK_XBUTTON1) < 0) event.stateMask |= SWT.BUTTON4;
-		if (OS.GetKeyState (OS.VK_XBUTTON2) < 0) event.stateMask |= SWT.BUTTON5;
+	if (getDisplay().GetKeyState (OS.VK_XBUTTON1) < 0) event.stateMask |= SWT.BUTTON4;
+	if (getDisplay().GetKeyState (OS.VK_XBUTTON2) < 0) event.stateMask |= SWT.BUTTON5;
 	}
 	switch (type) {
 		case SWT.MouseDown:
@@ -1312,12 +1326,12 @@
 			if (event.keyCode == SWT.SHIFT) event.stateMask |= SWT.SHIFT;
 			if (event.keyCode == SWT.CONTROL) event.stateMask |= SWT.CONTROL;
 			break;
-	}		
+	}
 	return true;
 }
 
 boolean setKeyState (Event event, int type, int /*long*/ wParam, int /*long*/ lParam) {
-	
+
 	/*
 	* Feature in Windows.  When the user presses Ctrl+Backspace
 	* or Ctrl+Enter, Windows sends a WM_CHAR with Delete (0x7F)
@@ -1333,13 +1347,13 @@
 			if (display.lastKey == SWT.CR) display.lastAscii = SWT.CR;
 			break;
 	}
-	
+
 	/*
 	* Feature in Windows.  When the user presses either the Enter
 	* key or the numeric keypad Enter key, Windows sends a WM_KEYDOWN
 	* with wParam=VK_RETURN in both cases.  In order to distinguish
 	* between the keys, the extended key bit is tested. If the bit
-	* is set, assume that the numeric keypad Enter was pressed. 
+	* is set, assume that the numeric keypad Enter was pressed.
 	*/
 	if (display.lastKey == SWT.CR && display.lastAscii == SWT.CR) {
 		if ((lParam & 0x1000000) != 0) display.lastKey = SWT.KEYPAD_CR;
@@ -1346,7 +1360,7 @@
 	}
 
 	setLocationMask(event, type, wParam, lParam);
-	
+
 	if (display.lastVirtual) {
 		/*
 		* Feature in Windows.  The virtual key VK_DELETE is not
@@ -1356,7 +1370,7 @@
 		* the ASCII value explicitly (Delete is 0x7F).
 		*/
 		if (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;
-		
+
 		/*
 		* Feature in Windows.  When the user presses Ctrl+Pause, the
 		* VK_CANCEL key is generated and a WM_CHAR is sent with 0x03,
@@ -1363,10 +1377,10 @@
 		* possibly to allow an application to look for Ctrl+C and the
 		* the Break key at the same time.  This is unexpected and
 		* unwanted.  The fix is to detect the case and set the character
-		* to zero. 
+		* to zero.
 		*/
 		if (display.lastKey == OS.VK_CANCEL) display.lastAscii = 0x0;
-		
+
 		event.keyCode = Display.translateKey (display.lastKey);
 	} else {
 		event.keyCode = display.lastKey;
@@ -1391,8 +1405,8 @@
 			case OS.VK_NUMLOCK:
 				location = SWT.KEYPAD;
 				break;
-			case OS.VK_CONTROL:	
-			case OS.VK_MENU:	
+			case OS.VK_CONTROL:
+			case OS.VK_MENU:
 				location = (lParam & 0x1000000) == 0 ? SWT.LEFT : SWT.RIGHT;
 				break;
 			case OS.VK_INSERT:
@@ -1457,31 +1471,48 @@
 	return OS.SetWindowPos (hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
 }
 
+public // <QFS/> temporarily made public
 boolean showMenu (int x, int y) {
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("showMenu(int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("this: ").add(this)
+         .add(", x: ").add(x)
+         .add(", y: ").add(y)).log(Log.MTD);
+    }
+    if (logger.level >= Log.DBG) {
+        logger.dumpStack(Log.DBG, "showMenu(int,int)", "");
+    }
+    // </QFS>
 	return showMenu (x, y, SWT.MENU_MOUSE);
 }
 
+public // <QFS/> temporarily made public
 boolean showMenu (int x, int y, int detail) {
-	Event event = new Event ();
-	event.x = x;
-	event.y = y;
+    Event event = new Event ();
+        event.x = x;
+        event.y = y;
 	event.detail = detail;
 	if (event.detail == SWT.MENU_KEYBOARD) {
 		updateMenuLocation (event);
 	}
-	sendEvent (SWT.MenuDetect, event);
+        sendEvent (SWT.MenuDetect, event);
 	// widget could be disposed at this point
 	if (isDisposed ()) return false;
-	if (!event.doit) return true;
-	Menu menu = getMenu ();
-	if (menu != null && !menu.isDisposed ()) {
-		if (x != event.x || y != event.y) {
-			menu.setLocation (event.x, event.y);
-		}
-		menu.setVisible (true);
-		return true;
-	}
-	return false;
+        if (!event.doit) return true;
+        Menu menu = getMenu ();
+        if (menu != null && !menu.isDisposed ()) {
+                // <QFS> Always force desired location, otherwise the popup will always
+                // appear at the location of the mouse cursor
+                // if (event.x != x || event.y != y) {
+                menu.setLocation (event.x, event.y);
+                // }
+                // </QFS>
+                menu.setVisible (true);
+                return true;
+        }
+        return false;
 }
 
 /**
@@ -1526,49 +1557,76 @@
 }
 
 LRESULT wmContextMenu (int /*long*/ hwnd, int /*long*/ wParam, int /*long*/ lParam) {
-	if (wParam != hwnd) return null;
-	
-	/*
-	* Feature in Windows.  SHRecognizeGesture() sends an undocumented
-	* WM_CONTEXTMENU notification when the flag SHRG_NOTIFY_PARENT is
-	* not set.  This causes the context menu to be displayed twice,
-	* once by the caller of SHRecognizeGesture() and once from this
-	* method.  The fix is to ignore WM_CONTEXTMENU notifications on
-	* all WinCE platforms.
-	* 
-	* NOTE: This only happens on WM2003.  Previous WinCE versions did
-	* not support WM_CONTEXTMENU.
-	*/
-	if (OS.IsWinCE) return null;
-	
-	/*
-	* Feature in Windows.  When the user presses  WM_NCRBUTTONUP,
-	* a WM_CONTEXTMENU message is generated.  This happens when
-	* the user releases the mouse over a scroll bar.  Normally,
-	* window displays the default scrolling menu but applications
-	* can process WM_CONTEXTMENU to display a different menu.
-	* Typically, an application does not want to supply a special
-	* scroll menu.  The fix is to look for a WM_CONTEXTMENU that
-	* originated from a mouse event and display the menu when the
-	* mouse was released in the client area.
-	*/
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmContextMenu(int,int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").add(hwnd)
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+    if (wParam != hwnd) return null;
+
+        /*
+        * Feature in Windows.  SHRecognizeGesture() sends an undocumented
+        * WM_CONTEXTMENU notification when the flag SHRG_NOTIFY_PARENT is
+        * not set.  This causes the context menu to be displayed twice,
+        * once by the caller of SHRecognizeGesture() and once from this
+        * method.  The fix is to ignore WM_CONTEXTMENU notifications on
+        * all WinCE platforms.
+        *
+        * NOTE: This only happens on WM2003.  Previous WinCE versions did
+        * not support WM_CONTEXTMENU.
+        */
+        if (OS.IsWinCE) return null;
+
+        /*
+        * Feature in Windows.  When the user presses  WM_NCRBUTTONUP,
+        * a WM_CONTEXTMENU message is generated.  This happens when
+        * the user releases the mouse over a scroll bar.  Normally,
+        * window displays the default scrolling menu but applications
+        * can process WM_CONTEXTMENU to display a different menu.
+        * Typically, an application does not want to supply a special
+        * scroll menu.  The fix is to look for a WM_CONTEXTMENU that
+        * originated from a mouse event and display the menu when the
+        * mouse was released in the client area.
+        */
 	int x = 0, y = 0, detail = 0;
-	if (lParam != -1) {
-		POINT pt = new POINT ();
+        if (lParam != -1) {
+                POINT pt = new POINT ();
 		OS.POINTSTOPOINT (pt, lParam);
 		x = pt.x;
 		y = pt.y;
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(int,int,int)")
+                        .add("pt1: ").add(pt).log(Log.DBG);
+                }
+                // </QFS>
 		detail = SWT.MENU_MOUSE;
-		OS.ScreenToClient (hwnd, pt);
-		RECT rect = new RECT ();
-		OS.GetClientRect (hwnd, rect);
-		if (!OS.PtInRect (rect, pt)) return null;
-	} else {
-		int pos = OS.GetMessagePos ();
+                OS.ScreenToClient (hwnd, pt);
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(int,int,int)")
+                        .add("pt2: ").add(pt).log(Log.DBG);
+                }
+                // </QFS>
+                RECT rect = new RECT ();
+                // <QFS>
+                if (logger.level >= Log.DBG) {
+                    logger.build("wmContextMenu(int,int,int)")
+                        .add("rect: ").add(rect).log(Log.DBG);
+                }
+                // </QFS>
+                OS.GetClientRect (hwnd, rect);
+                if (!OS.PtInRect (rect, pt)) return null;
+        } else {
+                int pos = OS.GetMessagePos ();
 		x = OS.GET_X_LPARAM (pos);
 		y = OS.GET_Y_LPARAM (pos);
 		detail = SWT.MENU_KEYBOARD;
-	}
+        }
 
 	/* Show the menu */
 	return showMenu (x, y, detail) ? LRESULT.ZERO : null;
@@ -1589,247 +1647,312 @@
 }
 
 LRESULT wmKeyDown (int /*long*/ hwnd, int /*long*/ wParam, int /*long*/ lParam) {
-	
-	/* Ignore repeating modifier keys by testing key down state */
+    // <QFS>
+    if (logger.level >= Log.MTD) {
+        Logger.Builder lb = logger.build("wmKeyDown(int,int,int)");
+        (logger.level < Log.MTDDETAIL ? lb : lb
+         .add("hwnd: ").add(hwnd)
+         .add(", wParam: ").add(wParam)
+         .add(", lParam: ").add(lParam)).log(Log.MTD);
+    }
+    // </QFS>
+
+        /* Ignore repeating modifier keys by testing key down state */
 	switch ((int)/*64*/wParam) {
-		case OS.VK_SHIFT:
-		case OS.VK_MENU:
-		case OS.VK_CONTROL:
-		case OS.VK_CAPITAL:
-		case OS.VK_NUMLOCK:
-		case OS.VK_SCROLL:
-			if ((lParam & 0x40000000) != 0) return null;
-	}
-	
-	/* Clear last key and last ascii because a new key has been typed */
-	display.lastAscii = display.lastKey = 0;
-	display.lastVirtual = display.lastNull = display.lastDead = false;
-	
-	/*
-	* Do not report a lead byte as a key pressed.
-	*/
-	if (!OS.IsUnicode && OS.IsDBLocale) {
-		byte lead = (byte) (wParam & 0xFF);
-		if (OS.IsDBCSLeadByte (lead)) return null;
-	}
-	
-	/* Map the virtual key */
-	/*
-	* Bug in WinCE.  MapVirtualKey() returns incorrect values.
-	* The fix is to rely on a key mappings table to determine
-	* whether the key event must be sent now or if a WM_CHAR
-	* event will follow.  The key mappings table maps virtual
-	* keys to SWT key codes and does not contain mappings for
-	* Windows virtual keys like VK_A.  Virtual keys that are
-	* both virtual and ASCII are a special case.
-	*/
-	int mapKey = 0;
-	if (OS.IsWinCE) {
+                case OS.VK_SHIFT:
+                case OS.VK_MENU:
+                case OS.VK_CONTROL:
+                case OS.VK_CAPITAL:
+                case OS.VK_NUMLOCK:
+                case OS.VK_SCROLL:
+                        if ((lParam & 0x40000000) != 0) return null;
+        }
+
+        /* Clear last key and last ascii because a new key has been typed */
+        display.lastAscii = display.lastKey = 0;
+        display.lastVirtual = display.lastNull = display.lastDead = false;
+
+        /*
+         * Do not report a lead byte as a key pressed.
+         */
+        if (!OS.IsUnicode && OS.IsDBLocale) {
+                byte lead = (byte) (wParam & 0xFF);
+                if (OS.IsDBCSLeadByte (lead)) return null;
+        }
+
+        /* Map the virtual key */
+        /*
+        * Bug in WinCE.  MapVirtualKey() returns incorrect values.
+        * The fix is to rely on a key mappings table to determine
+        * whether the key event must be sent now or if a WM_CHAR
+        * event will follow.  The key mappings table maps virtual
+        * keys to SWT key codes and does not contain mappings for
+        * Windows virtual keys like VK_A.  Virtual keys that are
+        * both virtual and ASCII are a special case.
+        */
+        int mapKey = 0;
+        if (OS.IsWinCE) {
 		switch ((int)/*64*/wParam) {
-			case OS.VK_BACK: mapKey = SWT.BS; break;
-			case OS.VK_RETURN: mapKey = SWT.CR; break;
-			case OS.VK_DELETE: mapKey = SWT.DEL; break;
-			case OS.VK_ESCAPE: mapKey = SWT.ESC; break;
-			case OS.VK_TAB: mapKey = SWT.TAB; break;
-		}
-	} else {
+                        case OS.VK_BACK: mapKey = SWT.BS; break;
+                        case OS.VK_RETURN: mapKey = SWT.CR; break;
+                        case OS.VK_DELETE: mapKey = SWT.DEL; break;
+                        case OS.VK_ESCAPE: mapKey = SWT.ESC; break;
+                        case OS.VK_TAB: mapKey = SWT.TAB; break;
+                }
+        } else {
 		mapKey = OS.MapVirtualKey ((int)/*64*/wParam, 2);
 		/*
 		* Feature in Windows.  For Devanagari and Bengali numbers,
-		* MapVirtualKey() returns the localized number instead of 
+		* MapVirtualKey() returns the localized number instead of
 		* the ASCII equivalent.  For example, MapVirtualKey()
 		* maps VK_1 on the numbers keyboard to \u0967, which is
 		* the Devanagari digit '1', but not ASCII.
-		* The fix is to test for Devanagari and Bengali digits and 
+		* The fix is to test for Devanagari and Bengali digits and
 		* map these explicitly.
-		* 
+		*
 		* NOTE: VK_0 to VK_9 are the same as ASCII.
 		*/
 		if (('\u09e6' <= mapKey && mapKey <= '\u09ef') || ('\u0966' <= mapKey && mapKey <= '\u096f')) {
 			mapKey = (int)/*64*/wParam;
-		}
+        }
 	}
 
-	/*
-	* Bug in Windows 95 and NT.  When the user types an accent key such
-	* as ^ to get an accented character on a German keyboard, the accent
-	* key should be ignored and the next key that the user types is the
-	* accented key.  The fix is to detect the accent key stroke (called
-	* a dead key) by testing the high bit of the value returned by
-	* MapVirtualKey().  A further problem is that the high bit on
-	* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
-	* They should both be bit 32.
-	*
-	* When the user types an accent key that does not correspond to a
-	* virtual key, MapVirtualKey() won't set the high bit to indicate
-	* a dead key.  This happens when an accent key, such as '^' is the
-	* result of a modifier such as Shift key and MapVirtualKey() always
-	* returns the unshifted key.  The fix is to peek for a WM_DEADCHAR
-	* and avoid issuing the event. 
-	*/
-	if (OS.IsWinNT) {
-		if ((mapKey & 0x80000000) != 0) return null;
-	} else {
-		if ((mapKey & 0x8000) != 0) return null;
-	}
-	MSG msg = new MSG ();
-	int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;
-	if (OS.PeekMessage (msg, hwnd, OS.WM_DEADCHAR, OS.WM_DEADCHAR, flags)) {
-		display.lastDead = true;
-		display.lastVirtual = mapKey == 0;
+        /*
+        * Bug in Windows 95 and NT.  When the user types an accent key such
+        * as ^ to get an accented character on a German keyboard, the accent
+        * key should be ignored and the next key that the user types is the
+        * accented key.  The fix is to detect the accent key stroke (called
+        * a dead key) by testing the high bit of the value returned by
+        * MapVirtualKey().  A further problem is that the high bit on
+        * Windows NT is bit 32 while the high bit on Windows 95 is bit 16.
+        * They should both be bit 32.
+        *
+        * When the user types an accent key that does not correspond to a
+        * virtual key, MapVirtualKey() won't set the high bit to indicate
+        * a dead key.  This happens when an accent key, such as '^' is the
+        * result of a modifier such as Shift key and MapVirtualKey() always
+        * returns the unshifted key.  The fix is to peek for a WM_DEADCHAR
+        * and avoid issuing the event.
+        */
+        if (OS.IsWinNT) {
+                if ((mapKey & 0x80000000) != 0) return null;
+        } else {
+                if ((mapKey & 0x8000) != 0) return null;
+        }
+        MSG msg = new MSG ();
+        int flags = OS.PM_NOREMOVE | OS.PM_NOYIELD | OS.PM_QS_INPUT | OS.PM_QS_POSTMESSAGE;
+        if (OS.PeekMessage (msg, hwnd, OS.WM_DEADCHAR, OS.WM_DEADCHAR, flags)) {
+                display.lastDead = true;
+                display.lastVirtual = mapKey == 0;
 		display.lastKey = display.lastVirtual ? (int)/*64*/wParam : mapKey;
-		return null;
-	}
-	
-	/*
-	*  Bug in Windows.  Somehow, the widget is becoming disposed after
-	*  calling PeekMessage().  In rare circumstances, it seems that
-	*  PeekMessage() can allow SWT listeners to run that might contain
-	*  application code that disposes the widget.  It is not exactly
-	*  clear how this can happen.  PeekMessage() is only looking for
-	*  WM_DEADCHAR.  It is not dispatching any message that it finds
-	*  or removing any message from the queue.  Cross-thread messages
-	*  are disabled.  The fix is to check for a disposed widget and
-	*  return without calling the window proc.
-	*/
-	if (isDisposed ()) return LRESULT.ONE;
-	
-	/*
-	* If we are going to get a WM_CHAR, ensure that last key has
-	* the correct character value for the key down and key up
-	* events.  It is not sufficient to ignore the WM_KEYDOWN
-	* (when we know we are going to get a WM_CHAR) and compute
-	* the key in WM_CHAR because there is not enough information
-	* by the time we get the WM_CHAR.  For example, when the user
-	* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with 
-	* wParam=30.  When the user types Ctrl+Shift+6 on a German 
-	* keyboard, we also get a WM_CHAR with wParam=30.  On the US
-	* keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.
-	* There is no way to map wParam=30 in WM_CHAR to the correct
-	* value.  Also, on international keyboards, the control key
-	* may be down when the user has not entered a control character.
-	* 
-	* NOTE: On Windows 98, keypad keys are virtual despite the
-	* fact that a WM_CHAR is issued.  On Windows 2000 and XP,
-	* they are not virtual.  Therefore it is necessary to force
-	* numeric keypad keys to be virtual.
-	*/
+                return null;
+        }
+
+        /*
+        *  Bug in Windows.  Somehow, the widget is becoming disposed after
+        *  calling PeekMessage().  In rare cirucmstances, it seems that
+        *  PeekMessage() can allow SWT listeners to run that might contain
+        *  application code that disposes the widget.  It is not exactly
+        *  clear how this can happen.  PeekMessage() is only looking for
+        *  WM_DEADCHAR.  It is not dispatching any message that it finds
+        *  or removing any message from the queue.  Cross-thread messages
+        *  are disabled.  The fix is to check for a disposed widget and
+        *  return without calling the window proc.
+        */
+        if (isDisposed ()) return LRESULT.ONE;
+
+        /*
+        * If we are going to get a WM_CHAR, ensure that last key has
+        * the correct character value for the key down and key up
+        * events.  It is not sufficient to ignore the WM_KEYDOWN
+        * (when we know we are going to get a WM_CHAR) and compute
+        * the key in WM_CHAR because there is not enough information
+        * by the time we get the WM_CHAR.  For example, when the user
+        * types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with
+        * wParam=30.  When the user types Ctrl+Shift+6 on a German
+        * keyboard, we also get a WM_CHAR with wParam=30.  On the US
+        * keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.
+        * There is no way to map wParam=30 in WM_CHAR to the correct
+        * value.  Also, on international keyboards, the control key
+        * may be down when the user has not entered a control character.
+        *
+        * NOTE: On Windows 98, keypad keys are virtual despite the
+        * fact that a WM_CHAR is issued.  On Windows 2000 and XP,
+        * they are not virtual.  Therefore it is necessary to force
+        * numeric keypad keys to be virtual.
+        */
 	display.lastVirtual = mapKey == 0 || display.numpadKey ((int)/*64*/wParam) != 0;
-	if (display.lastVirtual) {
+        if (display.lastVirtual) {
 		display.lastKey = (int)/*64*/wParam;
-		/*
-		* Feature in Windows.  The virtual key VK_DELETE is not
-		* treated as both a virtual key and an ASCII key by Windows.
-		* Therefore, we will not receive a WM_CHAR for this key.
-		* The fix is to treat VK_DELETE as a special case and map
-		* the ASCII value explicitly (Delete is 0x7F).
-		*/
-		if (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;
+                /*
+                * Feature in Windows.  The virtual key VK_DELETE is not
+                * treated as both a virtual key and an ASCII key by Windows.
+                * Therefore, we will not receive a WM_CHAR for this key.
+                * The fix is to treat VK_DELETE as a special case and map
+                * the ASCII value explictly (Delete is 0x7F).
+                */
+                if (display.lastKey == OS.VK_DELETE) display.lastAscii = 0x7F;
 
-		/*
-		* It is possible to get a WM_CHAR for a virtual key when
-		* Num Lock is on.  If the user types Home while Num Lock 
-		* is down, a WM_CHAR is issued with WPARM=55 (for the
-		* character 7).  If we are going to get a WM_CHAR we need
-		* to ensure that the last key has the correct value.  Note
-		* that Ctrl+Home does not issue a WM_CHAR when Num Lock is
-		* down.
-		*/
-		if (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {
-			/*
-			* Feature in Windows.  Calling to ToAscii() or ToUnicode(), clears
-			* the accented state such that the next WM_CHAR loses the accent.
-			* This makes is critical that the accent key is detected.  Also,
-			* these functions clear the character that is entered using the
-			* special Windows keypad sequence when NumLock is down (ie. typing 
-			* ALT+0231 should gives 'c' with a cedilla when NumLock is down).
-			*/
-			if (display.asciiKey (display.lastKey) != 0) return null;
-			display.lastAscii = display.numpadKey (display.lastKey);
-		}
-	} else {
-		/*
-		* Convert LastKey to lower case because Windows non-virtual
-		* keys that are also ASCII keys, such as like VK_A, are have
-		* upper case values in WM_KEYDOWN despite the fact that the 
-		* Shift was not pressed.
-		*/
+                /*
+                * It is possible to get a WM_CHAR for a virtual key when
+                * Num Lock is on.  If the user types Home while Num Lock
+                * is down, a WM_CHAR is issued with WPARM=55 (for the
+                * character 7).  If we are going to get a WM_CHAR we need
+                * to ensure that the last key has the correct value.  Note
+                * that Ctrl+Home does not issue a WM_CHAR when Num Lock is
+                * down.
+                */
+                if (OS.VK_NUMPAD0 <= display.lastKey && display.lastKey <= OS.VK_DIVIDE) {
+                        /*
+                        * Feature in Windows.  Calling to ToAscii() or ToUnicode(), clears
+                        * the accented state such that the next WM_CHAR loses the accent.
+                        * This makes is critical that the accent key is detected.  Also,
+                        * these functions clear the character that is entered using the
+                        * special Windows keypad sequence when NumLock is down (ie. typing
+                        * ALT+0231 should gives 'c' with a cedilla when NumLock is down).
+                        */
+                    // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                                   "lastKey-test");
+                    }
+                    // </QFS>
+
+                        if (display.asciiKey (display.lastKey) != 0) return null;
+                        display.lastAscii = display.numpadKey (display.lastKey);
+                }
+        } else {
+                /*
+                * Convert LastKey to lower case because Windows non-virtual
+                * keys that are also ASCII keys, such as like VK_A, are have
+                * upper case values in WM_KEYDOWN despite the fact that the
+                * Shift was not pressed.
+                */
 	 	display.lastKey = (int)/*64*/OS.CharLower ((short) mapKey);
 
-		/*
-		* Feature in Windows. The virtual key VK_CANCEL is treated
-		* as both a virtual key and ASCII key by Windows.  This
-		* means that a WM_CHAR with WPARAM=3 will be issued for
-		* this key.  In order to distinguish between this key and
-		* Ctrl+C, mark the key as virtual.
-		*/
-		if (wParam == OS.VK_CANCEL) display.lastVirtual = true;
-		
-		/*
-		* Some key combinations map to Windows ASCII keys depending
-		* on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a
-		* German keyboard.  If the current key combination is special,
-		* the correct character is placed in wParam for processing in
-		* WM_CHAR.  If this is the case, issue the key down event from
-		* inside WM_CHAR.
-		*/
+                /*
+                * Feature in Windows. The virtual key VK_CANCEL is treated
+                * as both a virtual key and ASCII key by Windows.  This
+                * means that a WM_CHAR with WPARAM=3 will be issued for
+                * this key.  In order to distinguish between this key and
+                * Ctrl+C, mark the key as virtual.
+                */
+                if (wParam == OS.VK_CANCEL) display.lastVirtual = true;
+
+                /*
+                * Some key combinations map to Windows ASCII keys depending
+                * on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a
+                * German keyboard.  If the current key combination is special,
+                * the correct character is placed in wParam for processing in
+                * WM_CHAR.  If this is the case, issue the key down event from
+                * inside WM_CHAR.
+                */
 		int asciiKey = display.asciiKey ((int)/*64*/wParam);
-		if (asciiKey != 0) {
-			/*
-			* When the user types Ctrl+Space, ToAscii () maps this to
-			* Space.  Normally, ToAscii () maps a key to a different
-			* key if both a WM_KEYDOWN and a WM_CHAR will be issued.
-			* To avoid the extra SWT.KeyDown, look for a space and
-			* issue the event from WM_CHAR.
-			*/
-			if (asciiKey == ' ') return null;
+                if (asciiKey != 0) {
+                        /*
+                        * When the user types Ctrl+Space, ToAscii () maps this to
+                        * Space.  Normally, ToAscii () maps a key to a different
+                        * key if both a WM_KEYDOWN and a WM_CHAR will be issued.
+                        * To avoid the extra SWT.KeyDown, look for a space and
+                        * issue the event from WM_CHAR.
+                        */
+                    // <QFS>
+                    if (logger.level >= Log.MTDDETAIL) {
+                        logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                                   "asciiKey test1");
+                    }
+                    // </QFS>
+
+                    if (asciiKey == ' ') return null;
+                    // <QFS>
+                    if (logger.level >= Log.DBG) {
+                        logger.build("wmKeyDown(int,int,int)")
+                            .add("asciiKey test2: asciiKey=").add(asciiKey)
+                            .add(" ==? wParam=").addHex(wParam).log(Log.DBG);
+                    }
+                    // </QFS>
+
 			if (asciiKey != (int)/*64*/wParam) return null;
-			/*
-			* Feature in Windows. The virtual key VK_CANCEL is treated
-			* as both a virtual key and ASCII key by Windows.  This
-			* means that a WM_CHAR with WPARAM=3 will be issued for
-			* this key. To avoid the extra SWT.KeyDown, look for
-			* VK_CANCEL and issue the event from WM_CHAR.
-			*/
-			if (wParam == OS.VK_CANCEL) return null;
-		}
-		
-		/*
-		* If the control key is not down at this point, then
-		* the key that was pressed was an accent key or a regular
-		* key such as 'A' or Shift+A.  In that case, issue the
-		* key event from WM_CHAR.
-		*/
-		if (OS.GetKeyState (OS.VK_CONTROL) >= 0) return null;
-		
-		/*
-		* Get the shifted state or convert to lower case if necessary.
-		* If the user types Ctrl+A, LastAscii should be 'a', not 'A'. 
-		* If the user types Ctrl+Shift+A, LastAscii should be 'A'.
-		* If the user types Ctrl+Shift+6, the value of LastAscii will
-		* depend on the international keyboard.
-		*/
-	 	if (OS.GetKeyState (OS.VK_SHIFT) < 0) {
+                        /*
+                        * Feature in Windows. The virtual key VK_CANCEL is treated
+                        * as both a virtual key and ASCII key by Windows.  This
+                        * means that a WM_CHAR with WPARAM=3 will be issued for
+                        * this key. To avoid the extra SWT.KeyDown, look for
+                        * VK_CANCEL and issue the event from WM_CHAR.
+                        */
+                        // <QFS>
+                        if (logger.level >= Log.MTDDETAIL) {
+                            logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                                       "cancel test");
+                        }
+                        // </QFS>
+
+                        if (wParam == OS.VK_CANCEL) return null;
+                }
+
+                /*
+                * If the control key is not down at this point, then
+                * the key that was pressed was an accent key or a regular
+                * key such as 'A' or Shift+A.  In that case, issue the
+                * key event from WM_CHAR.
+                */
+                // <QFS>
+                if (logger.level >= Log.MTDDETAIL) {
+                    logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                               "control test");
+                }
+                // </QFS>
+
+                // <QFS/> changed to getDisplay().GetKeyState
+                if (getDisplay().GetKeyState (OS.VK_CONTROL) >= 0) return null;
+
+                /*
+                * Get the shifted state or convert to lower case if necessary.
+                * If the user types Ctrl+A, LastAscii should be 'a', not 'A'.
+                * If the user types Ctrl+Shift+A, LastAscii should be 'A'.
+                * If the user types Ctrl+Shift+6, the value of LastAscii will
+                * depend on the international keyboard.
+                */
+                // <QFS/> changed to getDisplay().GetKeyState
+                if (getDisplay().GetKeyState (OS.VK_SHIFT) < 0) {
 			display.lastAscii = display.shiftedKey ((int)/*64*/wParam);
-			if (display.lastAscii == 0) display.lastAscii = mapKey;
-	 	} else {
+                        if (display.lastAscii == 0) display.lastAscii = mapKey;
+                } else {
 	 		display.lastAscii = (int)/*64*/OS.CharLower ((short) mapKey);
-	 	}
-	 			
-		/* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */
-		if (display.lastAscii == '@') return null;
-		display.lastAscii = display.controlKey (display.lastAscii);
-	}
-	if (!sendKeyEvent (SWT.KeyDown, OS.WM_KEYDOWN, wParam, lParam)) {
-		return LRESULT.ONE;
-	}
-	// widget could be disposed at this point
-	return null;
+                }
+                // <QFS>
+                if (logger.level >= Log.MTDDETAIL) {
+                    logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                               "@-test");
+                }
+                // </QFS>
+
+                /* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */
+                if (display.lastAscii == '@') return null;
+                display.lastAscii = display.controlKey (display.lastAscii);
+        }
+        // <QFS>
+        if (logger.level >= Log.MTDDETAIL) {
+            logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                       "doing sendKeyEvent now");
+        }
+        // </QFS>
+        if (!sendKeyEvent (SWT.KeyDown, OS.WM_KEYDOWN, wParam, lParam)) {
+                return LRESULT.ONE;
+        }
+        // <QFS>
+        if (logger.level >= Log.MTDDETAIL) {
+            logger.log(Log.MTDDETAIL, "wmKeyDown(int,int,int)",
+                       "sendKeyEvent failed");
+        }
+        // </QFS>
+        // widget could be disposed at this point
+        return null;
 }
 
 LRESULT wmKeyUp (int /*long*/ hwnd, int /*long*/ wParam, int /*long*/ lParam) {
 	Display display = this.display;
-	
+
 	/* Check for hardware keys */
 	if (OS.IsWinCE) {
 		if (OS.VK_APP1 <= wParam && wParam <= OS.VK_APP6) {
@@ -1844,7 +1967,7 @@
 			return null;
 		}
 	}
-	
+
 	/*
 	* If the key up is not hooked, reset last key
 	* and last ascii in case the key down is hooked.
@@ -1854,7 +1977,7 @@
 		display.lastVirtual = display.lastNull = display.lastDead = false;
 		return null;
 	}
-	
+
 	/* Map the virtual key. */
 	/*
 	* Bug in WinCE.  MapVirtualKey() returns incorrect values.
@@ -1934,7 +2057,7 @@
 	int /*long*/ code = callWindowProc (hwnd, OS.WM_KILLFOCUS, wParam, lParam);
 	sendFocusEvent (SWT.FocusOut);
 	// widget could be disposed at this point
-	
+
 	/*
 	* It is possible (but unlikely), that application
 	* code could have disposed the widget in the focus
@@ -1998,13 +2121,14 @@
 			consume = new boolean [1];
 			dragging = dragDetect (hwnd, x, y, true, detect, consume);
 			if (isDisposed ()) return LRESULT.ZERO;
-			mouseDown = OS.GetKeyState (OS.VK_LBUTTON) < 0;
+                        // <QFS/> changed to getDisplay().GetKeyState
+			mouseDown = getDisplay().GetKeyState (OS.VK_LBUTTON) < 0;
 		}
 	}
 	display.captureChanged = false;
 	boolean dispatch = sendMouseEvent (SWT.MouseDown, 1, count, 0, false, hwnd, OS.WM_LBUTTONDOWN, wParam, lParam);
 	if (dispatch && (consume == null || !consume [0])) {
-		result = new LRESULT (callWindowProc (hwnd, OS.WM_LBUTTONDOWN, wParam, lParam));	
+		result = new LRESULT (callWindowProc (hwnd, OS.WM_LBUTTONDOWN, wParam, lParam));
 	} else {
 		result = LRESULT.ZERO;
 	}
@@ -2021,7 +2145,7 @@
 			shrg.cbSize = SHRGINFO.sizeof;
 			shrg.hwndClient = hwnd;
 			shrg.ptDown_x = x;
-			shrg.ptDown_y = y; 
+			shrg.ptDown_y = y;
 			shrg.dwFlags = OS.SHRG_RETURNCMD;
 			int type = OS.SHRecognizeGesture (shrg);
 			if (type == OS.GN_CONTEXTMENU) showMenu (x, y);
@@ -2049,7 +2173,7 @@
 			* mouse down/up pairs or looks for the ESC key will not
 			* function properly.  The fix is to send the missing
 			* events when the drag has not started.
-			* 
+			*
 			* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP
 			* events for the ESC key.  This would require computing
 			* wParam (the key) and lParam (the repeat count, scan code,
@@ -2056,7 +2180,8 @@
 			* extended-key flag, context code, previous key-state flag,
 			* and transition-state flag) which is non-trivial.
 			*/
-			if (OS.GetKeyState (OS.VK_ESCAPE) >= 0) {
+                        // <QFS/> changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_ESCAPE) >= 0) {
 				OS.SendMessage (hwnd, OS.WM_LBUTTONUP, wParam, lParam);
 			}
 		}
@@ -2175,8 +2300,13 @@
 LRESULT wmMouseMove (int /*long*/ hwnd, int /*long*/ wParam, int /*long*/ lParam) {
 	LRESULT result = null;
 	Display display = this.display;
-	int pos = OS.GetMessagePos ();
-	if (pos != display.lastMouse || display.captureChanged) {
+    // <QFS> changed "OS.GetMessagePos" to "getDisplay().GetMessagePos" and test for overridden
+    // position and target
+    int pos = display.GetMessagePos ();
+    if ((! display.isReplaying()
+         || display.replayTarget == this)
+    // </QFS>
+	&& (pos != display.lastMouse || display.captureChanged)) {
 		if (!OS.IsWinCE) {
 			boolean trackMouse = (state & TRACK_MOUSE) != 0;
 			boolean mouseEnter = hooks (SWT.MouseEnter) || display.filters (SWT.MouseEnter);
@@ -2219,7 +2349,7 @@
 				result = LRESULT.ZERO;
 			}
 		}
-	} 
+	}
 	display.captureChanged = false;
 	return result;
 }
@@ -2242,7 +2372,7 @@
 	if (!hooks (SWT.Paint) && !filters (SWT.Paint)) {
 		return null;
 	}
-	
+
 	/* Issue a paint event */
 	int /*long*/ result = 0;
 	if (OS.IsWinCE) {
@@ -2438,7 +2568,7 @@
 	if (!hooks (SWT.KeyDown) && !display.filters (SWT.KeyDown)) {
 		return null;
 	}
-	
+
 	/* Call the window proc to determine whether it is a system key or mnemonic */
 	boolean oldKeyHit = display.mnemonicKeyHit;
 	display.mnemonicKeyHit = true;
@@ -2466,7 +2596,7 @@
 		/* Make sure WM_SYSKEYDOWN was sent by ALT-<aKey>. */
 		if ((lParam & 0x20000000) == 0) return null;
 	}
-	
+
 	/* Ignore well known system keys */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_F4: {
@@ -2479,7 +2609,7 @@
 			if ((bits & OS.WS_SYSMENU) != 0) return null;
 		}
 	}
-	
+
 	/* Ignore repeating modifier keys by testing key down state */
 	switch ((int)/*64*/wParam) {
 		case OS.VK_SHIFT:
@@ -2490,7 +2620,7 @@
 		case OS.VK_SCROLL:
 			if ((lParam & 0x40000000) != 0) return null;
 	}
-	
+
 	/* Clear last key and last ascii because a new key has been typed */
 	display.lastAscii = display.lastKey = 0;
 	display.lastVirtual = display.lastNull = display.lastDead = false;
@@ -2553,7 +2683,7 @@
 		/*
 		* Convert LastKey to lower case because Windows non-virtual
 		* keys that are also ASCII keys, such as like VK_A, are have
-		* upper case values in WM_SYSKEYDOWN despite the fact that the 
+		* upper case values in WM_SYSKEYDOWN despite the fact that the
 		* Shift was not pressed.
 		*/
 	 	display.lastKey = (int)/*64*/OS.CharLower ((short) mapKey);
Index: org/eclipse/swt/widgets/DirectoryDialog.java
===================================================================
--- org/eclipse/swt/widgets/DirectoryDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/DirectoryDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -14,6 +15,10 @@
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
 
 /**
  * Instances of this class allow the user to navigate
@@ -27,7 +32,7 @@
  * <p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/snippets/#directorydialog">DirectoryDialog snippets</a>
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample, Dialog tab</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
@@ -35,9 +40,18 @@
  */
 
 public class DirectoryDialog extends Dialog {
-	String message = "", filterPath = "";  //$NON-NLS-1$//$NON-NLS-2$
+
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.DirectoryDialog");
+    // </QFS>
+
+        String message = "", filterPath = "";  //$NON-NLS-1$//$NON-NLS-2$
 	String directoryPath;
-	
+
 /**
  * Constructs a new instance of this class given only its parent.
  *
@@ -61,7 +75,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -116,7 +130,7 @@
  * the directories it shows.
  *
  * @return the filter path
- * 
+ *
  * @see #setFilterPath
  */
 public String getFilterPath () {
@@ -148,9 +162,9 @@
  */
 public String open () {
 	if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);
-	
+
 	int /*long*/ hHeap = OS.GetProcessHeap ();
-	
+
 	/* Get the owner HWND for the dialog */
 	int /*long*/ hwndOwner = 0;
 	if (parent != null) hwndOwner = parent.handle;
@@ -181,7 +195,7 @@
 	Callback callback = new Callback (this, "BrowseCallbackProc", 4); //$NON-NLS-1$
 	int /*long*/ lpfn = callback.getAddress ();
 	if (lpfn == 0) error (SWT.ERROR_NO_MORE_CALLBACKS);
-	
+
 	/* Make the parent shell be temporary modal */
 	Dialog oldModal = null;
 	Display display = parent.getDisplay ();
@@ -189,7 +203,7 @@
 		oldModal = display.getModalDialog ();
 		display.setModalDialog (this);
 	}
-	
+
 	directoryPath = null;
 	BROWSEINFO lpbi = new BROWSEINFO ();
 	lpbi.hwndOwner = hwndOwner;
@@ -202,19 +216,36 @@
 	* Please insert a disk into \Device\Harddisk0\DR0".  This is possibly
 	* caused by SHBrowseForFolder() calling internally GetVolumeInformation().
 	* MSDN for GetVolumeInformation() says:
-	* 
+	*
 	* "If you are attempting to obtain information about a floppy drive
-	* that does not have a floppy disk or a CD-ROM drive that does not 
-	* have a compact disc, the system displays a message box asking the 
-	* user to insert a floppy disk or a compact disc, respectively. 
-	* To prevent the system from displaying this message box, call the 
+	* that does not have a floppy disk or a CD-ROM drive that does not
+	* have a compact disc, the system displays a message box asking the
+	* user to insert a floppy disk or a compact disc, respectively.
+	* To prevent the system from displaying this message box, call the
 	* SetErrorMode function with SEM_FAILCRITICALERRORS."
-	* 
+	*
 	* The fix is to save and restore the error mode using SetErrorMode()
 	* with the SEM_FAILCRITICALERRORS flag around SHBrowseForFolder().
 	*/
 	int oldErrorMode = OS.SetErrorMode (OS.SEM_FAILCRITICALERRORS);
-	
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
+
 	/*
 	* Bug in Windows.  When a WH_MSGFILTER hook is used to run code
 	* during the message loop for SHBrowseForFolder(), running code
@@ -222,7 +253,7 @@
 	* for static controls seemed to make the problem happen.
 	* The fix is to disable async messages while the directory
 	* dialog is open.
-	* 
+	*
 	* NOTE:  This only happens in versions of the comctl32.dll
 	* earlier than 6.0.
 	*/
@@ -231,12 +262,12 @@
 	int /*long*/ lpItemIdList = OS.SHBrowseForFolder (lpbi);
 	if (OS.COMCTL32_MAJOR < 6) display.runMessages = oldRunMessages;
 	OS.SetErrorMode (oldErrorMode);
-	
+
 	/* Clear the temporary dialog modal parent */
 	if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
 		display.setModalDialog (oldModal);
 	}
-	
+
 	boolean success = lpItemIdList != 0;
 	if (success) {
 		/* Use the character encoding for the default locale */
@@ -249,7 +280,7 @@
 
 	/* Free the BrowseCallbackProc */
 	callback.dispose ();
-	
+
 	/* Free the OS memory */
 	if (lpszTitle != 0) OS.HeapFree (hHeap, 0, lpszTitle);
 
@@ -259,7 +290,7 @@
 		/* void Free (struct IMalloc *this, void *pv); */
 		OS.VtblCall (5, ppMalloc [0], lpItemIdList);
 	}
-	
+
 	/*
 	* This code is intentionally commented.  On some
 	* platforms, the owner window is repainted right
@@ -267,10 +298,14 @@
 	* is currently unspecified.
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
-	
-	/* Return the directory path */
-	if (!success) return null;
-	return directoryPath;
+
+        // <QFS>
+        Object result = success ? directoryPath : null;
+        result = _qfGetDisplay().runDialogClosedHooks(this, result);
+	return (result instanceof String) || result == null
+            ? (String) result
+            : success ? directoryPath : null;
+        // </QFS>
 }
 
 /**
@@ -296,7 +331,7 @@
  * visible on the dialog while it is open.
  *
  * @param string the message
- * 
+ *
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_NULL_ARGUMENT - if the string is null</li>
  * </ul>
Index: org/eclipse/swt/widgets/ProgressBar.java
===================================================================
--- org/eclipse/swt/widgets/ProgressBar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ProgressBar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -341,7 +341,7 @@
  * Note: This operation is a hint and is not supported on
  * platforms that do not have this concept.
  * </p>
- * 
+ *
  * @param state the new state
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/widgets/ToolItem.java
===================================================================
--- org/eclipse/swt/widgets/ToolItem.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ToolItem.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -10,7 +10,7 @@
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.*;
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
@@ -27,7 +27,7 @@
  * <dd>Selection</dd>
  * </dl>
  * <p>
- * Note: Only one of the styles CHECK, PUSH, RADIO, SEPARATOR and DROP_DOWN 
+ * Note: Only one of the styles CHECK, PUSH, RADIO, SEPARATOR and DROP_DOWN
  * may be specified.
  * </p><p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
@@ -54,7 +54,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -94,7 +94,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -175,14 +175,15 @@
 	if (!isValidSubclass ()) error (SWT.ERROR_INVALID_SUBCLASS);
 }
 
-void click (boolean dropDown) {	
+void click (boolean dropDown) {
 	int /*long*/ hwnd = parent.handle;
-	if (OS.GetKeyState (OS.VK_LBUTTON) < 0) return;
+        // <QFS/> Changed to getDisplay().GetKeyState
+	if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) return;
 	int index = (int)/*64*/OS.SendMessage (hwnd, OS.TB_COMMANDTOINDEX, id, 0);
 	RECT rect = new RECT ();
 	OS.SendMessage (hwnd, OS.TB_GETITEMRECT, index, rect);
 	int hotIndex = (int)/*64*/OS.SendMessage (hwnd, OS.TB_GETHOTITEM, 0, 0);
-	
+
 	/*
 	* In order to emulate all the processing that
 	* happens when a mnemonic key is pressed, fake
@@ -196,7 +197,7 @@
 	OS.SendMessage (hwnd, OS.WM_LBUTTONDOWN, 0, lParam);
 	OS.SendMessage (hwnd, OS.WM_LBUTTONUP, 0, lParam);
 	parent.ignoreMouse = false;
-	
+
 	if (hotIndex != -1) {
 		OS.SendMessage (hwnd, OS.TB_SETHOTITEM, hotIndex, 0);
 	}
@@ -289,7 +290,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #isEnabled
  */
 public boolean getEnabled () {
@@ -407,7 +408,7 @@
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
  *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
  * </ul>
- * 
+ *
  * @see #getEnabled
  */
 public boolean isEnabled () {
@@ -456,7 +457,7 @@
 	* the style BTNS_SEP does not return I_IMAGENONE when queried
 	* for an image index, despite the fact that no attempt has been
 	* made to assign an image to the item.  As a result, operations
-	* on an image list that use the wrong index cause random results.	
+	* on an image list that use the wrong index cause random results.
 	* The fix is to ensure that the tool item is not a separator
 	* before using the image index.  Since separators cannot have
 	* an image and one is never assigned, this is not a problem.
@@ -493,7 +494,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 void resizeControl () {
@@ -533,7 +534,7 @@
  * @param control the new control
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the control has been disposed</li>
  *    <li>ERROR_INVALID_PARENT - if the control is not in the same widget tree</li>
  * </ul>
  * @exception SWTException <ul>
@@ -634,7 +635,7 @@
 	* Feature in Windows.  When TB_SETSTATE is used to set the
 	* state of a tool item, the item redraws even when the state
 	* has not changed.  The fix is to detect this case and avoid
-	* setting the state. 
+	* setting the state.
 	*/
 	if (((fsState & OS.TBSTATE_ENABLED) != 0) == enabled) return;
 	if (enabled) {
@@ -660,7 +661,7 @@
  * @param image the disabled image to display on the receiver (may be null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -685,7 +686,7 @@
  * @param image the hot image to display on the receiver (may be null)
  *
  * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li> 
+ *    <li>ERROR_INVALID_ARGUMENT - if the image has been disposed</li>
  * </ul>
  * @exception SWTException <ul>
  *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
@@ -741,7 +742,7 @@
 	* Feature in Windows.  When TB_SETSTATE is used to set the
 	* state of a tool item, the item redraws even when the state
 	* has not changed.  The fix is to detect this case and avoid
-	* setting the state. 
+	* setting the state.
 	*/
 	if (((fsState & OS.TBSTATE_CHECKED) != 0) == selected) return;
 	if (selected) {
@@ -750,7 +751,7 @@
 		fsState &= ~OS.TBSTATE_CHECKED;
 	}
 	OS.SendMessage (hwnd, OS.TB_SETSTATE, id, fsState);
-	
+
 	/*
 	* Bug in Windows.  When a tool item with the style
 	* BTNS_CHECK or BTNS_CHECKGROUP is selected and then
@@ -757,7 +758,7 @@
 	* disabled, the item does not draw using the disabled
 	* image.  The fix is to use the disabled image in all
 	* image lists for the item.
-	* 
+	*
 	* NOTE: This means that the image list must be updated
 	* when the selection changes in a disabled tool item.
 	*/
@@ -792,7 +793,7 @@
  * escaped by doubling it in the string, causing a single
  * '&amp;' to be displayed.
  * </p>
- * 
+ *
  * @param string the new text
  *
  * @exception IllegalArgumentException <ul>
@@ -820,12 +821,12 @@
 		TCHAR buffer = new TCHAR (parent.getCodePage (), string, true);
 		int byteCount = buffer.length () * TCHAR.sizeof;
 		pszText = OS.HeapAlloc (hHeap, OS.HEAP_ZERO_MEMORY, byteCount);
-		OS.MoveMemory (pszText, buffer, byteCount); 
+		OS.MoveMemory (pszText, buffer, byteCount);
 		info.pszText = pszText;
 	}
 	OS.SendMessage (hwnd, OS.TB_SETBUTTONINFO, id, info);
 	if (pszText != 0) OS.HeapFree (hHeap, 0, pszText);
-	
+
 	/*
 	* Bug in Windows.  For some reason, when the font is set
 	* before any tool item has text, the tool items resize to
@@ -853,7 +854,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
@@ -981,12 +982,12 @@
 
 	/*
 	* Bug in Windows.  If the width of an item has already been
-	* calculated, the tool bar control will not recalculate it to 
+	* calculated, the tool bar control will not recalculate it to
 	* include the space for the image.  The fix is to set the width
 	* to zero, forcing the control recalculate the width for the item.
 	*/
 	info.dwMask |= OS.TBIF_SIZE;
-	info.cx = 0;	
+	info.cx = 0;
 	OS.SendMessage (hwnd, OS.TB_SETBUTTONINFO, id, info);
 	int /*long*/ hFont = OS.SendMessage (hwnd, OS.WM_GETFONT, 0, 0);
 	OS.SendMessage (hwnd, OS.WM_SETFONT, hFont, 0);
Index: org/eclipse/swt/widgets/ColorDialog.java
===================================================================
--- org/eclipse/swt/widgets/ColorDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/ColorDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
@@ -16,6 +17,11 @@
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
 
+// <QFS>
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 /**
  * Instances of this class allow the user to select a color
  * from a predefined set of available colors.
@@ -28,7 +34,7 @@
  * <p>
  * IMPORTANT: This class is <em>not</em> intended to be subclassed.
  * </p>
- * 
+ *
  * @see <a href="http://www.eclipse.org/swt/examples.php">SWT Example: ControlExample, Dialog tab</a>
  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a>
  * @noextend This class is not intended to be subclassed by clients.
@@ -35,6 +41,14 @@
  */
 
 public class ColorDialog extends Dialog {
+    // <QFS>
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.widgets.ColorDialog");
+    // </QFS>
+
 	static final int CUSTOM_COLOR_COUNT = 16; // from the MS spec for CHOOSECOLOR.lpCustColors
 	Display display;
 	int width, height;
@@ -41,7 +55,7 @@
 	RGB rgb;
 	RGB [] rgbs;
 	int [] colors = new int [CUSTOM_COLOR_COUNT];
-	
+
 /**
  * Constructs a new instance of this class given only its parent.
  *
@@ -69,7 +83,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -145,7 +159,7 @@
  * if no custom colors were selected.
  *
  * @return the array of RGBs, which may be null
- * 
+ *
  * @since 3.8
  */
 public RGB[] getRGBs() {
@@ -166,11 +180,11 @@
  * </ul>
  */
 public RGB open () {
-	
+
 	/* Get the owner HWND for the dialog */
 	int /*long*/ hwndOwner = parent.handle;
 	int /*long*/ hwndParent = parent.handle;
-	
+
 	/*
 	* Feature in Windows.  There is no API to set the orientation of a
 	* color dialog.  It is always inherited from the parent.  The fix is
@@ -203,7 +217,7 @@
 	Callback callback = new Callback (this, "CCHookProc", 4); //$NON-NLS-1$
 	int /*long*/ lpfnHook = callback.getAddress ();
 	if (lpfnHook == 0) error(SWT.ERROR_NO_MORE_CALLBACKS);
-	
+
 	/* Allocate the Custom Colors and initialize to white */
 	display = parent.display;
 	if (display.lpCustColors == 0) {
@@ -214,7 +228,7 @@
 		}
 		OS.MoveMemory (display.lpCustColors, colors, CUSTOM_COLOR_COUNT * 4);
 	}
-	
+
 	/* Set the Custom Colors (if any) into the dialog */
 	if (rgbs != null) {
 		int length = rgbs.length > CUSTOM_COLOR_COUNT ? CUSTOM_COLOR_COUNT : rgbs.length;
@@ -230,8 +244,8 @@
 		}
 		OS.MoveMemory (display.lpCustColors, colors, CUSTOM_COLOR_COUNT * 4);
 	}
-	
-	/* Open the dialog */	
+
+	/* Open the dialog */
 	CHOOSECOLOR lpcc = new CHOOSECOLOR ();
 	lpcc.lStructSize = CHOOSECOLOR.sizeof;
 	lpcc.Flags = OS.CC_ANYCOLOR | OS.CC_ENABLEHOOK;
@@ -246,7 +260,7 @@
 		int blue = (rgb.blue << 16) & 0xFF0000;
 		lpcc.rgbResult = red | green | blue;
 	}
-	
+
 	/* Make the parent shell be temporary modal */
 	Dialog oldModal = null;
 	if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
@@ -253,15 +267,31 @@
 		oldModal = display.getModalDialog ();
 		display.setModalDialog (this);
 	}
-	
+
+        // <QFS>
+        runDialogShownHooks();
+        if (hwndOwner != 0) {
+            boolean ok = OS.SetForegroundWindow(hwndOwner);
+            if (logger.level >= Log.DBG) {
+                logger.build("open()").add("called SetForegroundWindow hwndOwner: ")
+                    .addHex(hwndOwner)
+                    .add(", returned ok: ").add(ok).log(Log.DBG);
+            }
+        } else {
+            if (logger.level >= Log.WRN) {
+                logger.log(Log.WRN, "open()",
+                           "hwndOwner is null - unable to call SetForegroundWindow");
+            }
+        }
+        // </QFS>
 	/* Open the dialog */
 	boolean success = OS.ChooseColor (lpcc);
-	
+
 	/* Clear the temporary dialog modal parent */
 	if ((style & (SWT.APPLICATION_MODAL | SWT.SYSTEM_MODAL)) != 0) {
 		display.setModalDialog (oldModal);
 	}
-	
+
 	/* Get the Custom Colors (if the user defined any) from the dialog */
 	boolean customColor = false;
 	OS.MoveMemory (colors, display.lpCustColors, colors.length * 4);
@@ -288,10 +318,10 @@
 		int blue = (lpcc.rgbResult >> 16) & 0xFF;
 		rgb = new RGB (red, green, blue);
 	}
-	
+
 	/* Free the CCHookProc */
 	callback.dispose ();
-	
+
 	/* Free the Custom Colors */
 	/*
 	* This code is intentionally commented.  Currently,
@@ -307,7 +337,7 @@
 		OS.SetActiveWindow (hwndParent);
 		OS.DestroyWindow (hwndOwner);
 	}
-	
+
 	/*
 	* This code is intentionally commented.  On some
 	* platforms, the owner window is repainted right
@@ -315,7 +345,13 @@
 	* is currently unspecified.
 	*/
 //	if (hwndOwner != 0) OS.UpdateWindow (hwndOwner);
-	
+
+        // <QFS>
+        rgb = (RGB) _qfGetDisplay().runDialogClosedHooks(this, success ? rgb : null);
+        if (rgb != null) {
+            success = true;
+        }
+        // </QFS>
 	display = null;
 	if (!success) return null;
 	return rgb;
@@ -343,7 +379,7 @@
  * @exception IllegalArgumentException <ul>
  *    <li>ERROR_INVALID_ARGUMENT - if an RGB in the rgbs array is null</li>
  * </ul>
- * 
+ *
  * @since 3.8
  */
 public void setRGBs(RGB[] rgbs) {
@@ -355,4 +391,4 @@
 	this.rgbs = rgbs;
 }
 
-}
\ No newline at end of file
+}
Index: org/eclipse/swt/widgets/Sash.java
===================================================================
--- org/eclipse/swt/widgets/Sash.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/Sash.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -10,7 +10,7 @@
  *******************************************************************************/
 package org.eclipse.swt.widgets;
 
- 
+
 import org.eclipse.swt.internal.win32.*;
 import org.eclipse.swt.*;
 import org.eclipse.swt.graphics.*;
@@ -49,7 +49,7 @@
  * <p>
  * The style value is either one of the style constants defined in
  * class <code>SWT</code> which is applicable to instances of this
- * class, or must be built by <em>bitwise OR</em>'ing together 
+ * class, or must be built by <em>bitwise OR</em>'ing together
  * (that is, using the <code>int</code> "|" operator) two or more
  * of those <code>SWT</code> style constants. The class description
  * lists the style constants that are applicable to the class.
@@ -175,7 +175,7 @@
 	if (listener == null) error (SWT.ERROR_NULL_ARGUMENT);
 	if (eventTable == null) return;
 	eventTable.unhook (SWT.Selection, listener);
-	eventTable.unhook (SWT.DefaultSelection,listener);	
+	eventTable.unhook (SWT.DefaultSelection,listener);
 }
 
 TCHAR windowClass () {
@@ -200,10 +200,12 @@
 		case OS.VK_RIGHT:
 		case OS.VK_UP:
 		case OS.VK_DOWN:
-			
+
 			/* Calculate the new x or y position */
-			if (OS.GetKeyState (OS.VK_LBUTTON) < 0) return result;
-			int step = OS.GetKeyState (OS.VK_CONTROL) < 0 ? INCREMENT : PAGE_INCREMENT;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			if (getDisplay().GetKeyState (OS.VK_LBUTTON) < 0) return result;
+                        // <QFS/> Changed to getDisplay().GetKeyState
+			int step = getDisplay().GetKeyState (OS.VK_CONTROL) < 0 ? INCREMENT : PAGE_INCREMENT;
 			if ((style & SWT.VERTICAL) != 0) {
 				if (wParam == OS.VK_UP || wParam == OS.VK_DOWN) break;
 				if (wParam == OS.VK_LEFT) step = -step;
@@ -226,7 +228,7 @@
 			int newX = rect.left, newY = rect.top;
 			if ((style & SWT.VERTICAL) != 0) {
 				cursorPt.x = newX = Math.min (Math.max (clientRect.left, newX + step), clientWidth - width);
-				cursorPt.y = rect.top + height / 2; 
+				cursorPt.y = rect.top + height / 2;
 			} else {
 				cursorPt.x = rect.left + width / 2;
 				cursorPt.y = newY = Math.min (Math.max (clientRect.top, newY + step), clientHeight - height);
@@ -288,7 +290,7 @@
 	}
 	sendSelectionEvent (SWT.Selection, event, true);
 	if (isDisposed ()) return LRESULT.ZERO;
-	
+
 	/* Draw the banding rectangle */
 	if (event.doit) {
 		dragging = true;
@@ -322,7 +324,7 @@
 	OS.GetWindowRect (handle, rect);
 	int width = rect.right - rect.left;
 	int height = rect.bottom - rect.top;
-	
+
 	/* The event must be sent because doit flag is used */
 	Event event = new Event ();
 	event.x = lastX;
Index: org/eclipse/swt/widgets/TrayItem.java
===================================================================
--- org/eclipse/swt/widgets/TrayItem.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/widgets/TrayItem.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -494,7 +494,7 @@
  * To display a single '&amp;' in the tool tip, the character '&amp;' can be 
  * escaped by doubling it in the string.
  * </p>
- * 
+ *
  * @param string the new tool tip text (or null)
  *
  * @exception SWTException <ul>
Index: org/eclipse/swt/custom/StyledText.java
===================================================================
--- org/eclipse/swt/custom/StyledText.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/StyledText.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -155,7 +155,7 @@
 	int alignmentMargin;
 	int newOrientation = SWT.NONE;
 	int accCaretOffset;
-	
+
 	//block selection
 	boolean blockSelection;
 	int blockXAnchor = -1, blockYAnchor = -1;
@@ -262,7 +262,7 @@
 						printerRenderer.setLineSegments(i, 1, event.segments);
 						printerRenderer.setLineSegmentChars(i, 1, event.segmentsChars);
 					}
-				}
+				}			
 				event = styledText.getLineStyleData(lineOffset, line);
 				if (event != null) {
 					printerRenderer.setLineIndent(i, 1, event.indent);
@@ -469,9 +469,9 @@
 					}
 				}
 			} else {
-				StringBuffer buffer = new StringBuffer("0");
-				while ((count /= 10) > 0) buffer.append("0");
-				printLayout.setText(buffer.toString());
+			StringBuffer buffer = new StringBuffer("0");
+			while ((count /= 10) > 0) buffer.append("0");
+			printLayout.setText(buffer.toString());
 				numberingWidth = printLayout.getBounds().width;
 			}
 			numberingWidth += printMargin;
@@ -629,7 +629,7 @@
 					printLayout.setText("");
 				}
 			} else {
-				printLayout.setText(String.valueOf(index));
+			printLayout.setText(String.valueOf(index));
 			}
 			int paintX = x - printMargin - printLayout.getBounds().width;
 			printLayout.draw(gc, paintX, y);
@@ -999,11 +999,11 @@
 				fontStyle = fontData.getStyle();
 			}
 			if ((fontStyle & SWT.BOLD) != 0) {
-				write("\\b");
-			}
+					write("\\b"); 
+				}
 			if ((fontStyle & SWT.ITALIC) != 0) {
-				write("\\i");
-			}
+					write("\\i"); 
+				}
 			if (style.underline) {
 				write("\\ul");
 			}
@@ -1017,11 +1017,11 @@
 			copyEnd = Math.max(copyEnd, lineIndex);
 			write(line, lineIndex, copyEnd);
 			if ((fontStyle & SWT.BOLD) != 0) {
-				write("\\b0");
-			}
-			if ((style.fontStyle & SWT.ITALIC) != 0) {
-				write("\\i0");
-			}
+					write("\\b0"); 
+				}
+				if ((style.fontStyle & SWT.ITALIC) != 0) {
+					write("\\i0"); 
+				}
 			if (style.underline) {
 				write("\\ul0");
 			}
@@ -1618,9 +1618,9 @@
 		int width = renderer.getWidth();
 		renderer.calculateClientArea();
 		if (width != renderer.getWidth()) {
-			setScrollBars(false);
-		}
+		setScrollBars(false);
 	}
+	}
 }
 /**
  * Hides the scroll bars if widget is created in single line mode.
@@ -1662,7 +1662,7 @@
  */
 void claimRightFreeSpace() {
 	int newHorizontalOffset = Math.max(0, renderer.getWidth() - clientAreaWidth);
-	if (newHorizontalOffset < horizontalScrollOffset) {
+	if (newHorizontalOffset < horizontalScrollOffset) {			
 		// item is no longer drawn past the right border of the client area
 		// align the right end of the item with the right border of the 
 		// client area (window is scrolled right).
@@ -1792,20 +1792,20 @@
 				return true;
 			}
 		} else {
-			int length = selection.y - selection.x;
-			if (length > 0) {
+	int length = selection.y - selection.x;
+	if (length > 0) {
 				setClipboardContent(selection.x, length, type);
 				return true;
 			}
 		}
-	} catch (SWTError error) {
-		// Copy to clipboard failed. This happens when another application 
-		// is accessing the clipboard while we copy. Ignore the error.
-		// Rethrow all other errors. Fixes bug 17578.
-		if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
-			throw error;
+		} catch (SWTError error) {
+			// Copy to clipboard failed. This happens when another application 
+			// is accessing the clipboard while we copy. Ignore the error.
+			// Rethrow all other errors. Fixes bug 17578.
+			if (error.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
+				throw error;
+			}
 		}
-	}
 	return false;
 }
 /**
@@ -1876,7 +1876,7 @@
 	}
 	return Math.min(height, availableHeight);
 }
-/** 
+/**
  * Returns the color of the margins.
  * 
  * @return the color of the margins.
@@ -1960,12 +1960,12 @@
 			return dragDetect(event);
 		}
 	} else {
-		if (selection.x == selection.y) return false;
-		int offset = getOffsetAtPoint(event.x, event.y, null, true);
-		if (selection.x <= offset && offset < selection.y) {
-			return dragDetect(event);
-		}
+	if (selection.x == selection.y) return false;
+	int offset = getOffsetAtPoint(event.x, event.y, null, true);
+	if (selection.x <= offset && offset < selection.y) {
+		return dragDetect(event);
 	}
+	}
 	return false;
 }
 /**
@@ -2105,8 +2105,8 @@
  */
 public void cut() {
 	checkWidget();
-	// Abort cut operation if copy to clipboard fails.
-	// Fixes bug 21030.
+			// Abort cut operation if copy to clipboard fails.
+			// Fixes bug 21030.
 	if (copySelection(DND.CLIPBOARD)) {
 		if (blockSelection && blockXLocation != -1) {
 			insertBlockSelectionText((char)0, SWT.NULL);
@@ -2163,7 +2163,7 @@
 							scrollVertical(pixels, true);
 						}
 					} else {
-						doSelectionPageUp(autoScrollDistance);
+					doSelectionPageUp(autoScrollDistance);
 					}
 					display.timerExec(V_SCROLL_RATE, this);
 				}
@@ -2185,7 +2185,7 @@
 							scrollVertical(pixels, true);
 						}
 					} else {
-						doSelectionPageDown(autoScrollDistance);
+					doSelectionPageDown(autoScrollDistance);
 					}
 					display.timerExec(V_SCROLL_RATE, this);
 				}
@@ -2206,9 +2206,9 @@
 							scrollHorizontal(pixels, true);
 						}
 					} else {
-						doVisualNext();
-						setMouseWordSelectionAnchor();
-						doMouseSelection();
+					doVisualNext();
+					setMouseWordSelectionAnchor();
+					doMouseSelection();
 					}
 					display.timerExec(H_SCROLL_RATE, this);
 				}
@@ -2228,9 +2228,9 @@
 							scrollHorizontal(pixels, true);
 						}
 					} else {
-						doVisualPrevious();
-						setMouseWordSelectionAnchor();
-						doMouseSelection();
+					doVisualPrevious();
+					setMouseWordSelectionAnchor();
+					doMouseSelection();
 					}
 					display.timerExec(H_SCROLL_RATE, this);
 				}
@@ -2270,7 +2270,7 @@
 			}
 			TextLayout layout = renderer.getTextLayout(lineIndex);
 			int start = layout.getPreviousOffset(caretOffset - lineOffset, isSurrogate ? SWT.MOVEMENT_CLUSTER : SWT.MOVEMENT_CHAR);
-			renderer.disposeTextLayout(layout);
+			renderer.disposeTextLayout(layout); 
 			event.start = start + lineOffset;
 			event.end = caretOffset;
 		}
@@ -2477,16 +2477,16 @@
 		doLineEnd();
 	} else {
 		int length = content.getCharCount();		
-		setCaretOffset(length, SWT.DEFAULT);
-		showCaret();
-	}
+			setCaretOffset(length, SWT.DEFAULT);
+			showCaret();
+		}
 }
 /**
  * Moves the caret in front of the first character of the widget content.
  */
 void doContentStart() {
-	setCaretOffset(0, SWT.DEFAULT);
-	showCaret();
+		setCaretOffset(0, SWT.DEFAULT);
+		showCaret();
 }
 /**
  * Moves the caret to the start of the selection if a selection exists.
@@ -2640,8 +2640,8 @@
 		int lineLength = content.getLine(caretLine).length();
 		lineEndOffset = lineOffset + lineLength;
 	}
-	setCaretOffset(lineEndOffset, PREVIOUS_OFFSET_TRAILING);
-	showCaret();
+		setCaretOffset(lineEndOffset, PREVIOUS_OFFSET_TRAILING);
+		showCaret();
 }
 /**
  * Moves the caret to the beginning of the line.
@@ -2657,8 +2657,8 @@
 		lineOffset += offsets[lineIndex];
 		renderer.disposeTextLayout(layout);
 	}
-	setCaretOffset(lineOffset, OFFSET_LEADING);
-	showCaret();
+		setCaretOffset(lineOffset, OFFSET_LEADING);
+		showCaret();
 }
 /**
  * Moves the caret one line up and to the same character offset relative 
@@ -2813,10 +2813,10 @@
 	boolean vchange = 0 <= y && y < clientAreaHeight || newCaretLine == 0 || newCaretLine == content.getLineCount() - 1;
 	boolean hchange = 0 <= x && x < clientAreaWidth || wordWrap || newCaretLine != content.getLineAtOffset(caretOffset); 
 	if (vchange && hchange && (newCaretOffset != caretOffset || newCaretAlignemnt != caretAlignment)) {
-		setCaretOffset(newCaretOffset, newCaretAlignemnt);
-		if (select) doMouseSelection();
-		showCaret();
-	}
+			setCaretOffset(newCaretOffset, newCaretAlignemnt);
+			if (select) doMouseSelection();
+			showCaret();
+		}
 	if (!select) {
 		setCaretOffset(newCaretOffset, newCaretAlignemnt);
 		clearSelection(true);
@@ -3486,7 +3486,7 @@
 	checkWidget();
 	return bidiColoring;
 }
-/**
+/** 
  * Returns whether the widget is in block selection mode.
  *
  * @return true if widget is in block selection mode, false otherwise
@@ -3692,7 +3692,7 @@
 }
 /**
  * Returns the content implementation that is used for text storage.
- * 
+ *
  * @return content the user defined content implementation that is used for
  * text storage or the default content implementation if no user defined 
  * content implementation has been set.
@@ -4411,23 +4411,23 @@
 			offsetInLine += trailing[0];
 			if (alignment != null) alignment[0] = PREVIOUS_OFFSET_TRAILING;
 		} else {
-			String line = content.getLine(lineIndex);
+			String line = content.getLine(lineIndex);			
 			int level = 0;
 			if (alignment != null) {
-				int offset = offsetInLine;
-				while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;
-				if (offset == 0 && Character.isDigit(line.charAt(offset))) {
-					level = isMirrored() ? 1 : 0;
-				} else {
-					level = layout.getLevel(offset) & 0x1;
-				}
+			int offset = offsetInLine;
+			while (offset > 0 && Character.isDigit(line.charAt(offset))) offset--;
+			if (offset == 0 && Character.isDigit(line.charAt(offset))) {
+				level = isMirrored() ? 1 : 0;
+			} else {
+				level = layout.getLevel(offset) & 0x1;
 			}
+			}
 			offsetInLine += trailing[0];
 			if (alignment != null) {
-				int trailingLevel = layout.getLevel(offsetInLine) & 0x1;
-				if ((level ^ trailingLevel) != 0) {
+			int trailingLevel = layout.getLevel(offsetInLine) & 0x1;
+			if ((level ^ trailingLevel) != 0) {
 					alignment[0] = PREVIOUS_OFFSET_TRAILING;
-				} else {
+			} else {
 					alignment[0] = OFFSET_LEADING;
 				}
 			}
@@ -4598,7 +4598,7 @@
 	}
 	return new int[0];
 }
-/** 
+/**
  * Returns the right margin.
  *
  * @return the right margin.
@@ -4777,13 +4777,13 @@
 	int lineLength = line.length();
 	int[] segments = event.segments;
 	if (segments[0] > lineLength) {
-		SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-	}
+			SWT.error(SWT.ERROR_INVALID_ARGUMENT);
+		} 	
 	for (int i = 1; i < segments.length; i++) {
-		if (segments[i] <= segments[i - 1] || segments[i] > lineLength) {
-			SWT.error(SWT.ERROR_INVALID_ARGUMENT);
+			if (segments[i] <= segments[i - 1] || segments[i] > lineLength) {
+				SWT.error(SWT.ERROR_INVALID_ARGUMENT);
+			} 	
 		}
-	}
 	return event;
 }
 /**
@@ -5127,7 +5127,7 @@
 		if (length > 0) {
 			if (i == lineStart) {
 				if (i == lineEnd) {
-					rect = layout.getBounds(start - lineOffset, end - lineOffset);
+				rect = layout.getBounds(start - lineOffset, end - lineOffset);
 				} else {
 					rect = layout.getBounds(start - lineOffset, length);
 				}
@@ -5204,7 +5204,7 @@
 	checkWidget();
 	return topIndex;
 }
-/** 
+/**
  * Returns the top margin.
  *
  * @return the top margin.
@@ -5371,7 +5371,7 @@
 	checkWidget();
 	return wordWrap;
 }
-/**
+/** 
  * Returns the wrap indentation of the widget.
  * 
  * @return the wrap indentation
@@ -5460,8 +5460,8 @@
 	if (blockSelection) {
 		insertBlockSelectionText(string, false); 
 	} else {
-		Point sel = getSelectionRange();
-		replaceTextRange(sel.x, sel.y, string);
+	Point sel = getSelectionRange();
+	replaceTextRange(sel.x, sel.y, string);
 	}
 }
 int insertBlockSelectionText(String text, boolean fillWithSpaces) {
@@ -5962,7 +5962,7 @@
 		newOrientation = SWT.NONE;
 	}
 }
-/**
+/** 
  * Update the event location for focus-based context menu triggers.
  *
  * @param event menu detect event
@@ -6025,10 +6025,10 @@
 				if (blockSelection) {
 					setBlockSelectionLocation(leftMargin, event.y, clientAreaWidth - rightMargin, event.y, true);
 				} else {
-					int lineEnd = content.getCharCount();
-					if (lineIndex + 1 < content.getLineCount()) {
-						lineEnd = content.getOffsetAtLine(lineIndex + 1);
-					}
+			int lineEnd = content.getCharCount();
+			if (lineIndex + 1 < content.getLineCount()) {
+				lineEnd = content.getOffsetAtLine(lineIndex + 1);
+			}
 					setSelection(lineOffset, lineEnd - lineOffset, false, false);
 					sendSelectionEvent();
 				}
@@ -6044,8 +6044,8 @@
  */
 void handleMouseMove(Event event) {
 	if (clickCount > 0) {
-		update();
-		doAutoScroll(event);
+	update();
+	doAutoScroll(event);
 		doMouseLocationChange(event.x, event.y, true);
 	} 
 	if (renderer.hasLinks) {
@@ -6201,7 +6201,7 @@
 	// in some cases new text would be drawn in scroll source area even 
 	// though the intent is to scroll it.
 	if (!(blockSelection && blockXLocation != -1)) {
-		updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);
+	updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);
 	}
 	if (lastTextChangeReplaceLineCount > 0 || wordWrap) {
 		claimBottomFreeSpace();
@@ -6328,12 +6328,12 @@
 		public void getKeyboardShortcut(AccessibleEvent e) {
 			String shortcut = null;
 			String text = getAssociatedLabel ();
-			if (text != null) {
-				char mnemonic = _findMnemonic (text);
-				if (mnemonic != '\0') {
-					shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+				if (text != null) {
+					char mnemonic = _findMnemonic (text);
+					if (mnemonic != '\0') {
+						shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+					}
 				}
-			}
 			e.result = shortcut;
 		}
 	});
@@ -7071,7 +7071,7 @@
 			if (blockXLocation != -1) {
 				insertBlockSelectionText((char)0, action);
 				return true;
-			}
+	}
 			return false;
 		case ST.DELETE_WORD_PREVIOUS:
 		case ST.DELETE_WORD_NEXT:
@@ -7378,7 +7378,7 @@
 	}
 }
 void redrawLines(int startLine, int lineCount, boolean bottomChanged) {
-	// do nothing if redraw range is completely invisible
+	// do nothing if redraw range is completely invisible	
 	int endLine = startLine + lineCount - 1;
 	int partialBottomIndex = getPartialBottomIndex();
 	int partialTopIndex = getPartialTopIndex();
@@ -7785,7 +7785,7 @@
 	topIndex = 0;
 	topIndexY = 0;
 	verticalScrollOffset = 0;
-	horizontalScrollOffset = 0;
+	horizontalScrollOffset = 0;	
 	resetSelection();
 	renderer.setContent(content);
 	if (verticalBar != null) {
@@ -8139,7 +8139,7 @@
 }
 /**
  * Sets the alignment of the widget. The argument should be one of <code>SWT.LEFT</code>, 
- * <code>SWT.CENTER</code> or <code>SWT.RIGHT</code>. The alignment applies for all lines.
+ * <code>SWT.CENTER</code> or <code>SWT.RIGHT</code>. The alignment applies for all lines.  
  * </p><p>
  * Note that if <code>SWT.MULTI</code> is set, then <code>SWT.WRAP</code> must also be set
  * in order to stabilize the right edge before setting alignment.
@@ -8370,7 +8370,7 @@
 	checkWidget();
 	bidiColoring = mode;
 }
-/** 
+/**
  * Sets the bottom margin.
  * 
  * @param bottomMargin the bottom margin.
@@ -8475,11 +8475,11 @@
 		if (blockSelection) {
 			clearBlockSelection(true, false);
 		} else {
-			clearSelection(false);
-		}
+		clearSelection(false);
 	}
+	}
 	setCaretLocation();
-}
+}	
 void setCaretOffset(int offset, int alignment) {
 	if (caretOffset != offset) {
 		caretOffset = offset;
@@ -8816,7 +8816,7 @@
 		}
 	}		
 }
-/** 
+/**
  * Sets the left margin.
  * 
  * @param leftMargin the left margin.
@@ -9100,7 +9100,7 @@
 	setCaretLocation();
 	super.redraw();
 }
-/**
+/** 
  * Sets the tab stops of the specified lines.
  * <p>
  * Should not be called if a <code>LineStyleListener</code> has been set since the listener 
@@ -9283,15 +9283,15 @@
 	super.setOrientation(orientation);
 	int newOrientation = getOrientation();
 	if (oldOrientation != newOrientation) {
-		caretDirection = SWT.NULL;
-		resetCache(0, content.getLineCount());
-		setCaretLocation();
-		keyActionMap.clear();
-		createKeyBindings();
-		super.redraw();
+	caretDirection = SWT.NULL;
+	resetCache(0, content.getLineCount());
+	setCaretLocation();
+	keyActionMap.clear();
+	createKeyBindings();
+	super.redraw();
 	}
 }
-/** 
+/**
  * Sets the right margin.
  * 
  * @param rightMargin the right margin.
@@ -9334,9 +9334,9 @@
 		if (verticalBar != null) verticalBar.setVisible(false);
 		if (horizontalBar != null) horizontalBar.setVisible(false);
 	}
-	if (verticalBar != null) {
+		if (verticalBar != null) {
 		setScrollBar(verticalBar, clientAreaHeight, renderer.getHeight(), topMargin + bottomMargin);
-	}
+			}
 	if (horizontalBar != null) {
 		setScrollBar(horizontalBar, clientAreaWidth, renderer.getWidth(), leftMargin + rightMargin);
 		if (!alwaysShowScroll && horizontalBar.getVisible() && verticalBar != null) {
@@ -9343,9 +9343,9 @@
 			setScrollBar(verticalBar, clientAreaHeight, renderer.getHeight(), topMargin + bottomMargin);
 			if (verticalBar.getVisible()) {
 				setScrollBar(horizontalBar, clientAreaWidth, renderer.getWidth(), leftMargin + rightMargin);
-			}
 		}
 	}
+		}
 	if (!alwaysShowScroll) {
 		redrawMargins(oldHeight, oldWidth);
 	}
@@ -9504,20 +9504,20 @@
 		if (blockSelection && doBlock) {
 			setBlockSelectionOffset(start, end, sendEvent);
 		} else {
-			clearSelection(sendEvent);
-			if (length < 0) {
-				selectionAnchor = selection.y = end;
+		clearSelection(sendEvent);
+		if (length < 0) {
+			selectionAnchor = selection.y = end;
 				selection.x = start;
 				setCaretOffset(start, PREVIOUS_OFFSET_TRAILING);
-			} else {
-				selectionAnchor = selection.x = start;
+		} else {
+			selectionAnchor = selection.x = start;
 				selection.y = end;
 				setCaretOffset(end, PREVIOUS_OFFSET_TRAILING);
-			}
-			internalRedrawRange(selection.x, selection.y - selection.x);
+		}
+		internalRedrawRange(selection.x, selection.y - selection.x);
 			sendAccessibleTextCaretMoved();
-		}
 	}
+	}
 }
 /** 
  * Sets the selection.
@@ -9756,7 +9756,7 @@
 			}
 			if (partialTopIndex <= lineEnd && lineEnd <= partialBottomIndex) {
 				bottom = getLinePixel(lineEnd + 1);
-			}
+				}
 			if (!isFixedLineHeight() && bottom != expectedBottom) {
 				bottom = clientAreaHeight;
 			}
@@ -9973,7 +9973,7 @@
 	} 
 	scrollVertical(pixel, true);
 }
-/** 
+/**
  * Sets the top margin.
  * 
  * @param topMargin the top margin.
@@ -10086,7 +10086,7 @@
 		scrolled = scrollVertical(rect.y - topMargin, true);
 	} else if (rect.y + rect.height > clientAreaHeight - bottomMargin) {
 		if (clientAreaHeight - topMargin - bottomMargin <= 0) {
-			scrolled = scrollVertical(rect.y - topMargin, true);
+		scrolled = scrollVertical(rect.y - topMargin, true);
 		} else {
 			scrolled = scrollVertical(rect.y + rect.height - (clientAreaHeight - bottomMargin), true);
 		}
Index: org/eclipse/swt/custom/TableCursor.java
===================================================================
--- org/eclipse/swt/custom/TableCursor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/TableCursor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -41,7 +41,7 @@
 	TableItem row = null;
 	TableColumn column = null;
 	Listener listener, tableListener, resizeListener, disposeItemListener, disposeColumnListener;
-
+	
 	Color background = null;
 	Color foreground = null;
 
Index: org/eclipse/swt/custom/CTabItem.java
===================================================================
--- org/eclipse/swt/custom/CTabItem.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/CTabItem.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -131,7 +131,7 @@
 	shortenedText = null;
 	font = null;
 }
-
+	
 /**
  * Returns a rectangle describing the receiver's size and location
  * relative to its parent.
@@ -300,10 +300,10 @@
 		    	selectedControl = parent.getItem(selectedIndex).control;
 		    }
 		    if (this.control != selectedControl) {
-		    	this.control.setVisible(false);
-		    }
+			this.control.setVisible(false);
 		}
 	}
+	}
 }
 /**
  * Sets the image that is displayed if the tab item is disabled.
Index: org/eclipse/swt/custom/BidiSegmentEvent.java
===================================================================
--- org/eclipse/swt/custom/BidiSegmentEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/BidiSegmentEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -57,7 +57,7 @@
  * 		"R4R5R6". 
  *		visual line = "R3R2R1" + "R6R5R4"
  * </pre>
- * 
+ *
  * <p>
  * The segments and segmentsChars fields can be used together to obtain different
  * types of bidi reordering and text display. The application can use these two fields
Index: org/eclipse/swt/custom/StyledTextRenderer.java
===================================================================
--- org/eclipse/swt/custom/StyledTextRenderer.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/StyledTextRenderer.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -377,11 +377,11 @@
 	if (event != null && event.lineBackground != null) lineBackground = event.lineBackground;
 	int height = layout.getBounds().height;
 	if (lineBackground != null) {
-		gc.setBackground(lineBackground);
+	gc.setBackground(lineBackground);
 		gc.fillRectangle(client.x, paintY, client.width, height);
 	} else {
 		gc.setBackground(widgetBackground);
-		styledText.drawBackground(gc, client.x, paintY, client.width, height);
+	styledText.drawBackground(gc, client.x, paintY, client.width, height);
 	}
 	gc.setForeground(widgetForeground);
 	if (selectionStart == selectionEnd || (selectionEnd <= 0 && selectionStart > lineLength - 1)) {
@@ -651,7 +651,7 @@
 			StyleRange style = styles[i];
 			newRanges[j] = style.start;
 			newRanges[j + 1] = style.length;
-		}
+		}		
 	}
 	if (start > newRanges[0]) {
 		newRanges[1] = newRanges[0] + newRanges[1] - start;
@@ -693,18 +693,18 @@
 		System.arraycopy(styles, rangeStart, newStyles, 0, newStyles.length);
 	}
 	if (includeRanges || ranges == null) {
-		StyleRange style = newStyles[0];
-		if (start > style.start) {
+	StyleRange style = newStyles[0];
+	if (start > style.start) {
 			newStyles[0] = style = (StyleRange)style.clone();
-			style.length = style.start + style.length - start;
-			style.start = start;
-		}
-		style = newStyles[newStyles.length - 1];
-		if (end < style.start + style.length - 1) {
+		style.length = style.start + style.length - start;
+		style.start = start;
+	}
+	style = newStyles[newStyles.length - 1];
+	if (end < style.start + style.length - 1) {
 			newStyles[newStyles.length - 1] = style = (StyleRange)style.clone();
-			style.length = end - style.start + 1;
-		}
+		style.length = end - style.start + 1;
 	}
+	}
 	return newStyles;
 }
 StyleRange getStyleRange(StyleRange style) {
Index: org/eclipse/swt/custom/CCombo.java
===================================================================
--- org/eclipse/swt/custom/CCombo.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/CCombo.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -59,7 +59,7 @@
 	Shell _shell;
 	
 	static final String PACKAGE_PREFIX = "org.eclipse.swt.custom."; //$NON-NLS-1$
-
+	
 /**
  * Constructs a new instance of this class given its parent
  * and a style value describing its behavior and appearance.
@@ -127,8 +127,8 @@
 				getDisplay().asyncExec(new Runnable() {
 					public void run() {
 						if (isDisposed ()) return;
-						handleFocus (SWT.FocusOut);
-					}
+				handleFocus (SWT.FocusOut);
+			}
 				});
 			}
 		}
@@ -522,7 +522,7 @@
 			index == list.getSelectionIndex() && 
 			text.getText().equals(list.getItem(index))) {
 		text.setText("");  //$NON-NLS-1$
-		list.deselect (index);
+	list.deselect (index);
 	}
 }
 /**
@@ -968,12 +968,12 @@
 		public void getKeyboardShortcut(AccessibleEvent e) {
 			String shortcut = null;
 			String text = getAssociatedLabel ();
-			if (text != null) {
-				char mnemonic = _findMnemonic (text);
-				if (mnemonic != '\0') {
-					shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+				if (text != null) {
+					char mnemonic = _findMnemonic (text);
+					if (mnemonic != '\0') {
+						shortcut = "Alt+"+mnemonic; //$NON-NLS-1$
+					}
 				}
-			}
 			e.result = shortcut;
 		}
 		public void getHelp (AccessibleEvent e) {
@@ -1855,7 +1855,7 @@
 					event.doit = traverse(SWT.TRAVERSE_TAB_PREVIOUS);
 					event.detail = SWT.TRAVERSE_NONE;
 					return;
-			}		
+			}
 			Event e = new Event ();
 			e.time = event.time;
 			e.detail = event.detail;
Index: org/eclipse/swt/custom/CTabFolder.java
===================================================================
--- org/eclipse/swt/custom/CTabFolder.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/CTabFolder.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -129,7 +129,7 @@
 	/* External Listener management */
 	CTabFolder2Listener[] folderListeners = new CTabFolder2Listener[0];
 	// support for deprecated listener mechanism
-	CTabFolderListener[] tabListeners = new CTabFolderListener[0];
+	CTabFolderListener[] tabListeners = new CTabFolderListener[0]; 
 	
 	/* Selected item appearance */
 	Image selectionBgImage;
@@ -140,7 +140,7 @@
 	Color selectionBackground;
 	
 	/* Unselected item appearance */
-	Color[] gradientColors; 
+	Color[] gradientColors;
 	int[] gradientPercents;
 	boolean gradientVertical;
 	boolean showUnselectedImage = true;
@@ -197,7 +197,7 @@
 	// internal constants
 	static final int DEFAULT_WIDTH = 64;
 	static final int DEFAULT_HEIGHT = 64;
-	
+
 	static final int SELECTION_FOREGROUND = SWT.COLOR_LIST_FOREGROUND;
 	static final int SELECTION_BACKGROUND = SWT.COLOR_LIST_BACKGROUND;
 	
@@ -743,7 +743,7 @@
 	
 	updateFolder(UPDATE_TAB_HEIGHT | REDRAW_TABS);
 }
-
+	
 /**
  * Returns <code>true</code> if the receiver's border is visible.
  *
@@ -1040,7 +1040,7 @@
 }
 /**
  * Returns the receiver's renderer.
- * 
+ *
  * @return the receiver's renderer
  *
  * @exception SWTException <ul>
@@ -1066,8 +1066,8 @@
 		if ((align & SWT.WRAP) == 0 && (align & SWT.LEAD) == 0 && !controls[i].isDisposed() && controls[i].getVisible()) {
 			Point rightSize = controls[i].computeSize(SWT.DEFAULT, SWT.DEFAULT);
 			width += rightSize.x;
-		}
 	}
+	}
 	if (width != 0) width += SPACING * 2;
 	x -= width;
 	return Math.max(0, x);
@@ -1337,13 +1337,13 @@
 				}
 			}
 			if (childID == ACC.CHILDID_NONE) {
-				Rectangle location = getBounds();
-				location.x = location.y = 0;
-				location.height = location.height - getClientArea().height;
-				if (location.contains(testPoint)) {
-					childID = ACC.CHILDID_SELF;
+					Rectangle location = getBounds();
+					location.x = location.y = 0;
+					location.height = location.height - getClientArea().height;
+					if (location.contains(testPoint)) {
+						childID = ACC.CHILDID_SELF;
+					}
 				}
-			}
 			e.childID = childID;
 		}
 
@@ -1356,9 +1356,9 @@
 				pt = getParent().toDisplay(location.x, location.y);
 			} else {
 				if (childID >= 0 && childID < items.length && items[childID].showing) {
-					location = items[childID].getBounds();
-				}
-				if (location != null) {
+				location = items[childID].getBounds();
+			}
+			if (location != null) {
 					pt = toDisplay(location.x, location.y);
 				}
 			}
@@ -1402,7 +1402,7 @@
 				role = ACC.ROLE_TABFOLDER;
 			} else if (childID >= 0 && childID < items.length) {
 				role = ACC.ROLE_TABITEM;
-			} 
+			}
 			e.detail = role;
 		}
 		
@@ -1607,12 +1607,12 @@
 }
 void onDragDetect(Event event) {
 	boolean consume = false;
-	for (int i = 0; i < items.length; i++) {
-		if (items[i].closeRect.contains(event.x, event.y)) {
-				consume = true;
-				break;
+		for (int i = 0; i < items.length; i++) {
+			if (items[i].closeRect.contains(event.x, event.y)) {
+					consume = true;
+					break;
+			}
 		}
-	}
 	if (consume) {
 		event.type = SWT.None;
 	}
@@ -1706,16 +1706,16 @@
 										}
 									} while (!reschedule);
 									if (reschedule) break;
-								}
-							}
+			}
+			}
 							if (reschedule && hoverTimerRunning) {
 								display.timerExec(2000, this);
-							} else {
+				} else {
 								hovering = false;
 								updateItems();
 							}
 						}
-					}
+				}
 				});
 				return;
 			}
@@ -1746,7 +1746,7 @@
 				int index = indexOf(item);
 				if (item.showing){
 				    	int oldSelectedIndex = selectedIndex;
-				    	setSelection(index, true);
+					setSelection(index, true);
 				    	if (oldSelectedIndex == selectedIndex) {
 				    	    /* If the click is on the selected tabitem, then set focus to the tabfolder */
 				    	    forceFocus();
@@ -1779,7 +1779,7 @@
 						item.state |= SWT.HOT;
 						redraw(item.x, item.y, item.width, item.height, false);
 					}
-				}
+				} 
 				if (i != selectedIndex && item.closeImageState != SWT.BACKGROUND && !close) {
 					item.closeImageState = SWT.BACKGROUND;
 					redraw(item.closeRect.x, item.closeRect.y, item.closeRect.width, item.closeRect.height, false);
@@ -1962,7 +1962,7 @@
 	
 	gc.setFont(gcFont);
 	gc.setForeground(gcForeground);
-	gc.setBackground(gcBackground);	
+	gc.setBackground(gcBackground);
 	
 	if (hoverTb) {
 		Rectangle trim = renderer.computeTrim(CTabFolderRenderer.PART_BORDER, SWT.NONE, 0, 0, 0, 0);
@@ -1980,7 +1980,7 @@
 	}
 	gc.setFont(gcFont);
 	gc.setForeground(gcForeground);
-	gc.setBackground(gcBackground);
+	gc.setBackground(gcBackground);	
 }
 
 void onResize(Event event) {
@@ -2003,7 +2003,7 @@
 			int y1 = Math.min(size.y, oldSize.y);
 			if (size.y != oldSize.y) y1 -= trim.height + trim.y - marginHeight;
 			int x2 = Math.max(size.x, oldSize.x);
-			int y2 = Math.max(size.y, oldSize.y);	
+			int y2 = Math.max(size.y, oldSize.y);		
 			redraw(0, y1, x2, y2 - y1, false);
 			redraw(x1, 0, x2 - x1, y2, false);
 			if (hoverTb) {
@@ -2302,25 +2302,25 @@
 	}
 	
 	// Are these settings the same as before?
-	if ((gradientColors != null) && (colors != null) && 
-		(gradientColors.length == colors.length)) {
-		boolean same = false;
-		for (int i = 0; i < gradientColors.length; i++) {
-		    if (gradientColors[i] == null) {
-			same = colors[i] == null;
-		    } else {
-			same = gradientColors[i].equals(colors[i]);
-		    }
-		    if (!same) break;
+		if ((gradientColors != null) && (colors != null) && 
+			(gradientColors.length == colors.length)) {
+			boolean same = false;
+			for (int i = 0; i < gradientColors.length; i++) {
+				if (gradientColors[i] == null) {
+					same = colors[i] == null;
+				} else {
+					same = gradientColors[i].equals(colors[i]);
+				}
+				if (!same) break;
+			}
+			if (same) {
+				for (int i = 0; i < gradientPercents.length; i++) {
+					same = gradientPercents[i] == percents[i];
+					if (!same) break;
+				}
+			}
+			if (same && this.gradientVertical == vertical) return;
 		}
-		if (same) {
-		    for (int i = 0; i < gradientPercents.length; i++) {
-			same = gradientPercents[i] == percents[i];
-			if (!same) break;
-		    }
-		}
-		if (same && this.gradientVertical == vertical) return;
-	}
 	// Store the new settings
 	if (colors == null) {
 		gradientColors = null;
@@ -2421,9 +2421,9 @@
 	if (showChevron) {
 		int itemCount = items.length;
 		int count;
-		if (single) {
+				if (single) {
 			count = selectedIndex == -1 ? itemCount : itemCount - 1;
-		} else {
+					} else {
 			int showCount = 0;
 			while (showCount < priority.length && items[priority[showCount]].showing) {
 				showCount++;
@@ -2435,8 +2435,8 @@
 			if (chevronImage != null) chevronImage.dispose();
 			chevronImage = createButtonImage(display, CTabFolderRenderer.PART_CHEVRON_BUTTON);
 			chevronItem.setImage(chevronImage);
-		} 
-    }
+					}
+				}
 
 	boolean[][] overflow = new boolean[1][0];
 	Rectangle[] rects = computeControlBounds(size, overflow);
@@ -2449,10 +2449,10 @@
 				if (!(overflow[0][i])) {
 					if (rects[i].height > height) {
 						hoverTb = true;
-						break;
-					}
-				}
+				break;
 			}
+			}
+		}
 			if (hoverTb) {
 				for (int i = 0; i < rects.length; i++) {
 					if (!(overflow[0][i])) {
@@ -2472,13 +2472,13 @@
 	ignoreResize = true;
 	for (int i = 0; i < controls.length; i++) {
 		if (!controls[i].isDisposed()) {
-			if (overflow[0][i]) {
-				controls[i].setBounds(rects[i]);
-			} else {
-				controls[i].moveAbove(null);
-				controls[i].setBounds(rects[i].x, rects[i].y, rects[i].width, headerHeight);
-			}
+		if (overflow[0][i]) {
+			controls[i].setBounds(rects[i]);
+		} else {
+			controls[i].moveAbove(null);
+			controls[i].setBounds(rects[i].x, rects[i].y, rects[i].width, headerHeight);
 		}
+		}
 		if (!changed && !rects[i].equals(controlRects[i])) changed = true;
 	}
 	ignoreResize = false;
@@ -3631,14 +3631,14 @@
 }
 boolean updateTabHeight(boolean force){
 	int oldHeight = tabHeight;
-	GC gc = new GC(this);
+		GC gc = new GC(this);
 	tabHeight = renderer.computeSize(CTabFolderRenderer.PART_HEADER, SWT.NONE, gc, SWT.DEFAULT, SWT.DEFAULT).y;
-	gc.dispose();
+		gc.dispose();
 	if (fixedTabHeight == SWT.DEFAULT && controls != null && controls.length > 0) {
 		for (int i = 0; i < controls.length; i++) {		
 			if ((controlAlignments[i] & SWT.WRAP) == 0 && !controls[i].isDisposed() && (controls[i].getVisible() || controls[i] == chevronTb)) {
 				int topHeight = controls[i].computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
-				topHeight +=  renderer.computeTrim(CTabFolderRenderer.PART_HEADER, SWT.NONE, 0,0,0,0).height + 1;
+				topHeight += renderer.computeTrim(CTabFolderRenderer.PART_HEADER, SWT.NONE, 0,0,0,0).height + 1;
 				tabHeight = Math.max(topHeight, tabHeight);
 			}
 		}
@@ -3675,7 +3675,7 @@
 	}
 	Rectangle rectAfter = getClientArea();
 	if (!rectBefore.equals(rectAfter)) {
-		notifyListeners(SWT.Resize, new Event());
+	notifyListeners(SWT.Resize, new Event());
 		layout();
 	}
 }
@@ -3685,32 +3685,32 @@
 		for (int i = 0; i < controls.length; i++) {
 			Control control = controls[i];
 			if (!control.isDisposed()) {
-				if (hovering) {
-					if (control instanceof Composite) ((Composite) control).setBackgroundMode(SWT.INHERIT_NONE);
+			if (hovering) {
+				if (control instanceof Composite) ((Composite) control).setBackgroundMode(SWT.INHERIT_NONE);
+				control.setBackgroundImage(null);
+				control.setBackground(getBackground());
+			} else {
+				if (control instanceof Composite) ((Composite) control).setBackgroundMode(SWT.INHERIT_DEFAULT);
+				Rectangle bounds = control.getBounds();
+				if (bounds.y > getTabHeight() || gradientColors == null) {
 					control.setBackgroundImage(null);
 					control.setBackground(getBackground());
 				} else {
-					if (control instanceof Composite) ((Composite) control).setBackgroundMode(SWT.INHERIT_DEFAULT);
-					Rectangle bounds = control.getBounds();
-					if (bounds.y > getTabHeight() || gradientColors == null) {
-						control.setBackgroundImage(null);
-						control.setBackground(getBackground());
-					} else {
-						bounds.width = 10;
-						bounds.y = -bounds.y;
-						bounds.height -= 2*bounds.y - 1;
-						bounds.x = 0;
-						if (controlBkImages[i] != null) controlBkImages[i].dispose();
-						controlBkImages[i] = new Image(control.getDisplay(), bounds);
-						GC gc = new GC(controlBkImages[i]);
-						renderer.drawBackground(gc, bounds, 0);
-						gc.dispose();
-						control.setBackground(null);
-						control.setBackgroundImage(controlBkImages[i]);
-					}
+					bounds.width = 10;
+					bounds.y = -bounds.y;
+					bounds.height -= 2*bounds.y - 1;
+					bounds.x = 0;
+					if (controlBkImages[i] != null) controlBkImages[i].dispose();
+					controlBkImages[i] = new Image(control.getDisplay(), bounds);
+					GC gc = new GC(controlBkImages[i]);
+					renderer.drawBackground(gc, bounds, 0);
+					gc.dispose();
+					control.setBackground(null);
+					control.setBackgroundImage(controlBkImages[i]);
 				}
 			}
 		}
+		}
 		
 	}
 }
Index: org/eclipse/swt/custom/LineStyleEvent.java
===================================================================
--- org/eclipse/swt/custom/LineStyleEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/LineStyleEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -61,7 +61,7 @@
 	 */
 	public int indent;
 
-	/**
+	/** 
 	 * line wrap indent (input, output)
 	 * 
 	 * @since 3.6
@@ -86,7 +86,7 @@
 	 * @since 3.2
 	 */
 	public int bulletIndex;
-
+	
 	/**
 	 * line tab stops (output)
 	 * @since 3.6
Index: org/eclipse/swt/custom/ST.java
===================================================================
--- org/eclipse/swt/custom/ST.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/ST.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -136,7 +136,7 @@
 	 *  @since 3.2
 	 */
 	public static final int BULLET_CUSTOM = 1 << 5;
-	
+
 	/**
 	 *  The ExtendedModify event type (value is 3000).
 	 *  
Index: org/eclipse/swt/custom/TreeCursor.java
===================================================================
--- org/eclipse/swt/custom/TreeCursor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/TreeCursor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,963 +1,963 @@
-/*******************************************************************************
+/*******************************************************************************
  * Copyright (c) 2011, 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.swt.custom;
-
-
-import org.eclipse.swt.*;
-import org.eclipse.swt.accessibility.*;
-import org.eclipse.swt.events.*;
-import org.eclipse.swt.graphics.*;
-import org.eclipse.swt.widgets.*;
-
-/**
- * A TreeCursor provides a way for the user to navigate around a Tree with columns using the
- * keyboard. It also provides a mechanism for selecting an individual cell in a tree.
- * <p>
- * For a detailed example of using a TreeCursor to navigate to a cell and then edit it see
- * http://git.eclipse.org/c/platform/eclipse.platform.swt.git/tree/examples/org.eclipse.swt.snippets/src/org/eclipse/swt/snippets/Snippet360.java .
- * 
- * <dl>
- * <dt><b>Styles:</b></dt>
- * <dd>BORDER</dd>
- * <dt><b>Events:</b></dt>
- * <dd>Selection, DefaultSelection</dd>
- * </dl>
- * 
- * @since 3.8
- */
-public class TreeCursor extends Canvas {
-	Tree tree;
-	TreeItem row;
-	TreeColumn column;
-	Listener listener, treeListener, resizeListener, disposeItemListener, disposeColumnListener;
-
-	Color background = null;
-	Color foreground = null;
-	
-	/* By default, invert the list selection colors */
-	static final int BACKGROUND = SWT.COLOR_LIST_SELECTION_TEXT;
-	static final int FOREGROUND = SWT.COLOR_LIST_SELECTION;
-
-/**
- * Constructs a new instance of this class given its parent tree and a style value describing
- * its behavior and appearance.
- * <p>
- * The style value is either one of the style constants defined in class <code>SWT</code> which
- * is applicable to instances of this class, or must be built by <em>bitwise OR</em>'ing
- * together (that is, using the <code>int</code> "|" operator) two or more of those
- * <code>SWT</code> style constants. The class description lists the style constants that are
- * applicable to the class. Style bits are also inherited from superclasses.
- * </p>
- * 
- * @param parent a Tree control which will be the parent of the new instance (cannot be null)
- * @param style the style of control to construct
- * 
- * @exception IllegalArgumentException <ul>
- *    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>
- * </ul>
- * @exception SWTException <ul>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
- *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
- * </ul>
- * 
- * @see SWT#BORDER
- * @see Widget#checkSubclass()
- * @see Widget#getStyle()
- */
-public TreeCursor(Tree parent, int style) {
-	super(parent, style);
-	tree = parent;
-	setBackground(null);
-	setForeground(null);
-
-	listener = new Listener() {
-		public void handleEvent(Event event) {
-			if (row != null) {
-				/*
-				 * Detect cases where the cursor position has become invalid and fix it.
-				 * The typical cause of this is programmatic tree changes, such as
-				 * expanding/collapsing and item and creating/disposing items.
-				 */
-				if (row.isDisposed()) {
-					unhookRowColumnListeners();
-					_resize();
-					tree.setFocus();
-					return;
-				}
-				TreeItem current = row;
-				TreeItem parentItem = row.getParentItem();
-				while (parentItem != null && !parentItem.getExpanded()) {
-					current = parentItem;
-					parentItem = current.getParentItem();
-				}
-				if (current != row) {
-					setRowColumn(current, column, false);
-				}
-			}
-			switch (event.type) {
-				case SWT.Dispose:
-					onDispose(event);
-					break;
-				case SWT.FocusIn:
-				case SWT.FocusOut:
-					redraw();
-					break;
-				case SWT.KeyDown:
-					keyDown(event);
-					break;
-				case SWT.Paint:
-					paint(event);
-					break;
-				case SWT.Traverse:
-					event.doit = true;
-					switch (event.detail) {
-						case SWT.TRAVERSE_ARROW_NEXT:
-						case SWT.TRAVERSE_ARROW_PREVIOUS:
-						case SWT.TRAVERSE_RETURN:
-							event.doit = false;
-							break;
-					}
-					break;
-			}
-		}
-	};
-	int[] events = new int[] { SWT.Dispose, SWT.FocusIn, SWT.FocusOut, SWT.KeyDown, SWT.Paint, SWT.Traverse };
-	for (int i = 0; i < events.length; i++) {
-		addListener(events[i], listener);
-	}
-
-	treeListener = new Listener() {
-		public void handleEvent(Event event) {
-			switch (event.type) {
-				case SWT.Collapse:
-					treeCollapse(event);
-					break;
-				case SWT.Expand:
-					treeExpand(event);
-					break;
-				case SWT.FocusIn:
-					treeFocusIn(event);
-					break;
-				case SWT.MouseDown:
-					treeMouseDown(event);
-					break;
-			}
-		}
-	};
-	tree.addListener(SWT.Collapse, treeListener);
-	tree.addListener(SWT.Expand, treeListener);
-	tree.addListener(SWT.FocusIn, treeListener);
-	tree.addListener(SWT.MouseDown, treeListener);
-	
-	disposeItemListener = new Listener() {
-		public void handleEvent(Event event) {
-			TreeItem currentItem = row;
-			while (currentItem != null) {
-				currentItem.removeListener(SWT.Dispose, disposeItemListener);
-				currentItem = currentItem.getParentItem();
-			}
-			TreeItem disposedItem = (TreeItem)event.widget;
-			TreeItem parentItem = disposedItem.getParentItem();
-			if (parentItem != null) {
-				setRowColumn(parentItem, column, true);
-			} else {
-				if (tree.getItemCount() == 1) {
-					unhookRowColumnListeners();
-				} else {
-					TreeItem newFocus = null;
-					int rowIndex = tree.indexOf(disposedItem);
-					if (rowIndex != 0) {
-						TreeItem previousItem = tree.getItem(rowIndex - 1);
-						if (!previousItem.isDisposed()) {
-							newFocus = previousItem;
-						}
-					}
-					if (newFocus == null && rowIndex + 1 < tree.getItemCount()) {
-						TreeItem nextItem = tree.getItem(rowIndex + 1);
-						if (!nextItem.isDisposed()) {
-							newFocus = nextItem;
-						}
-					}
-					if (newFocus != null) {
-						setRowColumn(newFocus, column, true);
-					} else {
-						unhookRowColumnListeners();
-					}
-				}
-			}
-			_resize();
-		}
-	};
-	disposeColumnListener = new Listener() {
-		public void handleEvent(Event event) {
-			if (column != null) {
-				if (tree.getColumnCount() == 1) {
-					column = null;
-				} else {
-					int columnIndex = tree.indexOf(column);
-					int positionIndex = columnIndex;
-					int[] columnOrder = tree.getColumnOrder();
-					for (int i = 0; i < columnOrder.length; i++) {
-						if (columnOrder[i] == columnIndex) {
-							positionIndex = i;
-							break;
-						}
-					}
-					if (positionIndex == columnOrder.length - 1) {
-						setRowColumn(row, tree.getColumn(columnOrder[positionIndex - 1]), true);
-					} else {
-						setRowColumn(row, tree.getColumn(columnOrder[positionIndex + 1]), true);
-					}
-				}
-			}
-			_resize();
-		}
-	};
-	resizeListener = new Listener() {
-		public void handleEvent(Event event) {
-			_resize();
-		}
-	};
-	ScrollBar hBar = tree.getHorizontalBar();
-	if (hBar != null) {
-		hBar.addListener(SWT.Selection, resizeListener);
-	}
-	ScrollBar vBar = tree.getVerticalBar();
-	if (vBar != null) {
-		vBar.addListener(SWT.Selection, resizeListener);
-	}
-	
-	getAccessible().addAccessibleControlListener(new AccessibleControlAdapter() {
-		public void getRole(AccessibleControlEvent e) {
-			e.detail = ACC.ROLE_TABLECELL;
-		}
-	});
-	getAccessible().addAccessibleListener(new AccessibleAdapter() {
-		public void getName(AccessibleEvent e) {
-			if (row == null) return;
-			int columnIndex = column == null ? 0 : tree.indexOf(column);
-			e.result = row.getText(columnIndex);
-		}
-	});
-}
-
-/**
- * Adds the listener to the collection of listeners who will be notified when the receiver's
- * selection changes, by sending it one of the messages defined in the
- * <code>SelectionListener</code> interface.
- * <p>
- * When <code>widgetSelected</code> is called, the item field of the event object is valid. If
- * the receiver has <code>SWT.CHECK</code> style set and the check selection changes, the event
- * object detail field contains the value <code>SWT.CHECK</code>.
- * <code>widgetDefaultSelected</code> is typically called when an item is double-clicked.
- * </p>
- * 
- * @param listener the listener which should be notified
- * 
- * @exception IllegalArgumentException <ul>
- *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
- * </ul>
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- * 
- * @see SelectionListener
- * @see SelectionEvent
- * @see #removeSelectionListener(SelectionListener)
- */
-public void addSelectionListener(SelectionListener listener) {
-	checkWidget();
-	if (listener == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
-	TypedListener typedListener = new TypedListener(listener);
-	addListener(SWT.Selection, typedListener);
-	addListener(SWT.DefaultSelection, typedListener);
-}
-
-int countSubTreePages(TreeItem root) {
-	int pages = 1;
-	if (root == null) return 0;
-	if (root.getItemCount() == 0) return 1;
-	if (!root.getExpanded()) return 1;
-	TreeItem[] items = root.getItems();
-	for (int i = 0; i < items.length; i++) {
-		pages += countSubTreePages(items[i]);
-	}
-	return pages;
-}
-
-int findIndex(TreeItem[] items, TreeItem treeItem) {
-	if (items == null || treeItem == null) return -1;
-	Rectangle rect = treeItem.getBounds();
-	int index = 0;
-	for (int i = 0; i < items.length; i++) {
-		TreeItem previousItem = null;
-		TreeItem currentItem = items[i];
-		if (i > 0) previousItem = items[i - 1];
-		Rectangle rect1 = currentItem.getBounds();
-		if (rect.y == rect1.y) return index;
-		if (rect.y < rect1.y) {
-			return index - 1 + findIndex(previousItem.getItems(), treeItem);
-		}
-		if (rect.y > rect1.y && i == items.length - 1) {
-			return index + findIndex(currentItem.getItems(), treeItem);
-		}
-		if (rect.y >= rect1.y + (1 + currentItem.getItemCount()) * tree.getItemHeight() && currentItem.getExpanded()) {
-			index += countSubTreePages(currentItem);
-			continue;
-		}
-		index++;
-	}
-	return -1;
-}
-
-TreeItem findItem(TreeItem[] items, Point pt) {
-	int start = 0, end = items.length - 1;
-	int index = end / 2;
-	while (end - start > 1) {
-		TreeItem currentItem = items[index];
-		Rectangle bounds = currentItem.getBounds();
-		if (pt.y < bounds.y) {
-			end = index;
-			index = (end - start) / 2;
-		} else {
-			start = index;
-			index = start + ((end - start) / 2);
-		}
-	}
-
-	Rectangle endBounds = items[end].getBounds();
-	if (endBounds.y < pt.y) {
-		if (endBounds.y + endBounds.height < pt.y) {
-			if (!items[end].getExpanded()) return null;
-			return findItem(items[end].getItems(), pt);
-		}
-		int[] columnOrder = tree.getColumnOrder();
-		Rectangle bounds = null;
-		if (columnOrder.length > 0) {
-			Rectangle rect1 = items[end].getBounds(columnOrder[0]);
-			Rectangle rect2 = items[end].getBounds(columnOrder[columnOrder.length - 1]);
-			bounds = rect1.union(rect2);
-			bounds.height += tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
-		} else {
-			bounds = items[end].getBounds();
-		}
-		return bounds.contains(pt) ? items[end] : null;		
-	}
-	
-	Rectangle startBounds = items[start].getBounds();
-	if (startBounds.y + startBounds.height < pt.y) {
-		return findItem(items[start].getItems(), pt);
-	}
-	int[] columnOrder = tree.getColumnOrder();
-	Rectangle bounds = null;
-	if (columnOrder.length > 0) {
-		Rectangle rect1 = items[start].getBounds(columnOrder[0]);
-		Rectangle rect2 = items[start].getBounds(columnOrder[columnOrder.length - 1]);
-		bounds = rect1.union(rect2);
-		bounds.height += tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
-	} else {
-		bounds = items[start].getBounds();
-	}
-	return bounds.contains(pt) ? items[start] : null;
-}
-
-/**
- * Returns the background color that the receiver will use to draw.
- *
- * @return the receiver's background color
- */
-public Color getBackground() {
-	checkWidget();
-	if (background == null) {
-		return getDisplay().getSystemColor(BACKGROUND);
-	}
-	return background;
-}
-
-/**
- * Returns the index of the column over which the TreeCursor is positioned.
- * 
- * @return the column index for the current position
- * 
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public int getColumn() {
-	checkWidget();
-	return column == null ? 0 : tree.indexOf(column);
-}
-
-/**
- * Returns the foreground color that the receiver will use to draw.
- *
- * @return the receiver's foreground color
- */
-public Color getForeground() {
-	checkWidget();
-	if (foreground == null) {
-		return getDisplay().getSystemColor(FOREGROUND);
-	}
-	return foreground;
-}
-
-TreeItem getLastVisibleItem(TreeItem[] items) {
-	if (items == null) return null;
-	TreeItem last = items[items.length - 1];
-	if (last.getExpanded() && last.getItemCount() > 0) {
-		return getLastVisibleItem(last.getItems());
-	}
-	return last;
-}
-
-TreeItem getNextItem(TreeItem item) {
-	if (item == null) return null;
-	if (item.getExpanded() && item.getItemCount() > 0) {
-		return item.getItem(0);
-	}
-
-	TreeItem parentItem = item.getParentItem();
-	while (parentItem != null) {
-		int index = parentItem.indexOf(item);
-		if (index == -1) return null;
-		if (index < parentItem.getItemCount() - 1) {
-			return parentItem.getItem(index + 1);
-		}
-		item = parentItem;
-		parentItem = item.getParentItem();
-	}
-	int index = tree.indexOf(item);
-	if (index == -1) return null;
-	if (index == tree.getItemCount() - 1) return null;
-	return tree.getItem(index + 1);	
-}
-
-TreeItem getPreviousItem(TreeItem item) {
-	if (item == null) return null;
-	TreeItem parentItem = item.getParentItem();
-	if (parentItem == null) {
-		int index = tree.indexOf(item);
-		if (index == -1 || index == 0) return null;
-		item = tree.getItem(index - 1);
-		if (item.getExpanded() && item.getItemCount() > 0) {
-			return getLastVisibleItem(item.getItems());
-		}
-		return item;
-	}
-	int index = parentItem.indexOf(item);
-	if (index == -1) return null;
-	if (index == 0) return parentItem;
-	item = parentItem.getItem(index - 1);
-	if (item.getExpanded() && item.getItemCount() > 0) {
-		return getLastVisibleItem(item.getItems());
-	}
-	return item;
-}
-
-/**
- * Returns the row over which the TreeCursor is positioned.
- * 
- * @return the item for the current position, or <code>null</code> if none
- * 
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public TreeItem getRow() {
-	checkWidget();
-	return row;
-}
-
-void keyDown(Event event) {
-	if (row == null) return;
-	switch (event.character) {
-		case SWT.CR:
-			notifyListeners(SWT.DefaultSelection, new Event());
-			return;
-	}
-	switch (event.keyCode) {
-		case SWT.ARROW_UP:
-			TreeItem previousItem = getPreviousItem(row);
-			if (previousItem != null) {
-				setRowColumn(previousItem, column, true);
-			}
-			break;
-		case SWT.ARROW_DOWN:
-			TreeItem nextItem = getNextItem(row);
-			if (nextItem != null) {
-				setRowColumn(nextItem, column, true);
-			}
-			break;
-		case SWT.ARROW_LEFT:
-		case SWT.ARROW_RIGHT: {
-			if ((event.stateMask & SWT.MOD1) != 0) {
-				row.setExpanded (event.keyCode == SWT.ARROW_RIGHT);
-				break;
-			}
-			int columnCount = tree.getColumnCount();
-			if (columnCount == 0) break;
-			int columnIndex = column == null ? 0 : tree.indexOf(column);
-			int[] columnOrder = tree.getColumnOrder();
-			int index = 0;
-			while (index < columnOrder.length) {
-				if (columnOrder[index] == columnIndex) break;
-				index++;
-			}
-			if (index == columnOrder.length) index = 0;
-			int leadKey = (getStyle() & SWT.RIGHT_TO_LEFT) != 0 ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT;
-			TreeItem parentRow = row.getParentItem();
-			int rowIndex = tree.indexOf(row);
-			if (event.keyCode == leadKey) {
-				if (parentRow != null) {
-					setRowColumn(row, tree.getColumn(columnOrder[Math.max(0, index - 1)]), true);
-				} else {
-					setRowColumn(rowIndex, columnOrder[Math.max(0, index - 1)], true);
-				}
-			} else {
-				if (parentRow != null) {
-					setRowColumn(row, tree.getColumn(columnOrder[Math.min(columnCount - 1, index + 1)]), true);
-				} else {
-					setRowColumn(rowIndex, columnOrder[Math.min(columnCount - 1, index + 1)], true);
-				}
-			}
-			break;
-		}
-		case SWT.HOME:
-			int columnIndex = column == null ? 0 : tree.indexOf(column);
-			setRowColumn(0, columnIndex, true);
-			break;
-		case SWT.END: {
-			TreeItem[] items = tree.getItems();
-			setRowColumn(getLastVisibleItem(items), column, true);
-			break;
-		}
-		case SWT.PAGE_UP: {
-			Rectangle rect = tree.getClientArea();
-			Rectangle itemRect = tree.getTopItem().getBounds();
-			TreeItem item = row;
-			int index = findIndex(tree.getItems(), item);
-			int itemHeight = tree.getItemHeight();
-			rect.height -= itemRect.y;
-			int page = Math.max(1, rect.height / itemHeight);
-			if (index - page <= 0) {
-				TreeItem first = tree.getItem(0);
-				setRowColumn(first, column, true);
-				break;
-			}
-			for (int i = 0; i < page; i++) {
-				item = getPreviousItem(item);
-			}
-			setRowColumn(item, column, true);
-			break;
-		}
-		case SWT.PAGE_DOWN: {
-			Rectangle rect = tree.getClientArea();
-			Rectangle itemRect = tree.getTopItem().getBounds();
-			TreeItem item = row;
-			int index = findIndex(tree.getItems(), item);
-			int height = tree.getItemHeight();
-			rect.height -= itemRect.y;
-			TreeItem last = getLastVisibleItem(tree.getItems());
-			int page = Math.max(1, rect.height / height);
-			int end = findIndex(tree.getItems(), last);
-			if (end <= index + page) {
-				setRowColumn(last, column, true);
-				break;
-			}
-			for (int i = 0; i < page; i++) {
-				item = getNextItem(item);
-			}
-			setRowColumn(item, column, true);
-			break;
-		}
-	}
-}
-
-void onDispose(Event event) {
-	removeListener(SWT.Dispose, listener);
-	notifyListeners(SWT.Dispose, event);
-	event.type = SWT.None;
-
-	tree.removeListener(SWT.Collapse, treeListener);
-	tree.removeListener(SWT.Expand, treeListener);
-	tree.removeListener(SWT.FocusIn, treeListener);
-	tree.removeListener(SWT.MouseDown, treeListener);
-	unhookRowColumnListeners();
-	ScrollBar hBar = tree.getHorizontalBar();
-	if (hBar != null) {
-		hBar.removeListener(SWT.Selection, resizeListener);
-	}
-	ScrollBar vBar = tree.getVerticalBar();
-	if (vBar != null) {
-		vBar.removeListener(SWT.Selection, resizeListener);
-	}
-}
-
-void paint(Event event) {
-	if (row == null) return;
-	int columnIndex = column == null ? 0 : tree.indexOf(column);
-	int orderedIndex = columnIndex;
-	int[] columnOrder = tree.getColumnOrder();
-	for (int i = 0; i < columnOrder.length; i++) {
-		if (columnOrder[i] == columnIndex) {
-			orderedIndex = i;
-			break;
-		}
-	}
-	GC gc = event.gc;
-	gc.setBackground(getBackground());
-	gc.setForeground(getForeground());
-	gc.fillRectangle(event.x, event.y, event.width, event.height);
-	Image image = row.getImage(columnIndex);
-	int x = 0;
-	// Temporary code - need a better way to determine trim
-	String platform = SWT.getPlatform();
-	if (image != null) {
-		if ("win32".equals(platform)) { //$NON-NLS-1$
-			if (orderedIndex > 0) { 
-				x += 2;
-			}
-		} else {
-			x += 2;
-		}
-	}
-	Point size = getSize();
-	if (image != null) {
-		Rectangle imageSize = image.getBounds();
-		int imageY = (size.y - imageSize.height) / 2;
-		gc.drawImage(image, x, imageY);
-		x += imageSize.width;
-	}
-	String text = row.getText(columnIndex);
-	if (text.length() > 0) {
-		Rectangle bounds = row.getBounds(columnIndex);
-		Point extent = gc.stringExtent(text);
-		// Temporary code - need a better way to determine trim
-		if ("win32".equals(platform)) { //$NON-NLS-1$
-			if (tree.getColumnCount() == 0 || orderedIndex == 0) {
-				x += image == null ? 2 : 5;
-			} else {
-				int alignmnent = column.getAlignment();
-				switch (alignmnent) {
-					case SWT.LEFT:
-						x += image == null ? 5 : 3;
-						break;
-					case SWT.RIGHT:
-						x = bounds.width - extent.x - 2;
-						break;
-					case SWT.CENTER:
-						x += Math.ceil((bounds.width - x - extent.x) / 2.0);
-						break;
-				}
-			}
-		} else {
-			if (tree.getColumnCount() == 0) {
-				x += image == null ? 4 : 3;
-			} else {
-				int alignmnent = column.getAlignment();
-				switch (alignmnent) {
-					case SWT.LEFT:
-						x += image == null ? 5 : 3;
-						break;
-					case SWT.RIGHT:
-						x = bounds.width - extent.x - 2;
-						break;
-					case SWT.CENTER:
-						x += (bounds.width - x - extent.x) / 2 + 2;
-						break;
-				}
-			}
-		}
-		int textY = (size.y - extent.y) / 2;
-		gc.drawString(text, x, textY);
-	}
-	if (isFocusControl()) {
-		Display display = getDisplay();
-		gc.setBackground(display.getSystemColor(SWT.COLOR_BLACK));
-		gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));
-		gc.drawFocus(0, 0, size.x, size.y);
-	}
-}
-
-/**
- * Removes the listener from the collection of listeners who will be notified when the
- * receiver's selection changes.
- * 
- * @param listener the listener which should no longer be notified
- * 
- * @exception IllegalArgumentException <ul>
- *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
- * </ul>
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- * 
- * @see SelectionListener
- * @see #addSelectionListener(SelectionListener)
- */
-public void removeSelectionListener(SelectionListener listener) {
-	checkWidget();
-	if (listener == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
-	removeListener(SWT.Selection, listener);
-	removeListener(SWT.DefaultSelection, listener);
-}
-
-void _resize() {
-	if (row == null) {
-		setBounds(-200, -200, 0, 0);
-	} else {
-		int columnIndex = column == null ? 0 : tree.indexOf(column);
-		setBounds(row.getBounds(columnIndex));
-	}
-}
-
-/**
- * Sets the receiver's background color to the color specified
- * by the argument, or to the default system color for the control
- * if the argument is null.
- * <p>
- * Note: This operation is a hint and may be overridden by the platform.
- * For example, on Windows the background of a Button cannot be changed.
- * </p>
- * @param color the new color (or null)
- *
- * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- * </ul>
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public void setBackground (Color color) {
-	background = color;
-	super.setBackground(getBackground());
-	redraw();
-}
-/**
- * Sets the receiver's foreground color to the color specified
- * by the argument, or to the default system color for the control
- * if the argument is null.
- * <p>
- * Note: This operation is a hint and may be overridden by the platform.
- * </p>
- * @param color the new color (or null)
- *
- * @exception IllegalArgumentException <ul>
- *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
- * </ul>
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public void setForeground (Color color) {
-	foreground = color;
-	super.setForeground(getForeground());
-	redraw();
-}
-
-void setRowColumn(int row, int column, boolean notify) {
-	TreeItem item = row == -1 ? null : tree.getItem(row);
-	TreeColumn col = column == -1 || tree.getColumnCount() == 0 ? null : tree.getColumn(column);
-	setRowColumn(item, col, notify);
-}
-
-void setRowColumn(TreeItem row, TreeColumn column, boolean notify) {
-	if (this.row != null && this.row != row) {
-		TreeItem currentItem = this.row;
-		while (currentItem != null) {
-			currentItem.removeListener(SWT.Dispose, disposeItemListener);
-			currentItem = currentItem.getParentItem();
-		}
-		this.row = null;
-	}
-	if (this.column != null && this.column != column) {
-		this.column.removeListener(SWT.Dispose, disposeColumnListener);
-		this.column.removeListener(SWT.Move, resizeListener);
-		this.column.removeListener(SWT.Resize, resizeListener);
-		this.column = null;
-	}
-	if (row != null) {
-		if (this.row != row) {
-			this.row = row;
-			TreeItem currentItem = row;
-			while (currentItem != null) {
-				currentItem.addListener(SWT.Dispose, disposeItemListener);
-				currentItem = currentItem.getParentItem();
-			}
-			tree.showItem(row);
-		}
-		if (this.column != column && column != null) {
-			this.column = column;
-			column.addListener(SWT.Dispose, disposeColumnListener);
-			column.addListener(SWT.Move, resizeListener);
-			column.addListener(SWT.Resize, resizeListener);
-			tree.showColumn(column);
-		}
-		int columnIndex = column == null ? 0 : tree.indexOf(column);
-		setBounds(row.getBounds(columnIndex));
-		redraw();
-		if (notify) notifyListeners(SWT.Selection, new Event());
-	}
-}
-
-/**
- * Positions the TreeCursor over the root-level cell at the given row and column in the parent tree.
- * 
- * @param row the index of the root-level row for the cell to select
- * @param column the index of column for the cell to select
- * 
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public void setSelection(int row, int column) {
-	checkWidget();
-	int columnCount = tree.getColumnCount();
-	int maxColumnIndex = columnCount == 0 ? 0 : columnCount - 1;
-	if (row < 0 || row >= tree.getItemCount() || column < 0 || column > maxColumnIndex) {
-		SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-	}
-	setRowColumn(row, column, false);
-}
-
-/**
- * Positions the TreeCursor over the cell at the given row and column in the parent tree.
- * 
- * @param row the TreeItem of the row for the cell to select
- * @param column the index of column for the cell to select
- * 
- * @exception SWTException <ul>
- *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
- *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
- * </ul>
- */
-public void setSelection(TreeItem row, int column) {
-	checkWidget();
-	int columnCount = tree.getColumnCount();
-	int maxColumnIndex = columnCount == 0 ? 0 : columnCount - 1;
-	if (row == null || row.isDisposed() || column < 0 || column > maxColumnIndex) {
-		SWT.error(SWT.ERROR_INVALID_ARGUMENT);
-	}
-	TreeColumn col = tree.getColumnCount() == 0 ? null : tree.getColumn(column);
-	setRowColumn(row, col, false);
-}
-
-public void setVisible(boolean visible) {
-	checkWidget();
-	if (visible) {
-		_resize();
-	}
-	super.setVisible(visible);
-}
-
-void treeCollapse(Event event) {
-	if (row == null) return;
-	TreeItem root = (TreeItem)event.item;
-	TreeItem parentItem = row.getParentItem();
-	while (parentItem != null) {
-		if (parentItem == root) {
-			setRowColumn(root, column, true);
-			return;
-		}
-		parentItem = parentItem.getParentItem();
-	}
-	
-	getDisplay().asyncExec(new Runnable() {
-		public void run() {
-			if (isDisposed()) return;
-			setRowColumn(row, column, true);
-		}
-	});
-}
-
-void treeExpand(Event event) {
-	getDisplay().asyncExec(new Runnable() {
-		public void run() {
-			if (isDisposed()) return;
-			setRowColumn(row, column, true);
-		}
-	});
-}
-
-void treeFocusIn(Event event) {
-	if (isVisible()) {
-		if (row == null && column == null) return;
-		setFocus();
-	}
-}
-
-void treeMouseDown(Event event) {
-	if (tree.getItemCount() == 0) return;
-	Point pt = new Point(event.x, event.y);
-	TreeItem item = tree.getItem(pt);
-	if (item == null && (tree.getStyle() & SWT.FULL_SELECTION) == 0) {
-		TreeItem currentItem = tree.getTopItem();
-		TreeItem parentItem = currentItem.getParentItem();
-		while (parentItem != null) {
-			currentItem = parentItem;
-			parentItem = currentItem.getParentItem();
-		}
-		int start = tree.indexOf(currentItem);
-		int viewportItemCount = tree.getClientArea().height / tree.getItemHeight();
-		int end = Math.min(start + viewportItemCount, tree.getItemCount() - 1);
-		TreeItem[] allItems = tree.getItems();
-		TreeItem[] items = new TreeItem[end - start + 1];
-		System.arraycopy(allItems, start, items, 0, end - start + 1);
-		item = findItem(items, pt);
-	}
-	if (item == null) return;
-
-	TreeColumn newColumn = null;
-	int lineWidth = tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
-	int columnCount = tree.getColumnCount();
-	if (columnCount > 0) {
-		for (int i = 0; i < columnCount; i++) {
-			Rectangle rect = item.getBounds(i);
-			rect.width += lineWidth;
-			rect.height += lineWidth;
-			if (rect.contains(pt)) {
-				newColumn = tree.getColumn(i);
-				break;
-			}
-		}
-		if (newColumn == null) {
-			newColumn = tree.getColumn(0);
-		}
-	}
-	setRowColumn(item, newColumn, true);
-	setFocus();
-}
-
-void unhookRowColumnListeners() {
-	if (column != null && !column.isDisposed()) {
-		column.removeListener(SWT.Dispose, disposeColumnListener);
-		column.removeListener(SWT.Move, resizeListener);
-		column.removeListener(SWT.Resize, resizeListener);
-	}
-	column = null;
-	if (row != null && !row.isDisposed()) {
-		TreeItem currentItem = row;
-		while (currentItem != null) {
-			currentItem.removeListener(SWT.Dispose, disposeItemListener);
-			currentItem = currentItem.getParentItem();
-		}
-	}
-	row = null;
-}
-
-}
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.swt.custom;
+
+
+import org.eclipse.swt.*;
+import org.eclipse.swt.accessibility.*;
+import org.eclipse.swt.events.*;
+import org.eclipse.swt.graphics.*;
+import org.eclipse.swt.widgets.*;
+
+/**
+ * A TreeCursor provides a way for the user to navigate around a Tree with columns using the
+ * keyboard. It also provides a mechanism for selecting an individual cell in a tree.
+ * <p>
+ * For a detailed example of using a TreeCursor to navigate to a cell and then edit it see
+ * http://git.eclipse.org/c/platform/eclipse.platform.swt.git/tree/examples/org.eclipse.swt.snippets/src/org/eclipse/swt/snippets/Snippet360.java .
+ * 
+ * <dl>
+ * <dt><b>Styles:</b></dt>
+ * <dd>BORDER</dd>
+ * <dt><b>Events:</b></dt>
+ * <dd>Selection, DefaultSelection</dd>
+ * </dl>
+ * 
+ * @since 3.8
+ */
+public class TreeCursor extends Canvas {
+	Tree tree;
+	TreeItem row;
+	TreeColumn column;
+	Listener listener, treeListener, resizeListener, disposeItemListener, disposeColumnListener;
+
+	Color background = null;
+	Color foreground = null;
+	
+	/* By default, invert the list selection colors */
+	static final int BACKGROUND = SWT.COLOR_LIST_SELECTION_TEXT;
+	static final int FOREGROUND = SWT.COLOR_LIST_SELECTION;
+
+/**
+ * Constructs a new instance of this class given its parent tree and a style value describing
+ * its behavior and appearance.
+ * <p>
+ * The style value is either one of the style constants defined in class <code>SWT</code> which
+ * is applicable to instances of this class, or must be built by <em>bitwise OR</em>'ing
+ * together (that is, using the <code>int</code> "|" operator) two or more of those
+ * <code>SWT</code> style constants. The class description lists the style constants that are
+ * applicable to the class. Style bits are also inherited from superclasses.
+ * </p>
+ * 
+ * @param parent a Tree control which will be the parent of the new instance (cannot be null)
+ * @param style the style of control to construct
+ * 
+ * @exception IllegalArgumentException <ul>
+ *    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>
+ * </ul>
+ * @exception SWTException <ul>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the parent</li>
+ *    <li>ERROR_INVALID_SUBCLASS - if this class is not an allowed subclass</li>
+ * </ul>
+ * 
+ * @see SWT#BORDER
+ * @see Widget#checkSubclass()
+ * @see Widget#getStyle()
+ */
+public TreeCursor(Tree parent, int style) {
+	super(parent, style);
+	tree = parent;
+	setBackground(null);
+	setForeground(null);
+
+	listener = new Listener() {
+		public void handleEvent(Event event) {
+			if (row != null) {
+				/*
+				 * Detect cases where the cursor position has become invalid and fix it.
+				 * The typical cause of this is programmatic tree changes, such as
+				 * expanding/collapsing and item and creating/disposing items.
+				 */
+				if (row.isDisposed()) {
+					unhookRowColumnListeners();
+					_resize();
+					tree.setFocus();
+					return;
+				}
+				TreeItem current = row;
+				TreeItem parentItem = row.getParentItem();
+				while (parentItem != null && !parentItem.getExpanded()) {
+					current = parentItem;
+					parentItem = current.getParentItem();
+				}
+				if (current != row) {
+					setRowColumn(current, column, false);
+				}
+			}
+			switch (event.type) {
+				case SWT.Dispose:
+					onDispose(event);
+					break;
+				case SWT.FocusIn:
+				case SWT.FocusOut:
+					redraw();
+					break;
+				case SWT.KeyDown:
+					keyDown(event);
+					break;
+				case SWT.Paint:
+					paint(event);
+					break;
+				case SWT.Traverse:
+					event.doit = true;
+					switch (event.detail) {
+						case SWT.TRAVERSE_ARROW_NEXT:
+						case SWT.TRAVERSE_ARROW_PREVIOUS:
+						case SWT.TRAVERSE_RETURN:
+							event.doit = false;
+							break;
+					}
+					break;
+			}
+		}
+	};
+	int[] events = new int[] { SWT.Dispose, SWT.FocusIn, SWT.FocusOut, SWT.KeyDown, SWT.Paint, SWT.Traverse };
+	for (int i = 0; i < events.length; i++) {
+		addListener(events[i], listener);
+	}
+
+	treeListener = new Listener() {
+		public void handleEvent(Event event) {
+			switch (event.type) {
+				case SWT.Collapse:
+					treeCollapse(event);
+					break;
+				case SWT.Expand:
+					treeExpand(event);
+					break;
+				case SWT.FocusIn:
+					treeFocusIn(event);
+					break;
+				case SWT.MouseDown:
+					treeMouseDown(event);
+					break;
+			}
+		}
+	};
+	tree.addListener(SWT.Collapse, treeListener);
+	tree.addListener(SWT.Expand, treeListener);
+	tree.addListener(SWT.FocusIn, treeListener);
+	tree.addListener(SWT.MouseDown, treeListener);
+	
+	disposeItemListener = new Listener() {
+		public void handleEvent(Event event) {
+			TreeItem currentItem = row;
+			while (currentItem != null) {
+				currentItem.removeListener(SWT.Dispose, disposeItemListener);
+				currentItem = currentItem.getParentItem();
+			}
+			TreeItem disposedItem = (TreeItem)event.widget;
+			TreeItem parentItem = disposedItem.getParentItem();
+			if (parentItem != null) {
+				setRowColumn(parentItem, column, true);
+			} else {
+				if (tree.getItemCount() == 1) {
+					unhookRowColumnListeners();
+				} else {
+					TreeItem newFocus = null;
+					int rowIndex = tree.indexOf(disposedItem);
+					if (rowIndex != 0) {
+						TreeItem previousItem = tree.getItem(rowIndex - 1);
+						if (!previousItem.isDisposed()) {
+							newFocus = previousItem;
+						}
+					}
+					if (newFocus == null && rowIndex + 1 < tree.getItemCount()) {
+						TreeItem nextItem = tree.getItem(rowIndex + 1);
+						if (!nextItem.isDisposed()) {
+							newFocus = nextItem;
+						}
+					}
+					if (newFocus != null) {
+						setRowColumn(newFocus, column, true);
+					} else {
+						unhookRowColumnListeners();
+					}
+				}
+			}
+			_resize();
+		}
+	};
+	disposeColumnListener = new Listener() {
+		public void handleEvent(Event event) {
+			if (column != null) {
+				if (tree.getColumnCount() == 1) {
+					column = null;
+				} else {
+					int columnIndex = tree.indexOf(column);
+					int positionIndex = columnIndex;
+					int[] columnOrder = tree.getColumnOrder();
+					for (int i = 0; i < columnOrder.length; i++) {
+						if (columnOrder[i] == columnIndex) {
+							positionIndex = i;
+							break;
+						}
+					}
+					if (positionIndex == columnOrder.length - 1) {
+						setRowColumn(row, tree.getColumn(columnOrder[positionIndex - 1]), true);
+					} else {
+						setRowColumn(row, tree.getColumn(columnOrder[positionIndex + 1]), true);
+					}
+				}
+			}
+			_resize();
+		}
+	};
+	resizeListener = new Listener() {
+		public void handleEvent(Event event) {
+			_resize();
+		}
+	};
+	ScrollBar hBar = tree.getHorizontalBar();
+	if (hBar != null) {
+		hBar.addListener(SWT.Selection, resizeListener);
+	}
+	ScrollBar vBar = tree.getVerticalBar();
+	if (vBar != null) {
+		vBar.addListener(SWT.Selection, resizeListener);
+	}
+	
+	getAccessible().addAccessibleControlListener(new AccessibleControlAdapter() {
+		public void getRole(AccessibleControlEvent e) {
+			e.detail = ACC.ROLE_TABLECELL;
+		}
+	});
+	getAccessible().addAccessibleListener(new AccessibleAdapter() {
+		public void getName(AccessibleEvent e) {
+			if (row == null) return;
+			int columnIndex = column == null ? 0 : tree.indexOf(column);
+			e.result = row.getText(columnIndex);
+		}
+	});
+}
+
+/**
+ * Adds the listener to the collection of listeners who will be notified when the receiver's
+ * selection changes, by sending it one of the messages defined in the
+ * <code>SelectionListener</code> interface.
+ * <p>
+ * When <code>widgetSelected</code> is called, the item field of the event object is valid. If
+ * the receiver has <code>SWT.CHECK</code> style set and the check selection changes, the event
+ * object detail field contains the value <code>SWT.CHECK</code>.
+ * <code>widgetDefaultSelected</code> is typically called when an item is double-clicked.
+ * </p>
+ * 
+ * @param listener the listener which should be notified
+ * 
+ * @exception IllegalArgumentException <ul>
+ *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
+ * </ul>
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ * 
+ * @see SelectionListener
+ * @see SelectionEvent
+ * @see #removeSelectionListener(SelectionListener)
+ */
+public void addSelectionListener(SelectionListener listener) {
+	checkWidget();
+	if (listener == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
+	TypedListener typedListener = new TypedListener(listener);
+	addListener(SWT.Selection, typedListener);
+	addListener(SWT.DefaultSelection, typedListener);
+}
+
+int countSubTreePages(TreeItem root) {
+	int pages = 1;
+	if (root == null) return 0;
+	if (root.getItemCount() == 0) return 1;
+	if (!root.getExpanded()) return 1;
+	TreeItem[] items = root.getItems();
+	for (int i = 0; i < items.length; i++) {
+		pages += countSubTreePages(items[i]);
+	}
+	return pages;
+}
+
+int findIndex(TreeItem[] items, TreeItem treeItem) {
+	if (items == null || treeItem == null) return -1;
+	Rectangle rect = treeItem.getBounds();
+	int index = 0;
+	for (int i = 0; i < items.length; i++) {
+		TreeItem previousItem = null;
+		TreeItem currentItem = items[i];
+		if (i > 0) previousItem = items[i - 1];
+		Rectangle rect1 = currentItem.getBounds();
+		if (rect.y == rect1.y) return index;
+		if (rect.y < rect1.y) {
+			return index - 1 + findIndex(previousItem.getItems(), treeItem);
+		}
+		if (rect.y > rect1.y && i == items.length - 1) {
+			return index + findIndex(currentItem.getItems(), treeItem);
+		}
+		if (rect.y >= rect1.y + (1 + currentItem.getItemCount()) * tree.getItemHeight() && currentItem.getExpanded()) {
+			index += countSubTreePages(currentItem);
+			continue;
+		}
+		index++;
+	}
+	return -1;
+}
+
+TreeItem findItem(TreeItem[] items, Point pt) {
+	int start = 0, end = items.length - 1;
+	int index = end / 2;
+	while (end - start > 1) {
+		TreeItem currentItem = items[index];
+		Rectangle bounds = currentItem.getBounds();
+		if (pt.y < bounds.y) {
+			end = index;
+			index = (end - start) / 2;
+		} else {
+			start = index;
+			index = start + ((end - start) / 2);
+		}
+	}
+
+	Rectangle endBounds = items[end].getBounds();
+	if (endBounds.y < pt.y) {
+		if (endBounds.y + endBounds.height < pt.y) {
+			if (!items[end].getExpanded()) return null;
+			return findItem(items[end].getItems(), pt);
+		}
+		int[] columnOrder = tree.getColumnOrder();
+		Rectangle bounds = null;
+		if (columnOrder.length > 0) {
+			Rectangle rect1 = items[end].getBounds(columnOrder[0]);
+			Rectangle rect2 = items[end].getBounds(columnOrder[columnOrder.length - 1]);
+			bounds = rect1.union(rect2);
+			bounds.height += tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
+		} else {
+			bounds = items[end].getBounds();
+		}
+		return bounds.contains(pt) ? items[end] : null;		
+	}
+	
+	Rectangle startBounds = items[start].getBounds();
+	if (startBounds.y + startBounds.height < pt.y) {
+		return findItem(items[start].getItems(), pt);
+	}
+	int[] columnOrder = tree.getColumnOrder();
+	Rectangle bounds = null;
+	if (columnOrder.length > 0) {
+		Rectangle rect1 = items[start].getBounds(columnOrder[0]);
+		Rectangle rect2 = items[start].getBounds(columnOrder[columnOrder.length - 1]);
+		bounds = rect1.union(rect2);
+		bounds.height += tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
+	} else {
+		bounds = items[start].getBounds();
+	}
+	return bounds.contains(pt) ? items[start] : null;
+}
+
+/**
+ * Returns the background color that the receiver will use to draw.
+ *
+ * @return the receiver's background color
+ */
+public Color getBackground() {
+	checkWidget();
+	if (background == null) {
+		return getDisplay().getSystemColor(BACKGROUND);
+	}
+	return background;
+}
+
+/**
+ * Returns the index of the column over which the TreeCursor is positioned.
+ * 
+ * @return the column index for the current position
+ * 
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public int getColumn() {
+	checkWidget();
+	return column == null ? 0 : tree.indexOf(column);
+}
+
+/**
+ * Returns the foreground color that the receiver will use to draw.
+ *
+ * @return the receiver's foreground color
+ */
+public Color getForeground() {
+	checkWidget();
+	if (foreground == null) {
+		return getDisplay().getSystemColor(FOREGROUND);
+	}
+	return foreground;
+}
+
+TreeItem getLastVisibleItem(TreeItem[] items) {
+	if (items == null) return null;
+	TreeItem last = items[items.length - 1];
+	if (last.getExpanded() && last.getItemCount() > 0) {
+		return getLastVisibleItem(last.getItems());
+	}
+	return last;
+}
+
+TreeItem getNextItem(TreeItem item) {
+	if (item == null) return null;
+	if (item.getExpanded() && item.getItemCount() > 0) {
+		return item.getItem(0);
+	}
+
+	TreeItem parentItem = item.getParentItem();
+	while (parentItem != null) {
+		int index = parentItem.indexOf(item);
+		if (index == -1) return null;
+		if (index < parentItem.getItemCount() - 1) {
+			return parentItem.getItem(index + 1);
+		}
+		item = parentItem;
+		parentItem = item.getParentItem();
+	}
+	int index = tree.indexOf(item);
+	if (index == -1) return null;
+	if (index == tree.getItemCount() - 1) return null;
+	return tree.getItem(index + 1);	
+}
+
+TreeItem getPreviousItem(TreeItem item) {
+	if (item == null) return null;
+	TreeItem parentItem = item.getParentItem();
+	if (parentItem == null) {
+		int index = tree.indexOf(item);
+		if (index == -1 || index == 0) return null;
+		item = tree.getItem(index - 1);
+		if (item.getExpanded() && item.getItemCount() > 0) {
+			return getLastVisibleItem(item.getItems());
+		}
+		return item;
+	}
+	int index = parentItem.indexOf(item);
+	if (index == -1) return null;
+	if (index == 0) return parentItem;
+	item = parentItem.getItem(index - 1);
+	if (item.getExpanded() && item.getItemCount() > 0) {
+		return getLastVisibleItem(item.getItems());
+	}
+	return item;
+}
+
+/**
+ * Returns the row over which the TreeCursor is positioned.
+ * 
+ * @return the item for the current position, or <code>null</code> if none
+ * 
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public TreeItem getRow() {
+	checkWidget();
+	return row;
+}
+
+void keyDown(Event event) {
+	if (row == null) return;
+	switch (event.character) {
+		case SWT.CR:
+			notifyListeners(SWT.DefaultSelection, new Event());
+			return;
+	}
+	switch (event.keyCode) {
+		case SWT.ARROW_UP:
+			TreeItem previousItem = getPreviousItem(row);
+			if (previousItem != null) {
+				setRowColumn(previousItem, column, true);
+			}
+			break;
+		case SWT.ARROW_DOWN:
+			TreeItem nextItem = getNextItem(row);
+			if (nextItem != null) {
+				setRowColumn(nextItem, column, true);
+			}
+			break;
+		case SWT.ARROW_LEFT:
+		case SWT.ARROW_RIGHT: {
+			if ((event.stateMask & SWT.MOD1) != 0) {
+				row.setExpanded (event.keyCode == SWT.ARROW_RIGHT);
+				break;
+			}
+			int columnCount = tree.getColumnCount();
+			if (columnCount == 0) break;
+			int columnIndex = column == null ? 0 : tree.indexOf(column);
+			int[] columnOrder = tree.getColumnOrder();
+			int index = 0;
+			while (index < columnOrder.length) {
+				if (columnOrder[index] == columnIndex) break;
+				index++;
+			}
+			if (index == columnOrder.length) index = 0;
+			int leadKey = (getStyle() & SWT.RIGHT_TO_LEFT) != 0 ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT;
+			TreeItem parentRow = row.getParentItem();
+			int rowIndex = tree.indexOf(row);
+			if (event.keyCode == leadKey) {
+				if (parentRow != null) {
+					setRowColumn(row, tree.getColumn(columnOrder[Math.max(0, index - 1)]), true);
+				} else {
+					setRowColumn(rowIndex, columnOrder[Math.max(0, index - 1)], true);
+				}
+			} else {
+				if (parentRow != null) {
+					setRowColumn(row, tree.getColumn(columnOrder[Math.min(columnCount - 1, index + 1)]), true);
+				} else {
+					setRowColumn(rowIndex, columnOrder[Math.min(columnCount - 1, index + 1)], true);
+				}
+			}
+			break;
+		}
+		case SWT.HOME:
+			int columnIndex = column == null ? 0 : tree.indexOf(column);
+			setRowColumn(0, columnIndex, true);
+			break;
+		case SWT.END: {
+			TreeItem[] items = tree.getItems();
+			setRowColumn(getLastVisibleItem(items), column, true);
+			break;
+		}
+		case SWT.PAGE_UP: {
+			Rectangle rect = tree.getClientArea();
+			Rectangle itemRect = tree.getTopItem().getBounds();
+			TreeItem item = row;
+			int index = findIndex(tree.getItems(), item);
+			int itemHeight = tree.getItemHeight();
+			rect.height -= itemRect.y;
+			int page = Math.max(1, rect.height / itemHeight);
+			if (index - page <= 0) {
+				TreeItem first = tree.getItem(0);
+				setRowColumn(first, column, true);
+				break;
+			}
+			for (int i = 0; i < page; i++) {
+				item = getPreviousItem(item);
+			}
+			setRowColumn(item, column, true);
+			break;
+		}
+		case SWT.PAGE_DOWN: {
+			Rectangle rect = tree.getClientArea();
+			Rectangle itemRect = tree.getTopItem().getBounds();
+			TreeItem item = row;
+			int index = findIndex(tree.getItems(), item);
+			int height = tree.getItemHeight();
+			rect.height -= itemRect.y;
+			TreeItem last = getLastVisibleItem(tree.getItems());
+			int page = Math.max(1, rect.height / height);
+			int end = findIndex(tree.getItems(), last);
+			if (end <= index + page) {
+				setRowColumn(last, column, true);
+				break;
+			}
+			for (int i = 0; i < page; i++) {
+				item = getNextItem(item);
+			}
+			setRowColumn(item, column, true);
+			break;
+		}
+	}
+}
+
+void onDispose(Event event) {
+	removeListener(SWT.Dispose, listener);
+	notifyListeners(SWT.Dispose, event);
+	event.type = SWT.None;
+
+	tree.removeListener(SWT.Collapse, treeListener);
+	tree.removeListener(SWT.Expand, treeListener);
+	tree.removeListener(SWT.FocusIn, treeListener);
+	tree.removeListener(SWT.MouseDown, treeListener);
+	unhookRowColumnListeners();
+	ScrollBar hBar = tree.getHorizontalBar();
+	if (hBar != null) {
+		hBar.removeListener(SWT.Selection, resizeListener);
+	}
+	ScrollBar vBar = tree.getVerticalBar();
+	if (vBar != null) {
+		vBar.removeListener(SWT.Selection, resizeListener);
+	}
+}
+
+void paint(Event event) {
+	if (row == null) return;
+	int columnIndex = column == null ? 0 : tree.indexOf(column);
+	int orderedIndex = columnIndex;
+	int[] columnOrder = tree.getColumnOrder();
+	for (int i = 0; i < columnOrder.length; i++) {
+		if (columnOrder[i] == columnIndex) {
+			orderedIndex = i;
+			break;
+		}
+	}
+	GC gc = event.gc;
+	gc.setBackground(getBackground());
+	gc.setForeground(getForeground());
+	gc.fillRectangle(event.x, event.y, event.width, event.height);
+	Image image = row.getImage(columnIndex);
+	int x = 0;
+	// Temporary code - need a better way to determine trim
+	String platform = SWT.getPlatform();
+	if (image != null) {
+		if ("win32".equals(platform)) { //$NON-NLS-1$
+			if (orderedIndex > 0) { 
+				x += 2;
+			}
+		} else {
+			x += 2;
+		}
+	}
+	Point size = getSize();
+	if (image != null) {
+		Rectangle imageSize = image.getBounds();
+		int imageY = (size.y - imageSize.height) / 2;
+		gc.drawImage(image, x, imageY);
+		x += imageSize.width;
+	}
+	String text = row.getText(columnIndex);
+	if (text.length() > 0) {
+		Rectangle bounds = row.getBounds(columnIndex);
+		Point extent = gc.stringExtent(text);
+		// Temporary code - need a better way to determine trim
+		if ("win32".equals(platform)) { //$NON-NLS-1$
+			if (tree.getColumnCount() == 0 || orderedIndex == 0) {
+				x += image == null ? 2 : 5;
+			} else {
+				int alignmnent = column.getAlignment();
+				switch (alignmnent) {
+					case SWT.LEFT:
+						x += image == null ? 5 : 3;
+						break;
+					case SWT.RIGHT:
+						x = bounds.width - extent.x - 2;
+						break;
+					case SWT.CENTER:
+						x += Math.ceil((bounds.width - x - extent.x) / 2.0);
+						break;
+				}
+			}
+		} else {
+			if (tree.getColumnCount() == 0) {
+				x += image == null ? 4 : 3;
+			} else {
+				int alignmnent = column.getAlignment();
+				switch (alignmnent) {
+					case SWT.LEFT:
+						x += image == null ? 5 : 3;
+						break;
+					case SWT.RIGHT:
+						x = bounds.width - extent.x - 2;
+						break;
+					case SWT.CENTER:
+						x += (bounds.width - x - extent.x) / 2 + 2;
+						break;
+				}
+			}
+		}
+		int textY = (size.y - extent.y) / 2;
+		gc.drawString(text, x, textY);
+	}
+	if (isFocusControl()) {
+		Display display = getDisplay();
+		gc.setBackground(display.getSystemColor(SWT.COLOR_BLACK));
+		gc.setForeground(display.getSystemColor(SWT.COLOR_WHITE));
+		gc.drawFocus(0, 0, size.x, size.y);
+	}
+}
+
+/**
+ * Removes the listener from the collection of listeners who will be notified when the
+ * receiver's selection changes.
+ * 
+ * @param listener the listener which should no longer be notified
+ * 
+ * @exception IllegalArgumentException <ul>
+ *    <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
+ * </ul>
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ * 
+ * @see SelectionListener
+ * @see #addSelectionListener(SelectionListener)
+ */
+public void removeSelectionListener(SelectionListener listener) {
+	checkWidget();
+	if (listener == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
+	removeListener(SWT.Selection, listener);
+	removeListener(SWT.DefaultSelection, listener);
+}
+
+void _resize() {
+	if (row == null) {
+		setBounds(-200, -200, 0, 0);
+	} else {
+		int columnIndex = column == null ? 0 : tree.indexOf(column);
+		setBounds(row.getBounds(columnIndex));
+	}
+}
+
+/**
+ * Sets the receiver's background color to the color specified
+ * by the argument, or to the default system color for the control
+ * if the argument is null.
+ * <p>
+ * Note: This operation is a hint and may be overridden by the platform.
+ * For example, on Windows the background of a Button cannot be changed.
+ * </p>
+ * @param color the new color (or null)
+ *
+ * @exception IllegalArgumentException <ul>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ * </ul>
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public void setBackground (Color color) {
+	background = color;
+	super.setBackground(getBackground());
+	redraw();
+}
+/**
+ * Sets the receiver's foreground color to the color specified
+ * by the argument, or to the default system color for the control
+ * if the argument is null.
+ * <p>
+ * Note: This operation is a hint and may be overridden by the platform.
+ * </p>
+ * @param color the new color (or null)
+ *
+ * @exception IllegalArgumentException <ul>
+ *    <li>ERROR_INVALID_ARGUMENT - if the argument has been disposed</li> 
+ * </ul>
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public void setForeground (Color color) {
+	foreground = color;
+	super.setForeground(getForeground());
+	redraw();
+}
+
+void setRowColumn(int row, int column, boolean notify) {
+	TreeItem item = row == -1 ? null : tree.getItem(row);
+	TreeColumn col = column == -1 || tree.getColumnCount() == 0 ? null : tree.getColumn(column);
+	setRowColumn(item, col, notify);
+}
+
+void setRowColumn(TreeItem row, TreeColumn column, boolean notify) {
+	if (this.row != null && this.row != row) {
+		TreeItem currentItem = this.row;
+		while (currentItem != null) {
+			currentItem.removeListener(SWT.Dispose, disposeItemListener);
+			currentItem = currentItem.getParentItem();
+		}
+		this.row = null;
+	}
+	if (this.column != null && this.column != column) {
+		this.column.removeListener(SWT.Dispose, disposeColumnListener);
+		this.column.removeListener(SWT.Move, resizeListener);
+		this.column.removeListener(SWT.Resize, resizeListener);
+		this.column = null;
+	}
+	if (row != null) {
+		if (this.row != row) {
+			this.row = row;
+			TreeItem currentItem = row;
+			while (currentItem != null) {
+				currentItem.addListener(SWT.Dispose, disposeItemListener);
+				currentItem = currentItem.getParentItem();
+			}
+			tree.showItem(row);
+		}
+		if (this.column != column && column != null) {
+			this.column = column;
+			column.addListener(SWT.Dispose, disposeColumnListener);
+			column.addListener(SWT.Move, resizeListener);
+			column.addListener(SWT.Resize, resizeListener);
+			tree.showColumn(column);
+		}
+		int columnIndex = column == null ? 0 : tree.indexOf(column);
+		setBounds(row.getBounds(columnIndex));
+		redraw();
+		if (notify) notifyListeners(SWT.Selection, new Event());
+	}
+}
+
+/**
+ * Positions the TreeCursor over the root-level cell at the given row and column in the parent tree.
+ * 
+ * @param row the index of the root-level row for the cell to select
+ * @param column the index of column for the cell to select
+ * 
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public void setSelection(int row, int column) {
+	checkWidget();
+	int columnCount = tree.getColumnCount();
+	int maxColumnIndex = columnCount == 0 ? 0 : columnCount - 1;
+	if (row < 0 || row >= tree.getItemCount() || column < 0 || column > maxColumnIndex) {
+		SWT.error(SWT.ERROR_INVALID_ARGUMENT);
+	}
+	setRowColumn(row, column, false);
+}
+
+/**
+ * Positions the TreeCursor over the cell at the given row and column in the parent tree.
+ * 
+ * @param row the TreeItem of the row for the cell to select
+ * @param column the index of column for the cell to select
+ * 
+ * @exception SWTException <ul>
+ *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+ *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>
+ * </ul>
+ */
+public void setSelection(TreeItem row, int column) {
+	checkWidget();
+	int columnCount = tree.getColumnCount();
+	int maxColumnIndex = columnCount == 0 ? 0 : columnCount - 1;
+	if (row == null || row.isDisposed() || column < 0 || column > maxColumnIndex) {
+		SWT.error(SWT.ERROR_INVALID_ARGUMENT);
+	}
+	TreeColumn col = tree.getColumnCount() == 0 ? null : tree.getColumn(column);
+	setRowColumn(row, col, false);
+}
+
+public void setVisible(boolean visible) {
+	checkWidget();
+	if (visible) {
+		_resize();
+	}
+	super.setVisible(visible);
+}
+
+void treeCollapse(Event event) {
+	if (row == null) return;
+	TreeItem root = (TreeItem)event.item;
+	TreeItem parentItem = row.getParentItem();
+	while (parentItem != null) {
+		if (parentItem == root) {
+			setRowColumn(root, column, true);
+			return;
+		}
+		parentItem = parentItem.getParentItem();
+	}
+	
+	getDisplay().asyncExec(new Runnable() {
+		public void run() {
+			if (isDisposed()) return;
+			setRowColumn(row, column, true);
+		}
+	});
+}
+
+void treeExpand(Event event) {
+	getDisplay().asyncExec(new Runnable() {
+		public void run() {
+			if (isDisposed()) return;
+			setRowColumn(row, column, true);
+		}
+	});
+}
+
+void treeFocusIn(Event event) {
+	if (isVisible()) {
+		if (row == null && column == null) return;
+		setFocus();
+	}
+}
+
+void treeMouseDown(Event event) {
+	if (tree.getItemCount() == 0) return;
+	Point pt = new Point(event.x, event.y);
+	TreeItem item = tree.getItem(pt);
+	if (item == null && (tree.getStyle() & SWT.FULL_SELECTION) == 0) {
+		TreeItem currentItem = tree.getTopItem();
+		TreeItem parentItem = currentItem.getParentItem();
+		while (parentItem != null) {
+			currentItem = parentItem;
+			parentItem = currentItem.getParentItem();
+		}
+		int start = tree.indexOf(currentItem);
+		int viewportItemCount = tree.getClientArea().height / tree.getItemHeight();
+		int end = Math.min(start + viewportItemCount, tree.getItemCount() - 1);
+		TreeItem[] allItems = tree.getItems();
+		TreeItem[] items = new TreeItem[end - start + 1];
+		System.arraycopy(allItems, start, items, 0, end - start + 1);
+		item = findItem(items, pt);
+	}
+	if (item == null) return;
+
+	TreeColumn newColumn = null;
+	int lineWidth = tree.getLinesVisible() ? tree.getGridLineWidth() : 0;
+	int columnCount = tree.getColumnCount();
+	if (columnCount > 0) {
+		for (int i = 0; i < columnCount; i++) {
+			Rectangle rect = item.getBounds(i);
+			rect.width += lineWidth;
+			rect.height += lineWidth;
+			if (rect.contains(pt)) {
+				newColumn = tree.getColumn(i);
+				break;
+			}
+		}
+		if (newColumn == null) {
+			newColumn = tree.getColumn(0);
+		}
+	}
+	setRowColumn(item, newColumn, true);
+	setFocus();
+}
+
+void unhookRowColumnListeners() {
+	if (column != null && !column.isDisposed()) {
+		column.removeListener(SWT.Dispose, disposeColumnListener);
+		column.removeListener(SWT.Move, resizeListener);
+		column.removeListener(SWT.Resize, resizeListener);
+	}
+	column = null;
+	if (row != null && !row.isDisposed()) {
+		TreeItem currentItem = row;
+		while (currentItem != null) {
+			currentItem.removeListener(SWT.Dispose, disposeItemListener);
+			currentItem = currentItem.getParentItem();
+		}
+	}
+	row = null;
+}
+
+}
Index: org/eclipse/swt/custom/TableEditor.java
===================================================================
--- org/eclipse/swt/custom/TableEditor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/custom/TableEditor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -113,7 +113,7 @@
 	Rectangle rect = item.getImageBounds(column);
 	if (rect.width != 0) {
 		int imageGap = Math.max(rect.x - cell.x, 0);
-		cell.x = rect.x + rect.width;
+	cell.x = rect.x + rect.width;
 		cell.width -= (imageGap + rect.width);
 	}
 	Rectangle area = table.getClientArea();
Index: org/eclipse/swt/internal/image/TIFFFileFormat.java
===================================================================
--- org/eclipse/swt/internal/image/TIFFFileFormat.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/TIFFFileFormat.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -54,8 +54,8 @@
 			(header[4] & 0xFF) | ((header[5] & 0xFF) << 8) | ((header[6] & 0xFF) << 16) | ((header[7] & 0xFF) << 24) :
 			(header[7] & 0xFF) | ((header[6] & 0xFF) << 8) | ((header[5] & 0xFF) << 16) | ((header[4] & 0xFF) << 24);
 		while (offset != 0) {
-			file.seek(offset);
-			TIFFDirectory directory = new TIFFDirectory(file, isLittleEndian, loader);
+		file.seek(offset);
+		TIFFDirectory directory = new TIFFDirectory(file, isLittleEndian, loader);
 			int [] nextIFDOffset = new int[1];
 			ImageData image = directory.read(nextIFDOffset);
 			offset = nextIFDOffset[0];
Index: org/eclipse/swt/internal/image/PngEncoder.java
===================================================================
--- org/eclipse/swt/internal/image/PngEncoder.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/PngEncoder.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -317,15 +317,15 @@
 				if (colorType == 6) {
 					lineBytes[offset++] = alphaData[x];
 				}
+				
+				}
 			
-			}
-			
 			os.write(lineBytes);
 			
+			}
+		
 		}
 	
-	}
-	
 	os.flush();
 	os.close();
 	
@@ -332,7 +332,7 @@
 	byte[] compressed = baos.toByteArray();
 	if (os == baos) {
 		/* Use PngDeflater for J2ME. */
-		PngDeflater deflater = new PngDeflater();
+	PngDeflater deflater = new PngDeflater();
 		compressed = deflater.deflate(compressed);
 	}
 	
Index: org/eclipse/swt/internal/image/PNGFileFormat.java
===================================================================
--- org/eclipse/swt/internal/image/PNGFileFormat.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/image/PNGFileFormat.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -280,7 +280,7 @@
 					System.arraycopy(data, y * srcBytesPerLine, imageData.data, y * destBytesPerLine, srcBytesPerLine);
 				}
 			} else {
-				imageData.data = data;
+			imageData.data = data;
 			}
 			break;
 	}
Index: org/eclipse/swt/internal/Library.java
===================================================================
--- org/eclipse/swt/internal/Library.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/Library.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -40,7 +40,7 @@
 
 	static final String SEPARATOR;
 	static final String DELIMITER;
-	
+
 	/* 64-bit support */
 	static final boolean IS_64 = longConst() == (int /*long*/)longConst();
 	static final String SUFFIX_64 = "-64";	//$NON-NLS-1$
@@ -257,12 +257,12 @@
 	if (prop == null) prop = System.getProperty ("com.ibm.vm.bitmode"); //$NON-NLS-1$
 	if (prop != null) {
 		if ("32".equals (prop) && IS_64) { //$NON-NLS-1$
-			throw new UnsatisfiedLinkError ("Cannot load 64-bit SWT libraries on 32-bit JVM"); //$NON-NLS-1$
-		}
+				throw new UnsatisfiedLinkError ("Cannot load 64-bit SWT libraries on 32-bit JVM"); //$NON-NLS-1$
+			 }
 		if ("64".equals (prop) && !IS_64) { //$NON-NLS-1$
-			throw new UnsatisfiedLinkError ("Cannot load 32-bit SWT libraries on 64-bit JVM"); //$NON-NLS-1$
+				throw new UnsatisfiedLinkError ("Cannot load 32-bit SWT libraries on 64-bit JVM"); //$NON-NLS-1$
+			}		
 		}
-	}
 	
 	/* Compute the library name and mapped name */
 	String libName1, libName2, mappedName1, mappedName2;
@@ -301,7 +301,7 @@
 	/* Try loading library from java library path */
 	if (load (libName1, message)) return;
 	if (mapName && load (libName2, message)) return;
-
+	
 	/* Try loading library from the tmp directory if swt library path is not specified */
 	String fileName1 = mappedName1;
 	String fileName2 = mappedName2;
Index: org/eclipse/swt/internal/BidiUtil.java
===================================================================
--- org/eclipse/swt/internal/BidiUtil.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/BidiUtil.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -496,7 +496,7 @@
 public static void removeLanguageListener (int /*long*/ hwnd) {
 	languageMap.remove(new LONG(hwnd));
 	unsubclass(hwnd);
-}
+}		
 public static void removeLanguageListener (Control control) {
 	removeLanguageListener(control.handle);
 }
@@ -512,13 +512,13 @@
 public static void setKeyboardLanguage(int language) {
 	if (language == getKeyboardLanguage()) return;
 	boolean bidi = language == KEYBOARD_BIDI; 
-	int /*long*/[] list = getKeyboardLanguageList();
-	for (int i=0; i<list.length; i++) {
+		int /*long*/[] list = getKeyboardLanguageList();
+		for (int i=0; i<list.length; i++) {
 		if (bidi == isBidiLang(list[i])) {
-			OS.ActivateKeyboardLayout(list[i], 0);
-			return;
+				OS.ActivateKeyboardLayout(list[i], 0);
+				return;
+			}
 		}
-	}
 }
 /**
  * Sets the orientation (writing order) of the specified control. Text will 
Index: org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java
===================================================================
--- org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/TVINSERTSTRUCT.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -27,11 +27,11 @@
 	/** @field accessor=item.pszText,cast=(LPTSTR) */
 	public int /*long*/ pszText;
   	/** @field accessor=item.cchTextMax */
-	public int cchTextMax;
+  	public int cchTextMax;
   	/** @field accessor=item.iImage */
-	public int iImage;
+  	public int iImage;
   	/** @field accessor=item.iSelectedImage */
-	public int iSelectedImage;
+  	public int iSelectedImage;
 	/** @field accessor=item.cChildren */
 	public int cChildren;
 	/** @field accessor=item.lParam */
Index: org/eclipse/swt/internal/win32/OS.java
===================================================================
--- org/eclipse/swt/internal/win32/OS.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/OS.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     QFS GmbH - Accessibility/Testing hooks (see <QFS>)
  *******************************************************************************/
 package org.eclipse.swt.internal.win32;
 
@@ -13,11 +14,85 @@
 
 import org.eclipse.swt.internal.*;
 
+// <QFS>
+import java.util.HashSet;
+import java.util.Set;
+
+import de.qfs.lib.log.Log;
+import de.qfs.lib.log.Logger;
+// </QFS>
+
 public class OS extends C {
 	static {
 		Library.loadLibrary ("swt"); //$NON-NLS-1$
 	}
-	
+
+    // <QFS>
+    // {{{ QF-Log, statics
+
+    /**
+     * The Logger used for logging.
+     */
+    private final static Logger logger =
+        new Logger ("org.eclipse.swt.internal.win32.OS");
+
+
+    // key = int Windows-Event
+    private static Set importantEvents = new HashSet();
+    private static Set unimportantEvents = new HashSet();
+    static {
+        importantEvents.add(new Integer(OS.WM_LBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_LBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_LBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_MBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_MBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_MBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_RBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_RBUTTONUP));
+        importantEvents.add(new Integer(OS.WM_RBUTTONDBLCLK));
+        importantEvents.add(new Integer(OS.WM_MOUSEMOVE));
+        importantEvents.add(new Integer(OS.WM_ACTIVATE));
+        importantEvents.add(new Integer(OS.WM_KEYDOWN));
+        importantEvents.add(new Integer(OS.WM_KEYUP));
+        importantEvents.add(new Integer(OS.WM_CHAR)); // why do we get that one when KEYDOWN is suppressed? where does it come from?
+        // importantEvents.add(new Integer(OS.WM_GETDLGCODE)); // why do we get that one when KEYDOWN is suppressed? where does it come from?
+        importantEvents.add(new Integer(OS.WM_NCLBUTTONDOWN));
+        importantEvents.add(new Integer(OS.WM_SYSCOMMAND)); // -> menubar
+        // importantEvents.add(new Integer(OS.WM_SETCURSOR));
+        importantEvents.add(new Integer(OS.WM_MENUSELECT));
+        importantEvents.add(new Integer(OS.WM_INITMENUPOPUP));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+        // importantEvents.add(new Integer(OS.));
+
+        unimportantEvents.add(new Integer(OS.WM_PAINT));
+        unimportantEvents.add(new Integer(OS.WM_GETFONT));
+        unimportantEvents.add(new Integer(OS.WM_NCACTIVATE));
+        unimportantEvents.add(new Integer(OS.WM_NCCALCSIZE));
+        unimportantEvents.add(new Integer(OS.WM_NCHITTEST));
+        unimportantEvents.add(new Integer(OS.WM_NOTIFY));
+        unimportantEvents.add(new Integer(OS.WM_SETCURSOR));
+        unimportantEvents.add(new Integer(OS.WM_SETFONT));
+        unimportantEvents.add(new Integer(OS.WM_ERASEBKGND));
+        unimportantEvents.add(new Integer(OS.WM_TIMER));
+        unimportantEvents.add(new Integer(OS.WM_ENTERIDLE));
+    }
+
+    static ThreadLocal replayOverride = new ThreadLocal ();
+    public static void setReplaying(boolean replaying, int replayPos)
+    {
+        if (logger.level >= Log.MTD) {
+            Logger.Builder lb = logger.build("setReplaying(boolean,int)");
+            (logger.level < Log.MTDDETAIL ? lb : lb
+             .add("replaying: ").add(replaying)
+             .add(", replayPos: ").add(replayPos)).log(Log.MTD);
+        }
+        replayOverride.set(replaying ? new Integer (replayPos) : null);
+    }
+    // }}}
+    // </QFS>
+
 	/*
 	* SWT Windows flags
 	*/
@@ -43,7 +118,7 @@
 	public static final int VER_PLATFORM_WIN32_WINDOWS = 1;
 	public static final int VER_PLATFORM_WIN32_NT = 2;
 	public static final int VER_PLATFORM_WIN32_CE = 3;
-	
+
 	/* Forward references */
 	public static final int HEAP_ZERO_MEMORY = 0x8;
 	public static final int ACTCTX_FLAG_RESOURCE_NAME_VALID = 0x00000008;
@@ -54,7 +129,7 @@
 	public static final int LANG_KOREAN = 0x12;
 	public static final int LANG_JAPANESE = 0x11;
 	public static final int MAX_PATH = 260;
-	
+
 	/* Get the Windows version and the flags */
 	static {
 		/*
@@ -62,7 +137,7 @@
 		* and then the ANSI version.  The UNICODE version
 		* is present on all versions of Windows but is not
 		* implemented on Win95/98/ME.
-		* 
+		*
 		* NOTE: The value of OSVERSIONINFO.sizeof cannot
 		* be static final because it relies on the Windows
 		* platform version to be initialized and IsUnicode
@@ -78,7 +153,7 @@
 			OS.GetVersionExA ((OSVERSIONINFOA)info);
 		}
 		OSVERSIONINFO.sizeof = info.dwOSVersionInfoSize;
-		
+
 		IsWin32s = info.dwPlatformId == VER_PLATFORM_WIN32s;
 		IsWin95 = info.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
 		IsWinNT = info.dwPlatformId == VER_PLATFORM_WIN32_NT;
@@ -85,7 +160,7 @@
 		IsWinCE = info.dwPlatformId == VER_PLATFORM_WIN32_CE;
 		IsSP = IsSP();
 		IsPPC = IsPPC();
-		IsHPC = IsWinCE && !IsPPC && !IsSP;	
+		IsHPC = IsWinCE && !IsPPC && !IsSP;
 		WIN32_MAJOR = info.dwMajorVersion;
 		WIN32_MINOR = info.dwMinorVersion;
 		WIN32_VERSION = VERSION (WIN32_MAJOR, WIN32_MINOR);
@@ -102,7 +177,7 @@
 				int /*long*/ hHeap = OS.GetProcessHeap ();
 				int byteCount = buffer.length () * (OS.IsUnicode ? 2 : 1);
 				int /*long*/ pszText = OS.HeapAlloc (hHeap, HEAP_ZERO_MEMORY, byteCount);
-				OS.MoveMemory (pszText, buffer, byteCount);	
+				OS.MoveMemory (pszText, buffer, byteCount);
 				ACTCTX pActCtx = new ACTCTX ();
 				pActCtx.cbSize = ACTCTX.sizeof;
 				pActCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_SET_PROCESS_DEFAULT;
@@ -119,7 +194,7 @@
 				*/
 			}
 		}
-		
+
 		/* Make the process DPI aware for Windows Vista */
 		if (!OS.IsWinCE && OS.WIN32_VERSION >= OS.VERSION (6, 0)) OS.SetProcessDPIAware ();
 
@@ -127,7 +202,7 @@
 		boolean dbcsEnabled = OS.GetSystemMetrics (SM_DBCSENABLED) != 0;
 		boolean immEnabled = OS.GetSystemMetrics (SM_IMMENABLED) != 0;
 		IsDBLocale = dbcsEnabled || immEnabled;
-		
+
 		/*
 		* Bug in Windows.  On Korean Windows XP when the Text
 		* Services Framework support for legacy applications
@@ -136,7 +211,7 @@
 		* to move the composition window outside of the client
 		* area, Windows crashes.  The fix is to disable legacy
 		* support.
-		* 
+		*
 		* Note: The bug is fixed in Service Pack 2.
 		*/
 		if (!OS.IsWinCE && OS.WIN32_VERSION == OS.VERSION (5, 1)) {
@@ -152,7 +227,7 @@
 			}
 		}
 	}
-	
+
 	/* Get the COMCTL32.DLL version */
 	static {
 		DLLVERSIONINFO dvi = new DLLVERSIONINFO ();
@@ -175,7 +250,7 @@
 		COMCTL32_MINOR = dvi.dwMinorVersion;
 		COMCTL32_VERSION = VERSION (COMCTL32_MAJOR, COMCTL32_MINOR);
 	}
-	
+
 	/* Get the Shell32.DLL version */
 	static {
 		DLLVERSIONINFO dvi = new DLLVERSIONINFO ();
@@ -202,7 +277,7 @@
 	static final int SYS_COLOR_INDEX_FLAG = OS.IsWinCE ? 0x40000000 : 0x0;
 
 	/*
-	* NOTE:  There is a bug in JVM 1.2 where loading 
+	* NOTE:  There is a bug in JVM 1.2 where loading
 	* a class with a large number of constants causes
 	* a segment fault to occur sometime later after
 	* the class is loaded.  The fix is to break the
@@ -276,7 +351,7 @@
 	public static final int BFFM_VALIDATEFAILED = IsUnicode ? 0x4 : 0x3;
 	public static final int BFFM_VALIDATEFAILEDW = 0x4;
 	public static final int BFFM_VALIDATEFAILEDA = 0x3;
-	public static final int BF_ADJUST = 0x2000; 
+	public static final int BF_ADJUST = 0x2000;
 	public static final int BF_LEFT = 0x0001;
 	public static final int BF_TOP = 0x0002;
 	public static final int BF_RIGHT = 0x0004;
@@ -579,7 +654,7 @@
 	public static final int DT_VCENTER = 4;
 	public static final int DT_WORDBREAK = 0x10;
 	public static final int DTM_FIRST = 0x1000;
-	public static final int DTM_GETSYSTEMTIME = DTM_FIRST + 1; 
+	public static final int DTM_GETSYSTEMTIME = DTM_FIRST + 1;
 	public static final int DTM_GETIDEALSIZE = DTM_FIRST + 15;
 	public static final int DTM_SETFORMAT = IsUnicode ? DTM_FIRST + 50 : DTM_FIRST + 5;
 	public static final int DTM_SETSYSTEMTIME = DTM_FIRST + 2;
@@ -593,7 +668,7 @@
 	public static final int DTS_TIMEFORMAT = 0x0009;
 	public static final int DTS_UPDOWN = 0x0001;
 	public static final int DWM_BB_ENABLE = 0x1;
-	public static final int DWM_BB_BLURREGION = 0x2; 
+	public static final int DWM_BB_BLURREGION = 0x2;
 	public static final int DWM_BB_TRANSITIONONMAXIMIZED = 0x4;
 	public static final int E_POINTER = 0x80004003;
 	public static final int EBP_NORMALGROUPBACKGROUND = 5;
@@ -976,9 +1051,9 @@
 	public static final int LOCALE_IDATE = 0x00000021;
 	public static final int LOCALE_ITIME = 0x00000023;
 	public static final int LOCALE_RETURN_NUMBER = 0x20000000; // #if(WINVER >= 0x0400)
-	public static final int LOCALE_S1159 = 0x00000028;	
-	public static final int LOCALE_S2359 = 0x00000029;	
-	public static final int LOCALE_SDECIMAL = 14;	
+	public static final int LOCALE_S1159 = 0x00000028;
+	public static final int LOCALE_S2359 = 0x00000029;
+	public static final int LOCALE_SDECIMAL = 14;
 	public static final int LOCALE_SISO3166CTRYNAME = 0x5a;
 	public static final int LOCALE_SISO639LANGNAME = 0x59;
 	public static final int LOCALE_SLONGDATE = 0x00000020;
@@ -1168,7 +1243,7 @@
 	public static final int MFS_GRAYED = 0x3;
 	public static final int MFT_RADIOCHECK = 0x200;
 	public static final int MFT_RIGHTJUSTIFY = 0x4000;
-	public static final int MFT_RIGHTORDER = 0x2000; 
+	public static final int MFT_RIGHTORDER = 0x2000;
 	public static final int MFT_SEPARATOR = 0x800;
 	public static final int MFT_STRING = 0x0;
 	public static final int MF_BYCOMMAND = 0x0;
@@ -1207,12 +1282,12 @@
 	public static final int MONITORINFOF_PRIMARY = 0x1;
 	public static final String MONTHCAL_CLASS = "SysMonthCal32"; //$NON-NLS-1$
 	public static final int MOUSEEVENTF_ABSOLUTE = 0x8000;
-	public static final int MOUSEEVENTF_LEFTDOWN = 0x0002; 
-	public static final int MOUSEEVENTF_LEFTUP = 0x0004; 
-	public static final int MOUSEEVENTF_MIDDLEDOWN = 0x0020; 
-	public static final int MOUSEEVENTF_MIDDLEUP = 0x0040; 
+	public static final int MOUSEEVENTF_LEFTDOWN = 0x0002;
+	public static final int MOUSEEVENTF_LEFTUP = 0x0004;
+	public static final int MOUSEEVENTF_MIDDLEDOWN = 0x0020;
+	public static final int MOUSEEVENTF_MIDDLEUP = 0x0040;
 	public static final int MOUSEEVENTF_MOVE = 0x0001;
-	public static final int MOUSEEVENTF_RIGHTDOWN = 0x0008; 
+	public static final int MOUSEEVENTF_RIGHTDOWN = 0x0008;
 	public static final int MOUSEEVENTF_RIGHTUP = 0x0010;
 	public static final int MOUSEEVENTF_VIRTUALDESK = 0x4000;
 	public static final int MOUSEEVENTF_WHEEL = 0x0800;
@@ -1321,7 +1396,7 @@
 	public static final int PBS_VERTICAL = 0x4;
 	public static final int PBS_NORMAL = 1;
 	public static final int PBS_HOT = 2;
-	public static final int PBS_PRESSED = 3; 
+	public static final int PBS_PRESSED = 3;
 	public static final int PBS_DISABLED = 4;
 	public static final int PBS_DEFAULTED = 5;
 	public static final int PBST_NORMAL = 0x0001;
@@ -1485,6 +1560,11 @@
 	public static final int SB_THUMBPOSITION = 0x4;
 	public static final int SB_THUMBTRACK = 0x5;
 	public static final int SB_TOP = 0x6;
+    // <QFS>
+    public static final int SB_LEFT = 0x6;
+    public static final int SB_PAGELEFT = 0x2;
+    public static final int SB_LINELEFT = 0x0;
+    // </QFS>
 	public static final int SB_VERT = 0x1;
 	public static final int SCF_ALL = 0x4;
 	public static final int SCF_DEFAULT = 0x0;
@@ -1669,7 +1749,7 @@
 	public static final int TBSTYLE_DROPDOWN = 0x8;
 	public static final int TBSTATE_ENABLED = 0x4;
 	public static final int TBSTYLE_AUTOSIZE = 0x10;
-	public static final int TBSTYLE_EX_DOUBLEBUFFER = 0x80; 
+	public static final int TBSTYLE_EX_DOUBLEBUFFER = 0x80;
 	public static final int TBSTYLE_EX_DRAWDDARROWS = 0x1;
 	public static final int TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0x10;
 	public static final int TBSTYLE_EX_MIXEDBUTTONS = 0x8;
@@ -1841,7 +1921,7 @@
 	public static final int TTM_DELTOOL = IsUnicode ? 0x433 : 0x405;
 	public static final int TTM_GETTOOLINFO = 0x400 + (IsUnicode ? 53 : 8);
 	public static final int TTM_NEWTOOLRECT = 0x400 + (IsUnicode ? 52 : 6);
-	public static final int TTM_POP = 0x400 + 28; 
+	public static final int TTM_POP = 0x400 + 28;
 	public static final int TTM_SETDELAYTIME = 0x400 + 3;
 	public static final int TTM_SETMAXTIPWIDTH = 0x418;
 	public static final int TTM_SETTITLEA = 0x400 + 32;
@@ -1862,6 +1942,9 @@
 	public static final int TTS_NOFADE = 0x20;
 	public static final int TTS_NOPREFIX = 0x02;
 	public static final int TV_FIRST = 0x1100;
+        // <QFS>
+        public static final int TVM_SETSCROLLTIME = TV_FIRST + 33;
+        // </QFS>
 	public static final int TVE_COLLAPSE = 0x1;
 	public static final int TVE_COLLAPSERESET = 0x8000;
 	public static final int TVE_EXPAND = 0x2;
@@ -1925,7 +2008,6 @@
 	public static final int TVM_SETINSERTMARK = 0x111a;
 	public static final int TVM_SETITEM = IsUnicode ? 0x113f : 0x110d;
 	public static final int TVM_SETITEMHEIGHT = TV_FIRST + 27;
-	public static final int TVM_SETSCROLLTIME = TV_FIRST + 33;
 	public static final int TVM_SETTEXTCOLOR = 0x111e;
 	public static final int TVM_SORTCHILDREN = TV_FIRST + 19;
 	public static final int TVM_SORTCHILDRENCB = TV_FIRST + 21;
@@ -2091,6 +2173,11 @@
 	public static final int WHITE_BRUSH = 0;
 	public static final int WHITENESS = 0x00FF0062;
 	public static final int WM_ACTIVATE = 0x6;
+    // <QFS>
+    public static final int WM_SETTEXT = 0xC;
+    public static final int WM_GETTEXT = 0xD;
+    public static final int WM_GETTEXTLENGTH = 0xE;
+    // </QFS>
 	public static final int WM_ACTIVATEAPP = 0x1c;
 	public static final int WM_APP = 0x8000;
 	public static final int WM_DWMCOLORIZATIONCOLORCHANGED = 0x320;
@@ -2103,7 +2190,7 @@
 	public static final int WM_COMMAND = 0x111;
 	public static final int WM_CONTEXTMENU = 0x7b;
 	public static final int WM_COPY = 0x301;
-	public static final int WM_CREATE = 0x0001;	
+	public static final int WM_CREATE = 0x0001;
 	public static final int WM_CTLCOLORBTN = 0x135;
 	public static final int WM_CTLCOLORDLG = 0x136;
 	public static final int WM_CTLCOLOREDIT = 0x133;
@@ -2160,7 +2247,13 @@
 	public static final int WM_NCACTIVATE = 0x86;
 	public static final int WM_NCCALCSIZE = 0x83;
 	public static final int WM_NCHITTEST = 0x84;
+    // <QFS>
+    public static final int WM_NCMOUSEMOVE = 0x00A0;
+    // </QFS>
 	public static final int WM_NCLBUTTONDOWN = 0x00A1;
+    // <QFS>
+    public static final int WM_NCLBUTTONUP = 0x00A2;
+    // </QFS>
 	public static final int WM_NCPAINT = 0x85;
 	public static final int WM_NOTIFY = 0x4e;
 	public static final int WM_NULL = 0x0;
@@ -2182,7 +2275,6 @@
 	public static final int WM_SETFONT = 0x30;
 	public static final int WM_SETICON = 0x80;
 	public static final int WM_SETREDRAW = 0xb;
-	public static final int WM_SETTEXT = 12;
 	public static final int WM_SETTINGCHANGE = 0x1A;
 	public static final int WM_SHOWWINDOW = 0x18;
 	public static final int WM_SIZE = 0x5;
@@ -2243,11 +2335,197 @@
 	public static final int XBUTTON1 = 0x1;
 	public static final int XBUTTON2 = 0x2;
 	public static final int X509_ASN_ENCODING = 1;
-	
+
+    // <QFS>
+    public static final int WA_INACTIVE = 0;
+    public static final int WA_ACTIVE = 1;
+    public static final int WA_CLICKACTIVE = 2;
+    // </QFS>
+
 public static int VERSION (int major, int minor) {
 	return major << 16 | minor;
 }
 
+// <QFS>
+    // {{{ getWinMsgType
+
+    public final static String getWinMsgType(int msg, boolean[] hasMatch)
+    {
+        String msgtype = null;
+        switch (msg) {
+            // {{{ big case to get name
+
+        case OS.WM_SETTEXT: msgtype = "WM_SETTEXT"; break;
+        case OS.WM_GETTEXT: msgtype = "WM_GETTEXT"; break;
+        case OS.WM_GETTEXTLENGTH: msgtype = "WM_GETTEXTLENGTH"; break;
+        case OS.WM_ACTIVATE: msgtype = "WM_ACTIVATE"; break;
+        case OS.WM_ACTIVATEAPP: msgtype = "WM_ACTIVATEAPP"; break;
+        case OS.WM_APP: msgtype = "WM_APP"; break;
+        case OS.WM_CANCELMODE: msgtype = "WM_CANCELMODE"; break;
+        case OS.WM_CAPTURECHANGED: msgtype = "WM_CAPTURECHANGED"; break;
+        case OS.WM_CHANGEUISTATE: msgtype = "WM_CHANGEUISTATE"; break;
+        case OS.WM_CHAR: msgtype = "WM_CHAR"; break;
+        case OS.WM_CLEAR: msgtype = "WM_CLEAR"; break;
+        case OS.WM_CLOSE: msgtype = "WM_CLOSE"; break;
+        case OS.WM_COMMAND: msgtype = "WM_COMMAND"; break;
+        case OS.WM_CONTEXTMENU: msgtype = "WM_CONTEXTMENU"; break;
+        case OS.WM_COPY: msgtype = "WM_COPY"; break;
+        case OS.WM_CREATE: msgtype = "WM_CREATE"; break;
+        case OS.WM_CTLCOLORBTN: msgtype = "WM_CTLCOLORBTN"; break;
+        case OS.WM_CTLCOLORDLG: msgtype = "WM_CTLCOLORDLG"; break;
+        case OS.WM_CTLCOLOREDIT: msgtype = "WM_CTLCOLOREDIT"; break;
+        case OS.WM_CTLCOLORLISTBOX: msgtype = "WM_CTLCOLORLISTBOX"; break;
+        case OS.WM_CTLCOLORMSGBOX: msgtype = "WM_CTLCOLORMSGBOX"; break;
+        case OS.WM_CTLCOLORSCROLLBAR: msgtype = "WM_CTLCOLORSCROLLBAR"; break;
+        case OS.WM_CTLCOLORSTATIC: msgtype = "WM_CTLCOLORSTATIC"; break;
+        case OS.WM_CUT: msgtype = "WM_CUT"; break;
+        case OS.WM_DEADCHAR: msgtype = "WM_DEADCHAR"; break;
+        case OS.WM_DESTROY: msgtype = "WM_DESTROY"; break;
+        case OS.WM_DRAWITEM: msgtype = "WM_DRAWITEM"; break;
+        case OS.WM_ENDSESSION: msgtype = "WM_ENDSESSION"; break;
+        case OS.WM_ENTERIDLE: msgtype = "WM_ENTERIDLE"; break;
+        case OS.WM_ERASEBKGND: msgtype = "WM_ERASEBKGND"; break;
+        case OS.WM_GETDLGCODE: msgtype = "WM_GETDLGCODE"; break;
+        case OS.WM_GETFONT: msgtype = "WM_GETFONT"; break;
+            //      case OS.WM_GETICON: msgtype = "WM_GETICON"; break;
+        case OS.WM_GETOBJECT: msgtype = "WM_GETOBJECT"; break;
+        case OS.WM_GETMINMAXINFO: msgtype = "WM_GETMINMAXINFO"; break;
+        case OS.WM_HELP: msgtype = "WM_HELP"; break;
+        case OS.WM_HOTKEY: msgtype = "WM_HOTKEY"; break;
+        case OS.WM_HSCROLL: msgtype = "WM_HSCROLL"; break;
+        case OS.WM_IME_CHAR: msgtype = "WM_IME_CHAR"; break;
+        case OS.WM_IME_COMPOSITION: msgtype = "WM_IME_COMPOSITION"; break;
+        case OS.WM_INITDIALOG: msgtype = "WM_INITDIALOG"; break;
+        case OS.WM_INITMENUPOPUP: msgtype = "WM_INITMENUPOPUP"; break;
+        case OS.WM_INPUTLANGCHANGE: msgtype = "WM_INPUTLANGCHANGE"; break;
+        case OS.WM_KEYDOWN: msgtype = "WM_KEYDOWN"; break;
+            // case OS.WM_KEYFIRST: msgtype = "WM_KEYFIRST"; break;
+        case OS.WM_KEYLAST: msgtype = "WM_KEYLAST"; break;
+        case OS.WM_KEYUP: msgtype = "WM_KEYUP"; break;
+        case OS.WM_KILLFOCUS: msgtype = "WM_KILLFOCUS"; break;
+        case OS.WM_LBUTTONDBLCLK: msgtype = "WM_LBUTTONDBLCLK"; break;
+        case OS.WM_LBUTTONDOWN: msgtype = "WM_LBUTTONDOWN"; break;
+        case OS.WM_LBUTTONUP: msgtype = "WM_LBUTTONUP"; break;
+        case OS.WM_MBUTTONDBLCLK: msgtype = "WM_MBUTTONDBLCLK"; break;
+        case OS.WM_MBUTTONDOWN: msgtype = "WM_MBUTTONDOWN"; break;
+        case OS.WM_MBUTTONUP: msgtype = "WM_MBUTTONUP"; break;
+        case OS.WM_MEASUREITEM: msgtype = "WM_MEASUREITEM"; break;
+        case OS.WM_MENUCHAR: msgtype = "WM_MENUCHAR"; break;
+        case OS.WM_MENUSELECT: msgtype = "WM_MENUSELECT"; break;
+        case OS.WM_MOUSEACTIVATE: msgtype = "WM_MOUSEACTIVATE"; break;
+        case OS.WM_MOUSEMOVE: msgtype = "WM_MOUSEMOVE"; break;
+        case OS.WM_MOUSEHOVER: msgtype = "WM_MOUSEHOVER"; break;
+        case OS.WM_MOUSELEAVE: msgtype = "WM_MOUSELEAVE"; break;
+        case OS.WM_MOUSEWHEEL: msgtype = "WM_MOUSEWHEEL"; break;
+        case OS.WM_MOUSELAST: msgtype = "WM_MOUSELAST"; break;
+        case OS.WM_MOVE: msgtype = "WM_MOVE"; break;
+        case OS.WM_NCACTIVATE: msgtype = "WM_NCACTIVATE"; break;
+        case OS.WM_NCCALCSIZE: msgtype = "WM_NCCALCSIZE"; break;
+        case OS.WM_NCMOUSEMOVE: msgtype = "WM_NCMOUSEMOVE"; break;
+        case OS.WM_NCHITTEST: msgtype = "WM_NCHITTEST"; break;
+        case OS.WM_NCLBUTTONDOWN: msgtype = "WM_NCLBUTTONDOWN"; break;
+        case OS.WM_NCLBUTTONUP: msgtype = "WM_NCLBUTTONUP"; break;
+        case OS.WM_NOTIFY: msgtype = "WM_NOTIFY"; break;
+        case OS.WM_NULL: msgtype = "WM_NULL"; break;
+        case OS.WM_PAINT: msgtype = "WM_PAINT"; break;
+        case OS.WM_PALETTECHANGED: msgtype = "WM_PALETTECHANGED"; break;
+        case OS.WM_PARENTNOTIFY: msgtype = "WM_PARENTNOTIFY"; break;
+        case OS.WM_PASTE: msgtype = "WM_PASTE"; break;
+        case OS.WM_PRINTCLIENT: msgtype = "WM_PRINTCLIENT"; break;
+        case OS.WM_QUERYENDSESSION: msgtype = "WM_QUERYENDSESSION"; break;
+        case OS.WM_QUERYNEWPALETTE: msgtype = "WM_QUERYNEWPALETTE"; break;
+        case OS.WM_QUERYOPEN: msgtype = "WM_QUERYOPEN"; break;
+        case OS.WM_RBUTTONDBLCLK: msgtype = "WM_RBUTTONDBLCLK"; break;
+        case OS.WM_RBUTTONDOWN: msgtype = "WM_RBUTTONDOWN"; break;
+        case OS.WM_RBUTTONUP: msgtype = "WM_RBUTTONUP"; break;
+        case OS.WM_SETCURSOR: msgtype = "WM_SETCURSOR"; break;
+        case OS.WM_SETFOCUS: msgtype = "WM_SETFOCUS"; break;
+        case OS.WM_SETFONT: msgtype = "WM_SETFONT"; break;
+        case OS.WM_SETICON: msgtype = "WM_SETICON"; break;
+        case OS.WM_SETREDRAW: msgtype = "WM_SETREDRAW"; break;
+        case OS.WM_SETTINGCHANGE: msgtype = "WM_SETTINGCHANGE"; break;
+        case OS.WM_SHOWWINDOW: msgtype = "WM_SHOWWINDOW"; break;
+        case OS.WM_SIZE: msgtype = "WM_SIZE"; break;
+        case OS.WM_SYSCHAR: msgtype = "WM_SYSCHAR"; break;
+        case OS.WM_SYSCOLORCHANGE: msgtype = "WM_SYSCOLORCHANGE"; break;
+        case OS.WM_SYSCOMMAND: msgtype = "WM_SYSCOMMAND"; break;
+        case OS.WM_SYSKEYDOWN: msgtype = "WM_SYSKEYDOWN"; break;
+        case OS.WM_SYSKEYUP: msgtype = "WM_SYSKEYUP"; break;
+        case OS.WM_TIMER: msgtype = "WM_TIMER"; break;
+        case OS.WM_UNDO: msgtype = "WM_UNDO"; break;
+        case OS.WM_USER: msgtype = "WM_USER"; break;
+        case OS.WM_VSCROLL: msgtype = "WM_VSCROLL"; break;
+        case OS.WM_WINDOWPOSCHANGED: msgtype = "WM_WINDOWPOSCHANGED"; break;
+        case OS.WM_WINDOWPOSCHANGING: msgtype = "WM_WINDOWPOSCHANGING"; break;
+
+        case OS.WM_XBUTTONDOWN: msgtype = "WM_XBUTTONDOWN"; break;
+        case OS.WM_XBUTTONUP: msgtype = "WM_XBUTTONUP"; break;
+
+	case OS.TVM_DELETEITEM: msgtype = "TVM_DELETEITEM"; break;
+	case OS.TVM_ENSUREVISIBLE: msgtype = "TVM_ENSUREVISIBLE"; break;
+	case OS.TVM_EXPAND: msgtype = "TVM_EXPAND"; break;
+	case OS.TVM_GETBKCOLOR: msgtype = "TVM_GETBKCOLOR"; break;
+	case OS.TVM_GETCOUNT: msgtype = "TVM_GETCOUNT"; break;
+	case OS.TVM_GETIMAGELIST: msgtype = "TVM_GETIMAGELIST"; break;
+	case 0x113e: msgtype = "TVM_GETITEM"; break;
+	case 0x110c: msgtype = "TVM_GETITEM"; break;
+	case OS.TVM_GETITEMHEIGHT: msgtype = "TVM_GETITEMHEIGHT"; break;
+	case OS.TVM_GETITEMRECT: msgtype = "TVM_GETITEMRECT"; break;
+	case OS.TVM_GETNEXTITEM: msgtype = "TVM_GETNEXTITEM"; break;
+	case OS.TVM_GETTEXTCOLOR: msgtype = "TVM_GETTEXTCOLOR"; break;
+	case OS.TVM_GETTOOLTIPS: msgtype = "TVM_GETTOOLTIPS"; break;
+	case OS.TVM_GETVISIBLECOUNT: msgtype = "TVM_GETVISIBLECOUNT"; break;
+	case OS.TVM_HITTEST: msgtype = "TVM_HITTEST"; break;
+	case 0x1132: msgtype = "TVM_INSERTITEM"; break;
+	case 0x1100: msgtype = "TVM_INSERTITEM"; break;
+	case OS.TVM_MAPACCIDTOHTREEITEM: msgtype = "TVM_MAPACCIDTOHTREEITEM"; break;
+	case OS.TVM_MAPHTREEITEMTOACCID: msgtype = "TVM_MAPHTREEITEMTOACCID"; break;
+	case OS.TVM_SELECTITEM: msgtype = "TVM_SELECTITEM"; break;
+	case OS.TVM_SETBKCOLOR: msgtype = "TVM_SETBKCOLOR"; break;
+	case OS.TVM_SETIMAGELIST: msgtype = "TVM_SETIMAGELIST"; break;
+	case OS.TVM_SETINSERTMARK: msgtype = "TVM_SETINSERTMARK"; break;
+	case 0x113f: msgtype = "TVM_SETITEM"; break;
+	case 0x110d: msgtype = "TVM_SETITEM"; break;
+	case OS.TVM_SETTEXTCOLOR: msgtype = "TVM_SETTEXTCOLOR"; break;
+
+            //case OS.WM_ACTIVATE: msgtype = "WM_ACTIVATE"; break;
+            //case OS.WM_DESTROY: msgtype = "WM_DESTROY"; break;
+            //case OS.WM_MOVE: msgtype = "WM_MOVE"; break;
+            //case OS.WM_SIZE: msgtype = "WM_SIZE"; break;
+            // }}}
+        }
+        if (msgtype == null) {
+            if (hasMatch != null)
+                hasMatch[0] = false;
+            msgtype = Integer.toHexString(msg);
+        } else {
+            if (hasMatch != null)
+                hasMatch[0] = true;
+        }
+        return msgtype;
+    }
+
+    // }}}
+    // {{{ isMessageImportant
+
+    public static boolean isMessageImportant(int msg)
+    {
+        return importantEvents.contains(new Integer(msg));
+    }
+
+
+    // }}}
+    // {{{ isMessageUnimportant
+
+    public static boolean isMessageUnimportant(int msg)
+    {
+        return unimportantEvents.contains(new Integer(msg));
+    }
+
+    // }}}
+// </QFS>
+
+
 /** 64 bit */
 public static final native int ACCEL_sizeof ();
 public static final native int ACTCTX_sizeof ();
@@ -2636,7 +2914,7 @@
 	if (IsUnicode) {
 		char [] lpClassName1 = lpClassName == null ? null : lpClassName.chars;
 		char [] lpWindowName1 = lpWindowName == null ? null : lpWindowName.chars;
-		return FindWindowW (lpClassName1, lpWindowName1); 
+		return FindWindowW (lpClassName1, lpWindowName1);
 	}
 	byte [] lpClassName1 = lpClassName == null ? null : lpClassName.bytes;
 	byte [] lpWindowName1 = lpWindowName == null ? null : lpWindowName.bytes;
@@ -2645,7 +2923,7 @@
 
 public static final int FormatMessage (int dwFlags, int /*long*/ lpSource, int dwMessageId, int dwLanguageId, int /*long*/ [] lpBuffer, int nSize, int /*long*/ Arguments) {
 	if (IsUnicode) {
-		return FormatMessageW (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments); 
+		return FormatMessageW (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
 	}
 	return FormatMessageA (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
 }
@@ -2661,7 +2939,7 @@
 		return GetCharacterPlacementW (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);
 	}
 	byte [] lpString1 = lpString == null ? null : lpString.bytes;
-	return GetCharacterPlacementA (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);	
+	return GetCharacterPlacementA (hdc, lpString1, nCount, nMaxExtent, lpResults, dwFlags);
 }
 
 public static final boolean GetCharWidth (int /*long*/ hdc, int iFirstChar, int iLastChar, int [] lpabc) {
@@ -2842,7 +3120,7 @@
 		return GetTextExtentPoint32W (hdc, lpString1, cbString, lpSize);
 	}
 	byte [] lpString1 = lpString == null ? null : lpString.bytes;
-	return GetTextExtentPoint32A (hdc, lpString1, cbString, lpSize);	
+	return GetTextExtentPoint32A (hdc, lpString1, cbString, lpSize);
 }
 
 public static final boolean GetTextMetrics (int /*long*/ hdc, TEXTMETRIC lptm) {
@@ -2969,7 +3247,7 @@
 		return InsertMenuW (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);
 	}
 	byte [] lpNewItem1 = lpNewItem == null ? null : lpNewItem.bytes;
-	return InsertMenuA (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);	
+	return InsertMenuA (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem1);
 }
 
 public static final boolean InsertMenuItem (int /*long*/ hMenu, int uItem, boolean fByPosition, MENUITEMINFO lpmii) {
@@ -3669,7 +3947,7 @@
  * @param uIDCheckItem cast=(UINT)
  * @param uCheck cast=(UINT)
  */
-public static final native boolean CheckMenuItem (int /*long*/ hmenu, int uIDCheckItem, int uCheck); 
+public static final native boolean CheckMenuItem (int /*long*/ hmenu, int uIDCheckItem, int uCheck);
 /** @param lpcc cast=(LPCHOOSECOLORW) */
 public static final native boolean ChooseColorW (CHOOSECOLOR lpcc);
 public static final native boolean ChooseColorA (CHOOSECOLOR lpcc);
@@ -3756,7 +4034,7 @@
 /** @param pv cast=(LPVOID) */
 public static final native void CoTaskMemFree(int /*long*/ pv);
 /** @param lpaccl cast=(LPACCEL) */
-public static final native int /*long*/ CreateAcceleratorTableW (byte [] lpaccl, int cEntries); 
+public static final native int /*long*/ CreateAcceleratorTableW (byte [] lpaccl, int cEntries);
 /** @param lpaccl cast=(LPACCEL) */
 public static final native int /*long*/ CreateAcceleratorTableA (byte [] lpaccl, int cEntries);
 /**
@@ -3792,7 +4070,7 @@
  * @param lpszOutput cast=(LPWSTR)
  * @param lpInitData cast=(CONST DEVMODEW *)
  */
-public static final native int /*long*/ CreateDCW (char [] lpszDriver, char [] lpszDevice, int /*long*/ lpszOutput, int /*long*/ lpInitData);  
+public static final native int /*long*/ CreateDCW (char [] lpszDriver, char [] lpszDevice, int /*long*/ lpszOutput, int /*long*/ lpInitData);
 /**
  * @param lpszDriver cast=(LPSTR)
  * @param lpszDevice cast=(LPSTR)
@@ -3799,7 +4077,7 @@
  * @param lpszOutput cast=(LPSTR)
  * @param lpInitData cast=(CONST DEVMODE *)
  */
-public static final native int /*long*/ CreateDCA (byte [] lpszDriver, byte [] lpszDevice, int /*long*/ lpszOutput, int /*long*/ lpInitData);  
+public static final native int /*long*/ CreateDCA (byte [] lpszDriver, byte [] lpszDevice, int /*long*/ lpszOutput, int /*long*/ lpInitData);
 /**
  * @param hdc cast=(HDC)
  * @param pbmi cast=(BITMAPINFO *),flags=no_out critical
@@ -4313,6 +4591,31 @@
 public static final native int GetCurrentProcessExplicitAppUserModelID(int /*long*/[] AppID);
 public static final native int /*long*/ GetCursor ();
 public static final native boolean GetCursorPos (POINT lpPoint);
+// <QFS> Wrapper for GetCursorPos to override during replay
+public static final boolean _GetCursorPos (POINT lpPoint)
+{
+    boolean ret;
+    Integer replayPos = (Integer) replayOverride.get();
+    if (replayPos == null) {
+        ret = GetCursorPos(lpPoint);
+    } else {
+        ret = true;
+        lpPoint.x = replayPos.intValue() & 0xFFFF;
+        lpPoint.y = replayPos.intValue() >> 16;
+    }
+    if (logger.level >= Log.DBG) {
+        Logger.Builder lb = logger.build("_GetCursorPos(POINT)").add("ret: ").add(ret);
+        if (ret) {
+            lb.add(", x: ").add(lpPoint.x).add(", y: ").add(lpPoint.y);
+        }
+        if (replayPos != null) {
+            lb.add(" [overridden]");
+        }
+        lb.log(Log.DBG);
+    }
+    return ret;
+}
+// </QFS>
 /**
  * @param Locale cast=(LCID)
  * @param dwFlags cast=(DWORD)
@@ -4894,7 +5197,7 @@
  * @param cx cast=(int *)
  * @param cy cast=(int *)
  */
-public static final native boolean ImageList_GetIconSize (int /*long*/ himl, int [] cx, int [] cy);   
+public static final native boolean ImageList_GetIconSize (int /*long*/ himl, int [] cx, int [] cy);
 /** @param himl cast=(HIMAGELIST) */
 public static final native int ImageList_GetImageCount (int /*long*/ himl);
 /** @param himl cast=(HIMAGELIST) */
@@ -5879,9 +6182,9 @@
 /** @param lpString cast=(LPTSTR) */
 public static final native int RegisterWindowMessageA (byte [] lpString);
 /** @param lpszFormat cast=(LPTSTR) */
-public static final native int RegisterClipboardFormatA (byte[] lpszFormat); 
+public static final native int RegisterClipboardFormatA (byte[] lpszFormat);
 /** @param lpszFormat cast=(LPWSTR) */
-public static final native int RegisterClipboardFormatW (char[] lpszFormat); 
+public static final native int RegisterClipboardFormatW (char[] lpszFormat);
 /**
  * @param hKey cast=(HKEY)
  * @param lpSubKey cast=(LPWSTR)
@@ -6165,7 +6468,7 @@
  * @param wParam cast=(WPARAM)
  * @param lParam cast=(LPARAM)
  */
-public static final native int /*long*/ SendMessageW (int /*long*/ hWnd, int Msg, int [] wParam, int [] lParam);
+public static final native int /*long*/ SendMessageW (int /*long*/ hWnd, int Msg, int  [] wParam, int [] lParam);
 /**
  * @param hWnd cast=(HWND)
  * @param wParam cast=(WPARAM)
Index: org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java
===================================================================
--- org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/OUTLINETEXTMETRIC.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -14,25 +14,25 @@
 	public int otmSize;
     public byte otmFiller;
     /** @field accessor=otmPanoseNumber.bFamilyType */
-	public byte otmPanoseNumber_bFamilyType;
+    public byte otmPanoseNumber_bFamilyType;
     /** @field accessor=otmPanoseNumber.bSerifStyle */
-	public byte otmPanoseNumber_bSerifStyle;
+    public byte otmPanoseNumber_bSerifStyle;
     /** @field accessor=otmPanoseNumber.bWeight */
-	public byte otmPanoseNumber_bWeight;
+    public byte otmPanoseNumber_bWeight;
     /** @field accessor=otmPanoseNumber.bProportion */
-	public byte otmPanoseNumber_bProportion;
+    public byte otmPanoseNumber_bProportion;
     /** @field accessor=otmPanoseNumber.bContrast */
-	public byte otmPanoseNumber_bContrast;
+    public byte otmPanoseNumber_bContrast;
     /** @field accessor=otmPanoseNumber.bStrokeVariation */
-	public byte otmPanoseNumber_bStrokeVariation;
+    public byte otmPanoseNumber_bStrokeVariation;
     /** @field accessor=otmPanoseNumber.bArmStyle */
-	public byte otmPanoseNumber_bArmStyle;
+    public byte otmPanoseNumber_bArmStyle;
     /** @field accessor=otmPanoseNumber.bLetterform */
-	public byte otmPanoseNumber_bLetterform;
+    public byte otmPanoseNumber_bLetterform;
     /** @field accessor=otmPanoseNumber.bMidline */
-	public byte otmPanoseNumber_bMidline;
+    public byte otmPanoseNumber_bMidline;
     /** @field accessor=otmPanoseNumber.bXHeight */
-	public byte otmPanoseNumber_bXHeight;
+    public byte otmPanoseNumber_bXHeight;
     public int otmfsSelection;
     public int otmfsType;
     public int otmsCharSlopeRise;
@@ -58,12 +58,12 @@
     public int otmsUnderscoreSize;
     public int otmsUnderscorePosition;
     /** @field cast=(PSTR) */
-	public int /*long*/ otmpFamilyName;
+    public int /*long*/ otmpFamilyName;
     /** @field cast=(PSTR) */
-	public int /*long*/ otmpFaceName;
+    public int /*long*/ otmpFaceName;
     /** @field cast=(PSTR) */
-	public int /*long*/ otmpStyleName;
+    public int /*long*/ otmpStyleName;
     /** @field cast=(PSTR) */
-	public int /*long*/ otmpFullName;
+    public int /*long*/ otmpFullName;
     public static final int sizeof = OS.IsUnicode ? OS.OUTLINETEXTMETRICW_sizeof ():  OS.OUTLINETEXTMETRICA_sizeof ();
 }
Index: org/eclipse/swt/internal/win32/NMTVDISPINFO.java
===================================================================
--- org/eclipse/swt/internal/win32/NMTVDISPINFO.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/NMTVDISPINFO.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -23,11 +23,11 @@
 	/** @field accessor=item.pszText,cast=(LPTSTR) */
 	public int /*long*/ pszText;
   	/** @field accessor=item.cchTextMax */
-	public int cchTextMax;
+  	public int cchTextMax;
   	/** @field accessor=item.iImage */
-	public int iImage;
+  	public int iImage;
   	/** @field accessor=item.iSelectedImage */
-	public int iSelectedImage;
+  	public int iSelectedImage;
 	/** @field accessor=item.cChildren */
 	public int cChildren;
 	/** @field accessor=item.lParam */
Index: org/eclipse/swt/internal/win32/DTTOPTS.java
===================================================================
--- org/eclipse/swt/internal/win32/DTTOPTS.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/win32/DTTOPTS.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,32 +1,32 @@
-/*******************************************************************************
+/*******************************************************************************
  * Copyright (c) 2011, 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.swt.internal.win32;
-
-	
-public class DTTOPTS {
-	public int dwSize;
-	public int dwFlags;
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.swt.internal.win32;
+
+	
+public class DTTOPTS {
+	public int dwSize;
+	public int dwFlags;
 	public int crText;
 	public int crBorder;
 	public int crShadow;
-	public int iTextShadowType;
-	public POINT ptShadowOffset;
-	public int iBorderSize;
-	public int iFontPropId;
-	public int iColorPropId;
-	public int iStateId;
-	public boolean fApplyOverlay;
-	public int iGlowSize;
-	/** @field cast=(DTT_CALLBACK_PROC) */
-	public int /*long*/ pfnDrawTextCallback;
-	public int /*long*/ lParam;
-	public static final int sizeof = OS.DTTOPTS_sizeof ();
+	public int iTextShadowType;
+	public POINT ptShadowOffset;
+	public int iBorderSize;
+	public int iFontPropId;
+	public int iColorPropId;
+	public int iStateId;
+	public boolean fApplyOverlay;
+	public int iGlowSize;
+	/** @field cast=(DTT_CALLBACK_PROC) */
+	public int /*long*/ pfnDrawTextCallback;
+	public int /*long*/ lParam;
+	public static final int sizeof = OS.DTTOPTS_sizeof ();
 }
\ No newline at end of file
Index: org/eclipse/swt/internal/Platform.java
===================================================================
--- org/eclipse/swt/internal/Platform.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/Platform.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -18,5 +18,5 @@
 public static boolean isLoadable () {
 	return Library.isLoadable ();	
 }
-
+	
 }
Index: org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMEventTarget.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,67 +1,67 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2003, 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMEventTarget extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDOMEVENTTARGET_IID_STR =
-		"1c773b30-d1cf-11d2-bd95-00805f8ae3f4";
-
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMEventTarget extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDOMEVENTTARGET_IID_STR =
+		"1c773b30-d1cf-11d2-bd95-00805f8ae3f4";
+
 	public static final String NS_IDOMEVENTTARGET_10_IID_STR =
 		"1797d5a4-b12a-428d-9eef-a0e13839728c";
 	
-	public static final nsID NS_IDOMEVENTTARGET_IID =
-		new nsID(NS_IDOMEVENTTARGET_IID_STR);
-
+	public static final nsID NS_IDOMEVENTTARGET_IID =
+		new nsID(NS_IDOMEVENTTARGET_IID_STR);
+
 	public static final nsID NS_IDOMEVENTTARGET_10_IID =
 		new nsID(NS_IDOMEVENTTARGET_10_IID_STR);
 
-	public nsIDOMEventTarget(int /*long*/ address) {
-		super(address);
-	}
-
-	public int AddEventListener(int /*long*/ type, int /*long*/ listener, int useCapture) {
+	public nsIDOMEventTarget(int /*long*/ address) {
+		super(address);
+	}
+
+	public int AddEventListener(int /*long*/ type, int /*long*/ listener, int useCapture) {
 		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), type, listener, useCapture);
-	}
-
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), type, listener, useCapture);
+	}
+
 	public int AddEventListener(int /*long*/ type, int /*long*/ listener, int useCapture, int wantsUntrusted, int _argc) {
 		if (!IsXULRunner10) return AddEventListener(type, listener, useCapture);
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), type, listener, useCapture, wantsUntrusted, _argc);
 	}
 
-	public int RemoveEventListener(int /*long*/ type, int /*long*/ listener, int useCapture) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), type, listener, useCapture);
-	}
-
-	public int DispatchEvent(int /*long*/ evt, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), evt, _retval);
-	}
-}
+	public int RemoveEventListener(int /*long*/ type, int /*long*/ listener, int useCapture) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), type, listener, useCapture);
+	}
+
+	public int DispatchEvent(int /*long*/ evt, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), evt, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIIOService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIIOService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIIOService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -65,15 +65,15 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aSpec, aOriginCharset, aBaseURI, _retval);
 	}
 
-	public int GetOffline(int[] aOffline) {
+	public int GetOffline(int[] aOffline) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aOffline);
 	}
 
-	public int SetOffline(int aOffline) {
+	public int SetOffline(int aOffline) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aOffline);
 	}
 
-	public int AllowPort(int aPort, byte[] aScheme, int[] _retval) {
+	public int AllowPort(int aPort, byte[] aScheme, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aPort, aScheme, _retval);
 	}
 
@@ -80,4 +80,4 @@
 	public int ExtractScheme(int /*long*/ urlString, int /*long*/ _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), urlString, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIX509CertValidity.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIX509CertValidity.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIX509CertValidity.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IX509CERTVALIDITY_IID =
 		new nsID(NS_IX509CERTVALIDITY_IID_STR);
 
-	public nsIX509CertValidity(int /*long*/ address) {
+	public  nsIX509CertValidity(int /*long*/ address) {
 		super(address);
 	}
 
@@ -72,4 +72,4 @@
 	public int GetNotAfterGMT(int /*long*/ aNotAfterGMT) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aNotAfterGMT);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,63 +1,63 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
-
-public class nsICookieService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
-
-	public static final String NS_ICOOKIESERVICE_IID_STR =
-		"011c3190-1434-11d6-a618-0010a401eb10";
-
-	public static final nsID NS_ICOOKIESERVICE_IID =
-		new nsID(NS_ICOOKIESERVICE_IID_STR);
-
-	public nsICookieService(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetCookieString(int /*long*/ aURI, int /*long*/ aChannel, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
-	}
-
-	public int GetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aChannel, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
-	}
-
-	public int SetCookieString(int /*long*/ aURI, int /*long*/ aPrompt, byte[] aCookie, int /*long*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
-	}
-
-	public int SetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aPrompt, byte[] aCookie, byte[] aServerTime, int /*long*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
-	}
-
-	public int GetCookieIconIsVisible(int[] aCookieIconIsVisible) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCookieIconIsVisible);
-	}
-}
+
+public class nsICookieService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 5;
+
+	public static final String NS_ICOOKIESERVICE_IID_STR =
+		"011c3190-1434-11d6-a618-0010a401eb10";
+
+	public static final nsID NS_ICOOKIESERVICE_IID =
+		new nsID(NS_ICOOKIESERVICE_IID_STR);
+
+	public nsICookieService(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetCookieString(int /*long*/ aURI, int /*long*/ aChannel, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
+	}
+
+	public int GetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aChannel, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
+	}
+
+	public int SetCookieString(int /*long*/ aURI, int /*long*/ aPrompt, byte[] aCookie, int /*long*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
+	}
+
+	public int SetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aPrompt, byte[] aCookie, byte[] aServerTime, int /*long*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
+	}
+
+	public int GetCookieIconIsVisible(int[] aCookieIconIsVisible) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aCookieIconIsVisible);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIEmbeddingSiteWindow.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -57,11 +57,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
 	}
 
-	public int GetVisibility(int[] aVisibility) {
+	public int GetVisibility(int[] aVisibility) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aVisibility);
 	}
 
-	public int SetVisibility(int aVisibility) {
+	public int SetVisibility(int aVisibility) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aVisibility);
 	}
 
@@ -76,4 +76,4 @@
 	public int GetSiteWindow(int /*long*/[] aSiteWindow) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aSiteWindow);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDocShell.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDocShell.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDocShell.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -53,7 +53,7 @@
 		super(address);
 	}
 
-	public int LoadURI(int /*long*/ uri, int /*long*/ loadInfo, int aLoadFlags, int firstParty) {
+	public int LoadURI(int /*long*/ uri, int /*long*/ loadInfo, int aLoadFlags, int firstParty) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uri, loadInfo, aLoadFlags, firstParty);
 	}
 
@@ -61,7 +61,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aStream, aURI, aContentType, aContentCharset, aLoadInfo);
 	}
 
-	public int InternalLoad(int /*long*/ aURI, int /*long*/ aReferrer, int /*long*/ aOwner, int aInheritOwner, char[] aWindowTarget, int /*long*/ aPostDataStream, int /*long*/ aHeadersStream, int aLoadFlags, int /*long*/ aSHEntry, int firstParty, int /*long*/[] aDocShell, int /*long*/[] aRequest) {
+	public int InternalLoad(int /*long*/ aURI, int /*long*/ aReferrer, int /*long*/ aOwner, int aInheritOwner, char[] aWindowTarget, int /*long*/ aPostDataStream, int /*long*/ aHeadersStream, int aLoadFlags, int /*long*/ aSHEntry, int firstParty, int /*long*/[] aDocShell, int /*long*/[] aRequest) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aReferrer, aOwner, aInheritOwner, aWindowTarget, aPostDataStream, aHeadersStream, aLoadFlags, aSHEntry, firstParty, aDocShell, aRequest);
 	}
 
@@ -121,43 +121,43 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aDocumentCharsetInfo);
 	}
 
-	public int GetAllowPlugins(int[] aAllowPlugins) {
+	public int GetAllowPlugins(int[] aAllowPlugins) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aAllowPlugins);
 	}
 
-	public int SetAllowPlugins(int aAllowPlugins) {
+	public int SetAllowPlugins(int aAllowPlugins) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aAllowPlugins);
 	}
 
-	public int GetAllowJavascript(int[] aAllowJavascript) {
+	public int GetAllowJavascript(int[] aAllowJavascript) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aAllowJavascript);
 	}
 
-	public int SetAllowJavascript(int aAllowJavascript) {
+	public int SetAllowJavascript(int aAllowJavascript) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), aAllowJavascript);
 	}
 
-	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
+	public int GetAllowMetaRedirects(int[] aAllowMetaRedirects) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 22, getAddress(), aAllowMetaRedirects);
 	}
 
-	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
+	public int SetAllowMetaRedirects(int aAllowMetaRedirects) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aAllowMetaRedirects);
 	}
 
-	public int GetAllowSubframes(int[] aAllowSubframes) {
+	public int GetAllowSubframes(int[] aAllowSubframes) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aAllowSubframes);
 	}
 
-	public int SetAllowSubframes(int aAllowSubframes) {
+	public int SetAllowSubframes(int aAllowSubframes) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), aAllowSubframes);
 	}
 
-	public int GetAllowImages(int[] aAllowImages) {
+	public int GetAllowImages(int[] aAllowImages) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aAllowImages);
 	}
 
-	public int SetAllowImages(int aAllowImages) {
+	public int SetAllowImages(int aAllowImages) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), aAllowImages);
 	}
 
@@ -181,11 +181,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aAppType);
 	}
 
-	public int GetAllowAuth(int[] aAllowAuth) {
+	public int GetAllowAuth(int[] aAllowAuth) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), aAllowAuth);
 	}
 
-	public int SetAllowAuth(int aAllowAuth) {
+	public int SetAllowAuth(int aAllowAuth) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aAllowAuth);
 	}
 
@@ -213,23 +213,23 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), aMarginHeight);
 	}
 
-	public int GetHasFocus(int[] aHasFocus) {
+	public int GetHasFocus(int[] aHasFocus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), aHasFocus);
 	}
 
-	public int SetHasFocus(int aHasFocus) {
+	public int SetHasFocus(int aHasFocus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 40, getAddress(), aHasFocus);
 	}
 
-	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
+	public int GetCanvasHasFocus(int[] aCanvasHasFocus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), aCanvasHasFocus);
 	}
 
-	public int SetCanvasHasFocus(int aCanvasHasFocus) {
+	public int SetCanvasHasFocus(int aCanvasHasFocus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), aCanvasHasFocus);
 	}
 
-	public int TabToTreeOwner(int forward, int[] tookFocus) {
+	public int TabToTreeOwner(int forward, int[] tookFocus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), forward, tookFocus);
 	}
 
@@ -253,11 +253,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 46, getAddress(), aLoadType);
 	}
 
-	public int IsBeingDestroyed(int[] _retval) {
+	public int IsBeingDestroyed(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 47, getAddress(), _retval);
 	}
 
-	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
+	public int GetIsExecutingOnLoadHandler(int[] aIsExecutingOnLoadHandler) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 48, getAddress(), aIsExecutingOnLoadHandler);
 	}
 
@@ -269,7 +269,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 50, getAddress(), aLayoutHistoryState);
 	}
 
-	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
+	public int GetShouldSaveLayoutState(int[] aShouldSaveLayoutState) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 51, getAddress(), aShouldSaveLayoutState);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIURI.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIURI.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIURI.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -28,7 +28,7 @@
 package org.eclipse.swt.internal.mozilla;
 
 public class nsIURI extends nsISupports {
-	
+
 	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 32 : 26);
 
 	public static final String NS_IURI_IID_STR =
@@ -39,7 +39,7 @@
 
 	public static final nsID NS_IURI_IID =
 		new nsID(NS_IURI_IID_STR);
-	
+
 	public static final nsID NS_IURI_10_IID =
 			new nsID(NS_IURI_10_IID_STR);
 
@@ -123,11 +123,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aPath);
 	}
 
-	public int Equals(int /*long*/ other, int[] _retval) {
+	public int Equals(int /*long*/ other, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), other, _retval);
 	}
 
-	public int SchemeIs(byte[] scheme, int[] _retval) {
+	public int SchemeIs(byte[] scheme, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 21, getAddress(), scheme, _retval);
 	}
 
@@ -180,4 +180,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), aHasRef);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsITooltipListener.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsITooltipListener.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsITooltipListener.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -48,4 +48,4 @@
 	public int OnHideTooltip() {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebProgress.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebProgress.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebProgress.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -64,7 +64,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDOMWindow);
 	}
 
-	public int GetIsLoadingDocument(int[] aIsLoadingDocument) {
+	public int GetIsLoadingDocument(int[] aIsLoadingDocument) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aIsLoadingDocument);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -49,7 +49,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aEnumerator);
 	}
 
-	public int Remove(int /*long*/ aDomain, int /*long*/ aName, int /*long*/ aPath, int aBlocked) {
+	public int Remove(int /*long*/ aDomain, int /*long*/ aName, int /*long*/ aPath, int aBlocked) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aDomain, aName, aPath, aBlocked);
 	}
 }
Index: org/eclipse/swt/internal/mozilla/nsISerializable.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISerializable.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISerializable.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -27,7 +27,7 @@
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
 
-public class nsISerializable extends nsISupports {
+public class  nsISerializable extends nsISupports {
 
 	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 2;
 
@@ -37,7 +37,7 @@
 	public static final nsID NS_ISERIALIZABLE_IID =
 		new nsID(NS_ISERIALIZABLE_IID_STR);
 
-	public nsISerializable(int /*long*/ address) {
+	public  nsISerializable(int /*long*/ address) {
 		super(address);
 	}
 
@@ -48,4 +48,4 @@
 	public int Write(int /*long*/ aOutputStream) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aOutputStream);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDownload.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDownload.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDownload.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -92,4 +92,4 @@
 	public int SetObserver(int /*long*/ aObserver) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aObserver);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIFactory.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFactory.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFactory.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -45,7 +45,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aOuter, iid, result);
 	}
 
-	public int LockFactory(int lock) {
+	public int LockFactory(int lock) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), lock);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICategoryManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICategoryManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICategoryManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -45,11 +45,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCategory, aEntry, _retval);
 	}
 
-	public int AddCategoryEntry(byte[] aCategory, byte[] aEntry, byte[] aValue, int aPersist, int aReplace, int /*long*/[] _retval) {
+	public int AddCategoryEntry(byte[] aCategory, byte[] aEntry, byte[] aValue, int aPersist, int aReplace, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCategory, aEntry, aValue, aPersist, aReplace, _retval);
 	}
 
-	public int DeleteCategoryEntry(byte[] aCategory, byte[] aEntry, int aPersist) {
+	public int DeleteCategoryEntry(byte[] aCategory, byte[] aEntry, int aPersist) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aCategory, aEntry, aPersist);
 	}
 
@@ -64,4 +64,4 @@
 	public int EnumerateCategories(int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_9.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -53,11 +53,11 @@
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
 	}
 
-	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
+	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
 	}
 
-	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
+	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
 	}
 
@@ -73,7 +73,7 @@
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
 	}
 
-	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
+	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTargetFileIsExecutable);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIFocusManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFocusManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFocusManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,137 +1,137 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2011, 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIFocusManager extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 18 : 17);
-
-	public static final String NS_IFOCUSMANAGER_IID_STR =
-			"cd6040a8-243f-412a-8a16-0bf2aa1083b9";
-	
-	public static final String NS_IFOCUSMANAGER_10_IID_STR =
-			"51db277b-7ee7-4bce-9b84-fd2efcd2c8bd";
-
-	public static final nsID NS_IFOCUSMANAGER_IID =
-		new nsID(NS_IFOCUSMANAGER_IID_STR);
-	
-	public static final nsID NS_IFOCUSMANAGER_10_IID =
-			new nsID(NS_IFOCUSMANAGER_10_IID_STR);
-
-	public nsIFocusManager(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetActiveWindow(int /*long*/[] aActiveWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aActiveWindow);
-	}
-
-	public int SetActiveWindow(int /*long*/ aActiveWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aActiveWindow);
-	}
-
-	public int GetFocusedWindow(int /*long*/[] aFocusedWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aFocusedWindow);
-	}
-
-	public int SetFocusedWindow(int /*long*/ aFocusedWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aFocusedWindow);
-	}
-
-	public int GetFocusedElement(int /*long*/[] aFocusedElement) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aFocusedElement);
-	}
-
-	public int GetLastFocusMethod(int /*long*/ window, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), window, _retval);
-	}
-
-	public int SetFocus(int /*long*/ aElement, int aFlags) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aElement, aFlags);
-	}
-
-	public int MoveFocus(int /*long*/ aWindow, int /*long*/ aStartElement, int aType, int aFlags, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aWindow, aStartElement, aType, aFlags, _retval);
-	}
-
-	public int ClearFocus(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aWindow);
-	}
-
-	public int GetFocusedElementForWindow(int /*long*/ aWindow, int aDeep, int /*long*/[] aFocusedWindow, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aWindow, aDeep, aFocusedWindow, _retval);
-	}
-
-	public int MoveCaretToFocus(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aWindow);
-	}
-
-	public static final int FLAG_RAISE = 1;
-	public static final int FLAG_NOSCROLL = 2;
-	public static final int FLAG_NOSWITCHFRAME = 4;
-	public static final int FLAG_BYMOUSE = 4096;
-	public static final int FLAG_BYKEY = 8192;
-	public static final int FLAG_BYMOVEFOCUS = 16384;
-	public static final int MOVEFOCUS_FORWARD = 1;
-	public static final int MOVEFOCUS_BACKWARD = 2;
-	public static final int MOVEFOCUS_FORWARDDOC = 3;
-	public static final int MOVEFOCUS_BACKWARDDOC = 4;
-	public static final int MOVEFOCUS_FIRST = 5;
-	public static final int MOVEFOCUS_LAST = 6;
-	public static final int MOVEFOCUS_ROOT = 7;
-	public static final int MOVEFOCUS_CARET = 8;
-
-	public int WindowRaised(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aWindow);
-	}
-
-	public int WindowLowered(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aWindow);
-	}
-
-	public int ContentRemoved(int /*long*/ aDocument, int /*long*/ aElement) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aDocument, aElement);
-	}
-
-	public int WindowShown(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aWindow);
-	}
-
-	public int WindowHidden(int /*long*/ aWindow) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aWindow);
-	}
-
-	public int FireDelayedEvents(int /*long*/ aDocument) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aDocument);
-	}
-	
-	public int FocusPlugin(int /*long*/ aPlugin) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPlugin);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsIFocusManager extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 18 : 17);
+
+	public static final String NS_IFOCUSMANAGER_IID_STR =
+		"cd6040a8-243f-412a-8a16-0bf2aa1083b9";
+
+	public static final String NS_IFOCUSMANAGER_10_IID_STR =
+			"51db277b-7ee7-4bce-9b84-fd2efcd2c8bd";
+
+	public static final nsID NS_IFOCUSMANAGER_IID =
+		new nsID(NS_IFOCUSMANAGER_IID_STR);
+
+	public static final nsID NS_IFOCUSMANAGER_10_IID =
+			new nsID(NS_IFOCUSMANAGER_10_IID_STR);
+
+	public  nsIFocusManager(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetActiveWindow(int /*long*/[] aActiveWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aActiveWindow);
+	}
+
+	public int SetActiveWindow(int /*long*/ aActiveWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aActiveWindow);
+	}
+
+	public int GetFocusedWindow(int /*long*/[] aFocusedWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aFocusedWindow);
+	}
+
+	public int SetFocusedWindow(int /*long*/ aFocusedWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aFocusedWindow);
+	}
+
+	public int GetFocusedElement(int /*long*/[] aFocusedElement) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aFocusedElement);
+	}
+
+	public int GetLastFocusMethod(int /*long*/ window, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), window, _retval);
+	}
+
+	public int SetFocus(int /*long*/ aElement, int aFlags) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aElement, aFlags);
+	}
+
+	public int MoveFocus(int /*long*/ aWindow, int /*long*/ aStartElement, int aType, int aFlags, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aWindow, aStartElement, aType, aFlags, _retval);
+	}
+
+	public int ClearFocus(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aWindow);
+	}
+
+	public int GetFocusedElementForWindow(int /*long*/ aWindow, int aDeep, int /*long*/[] aFocusedWindow, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aWindow, aDeep, aFocusedWindow, _retval);
+	}
+
+	public int MoveCaretToFocus(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aWindow);
+	}
+
+	public static final int FLAG_RAISE = 1;
+	public static final int FLAG_NOSCROLL = 2;
+	public static final int FLAG_NOSWITCHFRAME = 4;
+	public static final int FLAG_BYMOUSE = 4096;
+	public static final int FLAG_BYKEY = 8192;
+	public static final int FLAG_BYMOVEFOCUS = 16384;
+	public static final int MOVEFOCUS_FORWARD = 1;
+	public static final int MOVEFOCUS_BACKWARD = 2;
+	public static final int MOVEFOCUS_FORWARDDOC = 3;
+	public static final int MOVEFOCUS_BACKWARDDOC = 4;
+	public static final int MOVEFOCUS_FIRST = 5;
+	public static final int MOVEFOCUS_LAST = 6;
+	public static final int MOVEFOCUS_ROOT = 7;
+	public static final int MOVEFOCUS_CARET = 8;
+
+	public int WindowRaised(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aWindow);
+	}
+
+	public int WindowLowered(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aWindow);
+	}
+
+	public int ContentRemoved(int /*long*/ aDocument, int /*long*/ aElement) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aDocument, aElement);
+	}
+
+	public int WindowShown(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aWindow);
+	}
+
+	public int WindowHidden(int /*long*/ aWindow) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aWindow);
+	}
+
+	public int FireDelayedEvents(int /*long*/ aDocument) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aDocument);
+	}
+	
+	public int FocusPlugin(int /*long*/ aPlugin) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aPlugin);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/XPCOM.java
===================================================================
--- org/eclipse/swt/internal/mozilla/XPCOM.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/XPCOM.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -47,7 +47,7 @@
 	public static final String DOMEVENT_KEYDOWN = "keydown"; //$NON-NLS-1$
 	public static final String DOMEVENT_KEYPRESS = "keypress"; //$NON-NLS-1$
 	public static final String DOMEVENT_KEYUP = "keyup"; //$NON-NLS-1$
-
+	
 	/* CID constants */
 	public static final nsID EXTERNAL_CID = new nsID ("f2c59ad0-bd76-11dd-ad8b-0800200c9a66"); //$NON-NLS-1$
 	public static final nsID NS_APPSHELL_CID =	new nsID("2d96b3df-c051-11d1-a827-0040959a28c9"); //$NON-NLS-1$
Index: org/eclipse/swt/internal/mozilla/nsIXPCSecurityManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIXPCSecurityManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIXPCSecurityManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -76,4 +76,4 @@
 	public int CanAccess(int aAction, int /*long*/ aCallContext, int /*long*/ aJSContext, int /*long*/ aJSObject, int /*long*/ aObj, int /*long*/ aClassInfo, int /*long*/ aName, int /*long*/[] aPolicy) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aAction, aCallContext, aJSContext, aJSObject, aObj, aClassInfo, aName, aPolicy);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowserChrome.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -102,7 +102,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
 	}
 
-	public int IsWindowModal(int[] _retval) {
+	public int IsWindowModal(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), _retval);
 	}
 
@@ -109,4 +109,4 @@
 	public int ExitModalEventLoop(int aStatus) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aStatus);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -67,11 +67,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aEventPhase);
 	}
 
-	public int GetBubbles(int[] aBubbles) {
+	public int GetBubbles(int[] aBubbles) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aBubbles);
 	}
 
-	public int GetCancelable(int[] aCancelable) {
+	public int GetCancelable(int[] aCancelable) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aCancelable);
 	}
 
@@ -87,7 +87,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress());
 	}
 
-	public int InitEvent(int /*long*/ eventTypeArg, int canBubbleArg, int cancelableArg) {
+	public int InitEvent(int /*long*/ eventTypeArg, int canBubbleArg, int cancelableArg) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), eventTypeArg, canBubbleArg, cancelableArg);
 	}
 	
@@ -100,4 +100,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -44,4 +44,4 @@
 	public int GetFiles(byte[] prop, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsIDirectoryServiceProvider.LAST_METHOD_ID + 1, getAddress(), prop, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMNode.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMNode.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMNode.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,231 +1,231 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2011, 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMNode extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 36 : 25);
-
-	public static final String NS_IDOMNODE_IID_STR =
-		"a6cf907c-15b3-11d2-932e-00805f8add32";
-
-	public static final String NS_IDOMNODE_10_IID_STR =
-		"ce82fb71-60f2-4c38-be31-de5f2f90dada";
-
-	public static final nsID NS_IDOMNODE_IID =
-		new nsID(NS_IDOMNODE_IID_STR);
-
-	public static final nsID NS_IDOMNODE_10_IID =
-		new nsID(NS_IDOMNODE_10_IID_STR);
-
-	public nsIDOMNode(int /*long*/ address) {
-		super(address);
-	}
-
-	public static final int ELEMENT_NODE = 1;
-	public static final int ATTRIBUTE_NODE = 2;
-	public static final int TEXT_NODE = 3;
-	public static final int CDATA_SECTION_NODE = 4;
-	public static final int ENTITY_REFERENCE_NODE = 5;
-	public static final int ENTITY_NODE = 6;
-	public static final int PROCESSING_INSTRUCTION_NODE = 7;
-	public static final int COMMENT_NODE = 8;
-	public static final int DOCUMENT_NODE = 9;
-	public static final int DOCUMENT_TYPE_NODE = 10;
-	public static final int DOCUMENT_FRAGMENT_NODE = 11;
-	public static final int NOTATION_NODE = 12;
-
-	public int GetNodeName(int /*long*/ aNodeName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aNodeName);
-	}
-
-	public int GetNodeValue(int /*long*/ aNodeValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aNodeValue);
-	}
-
-	public int SetNodeValue(int /*long*/ aNodeValue) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aNodeValue);
-	}
-
-	public int GetNodeType(short[] aNodeType) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aNodeType);
-	}
-
-	public int GetParentNode(int /*long*/[] aParentNode) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParentNode);
-	}
-
-	public int GetParentElement(int /*long*/[] aParentElement) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParentElement);
-	}
-
-	public int GetChildNodes(int /*long*/[] aChildNodes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 7 : 6), getAddress(), aChildNodes);
-	}
-
-	public int GetFirstChild(int /*long*/[] aFirstChild) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 8 : 7), getAddress(), aFirstChild);
-	}
-
-	public int GetLastChild(int /*long*/[] aLastChild) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 9 : 8), getAddress(), aLastChild);
-	}
-
-	public int GetPreviousSibling(int /*long*/[] aPreviousSibling) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 10 : 9), getAddress(), aPreviousSibling);
-	}
-
-	public int GetNextSibling(int /*long*/[] aNextSibling) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 11 : 10), getAddress(), aNextSibling);
-	}
-
-	public int GetAttributes(int /*long*/[] aAttributes) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 12 : 11), getAddress(), aAttributes);
-	}
-
-	public int GetOwnerDocument(int /*long*/[] aOwnerDocument) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 13 : 12), getAddress(), aOwnerDocument);
-	}
-
-	public int InsertBefore(int /*long*/ newChild, int /*long*/ refChild, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 14 : 13), getAddress(), newChild, refChild, _retval);
-	}
-
-	public int ReplaceChild(int /*long*/ newChild, int /*long*/ oldChild, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 15 : 14), getAddress(), newChild, oldChild, _retval);
-	}
-
-	public int RemoveChild(int /*long*/ oldChild, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 16 : 15), getAddress(), oldChild, _retval);
-	}
-
-	public int AppendChild(int /*long*/ newChild, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 17 : 16), getAddress(), newChild, _retval);
-	}
-
-	public int HasChildNodes(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 18 : 17), getAddress(), _retval);
-	}
-
-	public int CloneNode(int deep, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 19 : 18), getAddress(), deep, _retval);
-	}
-
-	public int Normalize() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 20 : 19), getAddress());
-	}
-
-	public int IsSupported(int /*long*/ feature, int /*long*/ version, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 21 : 20), getAddress(), feature, version, _retval);
-	}
-
-	public int GetNamespaceURI(int /*long*/ aNamespaceURI) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 22 : 21), getAddress(), aNamespaceURI);
-	}
-
-	public int GetPrefix(int /*long*/ aPrefix) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 23 : 22), getAddress(), aPrefix);
-	}
-
-	public int SetPrefix(int /*long*/ aPrefix) {
-		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aPrefix);
-	}
-
-	public int GetLocalName(int /*long*/ aLocalName) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aLocalName);
-	}
-
-	public int HasAttributes(int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), _retval);
-	}
-	
-	public int GetDOMBaseURI(int /*long*/ aBaseURI) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aBaseURI);
-	}
-
-	/* the following constants are defined in Mozilla 10 */
-	public static final int DOCUMENT_POSITION_DISCONNECTED = 1;
-	public static final int DOCUMENT_POSITION_PRECEDING = 2;
-	public static final int DOCUMENT_POSITION_FOLLOWING = 4;
-	public static final int DOCUMENT_POSITION_CONTAINS = 8;
-	public static final int DOCUMENT_POSITION_CONTAINED_BY = 16;
-	public static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
-
-	public int CompareDocumentPosition(int /*long*/ other, short[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), other, _retval);
-	}
-
-	public int GetTextContent(int /*long*/ aTextContent) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aTextContent);
-	}
-
-	public int SetTextContent(int /*long*/ aTextContent) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aTextContent);
-	}
-
-	public int LookupPrefix(int /*long*/ namespaceURI, int /*long*/ _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), namespaceURI, _retval);
-	}
-
-	public int IsDefaultNamespace(int /*long*/ namespaceURI, int[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), namespaceURI, _retval);
-	}
-
-	public int LookupNamespaceURI(int /*long*/ prefix, int /*long*/ _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), prefix, _retval);
-	}
-
-	public int IsEqualNode(int /*long*/ arg, int[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), arg, _retval);
-	}
-
-	public int SetUserData(int /*long*/ key, int /*long*/ data, int /*long*/ handler, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), key, data, handler, _retval);
-	}
-
-	public int GetUserData(int /*long*/ key, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), key, _retval);
-	}
-
-	public int Contains(int /*long*/ aOther, int[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aOther, _retval);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsIDOMNode extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 36 : 25);
+
+	public static final String NS_IDOMNODE_IID_STR =
+		"a6cf907c-15b3-11d2-932e-00805f8add32";
+
+	public static final String NS_IDOMNODE_10_IID_STR =
+		"ce82fb71-60f2-4c38-be31-de5f2f90dada";
+
+	public static final nsID NS_IDOMNODE_IID =
+		new nsID(NS_IDOMNODE_IID_STR);
+
+	public static final nsID NS_IDOMNODE_10_IID =
+		new nsID(NS_IDOMNODE_10_IID_STR);
+
+	public  nsIDOMNode(int /*long*/ address) {
+		super(address);
+	}
+
+	public static final int ELEMENT_NODE = 1;
+	public static final int ATTRIBUTE_NODE = 2;
+	public static final int TEXT_NODE = 3;
+	public static final int CDATA_SECTION_NODE = 4;
+	public static final int ENTITY_REFERENCE_NODE = 5;
+	public static final int ENTITY_NODE = 6;
+	public static final int PROCESSING_INSTRUCTION_NODE = 7;
+	public static final int COMMENT_NODE = 8;
+	public static final int DOCUMENT_NODE = 9;
+	public static final int DOCUMENT_TYPE_NODE = 10;
+	public static final int DOCUMENT_FRAGMENT_NODE = 11;
+	public static final int NOTATION_NODE = 12;
+
+	public int GetNodeName(int /*long*/ aNodeName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aNodeName);
+	}
+
+	public int GetNodeValue(int /*long*/ aNodeValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aNodeValue);
+	}
+
+	public int SetNodeValue(int /*long*/ aNodeValue) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aNodeValue);
+	}
+
+	public int GetNodeType(short[] aNodeType) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aNodeType);
+	}
+
+	public int GetParentNode(int /*long*/[] aParentNode) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParentNode);
+	}
+
+	public int GetParentElement(int /*long*/[] aParentElement) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParentElement);
+	}
+
+	public int GetChildNodes(int /*long*/[] aChildNodes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 7 : 6), getAddress(), aChildNodes);
+	}
+
+	public int GetFirstChild(int /*long*/[] aFirstChild) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 8 : 7), getAddress(), aFirstChild);
+	}
+
+	public int GetLastChild(int /*long*/[] aLastChild) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 9 : 8), getAddress(), aLastChild);
+	}
+
+	public int GetPreviousSibling(int /*long*/[] aPreviousSibling) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 10 : 9), getAddress(), aPreviousSibling);
+	}
+
+	public int GetNextSibling(int /*long*/[] aNextSibling) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 11 : 10), getAddress(), aNextSibling);
+	}
+
+	public int GetAttributes(int /*long*/[] aAttributes) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 12 : 11), getAddress(), aAttributes);
+	}
+
+	public int GetOwnerDocument(int /*long*/[] aOwnerDocument) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 13 : 12), getAddress(), aOwnerDocument);
+	}
+
+	public int InsertBefore(int /*long*/ newChild, int /*long*/ refChild, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 14 : 13), getAddress(), newChild, refChild, _retval);
+	}
+
+	public int ReplaceChild(int /*long*/ newChild, int /*long*/ oldChild, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 15 : 14), getAddress(), newChild, oldChild, _retval);
+	}
+
+	public int RemoveChild(int /*long*/ oldChild, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 16 : 15), getAddress(), oldChild, _retval);
+	}
+
+	public int AppendChild(int /*long*/ newChild, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 17 : 16), getAddress(), newChild, _retval);
+	}
+
+	public int HasChildNodes(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 18 : 17), getAddress(), _retval);
+	}
+
+	public int CloneNode(int deep, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 19 : 18), getAddress(), deep, _retval);
+	}
+
+	public int Normalize() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 20 : 19), getAddress());
+	}
+
+	public int IsSupported(int /*long*/ feature, int /*long*/ version, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 21 : 20), getAddress(), feature, version, _retval);
+	}
+
+	public int GetNamespaceURI(int /*long*/ aNamespaceURI) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 22 : 21), getAddress(), aNamespaceURI);
+	}
+
+	public int GetPrefix(int /*long*/ aPrefix) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 23 : 22), getAddress(), aPrefix);
+	}
+
+	public int SetPrefix(int /*long*/ aPrefix) {
+		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 23, getAddress(), aPrefix);
+	}
+
+	public int GetLocalName(int /*long*/ aLocalName) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 24, getAddress(), aLocalName);
+	}
+
+	public int HasAttributes(int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 25, getAddress(), _retval);
+	}
+	
+	public int GetDOMBaseURI(int /*long*/ aBaseURI) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 26, getAddress(), aBaseURI);
+	}
+
+	/* the following constants are defined in Mozilla 10 */
+	public static final int DOCUMENT_POSITION_DISCONNECTED = 1;
+	public static final int DOCUMENT_POSITION_PRECEDING = 2;
+	public static final int DOCUMENT_POSITION_FOLLOWING = 4;
+	public static final int DOCUMENT_POSITION_CONTAINS = 8;
+	public static final int DOCUMENT_POSITION_CONTAINED_BY = 16;
+	public static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
+
+	public int CompareDocumentPosition(int /*long*/ other, short[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), other, _retval);
+	}
+
+	public int GetTextContent(int /*long*/ aTextContent) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 28, getAddress(), aTextContent);
+	}
+
+	public int SetTextContent(int /*long*/ aTextContent) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 29, getAddress(), aTextContent);
+	}
+
+	public int LookupPrefix(int /*long*/ namespaceURI, int /*long*/ _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), namespaceURI, _retval);
+	}
+
+	public int IsDefaultNamespace(int /*long*/ namespaceURI, int[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), namespaceURI, _retval);
+	}
+
+	public int LookupNamespaceURI(int /*long*/ prefix, int /*long*/ _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), prefix, _retval);
+	}
+
+	public int IsEqualNode(int /*long*/ arg, int[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), arg, _retval);
+	}
+
+	public int SetUserData(int /*long*/ key, int /*long*/ data, int /*long*/ handler, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), key, data, handler, _retval);
+	}
+
+	public int GetUserData(int /*long*/ key, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), key, _retval);
+	}
+
+	public int Contains(int /*long*/ aOther, int[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), aOther, _retval);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIWindowCreator.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWindowCreator.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWindowCreator.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -44,4 +44,4 @@
 	public int CreateChromeWindow(int /*long*/ parent, int chromeFlags, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parent, chromeFlags, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMKeyEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -161,7 +161,7 @@
 	public static final int DOM_VK_CLOSE_BRACKET = 221;
 	public static final int DOM_VK_QUOTE = 222;
 	public static final int DOM_VK_META = 224;
-	
+
 	/* the following constants are defined in Mozilla 10 */
 	public static final int DOM_VK_KANA = 21;
 	public static final int DOM_VK_HANGUL = 21;
@@ -188,23 +188,23 @@
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 2, getAddress(), aKeyCode);
 	}
 
-	public int GetAltKey(int[] aAltKey) {
+	public int GetAltKey(int[] aAltKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 3, getAddress(), aAltKey);
 	}
 
-	public int GetCtrlKey(int[] aCtrlKey) {
+	public int GetCtrlKey(int[] aCtrlKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aCtrlKey);
 	}
 
-	public int GetShiftKey(int[] aShiftKey) {
+	public int GetShiftKey(int[] aShiftKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aShiftKey);
 	}
 
-	public int GetMetaKey(int[] aMetaKey) {
+	public int GetMetaKey(int[] aMetaKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aMetaKey);
 	}
 
-	public int InitKeyEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, int keyCodeArg, int charCodeArg) {
+	public int InitKeyEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, int keyCodeArg, int charCodeArg) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, keyCodeArg, charCodeArg);
 	}
 }
Index: org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProgressDialog_1_8.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -45,11 +45,11 @@
 		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 1, getAddress(), aParent);
 	}
 
-	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
+	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
 		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
 	}
 
-	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
+	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
 		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
 	}
 
@@ -68,4 +68,4 @@
 	public int SetDialog(int /*long*/ aDialog) {
 		return XPCOM.VtblCall(nsIDownload_1_8.LAST_METHOD_ID + 7, getAddress(), aDialog);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIServiceManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIServiceManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIServiceManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -49,11 +49,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContractID, aIID, result);
 	}
 
-	public int IsServiceInstantiated(nsID aClass, nsID aIID, int[] _retval) {
+	public int IsServiceInstantiated(nsID aClass, nsID aIID, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aClass, aIID, _retval);
 	}
 
-	public int IsServiceInstantiatedByContractID(byte[] aContractID, nsID aIID, int[] _retval) {
+	public int IsServiceInstantiatedByContractID(byte[] aContractID, nsID aIID, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContractID, aIID, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebNavigation.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebNavigation.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebNavigation.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -41,11 +41,11 @@
 		super(address);
 	}
 
-	public int GetCanGoBack(int[] aCanGoBack) {
+	public int GetCanGoBack(int[] aCanGoBack) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCanGoBack);
 	}
 
-	public int GetCanGoForward(int[] aCanGoForward) {
+	public int GetCanGoForward(int[] aCanGoForward) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aCanGoForward);
 	}
 
@@ -106,4 +106,4 @@
 	public int SetSessionHistory(int /*long*/ aSessionHistory) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aSessionHistory);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIPromptService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPromptService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPromptService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,97 +1,97 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2003, 2011 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIPromptService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
-
-	public static final String NS_IPROMPTSERVICE_IID_STR =
-		"1630c61a-325e-49ca-8759-a31b16c47aa5";
-
-	public static final nsID NS_IPROMPTSERVICE_IID =
-		new nsID(NS_IPROMPTSERVICE_IID_STR);
-
-	public nsIPromptService(int /*long*/ address) {
-		super(address);
-	}
-
-	public int Alert(int /*long*/ aParent, char[] aDialogTitle, char[] aText) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aParent, aDialogTitle, aText);
-	}
-
-	public int AlertCheck(int /*long*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState);
-	}
-
-	public int Confirm(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aParent, aDialogTitle, aText, _retval);
-	}
-
-	public int ConfirmCheck(int /*long*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState, _retval);
-	}
-
-	public static final int BUTTON_POS_0 = 1;
-	public static final int BUTTON_POS_1 = 256;
-	public static final int BUTTON_POS_2 = 65536;
-	public static final int BUTTON_TITLE_OK = 1;
-	public static final int BUTTON_TITLE_CANCEL = 2;
-	public static final int BUTTON_TITLE_YES = 3;
-	public static final int BUTTON_TITLE_NO = 4;
-	public static final int BUTTON_TITLE_SAVE = 5;
-	public static final int BUTTON_TITLE_DONT_SAVE = 6;
-	public static final int BUTTON_TITLE_REVERT = 7;
-	public static final int BUTTON_TITLE_IS_STRING = 127;
-	public static final int BUTTON_POS_0_DEFAULT = 0;
-	public static final int BUTTON_POS_1_DEFAULT = 16777216;
-	public static final int BUTTON_POS_2_DEFAULT = 33554432;
-	public static final int BUTTON_DELAY_ENABLE = 67108864;
-	public static final int STD_OK_CANCEL_BUTTONS = 513;
-	public static final int STD_YES_NO_BUTTONS = 1027;
-	
-	public int ConfirmEx(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int aButtonFlags, char[] aButton0Title, char[] aButton1Title, char[] aButton2Title, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParent, aDialogTitle, aText, aButtonFlags, aButton0Title, aButton1Title, aButton2Title, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int Prompt(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aValue, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParent, aDialogTitle, aText, aValue, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int PromptUsernameAndPassword(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aUsername, int /*long*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParent, aDialogTitle, aText, aUsername, aPassword, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int PromptPassword(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParent, aDialogTitle, aText, aPassword, aCheckMsg, aCheckState, _retval);
-	}
-
-	public int Select(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int aCount, int /*long*/[] aSelectList, int[] aOutSelection, int[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aParent, aDialogTitle, aText, aCount, aSelectList, aOutSelection, _retval);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIPromptService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 9;
+
+	public static final String NS_IPROMPTSERVICE_IID_STR =
+		"1630c61a-325e-49ca-8759-a31b16c47aa5";
+
+	public static final nsID NS_IPROMPTSERVICE_IID =
+		new nsID(NS_IPROMPTSERVICE_IID_STR);
+
+	public nsIPromptService(int /*long*/ address) {
+		super(address);
+	}
+
+	public int Alert(int /*long*/ aParent, char[] aDialogTitle, char[] aText) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aParent, aDialogTitle, aText);
+	}
+
+	public int AlertCheck(int /*long*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState);
+	}
+
+	public int Confirm(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aParent, aDialogTitle, aText, _retval);
+	}
+
+	public int ConfirmCheck(int /*long*/ aParent, char[] aDialogTitle, char[] aText, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aParent, aDialogTitle, aText, aCheckMsg, aCheckState, _retval);
+	}
+
+	public static final int BUTTON_POS_0 = 1;
+	public static final int BUTTON_POS_1 = 256;
+	public static final int BUTTON_POS_2 = 65536;
+	public static final int BUTTON_TITLE_OK = 1;
+	public static final int BUTTON_TITLE_CANCEL = 2;
+	public static final int BUTTON_TITLE_YES = 3;
+	public static final int BUTTON_TITLE_NO = 4;
+	public static final int BUTTON_TITLE_SAVE = 5;
+	public static final int BUTTON_TITLE_DONT_SAVE = 6;
+	public static final int BUTTON_TITLE_REVERT = 7;
+	public static final int BUTTON_TITLE_IS_STRING = 127;
+	public static final int BUTTON_POS_0_DEFAULT = 0;
+	public static final int BUTTON_POS_1_DEFAULT = 16777216;
+	public static final int BUTTON_POS_2_DEFAULT = 33554432;
+	public static final int BUTTON_DELAY_ENABLE = 67108864;
+	public static final int STD_OK_CANCEL_BUTTONS = 513;
+	public static final int STD_YES_NO_BUTTONS = 1027;
+
+	public int ConfirmEx(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int aButtonFlags, char[] aButton0Title, char[] aButton1Title, char[] aButton2Title, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aParent, aDialogTitle, aText, aButtonFlags, aButton0Title, aButton1Title, aButton2Title, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int Prompt(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aValue, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aParent, aDialogTitle, aText, aValue, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int PromptUsernameAndPassword(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aUsername, int /*long*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aParent, aDialogTitle, aText, aUsername, aPassword, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int PromptPassword(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int /*long*/[] aPassword, char[] aCheckMsg, int[] aCheckState, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParent, aDialogTitle, aText, aPassword, aCheckMsg, aCheckState, _retval);
+	}
+
+	public int Select(int /*long*/ aParent, char[] aDialogTitle, char[] aText, int aCount, int /*long*/[] aSelectList, int[] aOutSelection, int[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aParent, aDialogTitle, aText, aCount, aSelectList, aOutSelection, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -53,11 +53,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
 	}
 
-	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
+	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
 	}
 
-	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
+	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
 	}
 
@@ -76,4 +76,4 @@
 	public int GetDownloadInfo(int /*long*/[] aSourceUrl, long[] aTimeDownloadStarted, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aSourceUrl, aTimeDownloadStarted, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIJSContextStack.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIJSContextStack.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIJSContextStack.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIJSContextStack extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_IJSCONTEXTSTACK_IID_STR =
-		"c67d8270-3189-11d3-9885-006008962422";
-
-	public static final nsID NS_IJSCONTEXTSTACK_IID =
-		new nsID(NS_IJSCONTEXTSTACK_IID_STR);
-
-	public nsIJSContextStack(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetCount(int[] aCount) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCount);
-	}
-
-	public int Peek(int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
-	}
-
-	public int Pop(int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), _retval);
-	}
-
-	public int Push(int /*long*/ cx) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), cx);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIJSContextStack extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_IJSCONTEXTSTACK_IID_STR =
+		"c67d8270-3189-11d3-9885-006008962422";
+
+	public static final nsID NS_IJSCONTEXTSTACK_IID =
+		new nsID(NS_IJSCONTEXTSTACK_IID_STR);
+
+	public nsIJSContextStack(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetCount(int[] aCount) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aCount);
+	}
+
+	public int Peek(int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
+	}
+
+	public int Pop(int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), _retval);
+	}
+
+	public int Push(int /*long*/ cx) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), cx);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebProgressListener.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebProgressListener.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebProgressListener.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -76,4 +76,4 @@
 	public int OnSecurityChange(int /*long*/ aWebProgress, int /*long*/ aRequest, int state) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aWebProgress, aRequest, state);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIAppShell.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIAppShell.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIAppShell.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -57,7 +57,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress());
 	}
 
-	public int ListenToEventQueue(int /*long*/ aQueue, int aListen) {
+	public int ListenToEventQueue(int /*long*/ aQueue, int aListen) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aQueue, aListen);
 	}
 
@@ -65,7 +65,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aRealEvent, aEvent);
 	}
 
-	public int DispatchNativeEvent(int aRealEvent, int /*long*/ aEvent) {
+	public int DispatchNativeEvent(int aRealEvent, int /*long*/ aEvent) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aRealEvent, aEvent);
 	}
 
@@ -72,4 +72,4 @@
 	public int Exit() {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHttpChannel.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHttpChannel.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHttpChannel.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IHTTPCHANNEL_IID =
 		new nsID(NS_IHTTPCHANNEL_IID_STR);
 
-	public nsIHttpChannel(int /*long*/ address) {
+	public  nsIHttpChannel(int /*long*/ address) {
 		super(address);
 	}
 
Index: org/eclipse/swt/internal/mozilla/init/XPCOMInit.java
===================================================================
--- org/eclipse/swt/internal/mozilla/init/XPCOMInit.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/init/XPCOMInit.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -32,7 +32,7 @@
 /** @jniclass flags=cpp */
 public class XPCOMInit extends Platform {
 	public static final int PATH_MAX = 4096;
-
+	
 public static final native int GREProperty_sizeof ();
 public static final native int GREVersionRange_sizeof ();
 
Index: org/eclipse/swt/internal/mozilla/nsIInterfaceRequestor.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIInterfaceRequestor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIInterfaceRequestor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -44,4 +44,4 @@
 	public int GetInterface(nsID uuid, int /*long*/[] result) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uuid, result);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIContextMenuListener.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIContextMenuListener.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIContextMenuListener.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -51,4 +51,4 @@
 	public int OnShowContextMenu(int aContextFlags, int /*long*/ aEvent, int /*long*/ aNode) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aContextFlags, aEvent, aNode);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIPrincipal.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPrincipal.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPrincipal.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -27,7 +27,7 @@
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
 
-public class nsIPrincipal extends nsISerializable {
+public class  nsIPrincipal extends nsISerializable {
 
 	static final int LAST_METHOD_ID = nsISerializable.LAST_METHOD_ID + (IsXULRunner10 ? 26 : 23);
 
@@ -43,7 +43,7 @@
 	public static final nsID NS_IPRINCIPAL_10_IID =
 		new nsID(NS_IPRINCIPAL_10_IID_STR);
 
-	public nsIPrincipal(int /*long*/ address) {
+	public  nsIPrincipal(int /*long*/ address) {
 		super(address);
 	}
 
@@ -158,4 +158,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISerializable.LAST_METHOD_ID + 26, getAddress(), aCsp);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIX509Cert.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIX509Cert.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIX509Cert.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IX509CERT_IID =
 		new nsID(NS_IX509CERT_IID_STR);
 
-	public nsIX509Cert(int /*long*/ address) {
+	public  nsIX509Cert(int /*long*/ address) {
 		super(address);
 	}
 
@@ -175,4 +175,4 @@
 	public int Equals(int /*long*/ other, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 27, getAddress(), other, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIPromptService2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPromptService2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPromptService2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -41,11 +41,11 @@
 		super(address);
 	}
 
-	public int PromptAuth(int /*long*/ aParent, int /*long*/ aChannel, int level, int /*long*/ authInfo, char[] checkboxLabel, int[] checkValue, int[] _retval) {
+	public int PromptAuth(int /*long*/ aParent, int /*long*/ aChannel, int level, int /*long*/ authInfo, char[] checkboxLabel, int[] checkValue, int[] _retval) {
 		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 1, getAddress(), aParent, aChannel, level, authInfo, checkboxLabel, checkValue, _retval);
 	}
 
-	public int AsyncPromptAuth(int /*long*/ aParent, int /*long*/ aChannel, int /*long*/ aCallback, int /*long*/ aContext, int level, int /*long*/ authInfo, char[] checkboxLabel, int[] checkValue, int /*long*/[] _retval) {
+	public int AsyncPromptAuth(int /*long*/ aParent, int /*long*/ aChannel, int /*long*/ aCallback, int /*long*/ aContext, int level, int /*long*/ authInfo, char[] checkboxLabel, int[] checkValue, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsIPromptService.LAST_METHOD_ID + 2, getAddress(), aParent, aChannel, aCallback, aContext, level, authInfo, checkboxLabel, checkValue, _retval);
 	}
 }
Index: org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFilePicker_1_8.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,67 +1,67 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2003, 2011 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIFilePicker_1_8 extends nsISupports {
-
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIFilePicker_1_8 extends nsISupports {
+
 	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 17 : 15);
-
-	public static final String NS_IFILEPICKER_IID_STR =
-		"80faf095-c807-4558-a2cc-185ed70754ea";
-
+
+	public static final String NS_IFILEPICKER_IID_STR =
+		"80faf095-c807-4558-a2cc-185ed70754ea";
+
 	public static final String NS_IFILEPICKER_10_IID_STR =
 		"f2c0e216-5d07-4df4-bbcb-37683077ae7e";
 	
-	public static final nsID NS_IFILEPICKER_IID =
-		new nsID(NS_IFILEPICKER_IID_STR);
-
+	public static final nsID NS_IFILEPICKER_IID =
+		new nsID(NS_IFILEPICKER_IID_STR);
+
 	public static final nsID NS_IFILEPICKER_10_IID =
 		new nsID(NS_IFILEPICKER_10_IID_STR);
 	
-	public nsIFilePicker_1_8(int /*long*/ address) {
-		super(address);
-	}
-
-	public static final int modeOpen = 0;
-	public static final int modeSave = 1;
-	public static final int modeGetFolder = 2;
-	public static final int modeOpenMultiple = 3;
-	public static final int returnOK = 0;
-	public static final int returnCancel = 1;
-	public static final int returnReplace = 2;
-	public static final int filterAll = 1;
-	public static final int filterHTML = 2;
-	public static final int filterText = 4;
-	public static final int filterImages = 8;
-	public static final int filterXML = 16;
-	public static final int filterXUL = 32;
-	public static final int filterApps = 64;
-	
+	public nsIFilePicker_1_8(int /*long*/ address) {
+		super(address);
+	}
+
+	public static final int modeOpen = 0;
+	public static final int modeSave = 1;
+	public static final int modeGetFolder = 2;
+	public static final int modeOpenMultiple = 3;
+	public static final int returnOK = 0;
+	public static final int returnCancel = 1;
+	public static final int returnReplace = 2;
+	public static final int filterAll = 1;
+	public static final int filterHTML = 2;
+	public static final int filterText = 4;
+	public static final int filterImages = 8;
+	public static final int filterXML = 16;
+	public static final int filterXUL = 32;
+	public static final int filterApps = 64;
+
 	/* the following constants are defined in mozilla 8 */
 	public static final int filterAllowURLs = 128;
 	public static final int filterAudio = 256;
@@ -68,62 +68,62 @@
 	public static final int filterVideo = 512;
 
 	public int Init(int /*long*/ parent, int /*long*/ title, short mode) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parent, title, mode);
-	}
-
-	public int AppendFilters(int filterMask) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), filterMask);
-	}
-
-	public int AppendFilter(int /*long*/ title, int /*long*/ filter) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), title, filter);
-	}
-
-	public int GetDefaultString(int /*long*/ aDefaultString) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aDefaultString);
-	}
-
-	public int SetDefaultString(int /*long*/ aDefaultString) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aDefaultString);
-	}
-
-	public int GetDefaultExtension(int /*long*/ aDefaultExtension) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aDefaultExtension);
-	}
-
-	public int SetDefaultExtension(int /*long*/ aDefaultExtension) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aDefaultExtension);
-	}
-
-	public int GetFilterIndex(int[] aFilterIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aFilterIndex);
-	}
-
-	public int SetFilterIndex(int aFilterIndex) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aFilterIndex);
-	}
-
-	public int GetDisplayDirectory(int /*long*/[] aDisplayDirectory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aDisplayDirectory);
-	}
-
-	public int SetDisplayDirectory(int /*long*/ aDisplayDirectory) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aDisplayDirectory);
-	}
-
-	public int GetFile(int /*long*/[] aFile) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aFile);
-	}
-
-	public int GetFileURL(int /*long*/[] aFileURL) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aFileURL);
-	}
-
-	public int GetFiles(int /*long*/[] aFiles) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aFiles);
-	}
-
-	public int Show(int /*long*/ _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), parent, title, mode);
+	}
+
+	public int AppendFilters(int filterMask) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), filterMask);
+	}
+
+	public int AppendFilter(int /*long*/ title, int /*long*/ filter) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), title, filter);
+	}
+
+	public int GetDefaultString(int /*long*/ aDefaultString) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aDefaultString);
+	}
+
+	public int SetDefaultString(int /*long*/ aDefaultString) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aDefaultString);
+	}
+
+	public int GetDefaultExtension(int /*long*/ aDefaultExtension) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aDefaultExtension);
+	}
+
+	public int SetDefaultExtension(int /*long*/ aDefaultExtension) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aDefaultExtension);
+	}
+
+	public int GetFilterIndex(int[] aFilterIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aFilterIndex);
+	}
+
+	public int SetFilterIndex(int aFilterIndex) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aFilterIndex);
+	}
+
+	public int GetDisplayDirectory(int /*long*/[] aDisplayDirectory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), aDisplayDirectory);
+	}
+
+	public int SetDisplayDirectory(int /*long*/ aDisplayDirectory) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aDisplayDirectory);
+	}
+
+	public int GetFile(int /*long*/[] aFile) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aFile);
+	}
+
+	public int GetFileURL(int /*long*/[] aFileURL) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aFileURL);
+	}
+
+	public int GetFiles(int /*long*/[] aFiles) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aFiles);
+	}
+
+	public int Show(int /*long*/ _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 17 : 15), getAddress(), _retval);
 	}
 	
@@ -135,5 +135,5 @@
 	public int SetAddToRecentDocs(int aAddToRecentDocs) {
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aAddToRecentDocs);
-	}
-}
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWindowWatcher.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWindowWatcher.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWindowWatcher.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -84,4 +84,4 @@
 	public int SetActiveWindow(int /*long*/ aActiveWindow) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 11, getAddress(), aActiveWindow);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDirectoryService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDirectoryService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDirectoryService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDirectoryService extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDIRECTORYSERVICE_IID_STR =
-		"57a66a60-d43a-11d3-8cc2-00609792278c";
-
-	public static final nsID NS_IDIRECTORYSERVICE_IID =
-		new nsID(NS_IDIRECTORYSERVICE_IID_STR);
-
-	public nsIDirectoryService(int /*long*/ address) {
-		super(address);
-	}
-
-	public int Init() {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
-	}
-
-	public int RegisterProvider(int /*long*/ prov) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prov);
-	}
-
-	public int UnregisterProvider(int /*long*/ prov) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prov);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDirectoryService extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDIRECTORYSERVICE_IID_STR =
+		"57a66a60-d43a-11d3-8cc2-00609792278c";
+
+	public static final nsID NS_IDIRECTORYSERVICE_IID =
+		new nsID(NS_IDIRECTORYSERVICE_IID_STR);
+
+	public nsIDirectoryService(int /*long*/ address) {
+		super(address);
+	}
+
+	public int Init() {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress());
+	}
+
+	public int RegisterProvider(int /*long*/ prov) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prov);
+	}
+
+	public int UnregisterProvider(int /*long*/ prov) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prov);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsISupportsWeakReference.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISupportsWeakReference.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISupportsWeakReference.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -44,4 +44,4 @@
 	public int GetWeakReference(int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsISeekableStream.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISeekableStream.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISeekableStream.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_ISEEKABLESTREAM_IID =
 		new nsID(NS_ISEEKABLESTREAM_IID_STR);
 
-	public nsISeekableStream(int /*long*/ address) {
+	public  nsISeekableStream(int /*long*/ address) {
 		super(address);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIRequest.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIRequest.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIRequest.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -45,7 +45,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aName);
 	}
 
-	public int IsPending(int[] _retval) {
+	public int IsPending(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), _retval);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIDOMElement.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMElement.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMElement.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,133 +1,133 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2011, 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMElement extends nsIDOMNode {
-
-	static final int LAST_METHOD_ID = nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 20 : 16);
-
-	public static final String NS_IDOMELEMENT_IID_STR =
-		"a6cf9078-15b3-11d2-932e-00805f8add32";
-
-	public static final String NS_IDOMELEMENT_10_IID_STR =
-		"1f249e8b-7b41-44c0-a8d5-15298c1198cd";
-
-	public static final nsID NS_IDOMELEMENT_IID =
-		new nsID(NS_IDOMELEMENT_IID_STR);
-
-	public static final nsID NS_IDOMELEMENT_10_IID =
-		new nsID(NS_IDOMELEMENT_10_IID_STR);
-
-	public nsIDOMElement(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetTagName(int /*long*/ aTagName) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 1, getAddress(), aTagName);
-	}
-
-	public int GetAttribute(int /*long*/ name, int /*long*/ _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 2, getAddress(), name, _retval);
-	}
-
-	public int SetAttribute(int /*long*/ name, int /*long*/ value) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 3, getAddress(), name, value);
-	}
-
-	public int RemoveAttribute(int /*long*/ name) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 4, getAddress(), name);
-	}
-
-	public int GetAttributeNode(int /*long*/ name, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 5, getAddress(), name, _retval);
-	}
-
-	public int SetAttributeNode(int /*long*/ newAttr, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 6, getAddress(), newAttr, _retval);
-	}
-
-	public int RemoveAttributeNode(int /*long*/ oldAttr, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 7, getAddress(), oldAttr, _retval);
-	}
-
-	public int GetElementsByTagName(int /*long*/ name, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 8, getAddress(), name, _retval);
-	}
-
-	public int GetAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/ _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 9, getAddress(), namespaceURI, localName, _retval);
-	}
-
-	public int SetAttributeNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/ value) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 10, getAddress(), namespaceURI, qualifiedName, value);
-	}
-
-	public int RemoveAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 11, getAddress(), namespaceURI, localName);
-	}
-
-	public int GetAttributeNodeNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 12, getAddress(), namespaceURI, localName, _retval);
-	}
-
-	public int SetAttributeNodeNS(int /*long*/ newAttr, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 13, getAddress(), newAttr, _retval);
-	}
-
-	public int GetElementsByTagNameNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 14, getAddress(), namespaceURI, localName, _retval);
-	}
-
-	public int HasAttribute(int /*long*/ name, int[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 15, getAddress(), name, _retval);
-	}
-
-	public int HasAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName, int[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 16, getAddress(), namespaceURI, localName, _retval);
-	}
-
-	public int GetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 17, getAddress(), cx, aOnmouseenter);
-	}
-
-	public int SetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 18, getAddress(), cx, aOnmouseenter);
-	}
-
-	public int GetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 19, getAddress(), cx, aOnmouseleave);
-	}
-
-	public int SetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 20, getAddress(), cx, aOnmouseleave);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsIDOMElement extends nsIDOMNode {
+
+	static final int LAST_METHOD_ID = nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 20 : 16);
+
+	public static final String NS_IDOMELEMENT_IID_STR =
+		"a6cf9078-15b3-11d2-932e-00805f8add32";
+
+	public static final String NS_IDOMELEMENT_10_IID_STR =
+		"1f249e8b-7b41-44c0-a8d5-15298c1198cd";
+
+	public static final nsID NS_IDOMELEMENT_IID =
+		new nsID(NS_IDOMELEMENT_IID_STR);
+
+	public static final nsID NS_IDOMELEMENT_10_IID =
+		new nsID(NS_IDOMELEMENT_10_IID_STR);
+
+	public  nsIDOMElement(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetTagName(int /*long*/ aTagName) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 1, getAddress(), aTagName);
+	}
+
+	public int GetAttribute(int /*long*/ name, int /*long*/ _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 2, getAddress(), name, _retval);
+	}
+
+	public int SetAttribute(int /*long*/ name, int /*long*/ value) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 3, getAddress(), name, value);
+	}
+
+	public int RemoveAttribute(int /*long*/ name) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 4, getAddress(), name);
+	}
+
+	public int GetAttributeNode(int /*long*/ name, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 5, getAddress(), name, _retval);
+	}
+
+	public int SetAttributeNode(int /*long*/ newAttr, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 6, getAddress(), newAttr, _retval);
+	}
+
+	public int RemoveAttributeNode(int /*long*/ oldAttr, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 7, getAddress(), oldAttr, _retval);
+	}
+
+	public int GetElementsByTagName(int /*long*/ name, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 8, getAddress(), name, _retval);
+	}
+
+	public int GetAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/ _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 9, getAddress(), namespaceURI, localName, _retval);
+	}
+
+	public int SetAttributeNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/ value) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 10, getAddress(), namespaceURI, qualifiedName, value);
+	}
+
+	public int RemoveAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 11, getAddress(), namespaceURI, localName);
+	}
+
+	public int GetAttributeNodeNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 12, getAddress(), namespaceURI, localName, _retval);
+	}
+
+	public int SetAttributeNodeNS(int /*long*/ newAttr, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 13, getAddress(), newAttr, _retval);
+	}
+
+	public int GetElementsByTagNameNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 14, getAddress(), namespaceURI, localName, _retval);
+	}
+
+	public int HasAttribute(int /*long*/ name, int[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 15, getAddress(), name, _retval);
+	}
+
+	public int HasAttributeNS(int /*long*/ namespaceURI, int /*long*/ localName, int[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 16, getAddress(), namespaceURI, localName, _retval);
+	}
+
+	public int GetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 17, getAddress(), cx, aOnmouseenter);
+	}
+
+	public int SetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 18, getAddress(), cx, aOnmouseenter);
+	}
+
+	public int GetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 19, getAddress(), cx, aOnmouseleave);
+	}
+
+	public int SetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 20, getAddress(), cx, aOnmouseleave);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_8.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_8.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,87 +1,87 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIHelperAppLauncher_8 extends nsICancelable {
-
-	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 11;
-
-	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
-		"d9a19faf-497b-408c-b995-777d956b72c0";
-
-	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
-		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
-
-	public nsIHelperAppLauncher_8(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetMIMEInfo(int /*long*/[] aMIMEInfo) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
-	}
-
-	public int GetSource(int /*long*/[] aSource) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
-	}
-
-	public int GetSuggestedFileName(int /*long*/ aSuggestedFileName) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
-	}
-
-	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
-	}
-
-	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
-	}
-
-	public int SetWebProgressListener(int /*long*/ aWebProgressListener) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
-	}
-
-	public int CloseProgressWindow() {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
-	}
-
-	public int GetTargetFile(int /*long*/[] aTargetFile) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
-	}
-
-	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTargetFileIsExecutable);
-	}
-
-	public int GetTimeDownloadStarted(int /*long*/ aTimeDownloadStarted) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 10, getAddress(), aTimeDownloadStarted);
-	}
-	
-	public int GetContentLength(int /*long*/ aContentLength) {
-		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 11, getAddress(), aContentLength);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2012 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIHelperAppLauncher_8 extends nsICancelable {
+
+	static final int LAST_METHOD_ID = nsICancelable.LAST_METHOD_ID + 11;
+
+	public static final String NS_IHELPERAPPLAUNCHER_IID_STR =
+		"d9a19faf-497b-408c-b995-777d956b72c0";
+
+	public static final nsID NS_IHELPERAPPLAUNCHER_IID =
+		new nsID(NS_IHELPERAPPLAUNCHER_IID_STR);
+
+	public nsIHelperAppLauncher_8(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetMIMEInfo(int /*long*/[] aMIMEInfo) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 1, getAddress(), aMIMEInfo);
+	}
+
+	public int GetSource(int /*long*/[] aSource) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 2, getAddress(), aSource);
+	}
+
+	public int GetSuggestedFileName(int /*long*/ aSuggestedFileName) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
+	}
+
+	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
+	}
+
+	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
+	}
+
+	public int SetWebProgressListener(int /*long*/ aWebProgressListener) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 6, getAddress(), aWebProgressListener);
+	}
+
+	public int CloseProgressWindow() {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 7, getAddress());
+	}
+
+	public int GetTargetFile(int /*long*/[] aTargetFile) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 8, getAddress(), aTargetFile);
+	}
+
+	public int GetTargetFileIsExecutable(int[] aTargetFileIsExecutable) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 9, getAddress(), aTargetFileIsExecutable);
+	}
+
+	public int GetTimeDownloadStarted(int /*long*/ aTimeDownloadStarted) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 10, getAddress(), aTimeDownloadStarted);
+	}
+	
+	public int GetContentLength(int /*long*/ aContentLength) {
+		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 11, getAddress(), aContentLength);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISimpleEnumerator.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -41,7 +41,7 @@
 		super(address);
 	}
 
-	public int HasMoreElements(int[] _retval) {
+	public int HasMoreElements(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), _retval);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIProperties.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProperties.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProperties.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -49,7 +49,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), prop, value);
 	}
 
-	public int Has(byte[] prop, int[] _retval) {
+	public int Has(byte[] prop, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), prop, _retval);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIBadCertListener2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIBadCertListener2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIBadCertListener2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IBADCERTLISTENER2_IID =
 		new nsID(NS_IBADCERTLISTENER2_IID_STR);
 
-	public nsIBadCertListener2(int /*long*/ address) {
+	public  nsIBadCertListener2(int /*long*/ address) {
 		super(address);
 	}
 
@@ -44,4 +44,4 @@
 	public int NotifyCertProblem(int /*long*/ socketInfo, int /*long*/ status, int /*long*/ targetSite, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), socketInfo, status, targetSite, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsISupports.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISupports.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISupports.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -67,4 +67,4 @@
 	public int Release() {
 		return XPCOM.VtblCall(FIRST_METHOD_ID + 2, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIURIContentListener.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIURIContentListener.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIURIContentListener.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -41,19 +41,19 @@
 		super(address);
 	}
 
-	public int OnStartURIOpen(int /*long*/ aURI, int[] _retval) {
+	public int OnStartURIOpen(int /*long*/ aURI, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, _retval);
 	}
 
-	public int DoContent(byte[] aContentType, int aIsContentPreferred, int /*long*/ aRequest, int /*long*/[] aContentHandler, int[] _retval) {
+	public int DoContent(byte[] aContentType, int aIsContentPreferred, int /*long*/ aRequest, int /*long*/[] aContentHandler, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aContentType, aIsContentPreferred, aRequest, aContentHandler, _retval);
 	}
 
-	public int IsPreferred(byte[] aContentType, int /*long*/[] aDesiredContentType, int[] _retval) {
+	public int IsPreferred(byte[] aContentType, int /*long*/[] aDesiredContentType, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aContentType, aDesiredContentType, _retval);
 	}
 
-	public int CanHandleContent(byte[] aContentType, int aIsContentPreferred, int /*long*/[] aDesiredContentType, int[] _retval) {
+	public int CanHandleContent(byte[] aContentType, int aIsContentPreferred, int /*long*/[] aDesiredContentType, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContentType, aIsContentPreferred, aDesiredContentType, _retval);
 	}
 
@@ -72,4 +72,4 @@
 	public int SetParentContentListener(int /*long*/ aParentContentListener) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aParentContentListener);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDirectoryServiceProvider.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,47 +1,47 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDirectoryServiceProvider extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 1;
-
-	public static final String NS_IDIRECTORYSERVICEPROVIDER_IID_STR =
-		"bbf8cab0-d43a-11d3-8cc2-00609792278c";
-
-	public static final nsID NS_IDIRECTORYSERVICEPROVIDER_IID =
-		new nsID(NS_IDIRECTORYSERVICEPROVIDER_IID_STR);
-
-	public nsIDirectoryServiceProvider(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetFile(byte[] prop, int[] persistent, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, persistent, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDirectoryServiceProvider extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 1;
+
+	public static final String NS_IDIRECTORYSERVICEPROVIDER_IID_STR =
+		"bbf8cab0-d43a-11d3-8cc2-00609792278c";
+
+	public static final nsID NS_IDIRECTORYSERVICEPROVIDER_IID =
+		new nsID(NS_IDIRECTORYSERVICEPROVIDER_IID_STR);
+
+	public nsIDirectoryServiceProvider(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetFile(byte[] prop, int[] persistent, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), prop, persistent, _retval);
+	}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIBaseWindow.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIBaseWindow.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIBaseWindow.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -67,7 +67,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), x, y);
 	}
 
-	public int SetSize(int cx, int cy, int fRepaint) {
+	public int SetSize(int cx, int cy, int fRepaint) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), cx, cy, fRepaint);
 	}
 
@@ -75,7 +75,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), cx, cy);
 	}
 
-	public int SetPositionAndSize(int x, int y, int cx, int cy, int fRepaint) {
+	public int SetPositionAndSize(int x, int y, int cx, int cy, int fRepaint) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), x, y, cx, cy, fRepaint);
 	}
 
@@ -83,7 +83,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), x, y, cx, cy);
 	}
 
-	public int Repaint(int force) {
+	public int Repaint(int force) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 10, getAddress(), force);
 	}
 
@@ -103,28 +103,28 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aParentNativeWindow);
 	}
 
-	public int GetVisibility(int[] aVisibility) {
+	public int GetVisibility(int[] aVisibility) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), aVisibility);
 	}
 
-	public int SetVisibility(int aVisibility) {
+	public int SetVisibility(int aVisibility) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 16, getAddress(), aVisibility);
 	}
 
-	public int GetEnabled(int[] aEnabled) {
+	public int GetEnabled(int[] aEnabled) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 17, getAddress(), aEnabled);
 	}
 
-	public int SetEnabled(int aEnabled) {
+	public int SetEnabled(int aEnabled) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 18, getAddress(), aEnabled);
 	}
 
-	public int GetBlurSuppression(int[] aBlurSuppression) {
+	public int GetBlurSuppression(int[] aBlurSuppression) {
 		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 19, getAddress(), aBlurSuppression);
 	}
 
-	public int SetBlurSuppression(int aBlurSuppression) {
+	public int SetBlurSuppression(int aBlurSuppression) {
 		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 20, getAddress(), aBlurSuppression);
 	}
@@ -144,4 +144,4 @@
 	public int SetTitle(char[] aTitle) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + (IsXULRunner10 ? 22 : 24), getAddress(), aTitle);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/XPCOMObject.java
===================================================================
--- org/eclipse/swt/internal/mozilla/XPCOMObject.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/XPCOMObject.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -20,9 +20,9 @@
 		String osName = System.getProperty ("os.name").toLowerCase (); //$NON-NLS-1$
 		IsSolaris = osName.startsWith ("sunos") || osName.startsWith("solaris"); //$NON-NLS-1$
 	}
+
+	private int /*long*/ ppVtable;
 	
-	private int /*long*/ ppVtable;
-
 	static private final int MAX_ARG_COUNT = 12;
 	static private final int MAX_VTABLE_LENGTH = 80;
 	static final int OS_OFFSET = IsSolaris ? 2 : 0;
Index: org/eclipse/swt/internal/mozilla/nsISSLStatus.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsISSLStatus.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsISSLStatus.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -43,7 +43,7 @@
 	public static final nsID NS_ISSLSTATUS_10_IID =
 		new nsID(NS_ISSLSTATUS_10_IID_STR);
 
-	public nsISSLStatus(int /*long*/ address) {
+	public  nsISSLStatus(int /*long*/ address) {
 		super(address);
 	}
 
@@ -79,4 +79,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aIsExtendedValidation);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWeakReference.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWeakReference.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWeakReference.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -44,4 +44,4 @@
 	public int QueryReferent(nsID uuid, int /*long*/[] result) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), uuid, result);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMWindow.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMWindow.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMWindow.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -675,4 +675,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 129, getAddress(), cx, aOnmouseleave);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHttpHeaderVisitor.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHttpHeaderVisitor.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHttpHeaderVisitor.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IHTTPHEADERVISITOR_IID =
 		new nsID(NS_IHTTPHEADERVISITOR_IID_STR);
 
-	public nsIHttpHeaderVisitor(int /*long*/ address) {
+	public  nsIHttpHeaderVisitor(int /*long*/ address) {
 		super(address);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsICookie.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookie.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookie.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -49,7 +49,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aValue);
 	}
 
-	public int GetIsDomain(int[] aIsDomain) {
+	public int GetIsDomain(int[] aIsDomain) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aIsDomain);
 	}
 
@@ -61,7 +61,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), aPath);
 	}
 
-	public int GetIsSecure(int[] aIsSecure) {
+	public int GetIsSecure(int[] aIsSecure) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aIsSecure);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIWebNavigationInfo.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebNavigationInfo.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebNavigationInfo.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -49,4 +49,4 @@
 	public int IsTypeSupported(int /*long*/ aType, int /*long*/ aWebNav, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aType, aWebNav, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWindowCreator2.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -43,7 +43,7 @@
 
 	public static final int PARENT_IS_LOADING_OR_RUNNING_TIMEOUT = 1;
 
-	public int CreateChromeWindow2(int /*long*/ parent, int chromeFlags, int contextFlags, int /*long*/ uri, int[] cancel, int /*long*/[] _retval) {
+	public int CreateChromeWindow2(int /*long*/ parent, int chromeFlags, int contextFlags, int /*long*/ uri, int[] cancel, int /*long*/[] _retval) {
 		return XPCOM.VtblCall(nsIWindowCreator.LAST_METHOD_ID + 1, getAddress(), parent, chromeFlags, contextFlags, uri, cancel, _retval);
 	}
 }
Index: org/eclipse/swt/internal/mozilla/nsIFile.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIFile.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIFile.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -100,7 +100,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), newParentDir, newName);
 	}
 
-	public int Remove(int recursive) {
+	public int Remove(int recursive) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 15, getAddress(), recursive);
 	}
 
@@ -164,39 +164,39 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 30, getAddress(), aNativePath);
 	}
 
-	public int Exists(int[] _retval) {
+	public int Exists(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 31, getAddress(), _retval);
 	}
 
-	public int IsWritable(int[] _retval) {
+	public int IsWritable(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 32, getAddress(), _retval);
 	}
 
-	public int IsReadable(int[] _retval) {
+	public int IsReadable(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 33, getAddress(), _retval);
 	}
 
-	public int IsExecutable(int[] _retval) {
+	public int IsExecutable(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 34, getAddress(), _retval);
 	}
 
-	public int IsHidden(int[] _retval) {
+	public int IsHidden(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 35, getAddress(), _retval);
 	}
 
-	public int IsDirectory(int[] _retval) {
+	public int IsDirectory(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 36, getAddress(), _retval);
 	}
 
-	public int IsFile(int[] _retval) {
+	public int IsFile(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 37, getAddress(), _retval);
 	}
 
-	public int IsSymlink(int[] _retval) {
+	public int IsSymlink(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 38, getAddress(), _retval);
 	}
 
-	public int IsSpecial(int[] _retval) {
+	public int IsSpecial(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 39, getAddress(), _retval);
 	}
 
@@ -208,11 +208,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 41, getAddress(), _retval);
 	}
 
-	public int Equals(int /*long*/ inFile, int[] _retval) {
+	public int Equals(int /*long*/ inFile, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 42, getAddress(), inFile, _retval);
 	}
 
-	public int Contains(int /*long*/ inFile, int recur, int[] _retval) {
+	public int Contains(int /*long*/ inFile, int recur, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 43, getAddress(), inFile, recur, _retval);
 	}
 
@@ -223,4 +223,4 @@
 	public int GetDirectoryEntries(int /*long*/[] aDirectoryEntries) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 45, getAddress(), aDirectoryEntries);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMUIEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -55,7 +55,7 @@
 		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 2, getAddress(), aDetail);
 	}
 
-	public int InitUIEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int detailArg) {
+	public int InitUIEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int detailArg) {
 		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 3, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg);
 	}
 	
@@ -112,4 +112,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsIDOMEvent.LAST_METHOD_ID + 13, getAddress(), aIsChar);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowserChromeFocus.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowserChromeFocus.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowserChromeFocus.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -48,4 +48,4 @@
 	public int FocusPrevElement() {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIMIMEInputStream.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIMIMEInputStream.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIMIMEInputStream.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -27,7 +27,7 @@
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
 
-public class nsIMIMEInputStream extends nsIInputStream {
+public class  nsIMIMEInputStream extends nsIInputStream {
 
 	static final int LAST_METHOD_ID = nsIInputStream.LAST_METHOD_ID + 4;
 
@@ -37,7 +37,7 @@
 	public static final nsID NS_IMIMEINPUTSTREAM_IID =
 		new nsID(NS_IMIMEINPUTSTREAM_IID_STR);
 
-	public nsIMIMEInputStream(int /*long*/ address) {
+	public  nsIMIMEInputStream(int /*long*/ address) {
 		super(address);
 	}
 
@@ -56,4 +56,4 @@
 	public int SetData(int /*long*/ stream) {
 		return XPCOM.VtblCall(nsIInputStream.LAST_METHOD_ID + 4, getAddress(), stream);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsID.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsID.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsID.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -137,4 +137,4 @@
     	toHex (m3[2], 2) + toHex (m3[3], 2) + toHex (m3[4], 2) + toHex (m3[5], 2) + toHex (m3[6], 2) + toHex (m3[7], 2) + '}';
 }
 
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIProgressDialog.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIProgressDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIProgressDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -45,11 +45,11 @@
 		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 1, getAddress(), aParent);
 	}
 
-	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
+	public int GetCancelDownloadOnClose(int[] aCancelDownloadOnClose) {
 		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 2, getAddress(), aCancelDownloadOnClose);
 	}
 
-	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
+	public int SetCancelDownloadOnClose(int aCancelDownloadOnClose) {
 		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 3, getAddress(), aCancelDownloadOnClose);
 	}
 
@@ -60,4 +60,4 @@
 	public int SetDialog(int /*long*/ aDialog) {
 		return XPCOM.VtblCall(nsIDownload.LAST_METHOD_ID + 5, getAddress(), aDialog);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICertificateDialogs.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICertificateDialogs.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICertificateDialogs.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -64,4 +64,4 @@
 	public int CrlImportStatusDialog(int /*long*/ ctx, int /*long*/ crl) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), ctx, crl);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIComponentRegistrar.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -65,11 +65,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aClass, aFile);
 	}
 
-	public int IsCIDRegistered(nsID aClass, int[] _retval) {
+	public int IsCIDRegistered(nsID aClass, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 7, getAddress(), aClass, _retval);
 	}
 
-	public int IsContractIDRegistered(byte[] aContractID, int[] _retval) {
+	public int IsContractIDRegistered(byte[] aContractID, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aContractID, _retval);
 	}
 
@@ -88,4 +88,4 @@
 	public int ContractIDToCID(byte[] aContractID, int /*long*/ _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aContractID, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsILocalFile.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsILocalFile.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsILocalFile.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -53,11 +53,11 @@
 		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 3, getAddress(), aFile);
 	}
 
-	public int GetFollowLinks(int[] aFollowLinks) {
+	public int GetFollowLinks(int[] aFollowLinks) {
 		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 4, getAddress(), aFollowLinks);
 	}
 
-	public int SetFollowLinks(int aFollowLinks) {
+	public int SetFollowLinks(int aFollowLinks) {
 		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 5, getAddress(), aFollowLinks);
 	}
 
@@ -108,4 +108,4 @@
 	public int SetRelativeDescriptor(int /*long*/ fromFile, int /*long*/ relativeDesc) {
 		return XPCOM.VtblCall(nsIFile.LAST_METHOD_ID + 17, getAddress(), fromFile, relativeDesc);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMMouseEvent.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -63,19 +63,19 @@
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 4, getAddress(), aClientY);
 	}
 
-	public int GetCtrlKey(int[] aCtrlKey) {
+	public int GetCtrlKey(int[] aCtrlKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 5, getAddress(), aCtrlKey);
 	}
 
-	public int GetShiftKey(int[] aShiftKey) {
+	public int GetShiftKey(int[] aShiftKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 6, getAddress(), aShiftKey);
 	}
 
-	public int GetAltKey(int[] aAltKey) {
+	public int GetAltKey(int[] aAltKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 7, getAddress(), aAltKey);
 	}
 
-	public int GetMetaKey(int[] aMetaKey) {
+	public int GetMetaKey(int[] aMetaKey) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 8, getAddress(), aMetaKey);
 	}
 
@@ -87,7 +87,7 @@
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 10, getAddress(), aRelatedTarget);
 	}
 
-	public int InitMouseEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int detailArg, int screenXArg, int screenYArg, int clientXArg, int clientYArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, short buttonArg, int /*long*/ relatedTargetArg) {
+	public int InitMouseEvent(int /*long*/ typeArg, int canBubbleArg, int cancelableArg, int /*long*/ viewArg, int detailArg, int screenXArg, int screenYArg, int clientXArg, int clientYArg, int ctrlKeyArg, int altKeyArg, int shiftKeyArg, int metaKeyArg, short buttonArg, int /*long*/ relatedTargetArg) {
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 11, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg);
 	}
 
@@ -115,4 +115,4 @@
 		return XPCOM.VtblCall(nsIDOMUIEvent.LAST_METHOD_ID + 14, getAddress(), typeArg, canBubbleArg, cancelableArg, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg, pressure, inputSourceArg);
 	}
 
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIComponentManager.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIComponentManager.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIComponentManager.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -56,4 +56,4 @@
 	public int CreateInstanceByContractID(byte[] aContractID, int /*long*/ aDelegate, nsID aIID, int /*long*/[] result) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aContractID, aDelegate, aIID, result);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowserStream.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowserStream.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowserStream.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -52,4 +52,4 @@
 	public int CloseStream() {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress());
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICookieService_1_9.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,59 +1,59 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2003, 2011 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsICookieService_1_9 extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
-
-	public static final String NS_ICOOKIESERVICE_IID_STR =
-		"2aaa897a-293c-4d2b-a657-8c9b7136996d";
-
-	public static final nsID NS_ICOOKIESERVICE_IID =
-		new nsID(NS_ICOOKIESERVICE_IID_STR);
-
-	public nsICookieService_1_9(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetCookieString(int /*long*/ aURI, int /*long*/ aChannel, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
-	}
-
-	public int GetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aChannel, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
-	}
-
-	public int SetCookieString(int /*long*/ aURI, int /*long*/ aPrompt, byte[] aCookie, int /*long*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
-	}
-
-	public int SetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aPrompt, byte[] aCookie, byte[] aServerTime, int /*long*/ aChannel) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsICookieService_1_9 extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 4;
+
+	public static final String NS_ICOOKIESERVICE_IID_STR =
+		"2aaa897a-293c-4d2b-a657-8c9b7136996d";
+
+	public static final nsID NS_ICOOKIESERVICE_IID =
+		new nsID(NS_ICOOKIESERVICE_IID_STR);
+
+	public  nsICookieService_1_9(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetCookieString(int /*long*/ aURI, int /*long*/ aChannel, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aURI, aChannel, _retval);
+	}
+
+	public int GetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aChannel, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aURI, aFirstURI, aChannel, _retval);
+	}
+
+	public int SetCookieString(int /*long*/ aURI, int /*long*/ aPrompt, byte[] aCookie, int /*long*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aURI, aPrompt, aCookie, aChannel);
+	}
+
+	public int SetCookieStringFromHttp(int /*long*/ aURI, int /*long*/ aFirstURI, int /*long*/ aPrompt, byte[] aCookie, byte[] aServerTime, int /*long*/ aChannel) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aURI, aFirstURI, aPrompt, aCookie, aServerTime, aChannel);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIMemory.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIMemory.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIMemory.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -53,11 +53,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), ptr);
 	}
 
-	public int HeapMinimize(int immediate) {
+	public int HeapMinimize(int immediate) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), immediate);
 	}
 
-	public int IsLowMemory(int[] _retval) {
+	public int IsLowMemory(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIObserverService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIObserverService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIObserverService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -41,7 +41,7 @@
 		super(address);
 	}
 
-	public int AddObserver(int /*long*/ anObserver, byte[] aTopic, int ownsWeak) {
+	public int AddObserver(int /*long*/ anObserver, byte[] aTopic, int ownsWeak) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), anObserver, aTopic, ownsWeak);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncher_1_8.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -53,11 +53,11 @@
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 3, getAddress(), aSuggestedFileName);
 	}
 
-	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
+	public int SaveToDisk(int /*long*/ aNewFileLocation, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 4, getAddress(), aNewFileLocation, aRememberThisPreference);
 	}
 
-	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
+	public int LaunchWithApplication(int /*long*/ aApplication, int aRememberThisPreference) {
 		return XPCOM.VtblCall(nsICancelable.LAST_METHOD_ID + 5, getAddress(), aApplication, aRememberThisPreference);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIPrefBranch.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIPrefBranch.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIPrefBranch.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -60,7 +60,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), aPrefName, _retval);
 	}
 
-	public int GetBoolPref(byte[] aPrefName, int[] _retval) {
+	public int GetBoolPref(byte[] aPrefName, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aPrefName, _retval);
 	}
 
@@ -100,11 +100,11 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 12, getAddress(), aPrefName);
 	}
 
-	public int PrefHasUserValue(byte[] aPrefName, int[] _retval) {
+	public int PrefHasUserValue(byte[] aPrefName, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 13, getAddress(), aPrefName, _retval);
 	}
 
-	public int PrefIsLocked(byte[] aPrefName, int[] _retval) {
+	public int PrefIsLocked(byte[] aPrefName, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 14, getAddress(), aPrefName, _retval);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsIInputStream.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIInputStream.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIInputStream.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -22,7 +22,7 @@
  *
  * IBM
  * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
+ * -  Copyright (C) 2003, 2008 IBM Corp.  All Rights Reserved.
  *
  * ***** END LICENSE BLOCK ***** */
 package org.eclipse.swt.internal.mozilla;
@@ -57,7 +57,7 @@
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 4, getAddress(), aWriter, aClosure, aCount, _retval);
 	}
 
-	public int IsNonBlocking(int[] _retval) {
+	public int IsNonBlocking(int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 5, getAddress(), _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIUploadChannel.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIUploadChannel.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIUploadChannel.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_IUPLOADCHANNEL_IID =
 		new nsID(NS_IUPLOADCHANNEL_IID_STR);
 
-	public nsIUploadChannel(int /*long*/ address) {
+	public  nsIUploadChannel(int /*long*/ address) {
 		super(address);
 	}
 
Index: org/eclipse/swt/internal/mozilla/nsICertOverrideService.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsICertOverrideService.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsICertOverrideService.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -37,7 +37,7 @@
 	public static final nsID NS_ICERTOVERRIDESERVICE_IID =
 		new nsID(NS_ICERTOVERRIDESERVICE_IID_STR);
 
-	public nsICertOverrideService(int /*long*/ address) {
+	public  nsICertOverrideService(int /*long*/ address) {
 		super(address);
 	}
 
@@ -68,4 +68,4 @@
 	public int IsCertUsedForOverrides(int /*long*/ aCert, int aCheckTemporaries, int aCheckPermanents, int[] _retval) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 6, getAddress(), aCert, aCheckTemporaries, aCheckPermanents, _retval);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMDocument.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMDocument.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMDocument.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,349 +1,349 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
  * -  Copyright (C) 2011, 2012 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMDocument extends nsIDOMNode {
-
-	static final int LAST_METHOD_ID = nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 61 : 17);
-
-	public static final String NS_IDOMDOCUMENT_IID_STR =
-		"a6cf9075-15b3-11d2-932e-00805f8add32";
-
-	public static final String NS_IDOMDOCUMENT_10_IID_STR =
-		"5c3bff4d-ae7f-4c93-948c-519589672c30";
-
-	public static final nsID NS_IDOMDOCUMENT_IID =
-		new nsID(NS_IDOMDOCUMENT_IID_STR);
-
-	public static final nsID NS_IDOMDOCUMENT_10_IID =
-		new nsID(NS_IDOMDOCUMENT_10_IID_STR);
-
-	public nsIDOMDocument(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetDoctype(int /*long*/[] aDoctype) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 1, getAddress(), aDoctype);
-	}
-
-	public int GetImplementation(int /*long*/[] aImplementation) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 2, getAddress(), aImplementation);
-	}
-
-	public int GetDocumentElement(int /*long*/[] aDocumentElement) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 3, getAddress(), aDocumentElement);
-	}
-
-	public int CreateElement(int /*long*/ tagName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 4, getAddress(), tagName, _retval);
-	}
-
-	public int CreateDocumentFragment(int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 5, getAddress(), _retval);
-	}
-
-	public int CreateTextNode(int /*long*/ data, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 6, getAddress(), data, _retval);
-	}
-
-	public int CreateComment(int /*long*/ data, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 7, getAddress(), data, _retval);
-	}
-
-	public int CreateCDATASection(int /*long*/ data, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 8, getAddress(), data, _retval);
-	}
-
-	public int CreateProcessingInstruction(int /*long*/ target, int /*long*/ data, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 9, getAddress(), target, data, _retval);
-	}
-
-	public int CreateAttribute(int /*long*/ name, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 10, getAddress(), name, _retval);
-	}
-
-	public int CreateEntityReference(int /*long*/ name, int /*long*/[] _retval) {
-		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 11, getAddress(), name, _retval);
-	}
-
-	public int GetElementsByTagName(int /*long*/ tagname, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 11 : 12), getAddress(), tagname, _retval);
-	}
-
-	public int ImportNode(int /*long*/ importedNode, int deep, int /*long*/[] _retval) {
-		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 13, getAddress(), importedNode, deep, _retval);
-	}
-
-	public int ImportNode(int /*long*/ importedNode, int deep, int _argc, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 12, getAddress(), importedNode, deep, _argc, _retval);
-	}
-
-	public int CreateElementNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 13 : 14), getAddress(), namespaceURI, qualifiedName, _retval);
-	}
-
-	public int CreateAttributeNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 14 : 15), getAddress(), namespaceURI, qualifiedName, _retval);
-	}
-
-	public int GetElementsByTagNameNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 15 : 16), getAddress(), namespaceURI, localName, _retval);
-	}
-
-	public int GetElementById(int /*long*/ elementId, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 16 : 17), getAddress(), elementId, _retval);
-	}
-	
-	public int GetInputEncoding(int /*long*/ aInputEncoding) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 17, getAddress(), aInputEncoding);
-	}
-
-	public int GetDocumentURI(int /*long*/ aDocumentURI) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 18, getAddress(), aDocumentURI);
-	}
-
-	public int AdoptNode(int /*long*/ source, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 19, getAddress(), source, _retval);
-	}
-
-	public int CreateRange(int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 20, getAddress(), _retval);
-	}
-
-	public int CreateNodeIterator(int /*long*/ root, int whatToShow, int /*long*/ filter, int entityReferenceExpansion, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 21, getAddress(), root, whatToShow, filter, entityReferenceExpansion, _retval);
-	}
-
-	public int CreateTreeWalker(int /*long*/ root, int whatToShow, int /*long*/ filter, int entityReferenceExpansion, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 22, getAddress(), root, whatToShow, filter, entityReferenceExpansion, _retval);
-	}
-
-	public int CreateEvent(int /*long*/ eventType, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 23, getAddress(), eventType, _retval);
-	}
-
-	public int GetDefaultView(int /*long*/[] aDefaultView) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 24, getAddress(), aDefaultView);
-	}
-
-	public int GetCharacterSet(int /*long*/ aCharacterSet) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 25, getAddress(), aCharacterSet);
-	}
-
-	public int GetDir(int /*long*/ aDir) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 26, getAddress(), aDir);
-	}
-
-	public int SetDir(int /*long*/ aDir) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 27, getAddress(), aDir);
-	}
-
-	public int GetLocation(int /*long*/[] aLocation) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 28, getAddress(), aLocation);
-	}
-
-	public int GetTitle(int /*long*/ aTitle) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 29, getAddress(), aTitle);
-	}
-
-	public int SetTitle(int /*long*/ aTitle) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 30, getAddress(), aTitle);
-	}
-
-	public int GetReadyState(int /*long*/ aReadyState) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 31, getAddress(), aReadyState);
-	}
-
-	public int GetLastModified(int /*long*/ aLastModified) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 32, getAddress(), aLastModified);
-	}
-
-	public int GetReferrer(int /*long*/ aReferrer) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 33, getAddress(), aReferrer);
-	}
-
-	public int HasFocus(int[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 34, getAddress(), _retval);
-	}
-
-	public int GetActiveElement(int /*long*/[] aActiveElement) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 35, getAddress(), aActiveElement);
-	}
-
-	public int GetElementsByClassName(int /*long*/ classes, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 36, getAddress(), classes, _retval);
-	}
-
-	public int GetStyleSheets(int /*long*/[] aStyleSheets) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 37, getAddress(), aStyleSheets);
-	}
-
-	public int GetPreferredStyleSheetSet(int /*long*/ aPreferredStyleSheetSet) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 38, getAddress(), aPreferredStyleSheetSet);
-	}
-
-	public int GetSelectedStyleSheetSet(int /*long*/ aSelectedStyleSheetSet) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 39, getAddress(), aSelectedStyleSheetSet);
-	}
-
-	public int SetSelectedStyleSheetSet(int /*long*/ aSelectedStyleSheetSet) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 40, getAddress(), aSelectedStyleSheetSet);
-	}
-
-	public int GetLastStyleSheetSet(int /*long*/ aLastStyleSheetSet) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 41, getAddress(), aLastStyleSheetSet);
-	}
-
-	public int GetStyleSheetSets(int /*long*/[] aStyleSheetSets) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 42, getAddress(), aStyleSheetSets);
-	}
-
-	public int EnableStyleSheetsForSet(int /*long*/ name) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 43, getAddress(), name);
-	}
-
-	public int ElementFromPoint(float x, float y, int /*long*/[] _retval) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 44, getAddress(), x, y, _retval);
-	}
-
-	public int GetContentType(int /*long*/ aContentType) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 45, getAddress(), aContentType);
-	}
-
-	public int GetMozSyntheticDocument(int[] aMozSyntheticDocument) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 46, getAddress(), aMozSyntheticDocument);
-	}
-
-	public int GetCurrentScript(int /*long*/[] aCurrentScript) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 47, getAddress(), aCurrentScript);
-	}
-
-	public int ReleaseCapture() {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 48, getAddress());
-	}
-
-	public int MozSetImageElement(int /*long*/ aImageElementId, int /*long*/ aImageElement) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 49, getAddress(), aImageElementId, aImageElement);
-	}
-
-	public int GetMozFullScreenElement(int /*long*/[] aMozFullScreenElement) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 50, getAddress(), aMozFullScreenElement);
-	}
-
-	public int MozCancelFullScreen() {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 51, getAddress());
-	}
-
-	public int GetMozFullScreen(int[] aMozFullScreen) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 52, getAddress(), aMozFullScreen);
-	}
-
-	public int GetMozFullScreenEnabled(int[] aMozFullScreenEnabled) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 53, getAddress(), aMozFullScreenEnabled);
-	}
-
-	public int GetOnreadystatechange(int /*long*/ cx, int /*long*/ aOnreadystatechange) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 54, getAddress(), cx, aOnreadystatechange);
-	}
-
-	public int SetOnreadystatechange(int /*long*/ cx, int /*long*/ aOnreadystatechange) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 55, getAddress(), cx, aOnreadystatechange);
-	}
-
-	public int GetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 56, getAddress(), cx, aOnmouseenter);
-	}
-
-	public int SetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 57, getAddress(), cx, aOnmouseenter);
-	}
-
-	public int GetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 58, getAddress(), cx, aOnmouseleave);
-	}
-
-	public int SetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 59, getAddress(), cx, aOnmouseleave);
-	}
-
-	public int GetMozHidden(int[] aMozHidden) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 60, getAddress(), aMozHidden);
-	}
-
-	public int GetMozVisibilityState(int /*long*/ aMozVisibilityState) {
-		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
-		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 61, getAddress(), aMozVisibilityState);
-	}
-}
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class  nsIDOMDocument extends nsIDOMNode {
+
+	static final int LAST_METHOD_ID = nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 61 : 17);
+
+	public static final String NS_IDOMDOCUMENT_IID_STR =
+		"a6cf9075-15b3-11d2-932e-00805f8add32";
+
+	public static final String NS_IDOMDOCUMENT_10_IID_STR =
+		"5c3bff4d-ae7f-4c93-948c-519589672c30";
+
+	public static final nsID NS_IDOMDOCUMENT_IID =
+		new nsID(NS_IDOMDOCUMENT_IID_STR);
+
+	public static final nsID NS_IDOMDOCUMENT_10_IID =
+		new nsID(NS_IDOMDOCUMENT_10_IID_STR);
+
+	public  nsIDOMDocument(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetDoctype(int /*long*/[] aDoctype) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 1, getAddress(), aDoctype);
+	}
+
+	public int GetImplementation(int /*long*/[] aImplementation) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 2, getAddress(), aImplementation);
+	}
+
+	public int GetDocumentElement(int /*long*/[] aDocumentElement) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 3, getAddress(), aDocumentElement);
+	}
+
+	public int CreateElement(int /*long*/ tagName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 4, getAddress(), tagName, _retval);
+	}
+
+	public int CreateDocumentFragment(int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 5, getAddress(), _retval);
+	}
+
+	public int CreateTextNode(int /*long*/ data, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 6, getAddress(), data, _retval);
+	}
+
+	public int CreateComment(int /*long*/ data, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 7, getAddress(), data, _retval);
+	}
+
+	public int CreateCDATASection(int /*long*/ data, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 8, getAddress(), data, _retval);
+	}
+
+	public int CreateProcessingInstruction(int /*long*/ target, int /*long*/ data, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 9, getAddress(), target, data, _retval);
+	}
+
+	public int CreateAttribute(int /*long*/ name, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 10, getAddress(), name, _retval);
+	}
+
+	public int CreateEntityReference(int /*long*/ name, int /*long*/[] _retval) {
+		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 11, getAddress(), name, _retval);
+	}
+
+	public int GetElementsByTagName(int /*long*/ tagname, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 11 : 12), getAddress(), tagname, _retval);
+	}
+
+	public int ImportNode(int /*long*/ importedNode, int deep, int /*long*/[] _retval) {
+		if (IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 13, getAddress(), importedNode, deep, _retval);
+	}
+
+	public int ImportNode(int /*long*/ importedNode, int deep, int _argc, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 12, getAddress(), importedNode, deep, _argc, _retval);
+	}
+
+	public int CreateElementNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 13 : 14), getAddress(), namespaceURI, qualifiedName, _retval);
+	}
+
+	public int CreateAttributeNS(int /*long*/ namespaceURI, int /*long*/ qualifiedName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 14 : 15), getAddress(), namespaceURI, qualifiedName, _retval);
+	}
+
+	public int GetElementsByTagNameNS(int /*long*/ namespaceURI, int /*long*/ localName, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 15 : 16), getAddress(), namespaceURI, localName, _retval);
+	}
+
+	public int GetElementById(int /*long*/ elementId, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + (IsXULRunner10 ? 16 : 17), getAddress(), elementId, _retval);
+	}
+	
+	public int GetInputEncoding(int /*long*/ aInputEncoding) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 17, getAddress(), aInputEncoding);
+	}
+
+	public int GetDocumentURI(int /*long*/ aDocumentURI) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 18, getAddress(), aDocumentURI);
+	}
+
+	public int AdoptNode(int /*long*/ source, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 19, getAddress(), source, _retval);
+	}
+
+	public int CreateRange(int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 20, getAddress(), _retval);
+	}
+
+	public int CreateNodeIterator(int /*long*/ root, int whatToShow, int /*long*/ filter, int entityReferenceExpansion, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 21, getAddress(), root, whatToShow, filter, entityReferenceExpansion, _retval);
+	}
+
+	public int CreateTreeWalker(int /*long*/ root, int whatToShow, int /*long*/ filter, int entityReferenceExpansion, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 22, getAddress(), root, whatToShow, filter, entityReferenceExpansion, _retval);
+	}
+
+	public int CreateEvent(int /*long*/ eventType, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 23, getAddress(), eventType, _retval);
+	}
+
+	public int GetDefaultView(int /*long*/[] aDefaultView) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 24, getAddress(), aDefaultView);
+	}
+
+	public int GetCharacterSet(int /*long*/ aCharacterSet) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 25, getAddress(), aCharacterSet);
+	}
+
+	public int GetDir(int /*long*/ aDir) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 26, getAddress(), aDir);
+	}
+
+	public int SetDir(int /*long*/ aDir) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 27, getAddress(), aDir);
+	}
+
+	public int GetLocation(int /*long*/[] aLocation) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 28, getAddress(), aLocation);
+	}
+
+	public int GetTitle(int /*long*/ aTitle) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 29, getAddress(), aTitle);
+	}
+
+	public int SetTitle(int /*long*/ aTitle) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 30, getAddress(), aTitle);
+	}
+
+	public int GetReadyState(int /*long*/ aReadyState) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 31, getAddress(), aReadyState);
+	}
+
+	public int GetLastModified(int /*long*/ aLastModified) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 32, getAddress(), aLastModified);
+	}
+
+	public int GetReferrer(int /*long*/ aReferrer) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 33, getAddress(), aReferrer);
+	}
+
+	public int HasFocus(int[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 34, getAddress(), _retval);
+	}
+
+	public int GetActiveElement(int /*long*/[] aActiveElement) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 35, getAddress(), aActiveElement);
+	}
+
+	public int GetElementsByClassName(int /*long*/ classes, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 36, getAddress(), classes, _retval);
+	}
+
+	public int GetStyleSheets(int /*long*/[] aStyleSheets) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 37, getAddress(), aStyleSheets);
+	}
+
+	public int GetPreferredStyleSheetSet(int /*long*/ aPreferredStyleSheetSet) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 38, getAddress(), aPreferredStyleSheetSet);
+	}
+
+	public int GetSelectedStyleSheetSet(int /*long*/ aSelectedStyleSheetSet) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 39, getAddress(), aSelectedStyleSheetSet);
+	}
+
+	public int SetSelectedStyleSheetSet(int /*long*/ aSelectedStyleSheetSet) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 40, getAddress(), aSelectedStyleSheetSet);
+	}
+
+	public int GetLastStyleSheetSet(int /*long*/ aLastStyleSheetSet) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 41, getAddress(), aLastStyleSheetSet);
+	}
+
+	public int GetStyleSheetSets(int /*long*/[] aStyleSheetSets) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 42, getAddress(), aStyleSheetSets);
+	}
+
+	public int EnableStyleSheetsForSet(int /*long*/ name) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 43, getAddress(), name);
+	}
+
+	public int ElementFromPoint(float x, float y, int /*long*/[] _retval) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 44, getAddress(), x, y, _retval);
+	}
+
+	public int GetContentType(int /*long*/ aContentType) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 45, getAddress(), aContentType);
+	}
+
+	public int GetMozSyntheticDocument(int[] aMozSyntheticDocument) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 46, getAddress(), aMozSyntheticDocument);
+	}
+
+	public int GetCurrentScript(int /*long*/[] aCurrentScript) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 47, getAddress(), aCurrentScript);
+	}
+
+	public int ReleaseCapture() {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 48, getAddress());
+	}
+
+	public int MozSetImageElement(int /*long*/ aImageElementId, int /*long*/ aImageElement) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 49, getAddress(), aImageElementId, aImageElement);
+	}
+
+	public int GetMozFullScreenElement(int /*long*/[] aMozFullScreenElement) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 50, getAddress(), aMozFullScreenElement);
+	}
+
+	public int MozCancelFullScreen() {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 51, getAddress());
+	}
+
+	public int GetMozFullScreen(int[] aMozFullScreen) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 52, getAddress(), aMozFullScreen);
+	}
+
+	public int GetMozFullScreenEnabled(int[] aMozFullScreenEnabled) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 53, getAddress(), aMozFullScreenEnabled);
+	}
+
+	public int GetOnreadystatechange(int /*long*/ cx, int /*long*/ aOnreadystatechange) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 54, getAddress(), cx, aOnreadystatechange);
+	}
+
+	public int SetOnreadystatechange(int /*long*/ cx, int /*long*/ aOnreadystatechange) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 55, getAddress(), cx, aOnreadystatechange);
+	}
+
+	public int GetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 56, getAddress(), cx, aOnmouseenter);
+	}
+
+	public int SetOnmouseenter(int /*long*/ cx, int /*long*/ aOnmouseenter) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 57, getAddress(), cx, aOnmouseenter);
+	}
+
+	public int GetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 58, getAddress(), cx, aOnmouseleave);
+	}
+
+	public int SetOnmouseleave(int /*long*/ cx, int /*long*/ aOnmouseleave) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 59, getAddress(), cx, aOnmouseleave);
+	}
+
+	public int GetMozHidden(int[] aMozHidden) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 60, getAddress(), aMozHidden);
+	}
+
+	public int GetMozVisibilityState(int /*long*/ aMozVisibilityState) {
+		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
+		return XPCOM.VtblCall(nsIDOMNode.LAST_METHOD_ID + 61, getAddress(), aMozVisibilityState);
+	}
+}
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowser.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowser.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowser.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -84,4 +84,4 @@
 		if (!IsXULRunner10) return XPCOM.NS_COMFALSE;
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 9, getAddress(), aIsActive);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIWebBrowserFocus.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIWebBrowserFocus.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIWebBrowserFocus.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -72,4 +72,4 @@
 	public int SetFocusedElement(int /*long*/ aFocusedElement) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 8, getAddress(), aFocusedElement);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIHelperAppLauncherDialog.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -52,4 +52,4 @@
 	public int ShowProgressDialog(int /*long*/ aLauncher, int /*long*/ aContext) {
 		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), aLauncher, aContext);
 	}
-}
+}
\ No newline at end of file
Index: org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java
===================================================================
--- org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java	(.../vendor/swt/win32/4.2/src)	(revision 23809)
+++ org/eclipse/swt/internal/mozilla/nsIDOMWindowCollection.java	(.../trunk/thirdparty/swt/4.2/win32/src)	(revision 23809)
@@ -1,55 +1,55 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code, released March 31, 1998.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by Netscape are Copyright (C) 1998-1999
- * Netscape Communications Corporation.  All Rights Reserved.
- *
- * Contributor(s):
- *
- * IBM
- * -  Binding to permit interfacing between Mozilla and SWT
- * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
- *
- * ***** END LICENSE BLOCK ***** */
-package org.eclipse.swt.internal.mozilla;
-
-public class nsIDOMWindowCollection extends nsISupports {
-
-	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
-
-	public static final String NS_IDOMWINDOWCOLLECTION_IID_STR =
-		"a6cf906f-15b3-11d2-932e-00805f8add32";
-
-	public static final nsID NS_IDOMWINDOWCOLLECTION_IID =
-		new nsID(NS_IDOMWINDOWCOLLECTION_IID_STR);
-
-	public nsIDOMWindowCollection(int /*long*/ address) {
-		super(address);
-	}
-
-	public int GetLength(int[] aLength) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aLength);
-	}
-
-	public int Item(int index, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), index, _retval);
-	}
-
-	public int NamedItem(int /*long*/ name, int /*long*/[] _retval) {
-		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), name, _retval);
-	}
-}
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code, released March 31, 1998.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by Netscape are Copyright (C) 1998-1999
+ * Netscape Communications Corporation.  All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * IBM
+ * -  Binding to permit interfacing between Mozilla and SWT
+ * -  Copyright (C) 2003 IBM Corp.  All Rights Reserved.
+ *
+ * ***** END LICENSE BLOCK ***** */
+package org.eclipse.swt.internal.mozilla;
+
+public class nsIDOMWindowCollection extends nsISupports {
+
+	static final int LAST_METHOD_ID = nsISupports.LAST_METHOD_ID + 3;
+
+	public static final String NS_IDOMWINDOWCOLLECTION_IID_STR =
+		"a6cf906f-15b3-11d2-932e-00805f8add32";
+
+	public static final nsID NS_IDOMWINDOWCOLLECTION_IID =
+		new nsID(NS_IDOMWINDOWCOLLECTION_IID_STR);
+
+	public nsIDOMWindowCollection(int /*long*/ address) {
+		super(address);
+	}
+
+	public int GetLength(int[] aLength) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 1, getAddress(), aLength);
+	}
+
+	public int Item(int index, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 2, getAddress(), index, _retval);
+	}
+
+	public int NamedItem(int /*long*/ name, int /*long*/[] _retval) {
+		return XPCOM.VtblCall(nsISupports.LAST_METHOD_ID + 3, getAddress(), name, _retval);
+	}
+}
\ No newline at end of file
Index: make_win32.mak
===================================================================
--- make_win32.mak	(.../vendor/swt/win32/4.2/csrc)	(revision 23809)
+++ make_win32.mak	(.../trunk/thirdparty/swt/4.2/win32/csrc)	(revision 23809)
@@ -169,7 +169,7 @@
 	echo -out:$(XULRUNNER_LIB) >>templrf
 	link @templrf
 	del templrf
-	
+
 swt.res:
 	rc $(RCFLAGS) -DSWT_ORG_FILENAME=\"$(SWT_LIB)\" -r -fo swt.res swt.rc
 
Index: callback.c
===================================================================
--- callback.c	(.../vendor/swt/win32/4.2/csrc)	(revision 23809)
+++ callback.c	(.../trunk/thirdparty/swt/4.2/win32/csrc)	(revision 23809)
@@ -1073,9 +1073,9 @@
 				code[j++] = ((i >> 16) & 0xFF);
 				code[j++] = ((i >> 24) & 0xFF);
 			} else {
-				//PUSH i - 2 bytes
-				code[j++] = 0x6a;
-				code[j++] = i;
+			//PUSH i - 2 bytes
+			code[j++] = 0x6a;
+			code[j++] = i;
 			}
 
 			//MOV EAX callback - 1 + sizeof(jintLong) bytes
@@ -1247,7 +1247,7 @@
 	}
 	va_end(vl);
 	ATOMIC_DEC(callbackEntryCount);
-
+	
 done:
 	/* If an exception has occurred in Java, return the error result. */
 	if ((ex = (*env)->ExceptionOccurred(env))) {
