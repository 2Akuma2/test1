<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="version" content="6.0.3">
<link rel="shortcut icon" href="../icons/favicon.ico" type="image/vnd.microsoft.icon">
<title>Name</title>
<link href="man.css" type="text/css" rel="stylesheet">
<meta name="organisation" content="Quality First Software GmbH">
<meta name="copyright" content="(C) 1999-2022 Quality First Software GmbH">
</head>
<body bgcolor="white">
<a name="usec_components_name"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="naviheader">
<tr>
<td class="margin"></td><td class="navicon"><a href="manual.html"><img src="../icons/linktop.png" width="34" height="36" border="0" alt="Top" title="Top"></a></td><td class="navicon"><a href="contents.html#table-of-contents"><img src="../icons/linktoc.png" width="34" height="36" border="0" alt="Inhaltsverzeichnis" title="Inhaltsverzeichnis"></a></td><td class="navicon"><a href="usec_componentclass.html#usec_componentclass"><img src="../icons/linkprev.png" width="34" height="36" border="0" alt="Vorheriges Kapitel: 5.4.1&nbsp;Klasse" title="Vorheriges Kapitel: 5.4.1&nbsp;Klasse"></a></td><td class="navicon"><a href="usec_components_feature.html#usec_components_feature"><img src="../icons/linkcont.png" width="34" height="36" border="0" alt="N&auml;chste Seite: 5.4.3&nbsp;Merkmal" title="N&auml;chste Seite: 5.4.3&nbsp;Merkmal"></a></td><td class="navicon"><a href="usec_components_feature.html#usec_components_feature"><img src="../icons/linknext.png" width="34" height="36" border="0" alt="N&auml;chstes Kapitel: 5.4.3&nbsp;Merkmal" title="N&auml;chstes Kapitel: 5.4.3&nbsp;Merkmal"></a></td><td class="navicon"><a href="user_component_recognition_criteria.html#usec_component_recognition_criteria"><img src="../icons/linkup.png" width="34" height="36" border="0" alt="Kapitel-&Uuml;bersicht: 5.4&nbsp;Wiedererkennungskriterien" title="Kapitel-&Uuml;bersicht: 5.4&nbsp;Wiedererkennungskriterien"></a></td><td class="navicon"><a href="../../manual_de.pdf" target="_parent"><img src="../icons/linkpdf.png" width="34" height="36" border="0" alt="PDF Version" title="PDF Version"></a></td><td class="homeicon"><a href="http://www.qfs.de/de/qftest/index.html" target="_parent"><img src="../icons/qftest.png" width="127" height="42" border="0" alt="QF-Test" title="QF-Test"></a></td>
</tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="naviversion">
<tr>
<td>Version 6.0.3</td>
</tr>
</table>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_components_name">5.4.2</a></span>
</div>
<a href="contents.html#toc_usec_components_name">Name</a>
</h5>
        
<p>
          Falls die Entwickler f&uuml;r eine Komponente einen <a href="#usec_components_identifier">Komponentenbezeichner</a> vergeben haben, erkennt QF-Test dies und verwendet diesen, wenn geeignet, f&uuml;r das Attribut <a href="components.html#att_ComponentStep_name" shape="rect">'Name'</a>.
        </p>
        
<p>
          Wenn ein Wert f&uuml;r <a href="components.html#att_ComponentStep_name" shape="rect">'Name'</a> gefunden wurde, wird dieser auch f&uuml;r die
          Generierung der <a href="components.html#att_ComponentStep_id" shape="rect">'QF-Test ID'</a> der Komponente verwendet.
          Weitere Informationen finden Sie in <a href="tech_qftestid.html#sec_qftestid_creation">Abschnitt 44.2</a>, Beispiele
          hierzu in <a href="bp_componentrecognition.html#sec_bpComponentRecognition">Wie erreicht man eine robuste Komponentenerkennung?</a>.
        </p>
        
<p>
          Auch bei der Aufnahme von <a href="user_smartid.html#usec_smartid">SmartID (Preview)</a>s ist der 'Name'
          im Standard die erste Wahl.
        </p>
        
<p>
          Der Grund f&uuml;r den gewaltigen Einfluss eines guten <a href="#usec_components_identifier">Komponentenbezeichner</a>s ist die
          Tatsache, dass dieser die Wiedererkennung von Komponenten &uuml;ber lange Zeit
          und viele &Auml;nderungen hinweg zuverl&auml;ssig erm&ouml;glicht. Eine Komponente zu
          finden, die einen eindeutigen Bezeichner besitzt, ist offensichtlich
          trivial. Ohne diese Hilfe verwendet QF-Test viele verschiedene Arten von
          Informationen, um eine Komponente zu lokalisieren. Der Algorithmus ist
          fehlertolerant und wurde fein abgestimmt, so dass er ausgezeichnete
          Ergebnisse erzielt. Und dennoch: Mit Ausnahme des Bezeichners kann sich
          jede Information zu einer Komponente &auml;ndern, wenn sich das SUT
          weiterentwickelt. Irgendwann, wenn gr&ouml;&szlig;ere &Auml;nderungen vorgenommen
          wurden oder sich mehrere kleinere &Auml;nderungen summiert haben, wird eine
          Komponente nicht mehr erkannt werden und ein manueller Eingriff vonn&ouml;ten
          sein, um die Testsuite anzupassen.
        </p>
        
<p>
          Ein weiterer wichtiger Aspekt von Bezeichnern ist, dass sie das Testen von Applikationen, deren
          Oberfl&auml;che in verschiedene Sprachen &uuml;bersetzt wird, von der aktuell eingestellten Sprache
          unabh&auml;ngig macht, da der Bezeichner nur intern vergeben wird und nie &uuml;bersetzt werden muss.
        </p>
        
<p>
          Die Automatisierung von Tests kann deutlich verbessert werden, wenn die Entwickler des SUT
          vorausgeplant haben oder bereit sind, durch Vergabe von Bezeichnern f&uuml;r zumindest einen Teil der
          Komponenten des SUT mitzuhelfen. Au&szlig;erdem haben Bezeichner in der Testsuite eine sehr hohe
          Sichtbarkeit, da sie als Basis f&uuml;r die 'QF-Test ID' Attribute der 'Komponenten' dienen.
          Letzteres sollte nicht untersch&auml;tzt werden, speziell f&uuml;r Komponenten ohne besondere
          Merkmale. Knoten, die Text in Felder namens "textName", "textAddress" oder "textAccount"
          einf&uuml;gen, sind wesentlich leichter zu verstehen und zu warten als solche f&uuml;r die Felder
          "text", "text2" oder "text3". Der koordinierte Einsatz von Bezeichnern ist einer der
          entscheidenden Faktoren f&uuml;r die Effizienz der Automatisierung und f&uuml;r die mit QF-Test
          erzielbaren Einsparungen. Sollte sich die Entwicklungsabteilung oder die Projektleitung
          trotz des minimalen Aufwands nicht mit der Vergabe von Bezeichnern anfreunden k&ouml;nnen, geben Sie
          ihnen einfach dieses Kapitel des Handbuchs zu lesen.
        </p>
        
<p>
          Falls Entwickler ein anderes, konsistentes Schema zur Vergabe von
          Bezeichnern eingesetzt haben, das QF-Test jedoch standardm&auml;&szlig;ig nicht erkennt,
          werfen Sie bitte einen Blick in <a href="#sec_bpCRNameRes">Beeinflussen des <a href="components.html#att_ComponentStep_name" shape="rect">'Name'</a> Attributs mittels NameResolver</a>.
        </p>
        
<p>
          Wenn eindeutige 'Namen' ermittelt werden, k&ouml;nnen die
          Optionen <a href="opt_play.html#opt_nameoverride">Gewichtung von Namen (Wiedergabe)</a> und <a href="opt_record.html#opt_nameoverriderec">Gewichtung von Namen (Aufnahme)</a>
          auf "Name &uuml;bertrifft alles" gesetzt werden, wodurch die Komponentenerkennung von
          der Komponentenhierarchie unabh&auml;ngig und auf Grund des Name-Cachings
          maximale Performanz erreicht wird.
        </p>
        
<p>
          Um die Vergabe von Bezeichnern zu
          vereinfachen, bietet QF-Test eine Funktion, um Bezeichner f&uuml;r die Komponenten
          vorzuschlagen, f&uuml;r die ein Bezeichner das Testen verbessert. N&auml;heres dazu
          finden Sie bei der Option <a href="opt_record.html#opt_hotkeycomponent">Hotkey f&uuml;r Komponenten</a>.
        </p>
        
<p>
<span class="margin"><span class="note">Hinweis</span></span>
          &Auml;nderungen von Bezeichnern in der zu testenden Applikation sollten
          m&ouml;glichst vermieden werden, da dies die Komponentenerkennung aushebelt
          und eine Menge Nacharbeit in den Tests bedeuten kann. Bitte beachten
          Sie, wenn dennoch &Auml;nderungen vorkommen werden, dass diese im
          <a href="components.html#att_ComponentStep_name" shape="rect">'Name'</a> Attribut der Komponente nachgezogen werden und
          nicht im <a href="components.html#att_ComponentStep_id" shape="rect">'QF-Test ID'</a> Attribut, das nur der Referenzierung
          der Komponente in den Tests dient! Eine weitere m&ouml;gliche Schwierigkeit
          kann sein, dass die Namens&auml;nderung direkt im Test in der Referenz
          auf die Komponente erfolgt, zum Beispiel bei einem Mausklick im
          Attribut <a href="events.html#att_MouseEventStep_component" shape="rect">'QF-Test ID der Komponente'</a>. Der Test schl&auml;gt dann mit einer
          <a href="exceptions.html#ex_UnresolvedComponentIdException">
          <a name="idx_N155423"></a><code>UnresolvedComponentIdException</code>
        </a> fehl.
        </p>

        

        
<a name="usec_components_identifier"></a>
          
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_components_identifier">5.4.2.1</a></span>
</div>
<a href="contents.html#toc_usec_components_identifier">Komponentenbezeichner</a>
</h5>
          
<p>
            Komponentenbezeichner werden in den unterschiedlichen UI-Technologien
            unterschiedlich genannt. Im Handbuch wird f&uuml;r sie auch der Begriff
            'Name' verwendet. Au&szlig;erdem sind die Kriterien,
            ob und wie die Bezeichner in das 'Name' Attribut &uuml;bernommen werden,
            je nach Technologie leicht unterschiedlich.
          </p>
          
<p>
            Die folgenden Ausf&uuml;hrungen gelten f&uuml;r die Standardeinstellungen der Optionen,
            insbesondere von <a href="opt_play.html#opt_nameoverride">Gewichtung von Namen (Wiedergabe)</a> und <a href="opt_record.html#opt_nameoverriderec">Gewichtung von Namen (Aufnahme)</a>
            (Standardwert: "Hierarchie von Namen"). Auch die Nutzung von Resolvern kann das
            beschriebene Verhalten ver&auml;ndern.
          </p>
          
<dl>
            
<dt>Java Swing/AWT</dt>
            
<dd>
              
<p>
                Der Komponentenbezeichner hei&szlig;t hier ebenfalls 'Name'. Falls er gesetzt wurde, wird er
                in das 'Name' Attribut &uuml;bernommen. Wenn innerhalb eines Containers Komponenten
                gleiche Bezeichner haben, legt QF-Test das <a href="components.html#att_ComponentStep_extrafeatures" shape="rect">'Weiteres Merkmal'</a> <code>qfs:matchindex</code>
                mit einem entsprechenden Index f&uuml;r die Duplikate an.
              </p>
              
<p>
                Alle AWT und Swing Komponenten sind von der AWT Klasse
                <code>Component</code> abgeleitet. Deren <code>setName</code> Methode ist daher der
                Standard f&uuml;r Swing SUTs. Dank dieses Standards machen viele Entwickler auch unabh&auml;ngig von
                Pl&auml;nen f&uuml;r eine Testautomatisierung davon Gebrauch, was eine gro&szlig;e Hilfe ist.
              </p>
            
</dd>

            
<dt>Java FX</dt>
            
<dd>
              
<p>
                Der Komponentenbezeichner hei&szlig;t hier 'ID'. Falls er gesetzt wurde, wird er in das
                'Name' Attribut &uuml;bernommen. Wenn innerhalb eines Containers Komponenten
                gleiche IDs haben, legt QF-Test das <a href="components.html#att_ComponentStep_extrafeatures" shape="rect">'Weiteres Merkmal'</a>
                <code>qfs:matchindex</code> mit einem entsprechenden Index f&uuml;r die Duplikate an.
              </p>
              
<p>
                F&uuml;r JavaFx wird <code>setId</code> verwendet, um Namen f&uuml;r Komponenten (hier "Node" genannt) zu vergeben.
                Alternativ k&ouml;nnen IDs mittels FXML &uuml;ber
                das Attribut <code>fx:id</code> gesetzt werden. Obwohl
                IDs von Knoten eindeutig sein sollen, wird dies nicht erzwungen.
              </p>
            
</dd>

            
<dt>Java SWT</dt>
            
<dd>
              
<p>
                Der Komponentenbezeichner hei&szlig;t hier ebenfalls 'Name'. Falls er gesetzt wurde, wird er
                in das 'Name' Attribut &uuml;bernommen. Wenn innerhalb eines
                Containers Komponenten gleiche Bezeichner haben, legt QF-Test das
                <a href="components.html#att_ComponentStep_extrafeatures" shape="rect">'Weiteres Merkmal'</a> <code>qfs:matchindex</code> mit einem
                entsprechenden Index f&uuml;r die Duplikate an.
              </p>
              
<p>
                Leider hat SWT kein eigenes Konzept f&uuml;r die Vergabe von Namen. Eine
                akzeptierte Konvention ist der Gebrauch der Methode <code>setData(String key, Object
                value)</code> mit dem String <code>"name"</code> als Schl&uuml;ssel und dem gew&uuml;nschten Namen
                als Wert. QF-Test wertet diese Daten - falls vorhanden - aus und verwendet sie als Namen f&uuml;r
                die Komponenten. Mangels eines echten Standards f&uuml;r die Vergabe von Namen kommen diese in
                SWT Anwendungen inklusive Eclipse nur in Ausnahmef&auml;llen zum Einsatz. <br>
                Gl&uuml;cklicherweise kann QF-Test Namen f&uuml;r die Hauptkomponenten von Eclipse/RCP Anwendungen aus
                den zugrunde liegenden Modellen ableiten, was zu guten Ergebnissen f&uuml;hrt, vorausgesetzt es
                wurden IDs f&uuml;r diese Modelle vergeben. Weitere Details finden Sie bei der Beschreibung der
                Option <a href="opt_record.html#opt_rcpnames">
              Automatische Namen f&uuml;r Komponenten in Eclipse/RCP Anwendungen</a>.
              </p>
            
</dd>

            
<dt>Web</dt>
            
<dd>
              
<p>
                Der naheliegende Kandidat f&uuml;r den Bezeichner eines DOM Knotens ist sein 'id'
                Attribut, nicht zu verwechseln mit dem 'QF-Test ID' Attribut von QF-Test's 'Komponente'
                Knoten. Leider erzwingt der HTML Standard keine Eindeutigkeit von IDs. Au&szlig;erdem sind 'id'
                Attribute ein zweischneidiges Schwert, da sie eine wichtige Rolle bei den internen
                JavaScript Operationen einer Webanwendung spielen k&ouml;nnen. Daher ist es zwar nicht
                unwahrscheinlich, dass 'id' Attribute vergeben wurden, sie k&ouml;nnen aber nicht so frei
                definiert werden wie Bezeichner in anderen Technologien. Zu allem &Uuml;bel m&uuml;ssen viele DHTML
                und Ajax Frameworks IDs automatisch generieren, was diese als Namen ungeeignet macht.
              </p>
              
<p>
                Gl&uuml;cklicherweise k&ouml;nnen Komponentenbezeichner &uuml;ber unterschiedliche Attribute des GUI-Elements
                realisiert werden. Meist ist es das Attribut 'id', manchmal auch 'name' - aber auch
                andere Attribute k&ouml;nnen genutzt werden.
              </p>
              
<p>
                Die Option <a href="opt_web.html#opt_webidasname">'ID' Attribut als Name verwenden falls "eindeutig genug"</a> bestimmt, ob QF-Test 'id' Attribute
                als Namen verwendet oder nicht. Bitte beachten Sie, dass  die
                Option <a href="opt_web.html#opt_websuppressnumerals">Alle Ziffern aus 'ID' Attributen eliminieren</a> bewirken kann, dass urspr&uuml;nglich
                eindeutige Bezeichner nach L&ouml;schung der Ziffern nicht mehr eindeutig sind.
                Bei der Pr&uuml;fung, ob der ermittelte 'Name' eindeutig genug ist, wird die
                Hierarchie, in der die Komponente liegt, f&uuml;r die
                Bestimmung der Eindeutigkeit mit herangezogen, wenn f&uuml;r die Optionen
                <a href="opt_play.html#opt_nameoverride">Gewichtung von Namen (Wiedergabe)</a> und <a href="opt_record.html#opt_nameoverriderec">Gewichtung von Namen (Aufnahme)</a>
                der Standardwert "Hierarchie von Namen" gesetzt.
              </p>
              
<p>
                Die automatisch generierten 'id' Attribute enthalten
                manchmal einen statischen Teil, der als Bezeichner genutzt werden kann. Dies kann
                &uuml;ber den Parameter <code>autoIdPatterns</code>, siehe
                <a href="tech_custom_web_resolver.html#sec_custom_web_resolver_parameters"><code>installCustomWebResolver</code> - Parameter</a>, konfiguriert werden.
                Au&szlig;erdem kann in dieser Prozedur &uuml;ber den Parameter <code>customIdAttributes</code> auch
                jedes andere HTML-Attribut als Komponentenbezeichner genutzt werden.
              </p>
              
<p>
                Im Falle einer Webapplikation, welche ein von QF-Test
                unterst&uuml;tztes AJAX Toolkit verwendet, k&ouml;nnen Sie einen Blick in <a href="tech_ajax.html#sec_ajax_ids">Abschnitt 47.2.2</a> werfen, um mehr &uuml;ber das Setzen eindeutiger
                Bezeichner f&uuml;r das jeweilige Toolkit zu erfahren.
              </p>
            
</dd>

            
<dt>Win</dt>
            
<dd>
              
<p>
                Der Komponentenbezeichner hei&szlig;t hier 'AutomationId'. Falls er gesetzt wurde, wird er
                in das 'Name' Attribut &uuml;bernommen. Wenn innerhalb eines Containers
                Komponenten gleiche Bezeichner haben, legt QF-Test ein <a href="components.html#att_ComponentStep_extrafeatures" shape="rect">'Weiteres Merkmal'</a> mit dem Namen
                <code>qfs:matchindex</code> und einem entsprechenden Index f&uuml;r die Duplikate an.
              </p>
            
</dd>

            
<dt>Android</dt>
            
<dd>
              Der Komponentenbezeichner hei&szlig;t hier 'ID'. Er wird nur dann
              in das 'Name' Attribut &uuml;bernommen, wenn es sich nicht um einen trivialen
              Klassennamen (vgl. <a href="sec_android_trivial_names.html#sec_android_trivial_names">Android - Liste der trivialen Komponentenbezeichner</a>) handelt.
              Wenn innerhalb eines
              Containers Komponenten gleiche Bezeichner haben, legt QF-Test ein <a href="components.html#att_ComponentStep_extrafeatures" shape="rect">'Weiteres Merkmal'</a>
              mit dem Namen <code>qfs:matchindex</code> und einem entsprechenden Wert f&uuml;r die Duplikate an.
            </dd>
          
</dl>
        

        
        

        
<a name="usec_howtosetname"></a>
          
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_howtosetname">5.4.2.2</a></span>
</div>
<a href="contents.html#toc_usec_howtosetname">&Uuml;ber die Vergabe von Bezeichnern</a>
</h5>
          
<p>
            Es gibt eine kritische Anforderung f&uuml;r Bezeichner: Sie d&uuml;rfen sich nicht im Lauf der Zeit
            &auml;ndern, nicht von einer Version der SUT zur n&auml;chsten, nicht von einem Aufruf zum anderen
            und nicht w&auml;hrend der Ausf&uuml;hrung des SUT, z.B. wenn eine Komponente zerst&ouml;rt und sp&auml;ter
            neu erstellt wird. Ist ein Bezeichner einmal vergeben, muss er Bestand haben. Leider gibt es
            kein automatisches Schema zur Vergabe von Bezeichnern, das diese Anforderungen erf&uuml;llt. Solche
            Systeme erstellen Bezeichnern meist aus dem Bezeichner der jeweiligen Klasse und einem laufenden
            Index, was unweigerlich fehlschl&auml;gt, da der Bezeichner dann von der Reihenfolge der Erstellung
            der Komponenten abh&auml;ngt. Da Bezeichner eine so zentrale Rolle bei der Erkennung von Komponenten
            spielen, k&ouml;nnen unzuverl&auml;ssige Bezeichner, insbesondere automatisch generierte, sehr negative
            Effekte haben. Falls die Entwickler nicht &uuml;berzeugt werden k&ouml;nnen, derartige Bezeichner durch
            eindeutige, stabile zu ersetzen, oder sie zumindest wegzulassen, k&ouml;nnen solche Bezeichner mit Hilfe
            eines <code>NameResolver</code> unterdr&uuml;ckt werden. Weitere Informationen hierzu finden
            Sie in <a href="tech_resolversmodule.html#sec_nameresolver">Abschnitt 50.1.6</a>.
          </p>
          
<p>
            Es ist f&uuml;r die Arbeit mit QF-Test nicht n&ouml;tig, Bezeichner fl&auml;chendeckend zu vergeben. Allzu
            ausgiebiger Gebrauch kann sogar kontraproduktiv sein, da QF-Test ein eigenes Konzept daf&uuml;r
            hat, ob eine Komponente "interessant" ist oder nicht. Uninteressante Komponenten werden
            wegabstrahiert und k&ouml;nnen so bei einer &Auml;nderung keine Probleme verursachen. Typische
            Beispiele f&uuml;r solche Komponenten sind Panels, die nur f&uuml;r Layout-Zwecke eingebaut werden.
            Eine Komponente mit nicht trivialem Bezeichner gilt f&uuml;r QF-Test immer als interessant, so dass die
            Benamung von unwichtigen Komponenten zu Problemen f&uuml;hren kann, wenn diese in einer
            sp&auml;teren Version aus der Hierarchie entfernt werden.
          </p>
          
<p>
            Auch m&uuml;ssen Bezeichner nicht global eindeutig vergeben werden. Jede Klasse von Komponenten
            bildet einen eigenen Namensraum, so dass es keinen Konflikt gibt, wenn ein Textfeld und
            ein Button den selben Bezeichner haben. Au&szlig;erdem gen&uuml;gt es, wenn die Bezeichner innerhalb
            einer Anzeige eindeutig sein - sie brauchen also nicht applikationsweit eindeutig zu sein
            (au&szlig;er bei Web-Applikationen).
            Andererseits ist der Optimalfall hinsichtlich stabiler Komponentenerkennung in den
            Regressionstests, wenn die Bezeichner applikationsweit eindeutig sind. Dann k&ouml;nnen Sie die Optionen <a href="opt_play.html#opt_nameoverride">Gewichtung von Namen (Wiedergabe)</a> und <a href="opt_record.html#opt_nameoverriderec">Gewichtung von Namen (Aufnahme)</a> auf "Name &uuml;bertrifft
            alles" setzen, die flexibelste Einstellung zur Wiedererkennung von Komponenten.
          </p>
          
<p>
            Zwei Fragen sind noch offen: Welche Komponenten sollten Bezeichner erhalten
            und was sind eigentlich gute Bezeichner? Eine gute Daumenregel ist es,
            allen Komponenten, mit denen ein Anwender direkt interagieren kann,
            einen Bezeichner zu geben, also Kn&ouml;pfen, Textfeldern, etc. Komponenten, die
            nicht direkt erzeugt werden, sondern automatisch als Elemente von
            komplexen Komponenten, brauchen keinen Bezeichner. Dies sind z.B. die
            Listenelemente einer <code>ComboBox</code>. Die komplexe Komponente selbst (im Beispiel
            also die <code>ComboBox</code>) sollte
            dagegen sehr wohl einen Bezeichner haben.
          </p>
          
<p>
            Falls Bezeichner f&uuml;r Komponenten nicht von Anfang an vergeben wurden und die Entwickler nur den
            geringstm&ouml;glichen Aufwand spendieren wollen, diese zur Verbesserung der
            Testautomatisierung nachzuziehen, hat sich folgende Strategie als guter Kompromiss
            erwiesen: Fenster, komplexe Komponenten wie B&auml;ume und Tabellen, sowie Panels, die eine
            Anzahl von Komponenten zu einer Art Formular zusammenfassen, sollten einen Bezeichner erhalten.
            So lange Struktur und Geometrie der Komponenten in solchen Formularen einigerma&szlig;en
            konstant sind, f&uuml;hrt dies zu einer guten Wiedererkennung und brauchbaren 'QF-Test ID'
            Attributen. Probleme durch individuelle Komponenten mit wechselnden Eigenschaften k&ouml;nnen
            von Fall zu Fall behandelt werden, entweder indem entwicklungsseitig nachtr&auml;glich ein Bezeichner
            vergeben wird, oder mit Hilfe eines <code>NameResolver</code>.
          </p>
        

        
        

        
<a name="sec_bpCRNameRes"></a>
          
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_bpCRNameRes">5.4.2.3</a></span>
</div>
<a href="contents.html#toc_sec_bpCRNameRes">Beeinflussen des <a href="components.html#att_ComponentStep_name" shape="rect">'Name'</a> Attributs mittels NameResolver</a>
</h5>
          
<p>
            In unterschiedlichen Applikationen kommen unterschiedlichste
            Namenskonzepte f&uuml;r Komponenten zum Einsatz. Nicht in allen
            F&auml;llen liefern sie stabile Bezeichner, die f&uuml;r Regressionstests sinnvoll
            genutzt werden k&ouml;nnen: beispielsweise, wenn die
            Komponenten keine Bezeichner haben oder Bezeichner existieren, die
            sich aber von Zeit zu Zeit &auml;ndern, z.B. zeichnen Sie einen 'button1'
            beim ersten Mal auf und beim n&auml;chsten Mal hei&szlig;t dieser Button
            pl&ouml;tzlich 'button2'. Eine andere Variante k&ouml;nnte sein, dass die
            aktuelle Versionsnummer des SUT im Bezeichner des Hauptfensters steckt.
          </p>
          
<p>
            Manchmal kennen die Tester jedoch einen Algorithmus, um
            eindeutige Namen zu setzen.
            In solchen F&auml;llen sollten Sie sich <a href="tech_resolversmodule.html#sec_nameresolver">
             Das <code class="interfacedef">NameResolver</code> Interface</a>
            im Kapitel <a href="tech_resolversmodule.html#sec_resolversmodule">Das <code class="moduledef">resolvers</code> Modul</a> genauer anschauen.
          </p>
          
<p>
            Ein NameResolver kann verwendet werden, um Bezeichner aus der QF-Test Sicht
            zu &auml;ndern oder zu l&ouml;schen.
            Diese &Auml;nderungen treffen dann nur f&uuml;r die QF-Test Sicht zu und &auml;ndern
            nichts am aktuellen Sourcecode.
          </p>
          
<p>Sie sollten &uuml;ber den Einsatz von NameResolver nachdenken, wenn:</p>
          
<ul>
            
<li>das SUT dynamische Bezeichner besitzt.</li>
            
<li>Sie einen Algorithmus kennen, um eindeutige Bezeichner zu vergeben.</li>
            
<li>
              Sie entwicklungsseitige &Auml;nderungen von Bezeichnern "neutralisieren" wollen, z.B. bei einer neuen
              Version.
            </li>
            
<li>
              Sie die Namensgebung der Komponenten optimieren wollen,
              z.B. einige Teile ausschneiden, um lesbarere 'QF-Test IDs' f&uuml;r Komponenten in
              QF-Test zu erhalten.
            </li>
          
</ul>
          
<p>
            Wenn Sie eine Eindeutigkeit pro Fenster erreichen (bei Web f&uuml;r alle Seiten), k&ouml;nnen Sie
            dar&uuml;ber nachdenken die Optionen <a href="opt_play.html#opt_nameoverride">Gewichtung von Namen (Wiedergabe)</a>
            und <a href="opt_record.html#opt_nameoverriderec">Gewichtung von Namen (Aufnahme)</a> auf "Name &uuml;bertrifft
            alles" zu setzen.
          </p>
          
<p>
            
<span class="margin"><span class="note">Hinweis</span></span>
            Wenn es m&ouml;glich ist, dass die Entwickler eindeutige und stabile
            Bezeichner direkt vergeben, dann sollten es diese im Quellcode tun, da die
            Entwickler am besten wissen, welche Komponenten angelegt werden. Das
            Implementieren eines NameResolvers kann eine sehr aufwendige und
            m&uuml;hsame Aufgabe sein, besonders wenn sich das GUI stark &auml;ndert.
          </p>
          
<p>
            NameResolver sind in <a href="tech_resolversmodule.html#sec_nameresolver">Abschnitt 50.1.6</a> beschrieben.
          </p>
        

        

      
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="navifooter">
<tr>
<td class="margin"></td><td class="navicon"><a href="manual.html"><img src="../icons/linktop.png" width="34" height="36" border="0" alt="Top" title="Top"></a></td><td class="navicon"><a href="contents.html#table-of-contents"><img src="../icons/linktoc.png" width="34" height="36" border="0" alt="Inhaltsverzeichnis" title="Inhaltsverzeichnis"></a></td><td class="navicon"><a href="usec_componentclass.html#usec_componentclass"><img src="../icons/linkprev.png" width="34" height="36" border="0" alt="Vorheriges Kapitel: 5.4.1&nbsp;Klasse" title="Vorheriges Kapitel: 5.4.1&nbsp;Klasse"></a></td><td class="navicon"><a href="usec_components_feature.html#usec_components_feature"><img src="../icons/linkcont.png" width="34" height="36" border="0" alt="N&auml;chste Seite: 5.4.3&nbsp;Merkmal" title="N&auml;chste Seite: 5.4.3&nbsp;Merkmal"></a></td><td class="navicon"><a href="usec_components_feature.html#usec_components_feature"><img src="../icons/linknext.png" width="34" height="36" border="0" alt="N&auml;chstes Kapitel: 5.4.3&nbsp;Merkmal" title="N&auml;chstes Kapitel: 5.4.3&nbsp;Merkmal"></a></td><td class="navicon"><a href="user_component_recognition_criteria.html#usec_component_recognition_criteria"><img src="../icons/linkup.png" width="34" height="36" border="0" alt="Kapitel-&Uuml;bersicht: 5.4&nbsp;Wiedererkennungskriterien" title="Kapitel-&Uuml;bersicht: 5.4&nbsp;Wiedererkennungskriterien"></a></td><td class="navicon"><a href="../../manual_de.pdf" target="_parent"><img src="../icons/linkpdf.png" width="34" height="36" border="0" alt="PDF Version" title="PDF Version"></a></td><td class="navcopymod">Letzte &Auml;nderung: 6.9.2022<br>Copyright &copy; 1999-2022 Quality First Software GmbH</td>
</tr>
</table>
</body>
</html>
