<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="version" content="6.0.3">
<link rel="shortcut icon" href="../icons/favicon.ico" type="image/vnd.microsoft.icon">
<title>Organizing the test-suite</title>
<link href="man.css" type="text/css" rel="stylesheet">
<meta name="organisation" content="Quality First Software GmbH">
<meta name="copyright" content="(C) 1999-2022 Quality First Software GmbH">
</head>
<body bgcolor="white">
<a name="usec_organization"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="naviheader">
<tr>
<td class="margin"></td><td class="navicon"><a href="manual.html"><img src="../icons/linktop.png" width="34" height="36" border="0" alt="Top" title="Top"></a></td><td class="navicon"><a href="contents.html#table-of-contents"><img src="../icons/linktoc.png" width="34" height="36" border="0" alt="Table of contents" title="Table of contents"></a></td><td class="navicon"><a href="user_debugging.html#usec_debugging"><img src="../icons/linkprev.png" width="34" height="36" border="0" alt="Previous Chapter: 7&nbsp;Problem analysis and debugging" title="Previous Chapter: 7&nbsp;Problem analysis and debugging"></a></td><td class="navicon"><a href="projects.html#usec_projects"><img src="../icons/linkcont.png" width="34" height="36" border="0" alt="Next Page: 9&nbsp;Projects" title="Next Page: 9&nbsp;Projects"></a></td><td class="navicon"><a href="projects.html#usec_projects"><img src="../icons/linknext.png" width="34" height="36" border="0" alt="Next Chapter: 9&nbsp;Projects" title="Next Chapter: 9&nbsp;Projects"></a></td><td class="navicon"><a href="user.html#sec_user"><img src="../icons/linkup.png" width="34" height="36" border="0" alt="Chapter Overview: I&nbsp;User manual" title="Chapter Overview: I&nbsp;User manual"></a></td><td class="navicon"><a href="../../manual_en.pdf" target="_parent"><img src="../icons/linkpdf.png" width="34" height="36" border="0" alt="PDF version" title="PDF version"></a></td><td class="homeicon"><a href="http://www.qfs.de/en/qftest/index.html" target="_parent"><img src="../icons/qftest.png" width="127" height="42" border="0" alt="QF-Test" title="QF-Test"></a></td>
</tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="naviversion">
<tr>
<td>Version 6.0.3</td>
</tr>
</table>
    
<h3 class="header-container h3">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_organization">8</a></span>
</div>
<a href="contents.html#toc_usec_organization">Organizing the test-suite</a>
</h3>
    
    

    
<p>
      Creating useful, reliable tests requires more than just recording
      sequences and playing them back. You can fill a test-suite with lots of
      sequences in a short time, but you are bound to lose track of what
      you've got sooner or later if you do not organize your tests in some
      logical structure. QF-Test provides you with a number of structure elements
      to achieve this.
    </p>
    
<p>
      Before you start recording sequences and put them into a structure make sure
      that you
    </p>
    
<ul>
      
<li>
        You have a good idea of what you are testing.
      </li>
      
<li>
        You are testing the right thing.
      </li>
      
<li>
        Your tests are reliable and repeatable.
      </li>
      
<li>
        Your tests are easy to maintain.
      </li>
      
<li>
        The results of your tests are conclusive.
      </li>
    
</ul>
    
<p>
      The essential prerequisite of getting the components right has been discussed in
      <a href="user_components.html#usec_components">chapter 5</a>. Here we are going to concentrate on structuring
      the actual test-sets, test-cases, test-steps, sequences, events, checks, etc.
    </p>

    
    

    
<a name="usec_testsuite_structure"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_testsuite_structure">8.1</a></span>
</div>
<a href="contents.html#toc_usec_testsuite_structure">Test-suite structure</a>
</h4>
      
<a name="figure_8.1"></a><a name="figure_8.1"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/TestsuiteStructure.png" target="_blank"><img src="images/TestsuiteStructure.png" alt="Structure of a testsuite" width="986" height="627" texscale=".66"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.1</a>:&nbsp;&nbsp;Test-suite structure</td><td class="captionglue"></td>
</tr>
</table>
      
<p>
        QF-Test provides structure elements on different levels:
      </p>
      
<p>
        The QF-Test files  for saving the tests and components in the file directory. These can
        be bundled in projects.
      </p>
      
<p>
        The 'Test-suite' has a set structure starting with the testing section that can hold any number of
        <a href="sequences.html#step_TestSet" shape="rect">'Test-set'</a> nodes, which in turn can have any number of <a href="sequences.html#step_TestCase" shape="rect">'Test-case'</a> nodes or more 'Test-sets'.
      </p>
      
<p>
        Next comes the <a href="procedures.html#step_Procedure" shape="rect">'Procedures'</a> section, where you can place any number of <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a> nodes.
        QF-Test provides <a href="procedures.html#step_Package" shape="rect">'Package'</a> nodes as structure element in this section. A package node can hold any number of
        procedure nodes or more package nodes.
      </p>
      
<p>
        After that you will find the <a href="sequences.html#step_ExtraSequence" shape="rect">'Extras'</a> where you place any type of node and try out tests
        before moving them to the testing section.
      </p>
      
<p>
        The last section, <a href="components.html#step_WindowList" shape="rect">'Windows and components'</a>, is reserved for the components referenced by the tests.
      </p>
      
<p>
        QF-Test provides a number of structure elements for the tests themselves like 'Test-case' and
        'Test-set' nodes as well as 'Setup' and 'Cleanup' nodes for
        setting up the preconditions for the tests, cleaning up after the test and
        error handling.
      </p>
    

    
    

    
<a name="usec_testcase"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_testcase">8.2</a></span>
</div>
<a href="contents.html#toc_usec_testcase">'Test-set' and 'Test-case' nodes</a>
</h4>
      
<a name="usec_testcase_management"></a>
        
<h5 class="header-container h5">
<div>
<span class="margin"><a name="new_N79096"></a><span class="note">2.0+</span></span><span class="numtitle"><a href="contents.html#toc_usec_testcase_management">8.2.1</a></span>
</div>
<a href="contents.html#toc_usec_testcase_management">
          Test management with 'Test-set' and 'Test-case' nodes</a>
</h5>
        
<p>
          The <a href="sequences.html#step_TestSet" shape="rect">'Test-set'</a> and <a href="sequences.html#step_TestCase" shape="rect">'Test-case'</a> nodes provide a small-scale, pragmatic form of test
          management right inside QF-Test. Their main feature is the smart dependency management
          described in <a href="#usec_dependencies">'Dependency' nodes</a> that allows 'Test-cases' to be
          implemented completely independent from each other. With properly written <a href="dependencies.html#step_Dependency" shape="rect">'Dependencies'</a>,
          cleanup of the SUT for previously executed tests is handled automatically along with
          the setup for the next test and all error handling.
        </p>
      
      
<a name="usec_testcase_concepts"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_testcase_concepts">8.2.2</a></span>
</div>
<a href="contents.html#toc_usec_testcase_concepts">Concept</a>
</h5>
        
<p>
          Conceptually a 'Test-case' node represents a single elementary test case. As such it is
          the main link between test planning, execution and result analysis. With the help of
          <a href="dependencies.html#step_Dependency" shape="rect">'Dependencies'</a>, 'Test-cases' can be isolated from each other so that they can be
          run in any arbitrary order. QF-Test automatically takes care of the necessary test setup.
          Cleanup is also automatic and will be performed only when necessary in order to minimize
          overhead in the transition from one test to the next. This enables things like running
          subsets of functional test-suites as build tests or retesting only failed 'Test-cases'.
        </p>
        
<p>
          'Test-sets' basically are bundles of 'Test-cases' that belong together and typically have
          similar requirements for setup and cleanup. 'Test-sets' can be nested. The whole structure
          of 'Test-sets' and 'Test-cases' is very similar to <a href="procedures.html#step_Package" shape="rect">'Package'</a> and <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a> nodes.
          The 'Test-suite' root node can be considered a special kind of 'Test-set'.
        </p>
        
<p>
          'Test-suite', 'Test-set' and 'Test-case' nodes can be called from other places using a 'Test call'
          node. That way, tests that run only a subset of other tests can easily be created and
          managed. 'Test call' nodes are allowed everywhere, but should not be executed from
          within a 'Test-case' node because that would break the atomicity of a 'Test-case' from the
          report's point of view. A warning is issued if 'Test-case' execution is nested.
      </p>
     
    

      
<a name="usec_testcase_vars"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_testcase_vars">8.2.3</a></span>
</div>
<a href="contents.html#toc_usec_testcase_vars">Variables and special attributes</a>
</h5>
        
<a name="sec_N79232"></a>
          
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79232">8.2.3.1</a></span>
</div>
<a href="contents.html#toc_sec_N79232">'Default value'</a>
</h5>  
          
<p>
            As both 'Test-sets' and 'Test-case' can be called via a 'Test call' node they each have a
            set of default parameters similar to those of a <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a>. These will be bound on
            the secondary variable stack and can be overridden in the 'Test call' node.
          </p>
        
        
<a name="sec_N79263"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79263">8.2.3.2</a></span>
</div>
<a href="contents.html#toc_sec_N79263">'Variable definitions'</a>
</h5>
        
          
<p>
            A 'Test-case'
            has an additional set of variable bindings. These are
            direct bindings for the primary variable stack that will be defined during the execution
            of the 'Test-case' and cannot be overridden via a 'Test call' node or the command line
            parameter <a href="tech_execution.html#arg_variable" shape="rect"><code>-variable &lt;name&gt;=&lt;value&gt;</code></a>. Primary and secondary variable stack are described in
            <a href="user_variables.html#usec_var_lookup">section 6.1</a>.
          </p>
        
        
<a name="sec_N79294"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79294">8.2.3.3</a></span>
</div>
<a href="contents.html#toc_sec_N79294">'Characteristic variables'</a>
</h5>
        
          
<p>
            The list of 'Characteristic variables' is a set of names of variables that are part of
            the characteristics of the test for data-driven testing. Each execution of the
            'Test-case' with a different set of values for these variables is considered a separate
            test case. The expanded values of these variables are shown in the run-log and report
            for improved error analysis.
          </p>
        
        
<a name="sec_N79313"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79313">8.2.3.4</a></span>
</div>
<a href="contents.html#toc_sec_N79313">'Condition'</a>
</h5>
          
<p>
            Another useful attribute is the 'Condition' which is similar to the
            <a href="control.html#att_IfSequence_test" shape="rect">'Condition'</a> of an <a href="control.html#step_IfSequence" shape="rect">'If'</a> node. If the 'Condition' is not empty,
            the test will only be executed if the expression evaluates to true. Otherwise the test
            will be reported as skipped.
          </p>
        
        
<a name="sec_N79342"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79342">8.2.3.5</a></span>
</div>
<a href="contents.html#toc_sec_N79342">'Expected to fail if...'</a>
</h5>
          
<p>
            Sometimes a 'Test-case' is expected to fail for a certain period of time e.g. when it is
            created prior to the implementation of the respective feature or before a bug-fix is
            available in the SUT. The 'Expected to fail if...' attribute allows marking such 'Test-cases'
            so they are counted separately and don't influence the percentage error statistics.
          </p>
        
      
      


    

    
    

    
<a name="sec_N79370"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N79370">8.3</a></span>
</div>
<a href="contents.html#toc_sec_N79370">'Sequence' and 'Test-step' nodes</a>
</h4>
      
<p>
        The primary building block of a test are the <a href="sequences.html#step_BasicSequence" shape="rect">'Sequence'</a> and <a href="sequences.html#step_TestStep" shape="rect">'Test-step'</a> nodes
        which execute their child nodes one by one in the order as they appear. They are used
        to structure the child nodes of a 'Test-case'.
      </p>
      
<p>
        The difference between <a href="sequences.html#step_BasicSequence" shape="rect">'Sequence'</a> and <a href="sequences.html#step_TestStep" shape="rect">'Test-step'</a> nodes is that
        <a href="sequences.html#step_TestStep" shape="rect">'Test-step'</a> nodes will show up in the report whereas <a href="sequences.html#step_BasicSequence" shape="rect">'Sequences'</a> will not.
      </p>
    

    
    

    
<a name="usec_setup_cleanup"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_setup_cleanup">8.4</a></span>
</div>
<a href="contents.html#toc_usec_setup_cleanup">'Setup' and 'Cleanup' nodes</a>
</h4>
      
      
<p>
        Since it is in the nature of testing that tests may fail from time to time it is crucial
        to have structure elements that will help you set up a defined initial state for
        a test. 'Setup' and 'Cleanup' nodes are for simple cases and are inserted
        as child nodes of 'Test-case' nodes. However, in most cases 'Dependency' nodes, that contain
        'Setup' and 'Cleanup' nodes, will prove far more efficient.
      </p>
      
<p>
        'Test-case' nodes with well designed 'Setup' and 'Cleanup' nodes have
        the following properties important to successful testing:
      </p>
      
<ul>
        
<li>
          The 'Test-case' can be executed independently of previous test cases that may have
          failed.
        </li>
        
<li>
          'Test-case' nodes can be added at any position in 'Test-suite' and 'Test-set' nodes without
          influencing other 'Test-cases'
        </li>
        
<li>
          You can work on a 'Test-case' or just run it without having to execute previous
          'Test-cases' to get the SUT into the state required by your test.
        </li>
        
<li>
          You can execute any number of 'Test-case' nodes in case you do not want to run the
          whole 'Test-set' or 'Test-suite'.
        </li>
      
</ul>



      
<p>
        In the simplest case exactly the same initial condition is required by all the
        'Test-case' nodes of a 'Test-set'. This can be implemented via the following structure:
      </p>
      
      
<a name="fig_simple_setup_cleanup_suite"></a><a name="figure_8.2"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/setup_cleanup_suite.png" target="_blank"><img src="images/setup_cleanup_suite.png" alt="Test structure with simple Setup sequence and Cleanup sequence" width="296" height="178" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.2</a>:&nbsp;&nbsp;Test structure with simple 'Setup' and 'Cleanup'</td><td class="captionglue"></td>
</tr>
</table>
      
<p>
        In the run-log you can see that for each 'Test-case' node first the 'Setup' node and
        then the 'Cleanup' node is run:
      </p>
      
      
<a name="fig_simple_setup_cleanup_log"></a><a name="figure_8.3"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/setup_cleanup_log.png" target="_blank"><img src="images/setup_cleanup_log.png" alt="Test execution with simple Setup sequence and Cleanup sequence" width="316" height="226" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.3</a>:&nbsp;&nbsp;Test execution with simple 'Setup' and 'Cleanup'</td><td class="captionglue"></td>
</tr>
</table>
      
<p>
        In this simple example the cleanup is done in any case, even if the next test could be executed
        with the state the previous test left the SUT in. QF-Test provides a more
        comprehensive structure for setting up the SUT and handling cleanup much more efficiently,
        and even including error handling. This is explained in chapter <a href="#usec_dependencies">section 8.6</a>
        in detail.
      </p>

    
    
    

    
<a name="usec_procedures"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_procedures">8.5</a></span>
</div>
<a href="contents.html#toc_usec_procedures">'Procedures' and 'Packages'</a>
</h4>
      
<p>
        In a way, writing good tests is a little like programming. After
        mastering the initial steps, tests and source code alike tend to
        proliferate. Things work fine until some building block that was taken
        for granted changes. Without a proper structure, programs as well as
        tests tend to collapse back upon themselves at this point as the effort of
        adapting them to the new situation is greater than the one needed for
        recreating them from scratch.
      </p>
      
<p>
        The key to avoiding this kind of problem is reuse or avoidance of
        redundancy. Generating redundancy is one of the main dangers of
        relying too much on recording alone. To give an example, imagine you
        are recording various sequences to interact with the components in a
        dialog.  To keep these sequences independent of each other, you start
        each one by opening the dialog and finish it by closing the dialog
        again. This is good thinking, but it creates redundancy because
        multiple copies of the events needed to open and close the dialog are
        contained in these sequences. Imagine what happens if the SUT
        changes in a way that invalidates these sequences. Let's say a little
        confirmation window is suddenly shown before the dialog is actually
        closed. Now you need to go through the whole suite, locate all of the
        sequences that close the dialog and change them accommodate the
        confirmation window. Pure horror.
      </p>
      
<p>
        To stress the analogy again, this kind of programming style is called
        <em>Spaghetti Programming</em> and it leads to the same kind of
        maintenance problems. These can be avoided by collecting the identical
        pieces in one place and referring to them wherever they are
        needed. Then the modifications required to adapt to a change like the
        one described above are restricted to this place only.
     </p>
      
<a name="figure_8.4"></a><a name="figure_8.4"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/Procedures.png" target="_blank"><img src="images/Procedures.png" alt="Packages and Procedures" width="196" height="114" texscale=".66"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.4</a>:&nbsp;&nbsp;'Packages' and 'Procedures'</td><td class="captionglue"></td>
</tr>
</table>
      
<p>
        QF-Test comes with a set of nodes that help to achieve this kind of
        modularization, namely the <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a>, <a href="procedures.html#step_ProcedureCall" shape="rect">'Procedure call'</a> and
        <a href="procedures.html#step_Package" shape="rect">'Package'</a> nodes. A 'Procedure' is similar to a
        <a href="sequences.html#step_BasicSequence" shape="rect">'Sequence'</a> except that its <a href="procedures.html#att_Procedure_name" shape="rect">'Name'</a> attribute is
        a handle by which a 'Procedure call' node can refer to it.
        When a 'Procedure call' is executed, the 'Procedure' it refers to is
        looked up and execution continues there. Once the last child node of
        the 'Procedure' has finished, the 'Procedure call' has completed as
        well.
      </p>
      
<p>
        'Packages' are just a way to give even more structure to
        'Procedures'. A hierarchy of 'Packages' and 'Procedures', rooted at
        the special <a href="procedures.html#step_PackageRoot" shape="rect">'Procedures'</a> node, is used to group sets of
        'Procedures' with a common context together and to separate them from
        other 'Procedures' used in different areas.
      </p>
      
<p>
        A 'Procedure' that always does exactly the same, no matter where it is
        called from, is only marginally useful. To expand on the above
        example, let's say we want to extend the 'Procedure' that opens the
        dialog to also set some initial values in some of its fields. Of
        course we don't want to have these initial values hard-coded in the
        'Procedure' node, but want to specify them when we call the
        'Procedure' to get different values in different contexts. To that
        end, parameters can be defined for the 'Procedure'. When the
        'Procedure call' is executed, it specifies the actual values for these
        parameters during this run. How all of this works is explained in
        <a href="user_variables.html#usec_variables">Variables</a>. Also please
        take a look at the detailed explanation for the <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a> and
        <a href="procedures.html#step_ProcedureCall" shape="rect">'Procedure call'</a> nodes for a better understanding of how these
        complement each other.
      </p>
      
<p>
        A test-suite library with a set of commonly useful 'Procedures' is
        provided with QF-Test under the name <code>qfs.qft</code>. An entire
        chapter of the Tutorial is devoted to this library and <a href="user_distributed.html#usec_suitereference">section 23.1</a> explains how to include it in your
        test-suites.
      </p>
      

      
<a name="usec_localprocedures"></a>
        
<h5 class="header-container h5">
<div>
<span class="margin"><a name="new_N79770"></a><span class="note">3.1+</span></span><span class="numtitle"><a href="contents.html#toc_usec_localprocedures">8.5.1</a></span>
</div>
<a href="contents.html#toc_usec_localprocedures">Local 'Procedures' and 'Packages'</a>
</h5>
        
<p>
          If you work with several test-suite libraries you might face a
          situation,
          where you define reusable test-steps
          or sequences, which you only want to use within a dedicated
          test-suite. If you want to create such local 'Procedures', you can put
          a '_' as first sign of the procedure's name. This marks a 'Procedure'
          as test-suite local.
        </p>
        
<p>
          A call of a local 'Procedure' can only be inserted within the
          test-suite, where it is defined. You can use the same concept for
          local 'Packages'.
        </p>
      

      
      

      
<a name="usec_relativeprocedures"></a>
      
<h5 class="header-container h5">
<div>
<span class="margin"><a name="new_N79807"></a><span class="note">3.1+</span></span><span class="numtitle"><a href="contents.html#toc_usec_relativeprocedures">8.5.2</a></span>
</div>
<a href="contents.html#toc_usec_relativeprocedures">Relative 'Procedures'</a>
</h5>
      
<p>
        If you call 'Procedures' from other 'Procedures', it could be convenient
        not to specify the full procedure name all the time.
      </p>
      
<p>
        So called 'relative' procedure calls can only be added to a
        'Package', which has the 'Border for relative calls' (see <a href="procedures.html#att_Package_border" shape="rect">'Border for relative calls'</a>) attribute
        specified. The structure of that call follows the concept below:
      </p>
      
<a name="table_8.1"></a><a name="table_8.1"></a>
<table class="table" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3">
<table class="tdleft" border="1" cellspacing="0" cellpadding="5" texwidth="\linewidth">
          
<tr>
            
<th rowspan="1" colspan="1">Level</th>
            <th rowspan="1" colspan="1">Call</th>
          
</tr>
          
<tr>
            
<td rowspan="1" colspan="1">'Procedures' of the same level</td>
            <td rowspan="1" colspan="1">.<i>Name of 'Procedure'</i></td>
          
</tr>
          
<tr>
            
<td rowspan="1" colspan="1">'Procedures' one level higher</td>
            <td rowspan="1" colspan="1">..<i>Name of 'Procedure'</i></td>
          
</tr>
          
<tr>
            
<td rowspan="1" colspan="1">'Procedures' one level deeper</td>
            <td rowspan="1" colspan="1">.<i>Name of 'Package'</i>.<i>Name of 'Procedure'</i></td>
          
</tr>
        
</table>
</td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="tables.html#list-of-tables">Table&nbsp;8.1</a>:&nbsp;&nbsp;Relative procedure calls</td><td class="captionglue"></td>
</tr>
</table>
      
<p>
        As you can see each dot stands for one level. So calling a 'Procedure' two
        levels higher requires three dots (Current level also requires a dot.)
      </p>
    

      
      

      

      
<a name="usec_procedures_InsertProcCalls"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_procedures_InsertProcCalls">8.5.3</a></span>
</div>
<a href="contents.html#toc_usec_procedures_InsertProcCalls">Inserting 'Procedure call' nodes</a>
</h5>
        
<p>
          As you should organize your tests in separate test steps, which are
          ideally the same like QF-Test's procedures, QF-Test offers several ways to
          insert those 'Procedure call' nodes:
        </p>
        
<ol>
          
<li>Via the menu &raquo;<em>Insert</em>&laquo;-&raquo;<em>Procedures</em>&laquo;-&raquo;<em>ProcedureCall</em>&laquo;</li>
          
<li>Via right mouse click and selecting &raquo;<em>Insert node</em>&laquo;-&raquo;<em>Procedures</em>&laquo;-&raquo;<em>ProcedureCall</em>&laquo;</li>
          
<li>Copy a 'Procedure' node and insert it at the location of the
                                                          'Procedure call'
                                                          using the normal
                                                          Copy/Paste
                                                          actions</li>
          
<li>Via Drag&amp;Drop operation, i.e. dragging the 'Procedure' node to
                                                          its target node </li>
          
<li>Via the keyboard shortcut [Ctrl-A]</li>
          
<li>By converting a 'Sequence' or a 'Test-step' into a procedure,
              as described in <a href="#usec_procedure_transform">subsection 8.5.5</a>.
              Shortcut [Ctrl-Shift-P]</li>
        
</ol>
        
<p>
          This approach is also valid for inserting 'Dependency reference' nodes,
          except the keyboard shortcut.
        </p>
      

      
      

      
<a name="usec_procedures_Param"></a>
        
<h5 class="header-container h5">
<div>
<span class="margin"><a name="new_N80029"></a><span class="note">3.1+</span></span><span class="numtitle"><a href="contents.html#toc_usec_procedures_Param">8.5.4</a></span>
</div>
<a href="contents.html#toc_usec_procedures_Param">Parameterizing nodes</a>
</h5>
        
<p>
          You can create parameters for a 'Procedure', 'Dependency' or
          'Test-case' automatically via the menu
          &raquo;<em>Operations</em>&laquo;-&raquo;<em>Parameterize node</em>&laquo;.
        </p>
        
<p>
          The parameter details dialog allows you to define for which actions
          you want to create parameters, e.g. only text-inputs or check nodes.
        </p>
      

      
      

      
<a name="usec_procedure_transform"></a>
        
<h5 class="header-container h5">
<div>
<span class="margin"><a name="new_N80064"></a><span class="note">3.0+</span></span><span class="numtitle"><a href="contents.html#toc_usec_procedure_transform">8.5.5</a></span>
</div>
<a href="contents.html#toc_usec_procedure_transform">Transforming a 'Sequence' into a 'Procedure'</a>
</h5>
        
<p>
          This transformation is very useful for developing procedures immediately after recording!
          Under 'Extras' you can convert a recorded 'Sequence'
          node into a 'Procedure' and move that to the 'Procedures' node.
          </p>
        
<p>
<span class="margin"><a name="new_N80089"></a><span class="note">3.1+</span></span>
          If you transform a 'Sequence' under 'Test-cases' QF-Test automatically creates a 'Procedure' node and
          inserts a 'Procedure call' to the previous location of the transformed node.
        </p>
      

      

    
    

    
    

    
<a name="usec_dependencies"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_dependencies">8.6</a></span>
</div>
<a href="contents.html#toc_usec_dependencies">'Dependency' nodes</a>
</h4>
      
<p>
        
<span class="margin"><span class="note"><img src="../icons/video.png" width="32" height="32" border="0" alt="Video" title="Video"></span></span>
        Video: <a href="https://www.qfs.de/en/yt/dependencies-basics-50.html" class="videolink" target="_blank"> Dependencies</a>
      
</p>
      
<a name="sec_N80133"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N80133">8.6.1</a></span>
</div>
<a href="contents.html#toc_sec_N80133">Concept</a>
</h5>
        
<p>
          Dependencies are a powerful and optimized concept for handling pre- and post-conditions.
          They are indispensable when running tests in the QF-Test <a href="tech_daemon.html#sec_daemon">Daemon mode</a> mode.
          They basically work the following way:
         </p>
        
<ol>
          
<li>
            Set up a list of all dependencies required for the test-case.
          </li>
          
<li>
            Compare the list of dependencies needed for the current test-case with the list
            of dependencies of the test-case executed last.
          </li>
          
<li>
            Execute all 'Cleanup' nodes of the dependencies no longer part of the
            current dependencies list plus the ones where the values of
            <a href="#usec_dependency_special_variables">'Characteristic variables'</a> changed, including the
             'Cleanup' nodes of the 'Dependencies' based on them.
          </li>
          
<li>
            Execute <strong>all</strong> 'Setup' nodes of the current
            dependencies list.
          </li>
        
</ol>
        
<p>
          Test-cases as well as other dependencies can make use of <a href="dependencies.html#step_Dependency" shape="rect">'Dependency'</a> nodes placed in the
          <a href="procedures.html#step_Procedure" shape="rect">'Procedures'</a> section via <a href="dependencies.html#step_DependencyReference" shape="rect">'Dependency reference'</a> nodes. Therefore, 'Setup' and
          'Cleanup' nodes placed in a 'Dependency' node can be used by various test-cases
          - in contrast to those placed directly in 'Test-case' or 'Test-set' nodes.
        </p>
        
<p>
          In order to understand the concept of 'Dependency' nodes it might be helpful to have a
          look at how a manual tester would proceed: He would do the setup for the first
          test case and then run it. In case of errors he may want to run special
          error cleanup routines. After that he would first check the requirements of the second
          test case. <strong>Only then</strong> would he do any cleanup. And he would only clean up
          as much as is necessary. Next he would check that the SUT still meets <strong>all</strong>
          preconditions required by the next test case and if not execute the necessary steps.
          In case the previous test case failed badly he
          might need to clean up the SUT completely before being able to set up the initial condition for
          the second test case.
        </p>
        
<p>
          This is exactly what you can implement using QF-Test 'Dependencies'.
        </p>
        
<p>
          'Dependencies' give an answer to the disadvantages of the classical <a href="#usec_setup_cleanup">'Setup' and 'Cleanup' nodes</a>
          where 'Setup' nodes can only be nested by nesting test-sets and where
          'Cleanup' nodes will be executed in any case, both of which is not very
          efficient. Moreover, 'Dependency' nodes provide structure elements for handling
          errors and exceptions.
        </p>
        
<p>
           
           Quite a number of the provided sample test-suites make use of 'Dependencies', e.g.:
        </p>
        
<ul>
          
<li>
           The test-suite in the directory <code>doc/tutorial</code> named <code>dependencies.qft</code>.
           You will find a detailed description in the tutorial in chapter 16.
          </li>
          
<li>
           The test-suite in <code>demo/carconfig</code> named <code>carconfig_en.qft</code>,
           showing a realistic example.
          </li>
          
<li>
          
            The SWT demo test-suite named <code>swt_addressbook.qft</code>, with an example
            for SWT users
          </li>
          
<li>
            The test-suite in <code>demo/eclipse</code> named <code>eclipse.qft</code>,
            containing nested 'Dependencies'.
          </li>
          
<li>
            The data driver demo <code>datadriver.qft</code> in <code>doc/tutorial</code> also uses
            'Dependencies'.
          </li>
        
</ul>
        
<p>
          Single-stepping
          through these suites in the debugger, looking at the variable bindings and examining the
          run-logs should help you to familiarize yourself with this feature. Please take care
          to store modified test-suites in a project-related folder.
        </p>

      
      
<a name="sec_N80315"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N80315">8.6.2</a></span>
</div>
<a href="contents.html#toc_sec_N80315">Usage of 'Dependencies'</a>
</h5>

         
<p>
          You can define 'Dependencies' in two places:
        </p>
        
<ul>
          
<li>
            You can implement 'Dependency' nodes at the beginning of 'Test-suite', 'Test-set' or
            'Test-case' nodes. Additionally to their own 'Dependency'
            a 'Test-case' or 'Test-set' may inherit the 'Dependency' of its parent node.
          </li>
         
<li>
            'Dependencies' used by a number of 'Test-cases' or used as a basis for other
            'Dependencies' may be implemented just like a <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a> node and be
            placed in the <a href="procedures.html#step_PackageRoot" shape="rect">'Procedures'</a> section, e.g. in a <a href="procedures.html#step_Package" shape="rect">'Package'</a>
            node named "Dependencies". The fully qualified name has the same structure as that
            of a 'Procedure'. Just like <a href="procedures.html#step_Procedure" shape="rect">'Procedures'</a> 'Dependencies' can be referred
            to by other nodes, in this case via 'Dependency reference' nodes.
          </li>
        
</ul>
        
<p>
          One 'Dependency' should deal with one precondition. Then you can reduce the test overhead
          generated by cleanup activities. In case a 'Dependency' itself relies on preconditions
          these should be implemented in separate 'Dependency' nodes. 'Dependencies' can either
          be inherited from a parent node or referred to explicitly via 'Dependency reference'
          nodes.
        </p>
        
<p>
          The implementation of the actual pre- and post-conditions is done in the 'Setup'
          and 'Cleanup' nodes of the 'Dependency'.
        </p>
        
<p>
          In case a 'Test-set' or 'Test-case' node has a 'Dependency' node as well as
          'Setup' and 'Cleanup' nodes the 'Dependency' will be executed
          first. 'Setup' and 'Cleanup' nodes have no influence on the dependency
          stack.
        </p>
      

      
<a name="usec_dependency_stack"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_dependency_stack">8.6.3</a></span>
</div>
<a href="contents.html#toc_usec_dependency_stack">'Dependency' execution and 'Dependency' stack</a>
</h5>
        
<p>
          The execution of a 'Dependency' has three phases:
        </p>
        
<ol>
          
<li>
            Generate a list of required 'Dependencies' and check with list of previously executed 'Dependency' nodes
          </li>
          
<li>
            Execute 'Cleanup' nodes if required
          </li>
          
<li>
            Execute 'Setup' nodes of all required 'Dependency' nodes
          </li>
        
</ol>
        
<p>
          The examples used in this chapter all refer to tests with the following preconditions
          and cleanup activities:
        </p>
        
<dl>
          
<dt>Sample</dt>
          
<dd>
            
<dl>
              
<dt>'Dependency' A:</dt>
              
<dd>
                'Setup': start application if necessary<br>
                'Cleanup': stop application
              </dd>

              
<dt>'Dependency' B:</dt>
              
<dd>
                'Setup': log in user if necessary<br>
                'Cleanup': log off user
              </dd>

              
<dt>'Dependency' C:</dt>
              
<dd>
                'Setup': load application module 1 if necessary<br>
                'Cleanup': close application module 1
              </dd>

              
<dt>'Dependency' D:</dt>
              
<dd>
                'Setup': load application module 2 if necessary<br>
                'Cleanup': close application module 2
              </dd>

              
<dt>'Dependency' E:</dt>
              
<dd>
                'Setup': open dialog in module 2 if necessary<br>
                'Cleanup': close dialog
              </dd>
            
</dl>
          
</dd>
          
<dd>
            Dependency C depends on B, B in turn on A. <br>
            Dependency E depends on D, D on B therefore also on A.
          </dd>
        
</dl>
        
<p>
          Before executing a 'Test-case' node QF-Test checks whether it has a 'Dependency' node of
          its own and/or inherits one from its parent nodes. In that case QF-Test checks whether
          the 'Dependency' node itself relies on other dependencies. Based on this analysis
          QF-Test generates a list of the dependencies required. This is done in step 1 of the
          example below.
        </p>
        
<p>
          Next, QF-Test checks if previous tests have already executed dependencies. If so, QF-Test
          checks if it has to execute any 'Cleanup' nodes. After that QF-Test goes through
          all the setup nodes, starting with the most basic ones. The name of each 'Dependency'
          executed is noted down in a list called dependency stack. See step 2 of below example.
        </p>
        
<dl>
          
<dt>Example: Test-case 1</dt>
            
<dd>
              
<p>
               Test of application module 1. First test-case to be executed.
              </p>
              
<ol>
                
<li>step<br>
                  Analyze the dependencies: the dependencies A-B-C have to be executed.
                </li>
                
<li>step<br>
                  Compare the dependencies to be executed with the dependency stack:
                  In this example the dependency stack is
                  still empty as the test-case is the first one to be executed.
                </li>
                
<li>step<br>
                  Execute the 'Setup' nodes, starting with  A (start application), then B
                  (login user (user name: Standard)), and last C (load application module 1).<br>
                  The dependency stack now reads A-B-C.
                </li>
                
<li>step<br>
                  Execute the 'Test-case'.
                </li>
              
</ol>
            
</dd>
        
</dl>
        
<p>
          In the run-log you can see exactly what QF-Test did:
        </p>
        
        
<a name="fig_dependency_abc"></a><a name="figure_8.5"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_1.png" target="_blank"><img src="images/dependency_1.png" alt="Dependency stack A-B-C" width="409" height="226" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.5</a>:&nbsp;&nbsp;Dependency stack A-B-C</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          After executing the test-case the application remains in the condition the last test-case
          left it in. Only after analyzing the dependencies of the next test-case 'Cleanup'
          nodes might be run and the respective 'Dependency' be deleted from the dependency stack. When
          'Cleanup' nodes need to be run they are executed in reverse order to the
          'Setup' nodes. After maybe clearing up dependencies no longer needed the 'Setup'
          nodes of all required 'Dependencies' are executed. Just like a manual tester will check that
          all requirements for the next test-case are fulfilled QF-Test will do the same. A manual tester
          may not be conscious of checking the basic requirements. However, if he notices that the last
          test-case left the application in a very bad state like a deadlock, he will probably kill the
          process if nothing else helped and start it again. To this end QF-Test explicitly runs all
          'Setup' nodes. These should be implemented in a way that they first check if the
          application is already in the required state and just in case not run the whole
          'Setup' node.
        </p>
        
        
<a name="fig_dependency_setup"></a><a name="figure_8.6"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_setup.png" target="_blank"><img src="images/dependency_setup.png" alt="Good practice Setup sequence" width="414" height="130" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.6</a>:&nbsp;&nbsp;Good practice 'Setup' node</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
           'Setups' nodes should first check if the required condition already exists
           before actually executing the node. 'Cleanup' nodes should first check
           if the requested cleanup action (e.g. closing a dialog)
           has already been performed. Also they should be programmed in such a way
           that they are in grade of clearing up error states of the application
           (e.g. error messages) so that a failed test-case will not affect the following ones.
        </p>
          
<dl>
            
<dt>Example: test-case 2</dt>
            
<dd>
              
<p>Test a dialog in application module 2</p>
              
<ol>
                
<li>step: <br>
                    Analyze the dependencies: the dependencies A-B-D-E have to be executed.
                </li>
                
<li>step: <br>
                    Compare the list of dependencies to be executed with the dependency stack:
                    'Dependency' C is not required for test-case 2. Therefore 'Cleanup'
                    node of 'Dependency' C is executed (close application module 1).
                </li>
                
<li>step: <br>
                    Execute the 'Setup' nodes, starting with A (check the application is
                    already started and skip the rest of the setup), then B (check the user is already logged in,
                    and skip the rest of the setup), then D (check if application module 2 is loaded and as it is not
                    execute the complete 'Cleanup' node), then E (same as D).
                </li>
                
<li>
                  step: <br>
                  Execute the 'Test-case'.
                </li>
              
</ol>
           
</dd>
          
</dl>
        
<p>
          You can see in the run-log that the cleanup was done:
        </p>
        
        
<a name="fig_dependency_2"></a><a name="figure_8.7"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_2.png" target="_blank"><img src="images/dependency_2.png" alt="Dependency stack A-B-D-E" width="409" height="354" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.7</a>:&nbsp;&nbsp;Dependency stack A-B-D-E</td><td class="captionglue"></td>
</tr>
</table>
      

      
<a name="usec_dependency_special_variables"></a>
        
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_dependency_special_variables">8.6.4</a></span>
</div>
<a href="contents.html#toc_usec_dependency_special_variables">'Characteristic variables'</a>
</h5>

        
<p>
          Values of certain variables may determine whether a dependency has to be cleared up
          and the setup re-executed, like the user name for dependency B 'Login'. These variables
          are called 'Characteristic variables'. The values of the 'Characteristic variables' are always
          taken into account when comparing dependency stacks. Two 'Dependencies' on the stack
          are only considered identical if the values of all 'Characteristic variables' from the previous
          and the current run are equivalent. Consequently it is also possible for a 'Dependency' to
          directly or indirectly refer to the same base 'Dependency' with different values for its
          'Characteristic variables'. In that case the base 'Dependency' will appear multiple times in the
          linearized dependency stack.
        </p>
        
<p>
          Furthermore, QF-Test stores the values of the 'Characteristic variables' during execution of
          the 'Setup' of a 'Dependency'. When the 'Dependency' is rolled back, i.e. its
          'Cleanup' node is executed, QF-Test will ensure that these variables are bound to the
          same value as during execution of the 'Setup'. This ensures that a completely
          unrelated 'Test-case' with conflicting variable definitions can be executed without
          interfering with the execution of the 'Cleanup' nodes during 'Dependency'
          rollback. Consider for example the commonly used "client" variable for the name of an
          SUT client. If a set of tests for one SUT has been run and the next test will need a
          different SUT with a different name, the "client" variable will be changed. However, the
          'Cleanup' node for the previous SUT must still refer to the old value of
          "client", otherwise it wouldn't be able to terminate the SUT client. This is taken care
          of automatically as long as "client" was added to the list of 'Characteristic variables'.
        </p>
        
<dl>
          
<dt>Example: 'Test-case' 3:</dt>
          
<dd>
            Test of the same dialog for the user Administrator.
          </dd>
          
<ol>
            
<li>Step:<br>
              Analyze the dependencies: same list of dependencies A-B-D-E as in
              'Test-case' 2. However, the 'Characteristic variables' of 'Dependency' B has a
              different value, i.e. 'Administrator'.
            </li>
            
<li>Step:<br>
              Compare the dependency list with the dependency stack:
              The required 'Dependency' B differs from the 'Dependency' B saved on the
              dependency stack because of the values of the 'Characteristic variables' 'username',
              which is 'Standard' on the dependency stack. This means that the
              dependency stack will be rolled back including 'Dependency' B, starting
              with the 'Cleanup' for 'Dependency' E (close dialog), then
              'Cleanup' for 'Dependency' D (stop module 2), then 'Cleanup'
              for 'Dependency' B (log off user - the variable 'username' then has the
              value 'Standard' saved via the 'Characteristic variables' on the dependency stack).
            </li>
            
<li>Step:<br>
              Execute the 'Setup' nodes, starting with A (check the application is
              already started and skip the rest of the setup), then B (log in user
              'Administrator'), then D (load module 2), then E (open dialog).
            </li>
            
<li>Step:<br>
              Execute the 'Test-case'.
            </li>
          
</ol>
        
</dl>
        
<p>
          In the run-log you can see the values of the 'Characteristic variables' behind the
          respective 'Dependency':
        </p>
        
        
<a name="fig_dependency_3"></a><a name="figure_8.8"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_3.png" target="_blank"><img src="images/dependency_3.png" alt="Dependency mit characteristic variable" width="435" height="434" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.8</a>:&nbsp;&nbsp;'Dependency' with 'Characteristic variables'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          Other examples for 'Characteristic variables' are JDK versions when the SUT needs to
          be tested for various JDK versions or the browser name with web applications.
          In our example these would be specified as 'Characteristic variables' for 'Dependency' A.
       </p>
      

      
<a name="sec_N81014"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N81014">8.6.5</a></span>
</div>
<a href="contents.html#toc_sec_N81014">'Forced cleanup'</a>
</h5>

        
<p>
          In some use cases it may be necessary to execute the 'Cleanup' node of a
          'Dependency' after each 'Test-case'. Then you should set the attribute
          'Forced cleanup'.
        </p>
        
<p>
          If 'Forced cleanup' is activated for a 'Dependency' node on the list of dependencies
          the 'Cleanup' node of this and maybe of subsequent 'Dependencies' will
          be executed.
        </p>
        
<dl>
          
<dt>Example:</dt>
          
<dd>
          
<p>
            In this example the test logic requires module 2 to be stopped after test
            execution. The attribute 'Forced cleanup' is activated for 'Dependency' D.
          </p>
          
<p>
            In our example the 'Cleanup' nodes of 'Dependencies' E (close dialog) and
            D (stop modul) would be executed after each 'Test-case'.
          </p>
          
</dd>
         
</dl>
      

      
<a name="sec_N81082"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_sec_N81082">8.6.6</a></span>
</div>
<a href="contents.html#toc_sec_N81082">Rolling back 'Dependencies'</a>
</h5>

         
<p>
            QF-Test rolls back 'Dependencies' depending on the needs of the 'Test-cases'.
         </p>
         
<p>
            If you want to clear the list of dependencies explicitly there are two ways to do it:
         </p>
         
<ul>
           
<li>
             The menu item &raquo;<em>Run</em>&laquo;-&raquo;<em>Roll back dependencies</em>&laquo;   
             rolls back the list of dependencies 'cleanly' executing all the 'Cleanup'
             nodes in reverse order to the setup activities.
           </li>
           
<li>
              The menu item &raquo;<em>Run</em>&laquo;-&raquo;<em>Reset dependencies</em>&laquo;   
              just deletes the list of dependencies without executing any nodes.
           </li>
         
</ul>
         
<p>
           When a 'Test-case' does not use 'Dependencies' the list of dependencies remains
           untouched, i.e. no 'Cleanup' nodes are executed.
         </p>
      

      
<a name="usec_error_escalation"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_error_escalation">8.6.7</a></span>
</div>
<a href="contents.html#toc_usec_error_escalation">Error escalation</a>
</h5>
        
<p>
          Another thing that is just grand about 'Dependencies' is the convenient way that errors
          can be escalated without any additional effort. Let's again consider the example from the
          previous section after the first dependency stack has been initialized to A-B-C
          (Application started, user logged in, module one loaded) and
          the 'Setups' have been run. Now what happens if the SUT has a really bad fault,
          like going into a deadlock and not reacting to user input any longer?
        </p>
        
<p>
          When a 'Cleanup' node fails during rollback of the dependencies stack, QF-Test will
          roll back an additional 'Dependency' and another one if that fails again and so on until
          the stack has been cleared. Similarly, if one of the 'Setups' fails, an additional
          'Dependency' is rolled back and the execution of the 'Setups' started from
          scratch.
        </p>
        
<dl>
          
<dt>Example:</dt>
          
<dd>
            In the example 'Test-case' 1 above the SUT would for example get deadlocked.
            In 'Test-case' 1 an exception would be thrown, 'Test-case' 1 would be stopped
            and execution passed on to 'Test-case' 2.
          </dd>
          
<ol>
            
<li>
              Step:<br>
              Analyze the dependencies: the list of dependencies A-B-D-E has to be executed.
              (Application started, user logged in, module 2 loaded, dialog opened)
            </li>
            
<li>
              Step: <br>
              Comparing the dependency list with the dependency stack set up by 'Test-case' 1
              A-B-C (application started, user logged in, module 1 loaded) results in the
              execution of the 'Cleanup' node of  'Dependency' C (stop module 1).
              Of course, the exception is thrown again. Now QF-Test runs the 'Cleanup' node
              for the next 'Dependency' B (log off user). This will fail again so that now
              the basic 'Dependency' A will be rolled back, which successfully stops the application.
            </li>
            
<li>
              Step:<br>
              Execute the 'Setup' nodes, starting with A (start the application),
              then B (log in user), then D (load module 2), then E (open dialog).
            </li>
            
<li>
              Step:<br>
              'Test-case' 2 will be executed despite the deadlock in 'Test-case' 1.
            </li>
          
</ol>
        
</dl>

        
<a name="fig_dependency_escalation"></a><a name="figure_8.9"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_escalation.png" target="_blank"><img src="images/dependency_escalation.png" alt="Error escalation" width="352" height="178" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.9</a>:&nbsp;&nbsp;Exception in forced cleanup sequence of C causes B to clean up</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          For this to work it is very important to write 'Cleanup' sequences in a way that
          ensures that either the desired state is reached or that an exception is thrown and that
          there is a more basic dependency with a more encompassing 'Cleanup'. For example,
          if the 'Cleanup' node for the SUT 'Dependency' just tries to cleanly shut down
          the SUT through its File-&gt;Exit menu without exception handling and further safeguards,
          an exception in that sequence will prevent the SUT from being terminated and possibly
          interfere with all subsequent tests. Instead, the shutdown should be wrapped in a
          Try/Catch with a Finally node that checks that the SUT is really dead and if not, kills
          the process as a last resort.
        </p>
        
<a name="fig_dependency_cleanup"></a><a name="figure_8.10"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_cleanup.png" target="_blank"><img src="images/dependency_cleanup.png" alt="Typical cleanup node" width="447" height="178" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.10</a>:&nbsp;&nbsp;Typical 'Cleanup' node</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          With good error handling in place, 'Test-cases' will rarely interfere with each other
          even in case of really bad errors. This helps avoid losing a whole night's worth of
          test-runs just because of a single error.
        </p>
      


    
<a name="usec_dependency_error_handling"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_dependency_error_handling">8.6.8</a></span>
</div>
<a href="contents.html#toc_usec_dependency_error_handling">Error handling</a>
</h5>
      
<p>
        Besides supporting automatic escalation of errors a 'Dependency' can also act as an error
        or exception handler for the tests that depend on it. 'Catch' nodes, which can be
        placed at the end of a 'Dependency', are used to catch and handle exceptions thrown during
        a test. Exceptions thus caught will still be reported as exceptions in the run-log and the
        report, but they will not interfere with subsequent tests or even abort the whole
        test-run.
      </p>
      
<p>
        An 'Error handler' node is another special node that may be added to a 'Dependency' after
        the 'Cleanup' and before the 'Catch' nodes. It will be executed whenever
        the result of a 'Test-case' is "error". In case of an exception, the 'Error handler' node
        is not executed automatically because that might only cause more problems and even
        interfere with the exception handling, depending on the kind of exception. To do similar
        things for errors and exception, implement the actual handler as a 'Procedure' and call
        it from the 'Error handler' and the 'Catch' node. 'Error handlers' are useful for
        capturing and saving miscellaneous states that are not automatically provided by QF-Test.
        For example, you may want to create copies of temporary files created during execution
        of your SUT that may hold information pertaining to the error.
      </p>
      
      
<p>
        Only the topmost 'Error handler' that is found on the dependency stack is executed, i.e. if
        in a dependency stack of [A,B,C,D] both A and C have 'Error handlers', only C's
        'Error handler' is run. Otherwise it would be difficult to modify the error handling of the
        more basic 'Dependency' A in the more specialized 'Dependency' C. To reuse A's error
        handling code in C, implement it as a 'Procedure'.
      </p>
    
      
<a name="usec_dependency_namespaces"></a>
      
<h5 class="header-container h5">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_dependency_namespaces">8.6.9</a></span>
</div>
<a href="contents.html#toc_usec_dependency_namespaces">Name spaces for Dependencies</a>
</h5>
        
<p>
          
<span class="margin"><span class="note">Note</span></span> You might be interested in reading this section in case you want to run
          several SUTs at the same time where you do not want the 'Dependency' node for a test
          on one of the SUTs to trigger cleanup actions for another SUT. Otherwise feel free to
          skip it.
        </p>
        
<p>
          A typical use case would be the test of whole process chains over several applications.
        </p>
        
<p>
          Consider the following situation: Sales representatives enter data for offers via a web
          application into a database at headquarters. There, the offers will be
          completed, printed and posted. A copy of each printed offer will be saved in a
          document management system (DMS).
        </p>
           
          
<a name="fig_dependency_namespaces_testcase"></a><a name="figure_8.11"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_testcase.png" target="_blank"><img src="images/dependency_namespaces_testcase.png" alt="Example test-set for name spaces" width="489" height="306" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.11</a>:&nbsp;&nbsp;Example 'Test-set' for name spaces</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          In above example two sales representatives (UserA and UserB) enter offers and two
          different persons (UserC and UserD) process the offers at headquarters. Then the
          offers will be checked in the document management system. Since you do not want
          the dependencies of the test-cases to interfere with one another you need to
          add a suitable name in the <a href="dependencies.html#att_DependencyReference_namespace" shape="rect">'Dependency namespace'</a> attribute of each
          'Dependency reference' node.
        </p>
        
<p>
          After running the test-set you can see in the run-log that a dependencies stack was
          set up in the name space 'data entry' for the first test-case:
        </p>
           
          
<a name="fig_dependency_namespaces_log1"></a><a name="figure_8.12"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log1.png" target="_blank"><img src="images/dependency_namespaces_log1.png" alt="Dependency handling for test-case 'Data entry by User A'" width="686" height="130" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.12</a>:&nbsp;&nbsp;Dependency handling for test-case 'Data entry by User A'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          A dependencies stack is set up in the name space 'database' for the second test-case.
          The dependencies stack in the name space 'data entry' remains unheeded.
          Looking at the applications, this means the database is started whereas the
          application for data entry is left as it is.
        </p>
           
          
<a name="fig_dependency_namespaces_log2"></a><a name="figure_8.13"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log2.png" target="_blank"><img src="images/dependency_namespaces_log2.png" alt="Dependency handling for test-case 'Offer processing by User C'" width="586" height="130" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.13</a>:&nbsp;&nbsp;Dependency handling for test-case 'Offer processing by User C'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          A dependencies stack is set up in the name space 'DMS' for the third test-case.
          The dependencies stacks in the name spaces 'data entry' and 'database' remain unheeded.
          Looking at the applications, this means the document management system is started whereas the
          other two applications are left as they are.
        </p>
           
          
<a name="fig_dependency_namespaces_log3"></a><a name="figure_8.14"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log3.png" target="_blank"><img src="images/dependency_namespaces_log3.png" alt="Dependency handling for test-case 'Check offer 1 in DMS'" width="688" height="98" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.14</a>:&nbsp;&nbsp;Dependency handling for test-case 'Check offer 1 in DMS'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          In test-case number four the required dependencies are checked against the ones on the
          dependencies stack in the name space 'data entry' of the first test-case.
          The dependencies stacks in the other two name spaces remain unheeded.
          Looking at the applications, this means User A is logged off, User B is logged into the
          data entry application and the other two applications are left as they are.
        </p>
           
          
<a name="fig_dependency_namespaces_log4"></a><a name="figure_8.15"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log4.png" target="_blank"><img src="images/dependency_namespaces_log4.png" alt="Dependency handling for test-case 'Data entry by User B'" width="700" height="178" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.15</a>:&nbsp;&nbsp;Dependency handling for test-case 'Data entry by User B'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          In test-case number five the required dependencies are checked against the ones on the
          dependencies stack in the name space 'database' of the second test-case.
          The dependencies stacks in the other two name spaces remain unheeded.
          Looking at the applications, this means User C is logged off, User D is logged into the
          database application and again the other two applications are left as they are.
        </p>
           
          
<a name="fig_dependency_namespaces_log5"></a><a name="figure_8.16"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log5.png" target="_blank"><img src="images/dependency_namespaces_log5.png" alt="Dependency handling for test-case 'Offer processing by User D'" width="586" height="162" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.16</a>:&nbsp;&nbsp;Dependency handling for test-case 'Offer processing by User D'</td><td class="captionglue"></td>
</tr>
</table>
        
<p>
          In the last test-case the required dependencies are checked against the ones on the
          dependencies stack in the name space 'DMS' of the third test-case.
          The dependencies stacks in the other two name spaces remain unheeded.
          Looking at the applications, this means no clean up action has to be done on the
          DMS. The other two applications are left as they are, anyway.
        </p>
           
          
<a name="fig_dependency_namespaces_log6"></a><a name="figure_8.17"></a>
<table class="figure" cellspacing="0">
<tr>
<td class="margin">
<table class="margin"></table>
</td><td align="center" colspan="3"><a href="images/dependency_namespaces_log6.png" target="_blank"><img src="images/dependency_namespaces_log6.png" alt="Dependency handling for test-case 'Check offer 2 in DMS'" width="688" height="114" texscale="1"></a></td>
</tr>
<tr>
<td class="margin">
<table class="margin"></table>
</td><td class="captionglue"></td><td class="caption"><a href="figures.html#list-of-figures">Figure&nbsp;8.17</a>:&nbsp;&nbsp;Dependency handling for test-case 'Check offer 2 in DMS'</td><td class="captionglue"></td>
</tr>
</table>
      
    
    
    

    
<a name="usec_documentation"></a>
      
<h4 class="header-container h4">
<div>
<span class="numtitle"><a href="contents.html#toc_usec_documentation">8.7</a></span>
</div>
<a href="contents.html#toc_usec_documentation">Documenting test-suites</a>
</h4>
      
<p>
        Like with any programming-related task it is important for successful test-automation to
        properly document your efforts. Otherwise there is a good chance (some might say a
        certainty) that you will lose the overview over what you have done so far and start
        re-implementing things or miss out tests that should have been automated. Proper
        documentation will be invaluable when working through a run-log, trying to understand the
        cause of a failed test. It will also greatly improve the readability of test reports.
      </p>
      
<p>
        An easy option for readable and documented tests is to group the recorded nodes into
        <a href="sequences.html#step_BasicSequence" shape="rect">'Sequence'</a> und <a href="sequences.html#step_TestStep" shape="rect">'Test-step'</a> nodes.
      </p>
      
<p>
        For inline documentation you can use the <a href="miscnodes.html#step_CommentStep" shape="rect">'Comment'</a> node.
      </p>
      
<p>
        When you want to set up a documentation available outside QF-Test you can do so
        based on the <a href="sequences.html#att_TestSet_comment" shape="rect">'Comment'</a> attributes of <a href="sequences.html#step_TestSet" shape="rect">'Test-set'</a>, <a href="sequences.html#step_TestCase" shape="rect">'Test-case'</a>,
        <a href="procedures.html#step_Package" shape="rect">'Package'</a> and <a href="procedures.html#step_Procedure" shape="rect">'Procedure'</a> nodes, and create a set of comprehensive HTML
        documents that will make all required information readily available. The various kinds of
        documents and the methods to create them are explained in detail in <a href="user_report.html#usec_report">chapter 21</a>.
      </p>
    

    
  
<table width="100%" border="0" cellspacing="0" cellpadding="0" class="navifooter">
<tr>
<td class="margin"></td><td class="navicon"><a href="manual.html"><img src="../icons/linktop.png" width="34" height="36" border="0" alt="Top" title="Top"></a></td><td class="navicon"><a href="contents.html#table-of-contents"><img src="../icons/linktoc.png" width="34" height="36" border="0" alt="Table of contents" title="Table of contents"></a></td><td class="navicon"><a href="user_debugging.html#usec_debugging"><img src="../icons/linkprev.png" width="34" height="36" border="0" alt="Previous Chapter: 7&nbsp;Problem analysis and debugging" title="Previous Chapter: 7&nbsp;Problem analysis and debugging"></a></td><td class="navicon"><a href="projects.html#usec_projects"><img src="../icons/linkcont.png" width="34" height="36" border="0" alt="Next Page: 9&nbsp;Projects" title="Next Page: 9&nbsp;Projects"></a></td><td class="navicon"><a href="projects.html#usec_projects"><img src="../icons/linknext.png" width="34" height="36" border="0" alt="Next Chapter: 9&nbsp;Projects" title="Next Chapter: 9&nbsp;Projects"></a></td><td class="navicon"><a href="user.html#sec_user"><img src="../icons/linkup.png" width="34" height="36" border="0" alt="Chapter Overview: I&nbsp;User manual" title="Chapter Overview: I&nbsp;User manual"></a></td><td class="navicon"><a href="../../manual_en.pdf" target="_parent"><img src="../icons/linkpdf.png" width="34" height="36" border="0" alt="PDF version" title="PDF version"></a></td><td class="navcopymod">Last update: 9/6/2022<br>Copyright &copy; 1999-2022 Quality First Software GmbH</td>
</tr>
</table>
</body>
</html>
