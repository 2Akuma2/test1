<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE RootStep>
<RootStep id="_0" name="root"
          signature="302C02146E16855791C924CF373240E842E68719B6A35D6E021402F0DBA16E47ADC05B82FCBB0BCB26DA57139910"
          version="6.0.3">
  <comment>This suite contains useful standard procedures provided and maintained by Quality First Software GmbH.

For a description of packages and procedures of this library in javadoc format, see qfs.html in the same directory.</comment>
  <PackageRoot id="_1">
    <Package id="_2" name="qfs">
      <comment>This package contains helpful standard procedures provided by Quality First Software.

&lt;strong&gt;The "SUT client" name is used in many of the contained procedures represented by the "$(client)" variable. We recommend to define the variable "client" in the respective table of the test-suite's root node - as long as only one SUT client is used in the test-suite. This ensures that the "client" parameter doesn't have to be given separately.&lt;/strong&gt;

@author	QFS
@since	1.05.0</comment>
      <Package id="_2YNn" name="android">
        <comment>Contains procedures to test android applications as well as useful procedures for remote controlling android devices.

@author	QFS
@since	5.4</comment>
        <Package id="_2YR1" name="adbUtils">
          <comment>Procedures using the Android-Debug-Bridge (adb).

@author	QFS
@since	5.4</comment>
          <Package id="_2YRc" name="appControl">
            <comment>Procedures for controlling android apps.

@author	QFS
@since	5.4</comment>
            <Procedure id="_2YSm" name="resetCurrentApp">
              <comment>Reset all data and permissons from an app and restart it.

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YSn" local="true"
                             procedure="..appPackage.getCurrentPackage"
                             retvarname="pack"/>
              <ProcedureCall id="_2YRZ" postdelay="500"
                             procedure="..appControl.stopApp">
                <variable name="packageName">$(pack)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2YRY"
                             procedure="..appSettings.resetClearData">
                <variable name="packageName">$(pack)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2YRb" predelay="500"
                             procedure="..appControl.startApp">
                <variable name="packageName">$(pack)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2YSk" name="startApp">
              <variable name="packageName"/>
              <comment>Start an Android app on an already running device. 

@param packageName        The package name of the Android app to be launched.

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YSl" procedure="..runAdbCommand">
                <variable name="command">shell monkey -p $(packageName) 1</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2YRW" name="stopApp">
              <variable name="packageName"/>
              <comment>Stop a running Android app. 

@param packageName        The package name of the Android app to be stopped.

@author	QFS
@since	5.4
</comment>
              <ProcedureCall id="_2YRX" procedure="..runAdbCommand">
                <variable name="command">shell am force-stop $(packageName)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_2YSo" name="appPackage">
            <comment>Procedures to read out the package name of an android application.

@author	QFS
@since	5.4</comment>
            <Procedure id="_2YSq" name="getCurrentPackage">
              <comment>Get the package name from the currently open app.

@return  the name of the package

@author	QFS
@since	5.4
</comment>
              <ProcedureCall id="_2YSr" local="true"
                             procedure="qfs.android.adbUtils.runAdbCommand"
                             retvarname="mCurrentFocus">
                <variable name="command">shell dumpsys window | grep -E mCurrentFocus</variable>
              </ProcedureCall>
              <ServerScriptStep id="_2YRK" interpreter="groovy">
                <code>import java.io.File;import java.io.File;
import java.io.IOException;import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;import java.net.URISyntaxException;
import de.qfs.apps.qftest.shared.android.apk.AndroidApkAnalyzer;

currentFocus = rc.lookup("mCurrentFocus")
print(currentFocus)
String[] focusArray = currentFocus.split("\\s+");
packageName =focusArray[3].substring(0,focusArray[3].indexOf("/"))

//print(packageName)
throw new ReturnException(packageName)

</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="_2YRA" name="getPackage">
              <variable name="apkPath"/>
              <comment>Get the package name out of an apk file

@param	apkPath     apk path 

@author	QFS
@since	5.4</comment>
              <ServerScriptStep id="_2YSp" interpreter="groovy">
                <code>import java.io.File;import java.io.File;
import java.io.IOException;import java.io.IOException;
import java.net.URI;import java.net.URI;
import java.net.URISyntaxException;import java.net.URISyntaxException;
import de.qfs.apps.qftest.shared.android.apk.AndroidApkAnalyzer;

path = rc.lookup("apkPath")

File apkFile = new File(path);
AndroidApkAnalyzer apkAnalyzer = new AndroidApkAnalyzer(apkFile);
throw new ReturnException(apkAnalyzer.getPackage())

</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
          <Package id="_2YO5" name="appSettings">
            <comment>Procedures for changing android apps settings.

@author	QFS
@since	5.4</comment>
            <Procedure id="_2YSt" name="grantPermissions">
              <variable name="packageName"/>
              <variable name="permission"/>
              <comment>Grant a permission from an app.

@param	packageName	package name
@param	permission android permisson

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YOJ"
                             procedure="qfs.android.adbUtils.runAdbCommand">
                <variable name="command">shell pm grant $(packageName) $(permission)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2YR3" name="resetClearData">
              <variable name="packageName"/>
              <comment>Deletes all data from an app.

@param	packageName	package name 

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YR5"
                             procedure="qfs.android.adbUtils.runAdbCommand">
                <variable name="command">shell pm clear $(packageName)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2YO8" name="revokePermissions">
              <variable name="packageName"/>
              <variable name="permission"/>
              <comment>Revoke a permission from an app.

@param	packageName	package name
@param	permission android permisson

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YOK"
                             procedure="qfs.android.adbUtils.runAdbCommand">
                <variable name="command">shell pm revoke $(packageName) $(permission)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_2YR2" name="dataTransfer">
            <comment>Procedures for transfering data from a computer to an android device and vica versa

@author	QFS
@since	5.4</comment>
            <Procedure id="_2YSu" name="pull">
              <variable name="filePath"/>
              <variable name="targetPath"/>
              <comment>Copy a file or folder from the android device to the local system.

@param	filePath	Source path where the file is stored.
@param 	targetPath	Target path where to copy the file

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YO3"
                             procedure="qfs.android.adbUtils.runAdbCommand">
                <variable name="command">pull $(filePath) $(targetPath)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2YSw" name="push">
              <variable name="filePath"/>
              <variable name="targetPath"/>
              <comment>Copy a file or folder from the local system to the android device.

@param	filePath	Source path where the file is stored.
@param 	targetPath	Target path where to copy the file

@author	QFS
@since	5.4</comment>
              <ProcedureCall id="_2YSy"
                             procedure="qfs.android.adbUtils.runAdbCommand">
                <variable name="command">"push" $(filePath) $(targetPath)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_2KFa" name="getAdbPath">
            <comment>Get the path to the adb binary.

@return	The path to the adb binary.
@author	QFS
@since	5.4</comment>
            <ServerScriptStep id="_2JlM" interpreter="groovy">
              <code>import de.qfs.apps.qftest.shared.android.adb.AdbLocator
def location = AdbLocator.instance().locate()
throw new ReturnException(location.getAbsolutePath())</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2YNv" name="runAdbCommand">
            <variable name="command"/>
            <variable name="retWithoutNewline">false</variable>
            <variable name="addDeviceName">true</variable>
            <comment>Copy a file or folder from the local system to the android device.

@param	command 		the adb command to execute
@param	retWithoutNewline	if the return value should cut "\n" default:false
@param	addDeviceName	Try to add the deviceName to the adb shell command.

@return 	The stdout/stderr output of the program.

@author	QFS
@since	5.4</comment>
            <ProcedureCall id="_2YNw" local="true"
                           procedure="qfs.android.adbUtils.getAdbPath"
                           retvarname="adbPath"/>
            <SetGlobalStep id="_2YNx" local="true" varname="adb">
              <default>$[rc.lookup("adbPath").replace("\\", "/") ]</default>
            </SetGlobalStep>
            <IfSequence id="_2YdR"
                        test="rc.getBool(&#34;addDeviceName&#34;) and rc.lookup(&#34;default&#34;, &#34;client:&#34;) != &#34;&#34;">
              <TryStep id="_2Ydo">
                <ClientScriptStep client="$(client)" engine="android"
                                  id="_2YdQ">
                  <code>device = rc.getEngine().getPlayer().getAdbDevice()
deviceName = device.getDeviceName()
rc.setLocal("deviceName", deviceName)</code>
                </ClientScriptStep>
                <CatchSequence exception="ClientNotConnectedException"
                               id="_2Ydp" maxerror="0"/>
                <CatchSequence exception="DeadlockTimeoutException" id="_2Ye2"
                               maxerror="0"/>
              </TryStep>
            </IfSequence>
            <IfSequence id="_2YdN"
                        test="rc.lookup(&#34;default&#34;, &#34;deviceName:&#34;) == &#34;&#34;">
              <ProcedureCall id="_2YdP" local="true"
                             procedure="qfs.shellutils.exec"
                             retvarname="output">
                <variable name="cmd">"$(adb)" $(command)</variable>
                <variable name="expectedExitCode">0</variable>
                <variable name="errorLvl">WARNING</variable>
              </ProcedureCall>
              <ElseSequence id="_2YdO">
                <ProcedureCall id="_2YNz" local="true"
                               procedure="qfs.shellutils.exec"
                               retvarname="output">
                  <variable name="cmd">"$(adb)" -s "$(deviceName)" $(command)</variable>
                  <variable name="expectedExitCode">0</variable>
                  <variable name="errorLvl">WARNING</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
            <ServerScriptStep id="_2YdD">
              <code>output = rc.lookup("output", expand=false)
if rc.getBool("retWithoutNewline"):
    while output and output[-1] in ["\r", "\n"]:
        output = output[:-1]

raise ReturnException(output)</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1oPC" name="checkbox">
          <comment>Procedures to set the state of checkboxes.

@author	QFS
@since	5.4

</comment>
          <Procedure id="_2YSz" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.


@param	id	The id of the checkbox.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YS+">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YS-"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2YT0"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YT1" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YT2" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YT3">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YT4"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2YT5"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YT6" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YT7" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.
@return  The state of the checkbox.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YT8">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YT9"
                                raise="true" timeout="0"/>
              <ReturnStep id="_2YTA" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_2YTB"
                             maxerror="0">
                <ReturnStep id="_2YTC" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YTD" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.


@param	id	The id of the checkbox.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YTE">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YTF"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2K1T"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YTG" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YTH" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YTI">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YTJ"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2YTK"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YTL" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YTM" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.


@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2YTN" test="$(check)">
              <ProcedureCall id="_2YTO" procedure=".select">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ElseSequence id="_2YTP">
                <ProcedureCall id="_2YTQ" procedure=".deselect">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2YTR" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.


@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2YTS" test="$(check)">
              <ProcedureCall id="_2YTT" procedure=".selectWithCoordinates">
                <variable name="id">$(id)</variable>
                <variable name="x">$(x)</variable>
                <variable name="y">$(y)</variable>
              </ProcedureCall>
              <ElseSequence id="_2YTU">
                <ProcedureCall id="_2YTV"
                               procedure=".deselectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_2YUK" name="device">
          <comment>Contains procedures to remote control android devices.

@author	QFS
@since	5.4</comment>
          <Package id="_2Ycv" name="gesture">
            <comment>Procedures for android gestures like pinch, swipe, ...

@author	QFS
@since	5.4</comment>
            <Procedure id="_2Ycw" name="pinch">
              <variable name="finger1X"/>
              <variable name="finger1Y"/>
              <variable name="finger2X"/>
              <variable name="finger2Y"/>
              <comment>Perform a two finger pinch action.

@param finger1X	position X of the first finger
@param finger1Y	position Y of the first finger
@param finger2X	position X of the second finger
@param finger2Y	position Y of the second finger

@author	QFS
@since	5.4</comment>
              <SelectionEventStep client="$(client)"
                                  component="genericAndroidApp"
                                  detail="pinch: $(finger1X) $(finger1Y) $(finger2X) $(finger2Y)"
                                  event="SELECTION" id="_2Yd0"/>
            </Procedure>
            <Procedure id="_2Ycz" name="zoom">
              <variable name="startX"/>
              <variable name="startY"/>
              <variable name="range"/>
              <variable name="angle"/>
              <comment>Perform a two finger zoom action.

@param startX	position X of the start point	
@param startY		position Y of the start point	
@param range	moving range
@param angle		moving angle  0 = horizontal

@author	QFS
@since	5.4</comment>
              <SelectionEventStep client="$(client)"
                                  component="genericAndroidApp"
                                  detail="zoom: $(startX) $(startY) $(range) $(angle)"
                                  event="SELECTION" id="_2Yc-"/>
            </Procedure>
          </Package>
          <Procedure id="_2YUL" name="appSwitch">
            <comment>Select the app switch button on the device.

@author	QFS
@since	5.4</comment>
            <SelectionEventStep client="$(client)"
                                component="genericAndroidApp"
                                detail="APP_SWITCH" event="SELECTION"
                                id="_2YUM"/>
          </Procedure>
          <Procedure id="_2YUN" name="back">
            <comment>Select the back button on the device.

@author	QFS
@since	5.4</comment>
            <SelectionEventStep client="$(client)"
                                component="genericAndroidApp" detail="BACK"
                                event="SELECTION" id="_2YUO"/>
          </Procedure>
          <Procedure id="_2YdJ" name="closeKeyboard">
            <comment>Close a maybe opened keyboard window.

@author	QFS
@since	5.4.1</comment>
            <ComponentWaiter client="$(client)"
                             component="genericAndroidInputApp" id="_2Jb1"
                             local="true" raise="false" resvarname="keyboard"
                             timeout="1"/>
            <IfSequence id="_2Jb0" test="$(keyboard)">
              <SelectionEventStep client="$(client)"
                                  component="genericAndroidInputApp"
                                  detail="BACK" event="SELECTION" id="_2Jax"/>
              <ComponentWaiter absence="true" client="$(client)"
                               component="genericAndroidInputApp" id="_2YdK"
                               local="true" raise="false"
                               resvarname="keyboard" timeout="1000"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2Yd1" name="getRotation">
            <comment>Get the rotation of the device.

@return 	direction in degree as string
	0, 90, 180, 270


@author	QFS
@since	5.4
</comment>
            <ProcedureCall id="_2Yd3" local="true"
                           procedure="qfs.android.adbUtils.runAdbCommand"
                           retvarname="output">
              <variable name="command">shell settings get system user_rotation</variable>
              <variable name="retWithoutNewline">true</variable>
            </ProcedureCall>
            <ServerScriptStep id="_2Yd6">
              <code>output = rc.lookup("output", expand=false)

if output == "1":
    output = "90"
elif output == "2":
    output = "180"
elif output == "3":
    output = "270"
   

raise ReturnException(output)
        
        
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2KFW" name="home">
            <comment>Select the home button on the device.

@author	QFS
@since	5.4</comment>
            <SelectionEventStep client="$(client)"
                                component="genericAndroidApp" detail="HOME"
                                event="SELECTION" id="_2Jla"/>
          </Procedure>
          <Procedure id="_2YNt" name="setRotation">
            <variable name="rotation"/>
            <comment>Set the rotation of the device.

@param rotation	The rotation in degree 
		valid values: 0,90,180,270
		0 = reset to the default position 

@author	QFS
@since	5.4
</comment>
            <SelectionEventStep client="$(client)"
                                component="genericAndroidApp"
                                detail="rotate: $(rotation) "
                                event="SELECTION" id="_2YNu"/>
          </Procedure>
          <Procedure id="_2KFY" name="syncTime">
            <variable name="timestamp"/>
            <comment>Sync the time of the android device with the current machine or a given timestamp.

@param	timestamp	Optional timestamp, empty to use the current time of the host system, otherwise data in the form MMDDhhmm[[CC]YY][.ss]

@author	QFS
@since	5.4</comment>
            <ProcedureCall id="_2KFb" local="true"
                           procedure="qfs.android.adbUtils.getAdbPath"
                           retvarname="adbPath"/>
            <SetGlobalStep id="_2YUR" local="true" varname="adb">
              <default>$[rc.lookup("adbPath").replace("\\", "/") ]</default>
            </SetGlobalStep>
            <CommentStep id="_2KFe">
              <heading>TODO: Add device name</heading>
            </CommentStep>
            <IfSequence id="_2YUS" name="set current time"
                        test="'$(timestamp)' == ''">
              <ProcedureCall id="_2KFh" local="true"
                             procedure="qfs.utils.getTime" retvarname="ts">
                <variable name="format">MMddHHmmyyyy.ss</variable>
              </ProcedureCall>
              <ProcedureCall id="_2KFf" procedure="qfs.shellutils.exec">
                <variable name="cmd">"$(adb)" shell "su 0 date $(ts)"</variable>
                <variable name="timeout">5000</variable>
                <variable name="expectedExitCode">0</variable>
                <variable name="errorLvl">WARNING</variable>
                <variable name="exitCodeVar"/>
              </ProcedureCall>
              <ElseSequence id="_2YNW" name="set timestamp ">
                <ProcedureCall id="_2YNX" procedure="qfs.shellutils.exec">
                  <variable name="cmd">"$(adb)" shell "su 0 date $(timestamp)"</variable>
                  <variable name="timeout">5000</variable>
                  <variable name="expectedExitCode">0</variable>
                  <variable name="errorLvl">WARNING</variable>
                  <variable name="exitCodeVar"/>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_2YUT" name="general">
          <comment>Procedures which work for any Android component.

@author	QFS
@since	5.4

</comment>
          <Procedure id="_2YUU" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2YUV" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_2YUW" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2YUX" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	id	The Id of the target-component.
@param	click	If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 16 for right mouse. 4 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2YUY" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_2YUZ"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2YUc" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.


@param	id		The Id of the target-component.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_2YUd" modifiers="16"/>
          </Procedure>
          <Procedure id="_2YUe" name="doLongClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Long click on a given component.


@param	id		The Id of the target-component.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_2YUf" modifiers="4"/>
          </Procedure>
          <Procedure id="_2YUg" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	id	The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 16 for right mouse. 4 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_2YUh"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2YUt" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.


@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YUu"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_2YUv" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.


@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_2YUw" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_2YUx" name="list">
          <comment>Procedures for accessing lists.


@author	QFS
@since	5.4</comment>
          <Package id="_2YUy" name="checks">
            <comment>Procedures for checking a list.

@author QFS
@since 5.4</comment>
            <Procedure id="_2YUz" name="checkNumberOfItems">
              <variable name="id">${id:listid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of items of a given list according to a specified comparison mode.

Sample usage:
You can check, that a list has exactly 6 items or that the table has less then 10 items.

@param	id 		The id of the list.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of items.
			&lt;, if the compareValue should be greater than the actual amount of items.
			&gt;, if the compareValue should be less than the actual amount of items.
			&lt;=, if the compareValue should be greater or equal than the actual amount of items.
			&gt;=, if the compareValue should be less or equal the actual amount of items.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2YU+" local="true"
                             procedure="..getItemCount"
                             retvarname="itemCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2YU-"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of items of list '$(id)'</variable>
                <variable name="got">$(itemCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_2YVJ" name="clickItemWithDetails">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given item by a mouse-click on it.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 16 for right mouse. 4 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2YdV" local="true"
                           procedure="qfs.android.list.scroll"
                           retvarname="newItem">
              <variable name="id">$(id)</variable>
              <variable name="item">$(item)</variable>
              <variable name="itemSeparator">$(itemSeparator)</variable>
            </ProcedureCall>
            <IfSequence id="_2YdW"
                        test="rc.lookup(&#34;itemSeparator&#34;) == &#34;&amp;&#34; and rc.getInt(&#34;item&#34;) &lt; 0 and rc.getInt(&#34;newItem&#34;) &gt;= 0">
              <SetGlobalStep id="_2YdX" local="true" varname="item">
                <default>$(newItem)</default>
              </SetGlobalStep>
            </IfSequence>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_2YVK"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2YVL" name="getIndexOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2YdY" local="true"
                           procedure="qfs.android.list.scroll"
                           retvarname="newItem">
              <variable name="id">$(id)</variable>
              <variable name="item">$(item)</variable>
              <variable name="itemSeparator">$(itemSeparator)</variable>
            </ProcedureCall>
            <IfSequence id="_2YdZ"
                        test="rc.lookup(&#34;itemSeparator&#34;) == &#34;&amp;&#34; and rc.getInt(&#34;item&#34;) &lt; 0 and rc.getInt(&#34;newItem&#34;) &gt;= 0">
              <SetGlobalStep id="_2Yda" local="true" varname="item">
                <default>$(newItem)</default>
              </SetGlobalStep>
            </IfSequence>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_2YVM" local="true" varname="index"/>
            <ReturnStep id="_2YVN" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2YVO" name="getItemCount">
            <variable name="id">${id:listid}</variable>
            <comment>Return the number of items of a given list.


@param id 		The component-ID of the list.
@return itemCount

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="android" id="_2Yc7"
                              name="Is at end?">
              <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

table = rc.getComponent("$(id)")
nrRows = table.getRows()

if nrRows != -1:
    raise ReturnException("%s" % nrRows)</code>
            </ClientScriptStep>
            <ProcedureCall id="_2Yc8"
                           procedure="qfs.android.list.scrollToBottom">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
            <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                            id="_2YVQ" local="true" varname="lastIdx">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </FetchIndexStep>
            <ReturnStep id="_2YVR" retval="$[$(lastIdx)+1]"/>
          </Procedure>
          <Procedure id="_2YVS" name="getValueOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2Ydb" local="true"
                           procedure="qfs.android.list.scroll"
                           retvarname="newItem">
              <variable name="id">$(id)</variable>
              <variable name="item">$(item)</variable>
              <variable name="itemSeparator">$(itemSeparator)</variable>
            </ProcedureCall>
            <IfSequence id="_2Ydc"
                        test="rc.lookup(&#34;itemSeparator&#34;) == &#34;&amp;&#34; and rc.getInt(&#34;item&#34;) &lt; 0 and rc.getInt(&#34;newItem&#34;) &gt;= 0">
              <SetGlobalStep id="_2Ydd" local="true" varname="item">
                <default>$(newItem)</default>
              </SetGlobalStep>
            </IfSequence>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_2YVT"
                           local="true" varname="value"/>
            <ReturnStep id="_2YVU" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2YVV" name="selectItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Select a given item by a mouse-click on it.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The x coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2Yc1" local="true"
                           procedure="qfs.android.list.scroll"
                           retvarname="newItem">
              <variable name="id">$(id)</variable>
              <variable name="item">$(item)</variable>
              <variable name="itemSeparator">$(itemSeparator)</variable>
            </ProcedureCall>
            <IfSequence id="_2YdT"
                        test="rc.lookup(&#34;itemSeparator&#34;) == &#34;&amp;&#34; and rc.getInt(&#34;item&#34;) &lt; 0 and rc.getInt(&#34;newItem&#34;) &gt;= 0">
              <SetGlobalStep id="_2YdU" local="true" varname="item">
                <default>$(newItem)</default>
              </SetGlobalStep>
            </IfSequence>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" id="_2YVW" modifiers="16"/>
          </Procedure>
          <Procedure id="_2Yb4" name="scrollToTop">
            <variable name="id">${id:listid}</variable>
            <comment>Scroll to the top of the list.

@param id  		ID of the list.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcB"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <WhileSequence id="_2YbJ" test="True">
              <ProcedureCall id="_2YbO" local="true"
                             procedure="qfs.android.list.isAtTop"
                             retvarname="atTop">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <IfSequence id="_2YbP" test="$(atTop)">
                <BreakStep id="_2YbQ"/>
              </IfSequence>
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="swipe: C N C S 2" event="SELECTION"
                                  id="_2YbI"/>
            </WhileSequence>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: C N C S 2" event="SELECTION"
                                id="_2YbS"/>
          </Procedure>
          <Procedure id="_2YbM" name="isAtTop">
            <variable name="id">${id:listid}</variable>
            <variable name="pixelVisible">2</variable>
            <comment>Check whether we are at the top of the list.

@param id  		ID of the list.
@param pixelVisible	Number of pixels that must be visible.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcC"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)" engine="android" id="_2YbN"
                              name="Is at top?">
              <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

table = rc.getComponent("$(id)")
if len(table.getChildren()) == 0:
    raise ReturnException("true")

try:
    com = rc.getComponent("$(id)&amp;0")
    row = com.getRow()
    if row == 0:
        # ok, we get the top element
        # - but is it "visible"
        h1 = com.getInParentHeight()
        if h1 &lt;= rc.getInt("pixelVisible"):
            # not "fully" visisble
            raise ReturnException("false")
        raise ReturnException("true")
except IndexNotFoundException:
    pass

raise ReturnException("false")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YbF" name="isAtBottom">
            <variable name="id">${id:listid}</variable>
            <variable name="pixelVisible">2</variable>
            <variable name="scrollBack">true</variable>
            <comment>Check whether we are at the end of the list.

@param id  		ID of the list.
@param pixelVisible	Number of pixels that must be visible.
@param scrollBack      Sometimes QF-Test needs to scroll in order to determine whether a particular list is at the bottom or not. In case QF-Test needed to scroll down but we are not at the bottom, this parameter will determine whether to scroll back.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcD"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)" engine="android" id="_2YbR"
                              name="Is at end?">
              <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

table = rc.getComponent("$(id)")
nrRows = table.getRows()

if nrRows != -1:
    # android may return -1 in case the number of rows is unknown
    # in this case we cannot use this way to determine whether we
    # are at the top anymore ...
    try:
        com = rc.getComponent("$(id)&amp;-1")
        h1 = com.getInParentHeight()
        if h1 &lt;= rc.getInt("pixelVisible"):
            raise ReturnException("false")
        raise ReturnException("true")
    except IndexNotFoundException:
        raise ReturnException("false")

# we do not know the number of elements - calculate variable h for later on - then we do not need tons of other nodes to do that later on
tableHeight = table.getAbsoluteHeight()
h = max(tableHeight - 20, 1)
rc.setLocal("h", "%s" % h)

# also remember the current last item
lastIdx = len(table.getChildren()) - 1
if lastIdx == -1: raise ReturnException("true")
child = table.getChildren()[lastIdx]
rc.setLocal("height", child.getInParentHeight())
rc.setLocal("lastIdx", child.getRow())</code>
            </ClientScriptStep>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: C S C $(h)" event="SELECTION"
                                id="_2Ybg"/>
            <ClientScriptStep client="$(client)" engine="android" id="_2Ybl">
              <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

list = rc.getComponent("$(id)")
lastIdx = len(list.getChildren()) - 1
child = list.getChildren()[lastIdx]

height1 = rc.getInt("height")
height2 = child.getInParentHeight()
row1 = rc.getInt("lastIdx")
row2 = child.getRow()

result = ((height1 == height2) and (row1 == row2))

rc.setLocal("atBottom", "%s" % result)</code>
            </ClientScriptStep>
            <IfSequence id="_2Ybo" test="not $(atBottom) and $(scrollBack)">
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="swipe: C $(h) C S" event="SELECTION"
                                  id="_2Ybh"/>
            </IfSequence>
            <ReturnStep id="_2Ybn" retval="$(atBottom)"/>
          </Procedure>
          <Procedure id="_2Ybp" name="scrollToBottom">
            <variable name="id">${id:listid}</variable>
            <comment>Scroll to the top of the list.

@param id  		ID of the list.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcE"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <WhileSequence id="_2Ybq" test="True">
              <ProcedureCall id="_2Ybr" local="true"
                             procedure="qfs.android.list.isAtBottom"
                             retvarname="atBottom">
                <variable name="id">$(id)</variable>
                <variable name="scrollBack">false</variable>
              </ProcedureCall>
              <IfSequence id="_2Ybs" test="$(atBottom)">
                <BreakStep id="_2Ybt"/>
              </IfSequence>
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="swipe: C S C N 2" event="SELECTION"
                                  id="_2Ybu"/>
            </WhileSequence>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: C S C N 2" event="SELECTION"
                                id="_2Ybw"/>
          </Procedure>
          <Procedure id="_2Yb3" name="scroll">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Scroll to a particular element in the list.

@param id  		ID of the list.
@param item		The item to scroll to.
@param itemSeparator	The item separator (@, % or &amp;).

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2Yc3"
                        test="rc.lookup(&#34;itemSeparator&#34;) == &#34;&amp;&#34;">
              <ProcedureCall id="_2Yc4" local="true"
                             procedure="qfs.android.list.scrollByIndex"
                             retvarname="newitem">
                <variable name="id">$(id)</variable>
                <variable name="item">$(item)</variable>
              </ProcedureCall>
              <ReturnStep id="_2Yc5" retval="$(newitem)"/>
            </IfSequence>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcF"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ProcedureCall id="_2YbC"
                           procedure="qfs.android.list.scrollToTop">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_2Ycf" local="true"/>
            <SetGlobalStep id="_2Ycg" local="true" varname="h">
              <default>$[max($(h) - 40, 1)]</default>
            </SetGlobalStep>
            <WhileSequence id="_2YbD" test="True">
              <TryStep id="_2JVh" name="check whether the item can be found">
                <ComponentWaiter client="$(client)"
                                 component="$(id)$(itemSeparator)${quoteitem:$(item)}"
                                 id="_2JVk" timeout="1"/>
                <CommentStep id="_2YbU">
                  <heading>Element is available - but is it "fully" visible?</heading>
                </CommentStep>
                <ClientScriptStep client="$(client)" engine="android"
                                  id="_2Ybe" name="Is visible">
                  <code>result = "False"

com = rc.getComponent("$(id)$(itemSeparator)${quoteitem:$(item)}")
row = com.getRow()
if com.isVisibleToUser():
    h1 = com.getInParentHeight()
    if h1 &lt;= 2:
        result = "True"

rc.setLocal("needABitMoreScrolling", result)</code>
                </ClientScriptStep>
                <IfSequence id="_2Yb+" test="$(needABitMoreScrolling)">
                  <SelectionEventStep client="$(client)" component="$(id)"
                                      detail="swipe: C S C $[max($(h) - 20, 1)]"
                                      event="SELECTION" id="_2Ybd"/>
                </IfSequence>
                <BreakStep id="_2JVj"/>
                <CatchSequence exception="IndexNotFoundException" id="_2JVi"
                               maxerror="0"/>
              </TryStep>
              <CommentStep id="_2YbV">
                <heading>do not scroll too fast</heading>
              </CommentStep>
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="swipe: C S C $(h) 100 10"
                                  event="SELECTION" id="_2Yci"/>
              <CommentStep id="_2Yb-">
                <heading>check if at bottom</heading>
              </CommentStep>
              <ProcedureCall id="_2Yc0"
                             procedure="qfs.android.list.isAtBottom"
                             retvarname="atEnd">
                <variable name="id">$(id)</variable>
                <variable name="pixelVisible">2</variable>
              </ProcedureCall>
              <IfSequence id="_2YbZ" test="$(atEnd)">
                <CommentStep id="_2Ybb">
                  <heading>not found? Throw a IndexNotFoundException by searching for the component</heading>
                </CommentStep>
                <ComponentWaiter client="$(client)"
                                 component="$(id)$(itemSeparator)${quoteitem:$(item)}"
                                 id="_2Ybc" timeout="0"/>
              </IfSequence>
            </WhileSequence>
            <ReturnStep id="_2Yde" retval="$(item)"/>
          </Procedure>
          <Procedure id="_2Yc2" name="scrollByIndex">
            <variable name="id">${id:listid}</variable>
            <variable name="item">0</variable>
            <comment>Scroll to a particular element in the list.

@param id  		ID of the list.
@param item		The item to scroll to.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YcK"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)" engine="android" id="_2YcP"
                              name="empty list handling">
              <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

com = rc.getComponent("$(id)")
childs = com.getChildren()

if len(childs) == 0:
    # independently of the index - if there are no childs,
    # there is no item ...
    raise IndexNotFoundException()

# get table height for later on
tableHeight = com.getAbsoluteHeight()
rc.setLocal("h", "%s" % tableHeight)</code>
            </ClientScriptStep>
            <ProcedureCall id="_2YcU" local="true"
                           procedure="qfs.android.list.getItemCount"
                           retvarname="itemCount">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
            <SetGlobalStep id="_2YcQ" local="true" varname="item">
              <default>$[rc.getInt("item") if rc.getInt("item") &gt;= 0 else rc.getInt("itemCount") + rc.getInt("item")]</default>
            </SetGlobalStep>
            <IfSequence id="_2YcR" name="Check item bounds"
                        test="$(item) &lt; 0 or $(item) &gt;= $(itemCount)">
              <ClientScriptStep client="$(client)" engine="android" id="_2YcL"
                                name="throw IndexNotFoundException">
                <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

raise IndexNotFoundException()</code>
              </ClientScriptStep>
            </IfSequence>
            <SetGlobalStep id="_2Ycs" local="true" varname="lastDirection">
              <default>0</default>
              <comment>-1 up
0 stay
1 down</comment>
            </SetGlobalStep>
            <SetGlobalStep id="_2Ycu" local="true" varname="scrollSize">
              <default>$[max($(h)-10, 1)]</default>
              <comment>-1 up
0 stay
1 down</comment>
            </SetGlobalStep>
            <WhileSequence id="_2YcT" test="True">
              <TryStep id="_2YcX">
                <ComponentWaiter client="$(client)"
                                 component="$(id)&amp;$(item)" id="_2YcZ"
                                 timeout="1"/>
                <CommentStep id="_2Yca">
                  <heading>Element is available - but is it "fully" visible?</heading>
                </CommentStep>
                <ClientScriptStep client="$(client)" engine="android"
                                  id="_2Ycb" name="Is visible">
                  <code>needScroll, up, down = False, False, False

com = rc.getComponent("$(id)&amp;$(item)")
row = com.getRow()
if com.isVisibleToUser():
    h1 = com.getInParentHeight()
    if h1 &lt;= 2:
        needScroll = True

if needScroll:
    table = com.getParent()
    childs = table.getChildren()
    if childs[0] == com:
        up = True
    if childs[-1] == com:
        down = True

rc.setLocal("needABitMoreScrollingUp", up)
rc.setLocal("needABitMoreScrollingDown", down)</code>
                </ClientScriptStep>
                <IfSequence id="_2Ycc" test="$(needABitMoreScrollingUp)">
                  <SelectionEventStep client="$(client)" component="$(id)"
                                      detail="swipe: C N C $[min(20, $(h))]"
                                      event="SELECTION" id="_2Ycq"/>
                </IfSequence>
                <IfSequence id="_2Ycj" test="$(needABitMoreScrollingDown)">
                  <SelectionEventStep client="$(client)" component="$(id)"
                                      detail="swipe: C S C $[max($(h) - 20, 1)]"
                                      event="SELECTION" id="_2Yck"/>
                </IfSequence>
                <BreakStep id="_2Yce"/>
                <CatchSequence exception="IndexNotFoundException" id="_2YcY"
                               maxerror="0"/>
              </TryStep>
              <CommentStep id="_2Ycl">
                <heading>scroll</heading>
              </CommentStep>
              <ClientScriptStep client="$(client)" engine="android" id="_2YcS"
                                name="calculate scroll direction and size">
                <code>from de.qfs.apps.qftest.shared.exceptions import IndexNotFoundException

com = rc.getComponent("$(id)")
child = com.getChildren()[0]

row = child.getRow()
if row &gt; rc.getInt("item"):
    direction = 1
else:
    direction = -1

rc.setLocal("direction", "%s" % direction)

if direction != rc.getInt("lastDirection"):
    scrollSize = max(rc.getInt("scrollSize") / 2, 20)
    rc.setLocal("scrollSize", "%s" % scrollSize)</code>
              </ClientScriptStep>
              <IfSequence id="_2Yco" test="$(direction) == 1">
                <SelectionEventStep client="$(client)" component="$(id)"
                                    detail="swipe: C N C $[min($(scrollSize), $(h))]"
                                    event="SELECTION" id="_2Ycr"/>
              </IfSequence>
              <IfSequence id="_2Ycn" test="$(direction) == -1">
                <SelectionEventStep client="$(client)" component="$(id)"
                                    detail="swipe: C S C $[max($(h) - $(scrollSize), 1)]"
                                    event="SELECTION" id="_2Ycm"/>
              </IfSequence>
              <SetGlobalStep id="_2Yct" local="true" varname="lastDirection">
                <default>$(direction)</default>
              </SetGlobalStep>
            </WhileSequence>
            <ReturnStep id="_2YdS" retval="$(item)"/>
          </Procedure>
        </Package>
        <Package id="_2YVX" name="menu">
          <comment>Procedures to select menu items

@author	QFS
@since	5.4</comment>
          <Procedure id="_2YV+" name="selectItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.


@param	menu	The id of the menu.
@param	item	The id of menu item.


@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_2YW0" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_2YW1" modifiers="16"/>
          </Procedure>
          <Procedure id="_2YW2" name="selectItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.


@param	menu	The id of the menu.
@param	item	The id of menu item.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.


@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_2YW4" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_2YW5" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
          </Procedure>
        </Package>
        <Package id="_2YXK" name="radiobutton">
          <comment>Procedures to get and set the state of radio buttons.


@author	QFS
@since	5.4

</comment>
          <Procedure id="_2YXL" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  		The state of the checkbox.
@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YXM">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YXN"
                                raise="true" timeout="0"/>
              <ReturnStep id="_2YXO" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_2YXP"
                             maxerror="0">
                <ReturnStep id="_2YXQ" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YXR" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.

@param	id	The id of the radio button.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YXS">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YXT"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2YXU"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YXV" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2YXW" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TryStep id="_2YXX">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2YXY"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2YXZ"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2YXa" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1oP9" name="swipe">
          <comment>Packages containing swiping procedures
@author	QFS
@since	5.4</comment>
          <Procedure id="_2KF7" name="down">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe down operation.

@param id  	    The QF-Test ID of the component to perform the swipe operation on.
@param time 	    The duration of the swipe operation in milli seconds.
@params steps   The number of single steps making up the the swipe operation.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: down $(time) $(steps)"
                                event="SELECTION" id="_2KF8"/>
          </Procedure>
          <Procedure id="_2YXl" name="inDirection">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="direction">down</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe operation.

@param direction	The direction of the swipe.
		Valid entries: up, down, right, left, upright, up_left, down_right, 			down_left (and some more, see manual)
@param id   		The QF-Test ID of the component to perform the swipe operation on.
@param time   	The duration of the swipe operation in milli seconds.
@params steps  	The number of single steps making up the the swipe operation.


@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: $(direction) $(time) $(steps)"
                                event="SELECTION" id="_2KF4"/>
          </Procedure>
          <Procedure id="_2KFD" name="left">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe left operation.


@param id   		The QF-Test ID of the component to perform the swipe operation on.
@param time   	The duration of the swipe operation in milli seconds.
@params steps  	The number of single steps making up the the swipe operation.



@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: left $(time) $(steps)"
                                event="SELECTION" id="_2KFE"/>
          </Procedure>
          <Procedure id="_2KF9" name="right">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe right operation.


@param id   		The QF-Test ID of the component to perform the swipe operation on.
@param time   	The duration of the swipe operation in milli seconds.
@params steps  	The number of single steps making up the the swipe operation.



@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: right $(time) $(steps)"
                                event="SELECTION" id="_2KFA"/>
          </Procedure>
          <Procedure id="_2KF5" name="up">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe up operation.


@param id   		The QF-Test ID of the component to perform the swipe operation on.
@param time   	The duration of the swipe operation in milli seconds.
@params steps  	The number of single steps making up the the swipe operation.



@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: up $(time) $(steps)"
                                event="SELECTION" id="_2KF6"/>
          </Procedure>
          <Procedure id="_1oPA" name="withCoordinates">
            <variable name="id">${id:anAndroidComponentId}</variable>
            <variable name="startX">300</variable>
            <variable name="startY">300</variable>
            <variable name="swipeHorizontal">0</variable>
            <variable name="swipeVertical">300</variable>
            <variable name="time">100</variable>
            <variable name="steps">10</variable>
            <comment>Perform a swipe operation.

@param id		The id the coordinates refer to
@param startX	The number pixels right of the upper left corner of the id where to start the swipe
@param startY		The number pixels down from the upper left corner of the id where to start the swipe
@param swipeHorizontal	The number of pixels covered by the swipe.
@param swipeVertical	The number of pixels covered by the swipe.
@param time		The time in which to execute the swipe. With many applications a quick swipe will give the display a momentum which will make the display scroll further than the actual length of the swipe.
@param steps		The number of steps the swipe is broken down to. If you choose a long time or long distance increase the number of steps to make the movement more fluent.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="swipe: $(startX) $(startY) $[rc.getInt(&#34;startX&#34;) + rc.getInt(&#34;swipeHorizontal&#34;)] $[rc.getInt(&#34;startY&#34;) + rc.getInt(&#34;swipeVertical&#34;)] $(time) $(steps)"
                                event="SELECTION" id="_1oPI"/>
          </Procedure>
        </Package>
        <Package id="_2YZM" name="text">
          <comment>Procedures to access text fields and text areas.


@author	QFS
@since	5.4</comment>
          <Procedure id="_2YZN" name="clear">
            <variable name="id">${id:aTextField}</variable>
            <comment>Clear a text field.


@param	id	The id of the text field.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_2YZO" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2YZP" name="getText">
            <variable name="id">${id:aTextField}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  The text of the textfield.

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_2YZQ"
                           local="true" varname="currentText"/>
            <ReturnStep id="_2YZR" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_2YZS" name="setText">
            <variable name="id">${id:aTextField}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">true</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

@param	id		ID of the textfield.
@param 	text		text to be set. 
@param	append		if this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared before the text given as parameter "text" is inserted.
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2YZT"
                        test="not $(clear) and not $(append) and not $(replaySingleEvents)">
              <ProcedureCall id="_2YZU" procedure="qfs.run-log.logWarning">
                <variable name="message">Text cannot be inserted at cursor position (append=false) 
with replaySingleEvents=false 
-&gt; replaying single events</variable>
                <variable name="report">true</variable>
              </ProcedureCall>
              <SetGlobalStep id="_2YZV" local="true"
                             varname="replaySingleEvents">
                <default>true</default>
              </SetGlobalStep>
            </IfSequence>
            <ServerScriptStep id="_2YZW" interpreter="groovy">
              <code>import de.qfs.lib.util.Misc

def text = rc.lookup("text")
def newline = rc.lookup("newline")
if (newline) {
    rc.setLocal("text", text.replace(newline, "\n"))
}
</code>
            </ServerScriptStep>
            <IfSequence id="_2YZX" test="$(append)">
              <KeyEventStep client="$(client)" component="$(id)"
                            event="KEY_PTR" id="_2YZY" keychar="0"
                            keycode="35" modifiers="2"/>
            </IfSequence>
            <TextInputStep clear="$(clear)" client="$(client)"
                           component="$(id)" id="_2YZZ"
                           single="$(replaySingleEvents)">
              <text>$(text)</text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2YZa" name="setTextFromFile">
            <variable name="id">${id:aTextField}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param id 	The id of the text-field to set.
@param file	The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author	QFS
@since	5.4

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2YZb" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_2YZc" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2Jh2" name="automac">
        <comment>Contains procedures to work with native windows on a MacOS system.

All procedures use the Jython libraries automac.py, located in the jython/Lib folder of the current installation.
In the libraries there are even more methods for your needs.

@author QFS,ue
@since 4.4.0</comment>
        <Package id="_2Jjt" name="app">
          <comment>Procedures to start/close/raise a native macOS application.

@author	QFS
@since	4.4.0</comment>
          <Procedure id="qfs.automac.close" name="close" uid="_2Jh4">
            <variable name="timeout">2000</variable>
            <comment>Close the application. The application defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
The procedure deletes the global Jython variable "app".

@param timeout    Timeout how long to wait till window disappears

@throws UserException if the window was not closed 

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jh5"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <TryStep id="_2Jcn" name="close app">
              <SetGlobalStep id="_2Jh6" local="true" varname="iMaxWait">
                <default>$[$(timeout)/500]</default>
              </SetGlobalStep>
              <ServerScriptStep id="_2Jcx" name="close the window">
                <code>import automac
global app

if app == None:
    raise UserException ("No application connected")
rc.setLocal("pid", app.getPid())
rc.setLocal("title", app.getTitle())
try:
    automac.closeWindow(app.getMainWindow())
except:
    automac.closeWindow(app.getWindow())
    </code>
              </ServerScriptStep>
              <RepeatSequence count="$(iMaxWait)"
                              id="waitForAutowinWindowToClose"
                              name="wait for window to close" uid="_2Jh7">
                <ProcedureCall id="_2Jh8" procedure="qfs.utils.sleep">
                  <variable name="sleeptime">500</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2Jci" name="Check if closed">
                  <code>import automac
global app

found = false
try:
    a = automac.getApplicationAccessibilityObject(pid)
    found = true
except:
    del app
    
rc.setLocal("isRunning", found)    </code>
                </ServerScriptStep>
                <IfSequence id="_2Jh9" name="window is closed"
                            test="not $(isRunning)">
                  <BreakStep id="_2JhA"/>
                </IfSequence>
                <ElseSequence id="_2Jcj" name="last try">
                  <ServerScriptStep id="_2Jck" name="Check if closed">
                    <code>import automac
global app

try:
    a = automac.getApplicationAccessibilityObject(pid)
    raise UserException ("Application " + rc.lookup("title") + " could not be closed!")
except:
    del app
    </code>
                  </ServerScriptStep>
                </ElseSequence>
              </RepeatSequence>
              <CatchSequence exception="ScriptException" id="_2Jco"
                             maxerror="0" name="no app connected"
                             regexp="true">
                <catchmessage>(?s).*global name 'app' is not defined.*</catchmessage>
              </CatchSequence>
              <CatchSequence exception="UserException" id="_2Jcy"
                             maxerror="0">
                <catchmessage>No application connected</catchmessage>
              </CatchSequence>
            </TryStep>
            <ServerScriptStep id="_2JeB"
                              name="delete global jython var &#34;app&#34;">
              <code>global app
try:
    del app
except:
    pass</code>
            </ServerScriptStep>
            <TryStep id="_2JeY" name="stop QF-Test client process">
              <ClientStopper client="macclient" id="_2JeW"/>
              <ProcessWaiter client="macclient" id="_2JeX"/>
              <CatchSequence exception="TestException" id="_2JeZ"
                             maxerror="0"/>
            </TryStep>
          </Procedure>
          <Procedure id="_2Jbg" name="connect">
            <variable name="title"/>
            <variable name="processId"/>
            <variable name="bundleFile"/>
            <variable name="bundleId"/>
            <variable name="timeout">60000</variable>
            <comment>Connect to the given application. If the application has not been started yet and either the bundle file or the bundle id is provided the application will be started first.
The procedure sets the global jython variable "app". 

One of the following parameters needs to be provided.

@param title		The title of the application window.
@param processId	The pid as shown by the Activity Monitor.
@param bundleFile	The bundle file of the application.
@param bundleId	The bundle id of the application.
@param timeout	Maximum time (in ms) to wait for the application to start.
Only relevant if bundleFile or bundleId are provided and the application has to be started.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JcJ"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ServerScriptStep id="_2JdN"
                              name="check if application is already connected ">
              <code>defined = False
try:
    if app != None:
        defined = True
except:
    pass

rc.setLocal ("isConnected", defined)</code>
            </ServerScriptStep>
            <IfSequence id="_2Jc+"
                        name="application already connected -&gt; return"
                        test="$(isConnected)">
              <ReturnStep id="_2Jcz"/>
            </IfSequence>
            <IfSequence id="_2Jbh" test="&#34;$(title)&#34; != &#34;&#34;">
              <ServerScriptStep id="_2Jh3" name="Connect to app using title">
                <code>import automac
global app

title = rc.lookup("title")
window = automac.findWindow(title)
app = window.getParent()
</code>
              </ServerScriptStep>
              <ElseifSequence id="_2Jbi"
                              test="&#34;$(processId)&#34; != &#34;&#34;">
                <ServerScriptStep id="_2Jbl"
                                  name="Connect to app using processId">
                  <code>import automac
global app

pid = rc.getInt("processId")
app = automac.getApplicationAccessibilityObject(pid)
</code>
                </ServerScriptStep>
              </ElseifSequence>
              <ElseifSequence id="_2Jby"
                              test="&#34;$(bundleFile)&#34; != &#34;&#34;">
                <ServerScriptStep id="_2JcO"
                                  name="Connect to app using bundleFile">
                  <code>import automac
global app

bundleFile = rc.lookup("bundleFile")
apps = automac.runningApplications()
found = False
for a in apps:
    bf = a.getBundleFile()
    if str(bf) == str(bundleFile):
        pid = a.processIdentifier
        app = automac.getApplicationAccessibilityObject(pid)
        found = True
        
rc.setLocal("isRunning", found)</code>
                </ServerScriptStep>
                <IfSequence id="_2JcP" test="not $(isRunning)">
                  <ProcessClientStarter client="macclient"
                                        executable="$(bundleFile)"
                                        id="_2Jbv"/>
                  <SetGlobalStep id="_2JcX" local="true" varname="iMaxWait">
                    <default>$[$(timeout)/500]</default>
                  </SetGlobalStep>
                  <RepeatSequence count="$(iMaxWait)"
                                  id="waitForAutowinWindowToClose"
                                  name="wait for application to start"
                                  uid="_2JcY">
                    <ProcedureCall id="_2Jca" procedure="qfs.utils.sleep">
                      <variable name="sleeptime">500</variable>
                    </ProcedureCall>
                    <ServerScriptStep id="_2JcQ" name="Connect to app">
                      <code>import automac
global app

bundleFile = rc.lookup("bundleFile")

apps = automac.runningApplications()
found = False
for a in apps:
    bf = a.getBundleFile()
    if str(bf) == str(bundleFile):
        pid = a.processIdentifier
        app = automac.getApplicationAccessibilityObject(pid)
        found = True
        
rc.setLocal("isRunning", found)    </code>
                    </ServerScriptStep>
                    <IfSequence id="_2Jcd" name="application started"
                                test="$(isRunning)">
                      <BreakStep id="_2Jce"/>
                    </IfSequence>
                    <ElseSequence id="_2Jcg" name="last try">
                      <ServerScriptStep id="_2Jch" name="Connect to app">
                        <code>import automac
global app

bundleFile = rc.lookup("bundleFile")

apps = automac.runningApplications()
found = False
for a in apps:
    bf = a.getBundleFile()
    if str(bf) == str(bundleFile):
        pid = a.processIdentifier
        app = automac.getApplicationAccessibilityObject(pid)
        found = True

if not found:
    raise UserException ("Could not connect to " + str(bundleFile))       
   </code>
                      </ServerScriptStep>
                    </ElseSequence>
                  </RepeatSequence>
                </IfSequence>
              </ElseifSequence>
              <ElseifSequence id="_2Jb+"
                              test="&#34;$(bundleId)&#34; != &#34;&#34;">
                <TryStep id="_2Jc2">
                  <ServerScriptStep id="_2Jc0" name="Connect to app">
                    <code>import automac
global app

bundleId = rc.lookup("bundleId")
apps = automac.runningApplicationsWithBundleIdentifier(bundleId)
pid = apps[0].processIdentifier
app = automac.getApplicationAccessibilityObject(pid)
</code>
                  </ServerScriptStep>
                  <CatchSequence exception="ScriptException" id="_2Jc3"
                                 maxerror="0">
                    <ProcessClientStarter client="macclient"
                                          executable="/usr/bin/open"
                                          id="_2Jc4">
                      <parameter>-b</parameter>
                      <parameter>$(bundleId)</parameter>
                    </ProcessClientStarter>
                    <SetGlobalStep id="_2Jdf" local="true" varname="iMaxWait">
                      <default>$[$(timeout)/500]</default>
                    </SetGlobalStep>
                    <RepeatSequence count="$(iMaxWait)"
                                    id="waitForAutowinWindowToClose"
                                    name="wait for application to start"
                                    uid="_2Jdg">
                      <ProcedureCall id="_2Jdh" procedure="qfs.utils.sleep">
                        <variable name="sleeptime">500</variable>
                      </ProcedureCall>
                      <TryStep id="_2Jd+" name="application started">
                        <ServerScriptStep id="_2Jc5"
                                          name="Retry Connect to app">
                          <code>import automac
global app

bundleId = rc.lookup("bundleId")
apps = automac.runningApplicationsWithBundleIdentifier(bundleId)
pid = apps[0].processIdentifier
app = automac.getApplicationAccessibilityObject(pid)
</code>
                        </ServerScriptStep>
                        <BreakStep id="_2Jdk"/>
                        <CatchSequence exception="TestException" id="_2Jd-"
                                       maxerror="0"/>
                      </TryStep>
                      <ElseSequence id="_2Jdl" name="last try">
                        <ServerScriptStep id="_2Jdn"
                                          name="Retry Connect to app">
                          <code>import automac
global app

bundleId = rc.lookup("bundleId")
apps = automac.runningApplicationsWithBundleIdentifier(bundleId)
pid = apps[0].processIdentifier
app = automac.getApplicationAccessibilityObject(pid)
</code>
                        </ServerScriptStep>
                      </ElseSequence>
                    </RepeatSequence>
                  </CatchSequence>
                </TryStep>
              </ElseifSequence>
              <ElseSequence id="_2Jbj">
                <ProcedureCall id="_2Jbk" procedure="qfs.run-log.logError">
                  <variable name="message">No parameter given!</variable>
                  <variable name="withScreenshots">false</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2Jjc" name="raise">
            <comment>Raise the application. 

The application defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
The procedure deletes the global Jython variable "app".

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jjf"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ServerScriptStep id="_2Jjg" name="set frontmost">
              <code>global app

app.setFrontmost(1)</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_2Jj8" name="checkbox">
          <comment>Procedures to get and set the state of checkboxes in native macOS applications.

@author	QFS
@since	4.4.0</comment>
          <Procedure id="_2Jj9" name="checkValue">
            <variable name="expectedValue">true</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="identifier"/>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Check the value of the given component.

Write an error into the run-log or throw an exception, if the check fails.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param 	expectedValue	true if the checkbox should be checked (on), false otherwise.

@param 	errorLevel	ERROR or EXCEPTION

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0
</comment>
            <ProcedureCall id="_2JjA"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JjB" local="true"
                           procedure="qfs.automac.checkbox.getValue"
                           retvarname="actValue"/>
            <IfSequence id="_2JjC" test="$(expectedValue)!= $(actValue)">
              <IfSequence id="_2JjD"
                          test="&#34;$(errorLevel)&#34; == &#34;EXCEPTION&#34;">
                <ThrowStep id="_2JjE"
                           throwmessage="Checkbox should be checked: $(expectedValue). Got: $(actValue)"/>
                <ElseSequence id="_2JjF">
                  <ProcedureCall id="_2JjG" procedure="qfs.run-log.logError">
                    <variable name="message">Checkbox should be checked: $(expectedValue). Got: $(actValue)</variable>
                    <variable name="withScreenshots">true</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JjH" name="deselect">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="identifier"/>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Deselect a checkbox. If the checkbox is already deselected, no action is performed.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0

</comment>
            <ProcedureCall id="_2JjI"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JjJ" local="true"
                           procedure="qfs.automac.checkbox.getValue"
                           retvarname="isChecked"/>
            <IfSequence id="_2JjK" test="$(isChecked)">
              <ProcedureCall id="_2JjL" procedure="..component.click"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JjM" name="getValue">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="identifier"/>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Return the value of a checkbox.
It's either 1 if box is checked or 0 if box is not checked.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@return	The state of the checkbox.(1=checked, 0=not checked)

@author	QFS,ue
@since	4.4.0

</comment>
            <ProcedureCall id="_2JjN"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JjO" local="true"
                           procedure="..component.waitForComponent"
                           retvarname="isChecked"/>
            <ServerScriptStep id="_2JjP">
              <code>global __uiauto_control

status = __uiauto_control.getValue()
rc.setLocal("state", status)
</code>
            </ServerScriptStep>
            <ReturnStep id="_2JjQ" retval="$(state)"/>
          </Procedure>
          <Procedure id="_2JjR" name="select">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="identifier"/>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0

</comment>
            <ProcedureCall id="_2JjS"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JjT" local="true"
                           procedure="qfs.automac.checkbox.getValue"
                           retvarname="isChecked"/>
            <IfSequence id="_2JjU" test="not $(isChecked)">
              <ProcedureCall id="_2JjV" procedure="..component.click"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JjW" name="set">
            <variable name="check">true</variable>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="identifier"/>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Set checkbox to the given state.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	check	The check value to be set (either true or false).

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0
</comment>
            <ProcedureCall id="_2JjX"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <IfSequence id="_2JjY" test="$(check)">
              <ProcedureCall id="_2JjZ"
                             procedure="qfs.automac.checkbox.select"/>
              <ElseSequence id="_2Jja">
                <ProcedureCall id="_2Jjb"
                               procedure="qfs.automac.checkbox.deselect"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_2JhU" name="component">
          <comment>Basic procedures for interacting with a component of a native macOS application.

@author	QFS
@since	4.4.0</comment>
          <Procedure id="_2JhV" name="checkGeometry">
            <variable name="left"/>
            <variable name="top"/>
            <variable name="width"/>
            <variable name="height"/>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Check the position, width and height of the component on the screen.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param 	left	The expected number of pixels from the left border of the screen to the left border of the component. 
		Empty string: skip check.
@param 	top	The expected number of pixels from the top of the screen to the top of the component. 
		Empty string: skip check.
@param 	width	The expected number of pixels for the width of the component. 
		Empty string: skip check.
@param 	height	The expected number of pixels for the height of the component. 
		Empty string: skip check.
@param 	errorLevel   	The kind of error, which should be logged. 
		Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.
@param 	timeout	The time in ms to wait for the component.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JhW"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JhX" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <SetGlobalStep id="_2JhY" local="true" varname="now">
              <default>$(start)</default>
            </SetGlobalStep>
            <WhileSequence id="_2JhZ"
                           test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &lt; rc.getInt(&#34;timeout&#34;)">
              <TryStep id="_2Jha">
                <ProcedureCall id="_2Je6" local="true"
                               procedure="qfs.automac.component.getGeometry"
                               retvarname="geometry">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2Jhb">
                  <code>global __uiauto_control

level = rc.ERROR
if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")
    
geo = rc.lookup("geometry").split(",")
#print geo
left = geo[0]
top = geo[1]
width = geo[2]
height = geo[3]

if rc.lookup("left") != "":
    rc.checkEqual(left, rc.lookup("left"), 'Left', level, appearInReport)
if rc.lookup("top") != "":
    rc.checkEqual(top, rc.lookup("top"), 'Top', level, appearInReport)
if rc.lookup("height") != "":
    rc.checkEqual(height, rc.lookup("height"), 'Height', level, appearInReport)
if rc.lookup("width") != "":
    rc.checkEqual(width, rc.lookup("width"), 'Width', level, appearInReport)</code>
                </ServerScriptStep>
                <ReturnStep id="_2Jhc"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2Jhd" maxerror="0"/>
                <CatchSequence exception="UserException" id="_2Jhe"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2Jhf" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
            </WhileSequence>
            <TestStep id="_2Jhg" name="Last try if time is up">
              <ProcedureCall id="_2Je7" local="true"
                             procedure="qfs.automac.component.getGeometry"
                             retvarname="geometry">
                <variable name="timeout">500</variable>
              </ProcedureCall>
              <ServerScriptStep id="_2Je8">
                <code>global __uiauto_control

level = rc.ERROR
if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")
    
geo = rc.lookup("geometry").split(",")
#print geo
left = geo[0]
top = geo[1]
width = geo[2]
height = geo[3]

if rc.lookup("left") != "":
    rc.checkEqual(left, rc.lookup("left"), 'Left', level, appearInReport)
if rc.lookup("top") != "":
    rc.checkEqual(top, rc.lookup("top"), 'Top', level, appearInReport)
if rc.lookup("height") != "":
    rc.checkEqual(height, rc.lookup("height"), 'Height', level, appearInReport)
if rc.lookup("width") != "":
    rc.checkEqual(width, rc.lookup("width"), 'Width', level, appearInReport)</code>
              </ServerScriptStep>
            </TestStep>
          </Procedure>
          <Procedure id="_2Jhh" name="checkImage">
            <variable name="target"/>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="best">True</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="label"/>
            <variable name="identifier"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Check the image of a given component. The target image has to be provided as PNG-file. QF-Test tries to match this image to the image of the component on the screen by using an advanced image check algorithm.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	target	An image as PNG-file, e.g. C:\temp\target.png

@param	algorithm	The algorithm used for finding the target. 
		Best is to use the default one and adjust match probability if necessary.

@param	best	True means to find the best match. 
		False means to find the first match which is better than the defined probability.

@param 	errorLevel   	The kind of error to be logged. 
		Either EXCEPTION, ERROR, WARNING or MESSAGE.
assumed. 

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jhi"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jjh" procedure="qfs.automac.app.raise"/>
            <ProcedureCall id="_2Jhj" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="120" id="_2Jhk"
                            name="Repeat till found or timeout reached">
              <comment>with a loop time of min 1 s max timeout results in at least 2 min</comment>
              <TryStep id="_2Jhl" name="image found?">
                <BasicSequence id="_2Ja+"
                               name="fetch geometry of the component">
                  <ProcedureCall id="_2Jhm" local="true"
                                 procedure=".getGeometry"
                                 retvarname="geometry">
                    <variable name="timeout">1000</variable>
                  </ProcedureCall>
                  <ServerScriptStep id="_2Jhn" name="set local variables">
                    <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                  </ServerScriptStep>
                </BasicSequence>
                <ProcedureCall id="_2Jb2"
                               procedure="qfs.autoscreen.screen.getPositionOfImage">
                  <variable name="target">$(target)</variable>
                  <variable name="x">$["$(x)".split(".")[0] ]</variable>
                  <variable name="y">$["$(y)".split(".")[0] ]</variable>
                  <variable name="width">$["$(width)".split(".")[0] ]</variable>
                  <variable name="height">$["$(height)".split(".")[0] ]</variable>
                  <variable name="algorithm">$(algorithm)</variable>
                  <variable name="best">$(best)</variable>
                </ProcedureCall>
                <BreakStep id="_2Jhp"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2Jhq" maxerror="0"/>
                <CatchSequence exception="UserException" id="_2Jhr"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2Jhs" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2Jht" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2Jhu" local="true"
                               procedure=".getGeometry" retvarname="geometry">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2Jhv"
                                  name="fetch geometry of the component">
                  <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                </ServerScriptStep>
                <IfSequence id="_2Jhw"
                            test="&#34;$(errorLevel)&#34; == &#34;ERROR&#34;">
                  <BasicSequence id="_2Jhx" maxerror="2"
                                 name="Reduce max. errorlevel to &#34;Error&#34;">
                    <ProcedureCall id="_2Jhy"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$["$(x)".split(".")[0] ]</variable>
                      <variable name="y">$["$(y)".split(".")[0] ]</variable>
                      <variable name="width">$["$(width)".split(".")[0] ]</variable>
                      <variable name="height">$["$(height)".split(".")[0] ]</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </BasicSequence>
                  <ElseifSequence id="_2Jhz"
                                  test="&#34;$(errorLevel)&#34; == &#34;WARNING&#34;">
                    <BasicSequence id="_2Jh+" maxerror="1"
                                   name="Reduce max. errorlevel to &#34;Warning&#34;">
                      <ProcedureCall id="_2Jb3"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$["$(x)".split(".")[0] ]</variable>
                        <variable name="y">$["$(y)".split(".")[0] ]</variable>
                        <variable name="width">$["$(width)".split(".")[0] ]</variable>
                        <variable name="height">$["$(height)".split(".")[0] ]</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseifSequence id="_2Jh-"
                                  test="&#34;$(errorLevel)&#34; == &#34;MESSAGE&#34;">
                    <BasicSequence id="_2Ji0" maxerror="0"
                                   name="Reduce max. errorlevel to &#34;Message&#34;">
                      <ProcedureCall id="_2Jb4"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$["$(x)".split(".")[0] ]</variable>
                        <variable name="y">$["$(y)".split(".")[0] ]</variable>
                        <variable name="width">$["$(width)".split(".")[0] ]</variable>
                        <variable name="height">$["$(height)".split(".")[0] ]</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseSequence id="_2Ji1" name="EXCEPTION">
                    <ProcedureCall id="_2Jb5"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$["$(x)".split(".")[0] ]</variable>
                      <variable name="y">$["$(y)".split(".")[0] ]</variable>
                      <variable name="width">$["$(width)".split(".")[0] ]</variable>
                      <variable name="height">$["$(height)".split(".")[0] ]</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
                <BreakStep id="_2Ji2"/>
              </IfSequence>
              <ElseSequence id="_2Ji3" name="one last try">
                <ProcedureCall id="_2Ji4" local="true"
                               procedure=".getGeometry" retvarname="geometry">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2Ji5"
                                  name="fetch geometry of the component">
                  <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                </ServerScriptStep>
                <IfSequence id="_2Ji6"
                            test="&#34;$(errorLevel)&#34; == &#34;ERROR&#34;">
                  <BasicSequence id="_2Ji7" maxerror="2"
                                 name="Reduce max. errorlevel to &#34;Error&#34;">
                    <ProcedureCall id="_2Ji8"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </BasicSequence>
                  <ElseifSequence id="_2Ji9"
                                  test="&#34;$(errorLevel)&#34; == &#34;WARNING&#34;">
                    <BasicSequence id="_2JiA" maxerror="1"
                                   name="Reduce max. errorlevel to &#34;Warning&#34;">
                      <ProcedureCall id="_2JiB"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseifSequence id="_2JiC"
                                  test="&#34;$(errorLevel)&#34; == &#34;MESSAGE&#34;">
                    <BasicSequence id="_2JiD" maxerror="0"
                                   name="Reduce max. errorlevel to &#34;Message&#34;">
                      <ProcedureCall id="_2JiE"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseSequence id="_2JiF" name="EXCEPTION">
                    <ProcedureCall id="_2JiG"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_2JiH" name="checkValue">
            <variable name="expectedValue"/>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="timeout">10000</variable>
            <comment>Compare the given value to the value of a component according to the compareMode.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param 	expectedValue	The expected value.

@param	checkMessage	The message, which should be written into the run-log for that check.

@param	compareMode	The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.

@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.

@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.


@throws  UserException, if wrong comparison mode has been set.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JiI"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JiJ" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="120" id="_2JiK">
              <TryStep id="_2JiL" name="check value">
                <ProcedureCall id="_2JiM" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ServerScriptStep disabled="true" id="_2Jaq">
                  <code>rc.setLocal("componentValue", rc.lookup("componentValue").replace(" ","."))
rc.setLocal("expectedValue", rc.lookup("expectedValue").replace(" ","."))
</code>
                </ServerScriptStep>
                <ProcedureCall disabled="true" id="_2JiN"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentValue)</variable>
                  <variable name="expected">$(expectedValue)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">EXCEPTION</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <IfSequence id="_2Jas"
                            test="&#34;$(componentValue)&#34; == &#34;$(expectedValue)&#34;">
                  <BreakStep id="_2JiO"/>
                  <ElseSequence id="_2Jat">
                    <IfSequence id="_2Jau"
                                test="&#34;$(errorLevel)&#34; == &#34;EXCEPTION&#34;">
                      <ThrowStep id="_2Jaw" throwmessage="Check failed!"/>
                      <ElseSequence id="_2Jav">
                        <ProcedureCall id="_2Jar"
                                       procedure="qfs.run-log.logError">
                          <variable name="message">Implement all parameter values!</variable>
                          <variable name="withScreenshots">false</variable>
                        </ProcedureCall>
                      </ElseSequence>
                    </IfSequence>
                  </ElseSequence>
                </IfSequence>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JiP" maxerror="0" regexp="true"/>
                <CatchSequence exception="UserException" id="_2JiQ"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JiR" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2JiS" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2JiT" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JiU"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentValue)</variable>
                  <variable name="expected">$(expectedValue)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <BreakStep id="_2JiV"/>
              </IfSequence>
              <ElseSequence id="_2JiW" name="one last try">
                <ProcedureCall id="_2JiX" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JiY"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentText)</variable>
                  <variable name="expected">$(expectedText)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_2JiZ" name="click">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="identifier"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Click a given component.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.
@param 	title	The attribute "Title" or "AXTitle" of the GUI element.
@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.
@param 	role	The attribute "Role" or "AXRole" of the GUI element.
@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.
@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.
@param 	index	The index of the GUI element in case more than one element matches the given parameters. 
@param 	timeout	The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jia"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jib" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2Jic">
              <code>global __uiauto_control

if ${default:debug:false}: print "Click component"
__uiauto_control.press()
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2Jid" name="getControl">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Set the global Jython variable __uiauto_control to the GUI element matching the given parameters.
The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the following parameters all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 


@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jie"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ServerScriptStep id="_2Ja0" name="find GUI element">
              <code>import automac
global app
global __uiauto_control

def matches(comp, title, role, roleType, subrole, identifier, label):
    #check if the values of the component match the given parameters
    #An empty parameter is not checked
    #If a parameter is given and the component does not have the 
    #corresponding value false is returned
    
    if role != "":
        try:
            r = comp.getRole()
            if r != role:
                return False
        except:
            return False
        
    if subrole != "":
        try:
            r = comp.getSubrole()
            if r != subrole:
                return False
        except:
            return False
        
    if identifier != "":
        try:
            i = comp.getIdentifier()
            if i != identifier:
                return False
        except:
            return False
        
    if title != "":
        try:
            t = comp.getTitle()
            if str(t) != str(title):
                return False
        except:
            return False
    return True

    if label != "":
        try:
            l = comp.getDescription()
            if l != label:
                return False
        except:
            return False
    return True

    if roleType != "":
        try:
            t = comp.getRoleDescription()
            if t != roleType:
                return False
        except:
            return False
    return True

def printComp(comp):
    try:
        print "Role: ", comp.getRole()
    except:
        pass    
    try:
        print "Role type: ", comp.getRoleDescription()
    except:
        pass    
    try:
        print "Subrole: ", comp.getSubrole()
    except:
        pass    
    try:
        print "Title: ", comp.getTitle()
    except:
        pass    
    try:
        print "Identifier: ", comp.getIdentifier()
    except:
        pass    
    try:
        print "Label: ", comp.getDescription()
    except:
        pass    

def findChild(comp, title, role, roleType, subrole, identifier, label, index, count, level, maxLevel=10):
    if level &gt; maxLevel: return
    compChildren = comp.getChildren()
    i = 0
    for child in compChildren:
        
        match = matches(child, title, role, roleType, subrole, identifier, label)
        if match:
            if index == count:
                return child
            else:
                count += 1
        try:
            if child.getChildren():
                c = findChild(child, title, role, roleType, subrole, identifier, label, index, count, level+1)
                if c != None:
                    return c
        except:
            pass
        i += 1

title = rc.lookup("title")
role = rc.lookup("role")
roleType = rc.lookup("roleType")
subrole = rc.lookup("subrole")
identifier = rc.lookup("identifier")
try:
    index = rc.getInt("index")
except:
    index = 0
label = rc.lookup("label")

__uiauto_control = findChild(app, title, role, roleType, subrole, identifier, label, index, 0, 0)

if not __uiauto_control:
    raise ComponentNotFoundException()
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2Jif" name="getGeometry">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Fetch the screen coordinates for the left border, top, width and height for the component.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@return	The geometry data as a comma-separaed list: left,top,width,height.

@param 	timeout	The time in ms to wait for the component.

@author 	QFS,ue
@since 	4.4.0</comment>
            <ProcedureCall id="_2Jig"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jih" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2Jii" name="get size and position">
              <code>global __uiauto_control

pos = __uiauto_control.getPosition()
size = __uiauto_control.getSize()

left = pos.getX()
top = pos.getY()
height = size.getHeight()
width = size.getWidth()

rc.setLocal("retVal", "%s,%s,%s,%s" % (left, top, width, height))</code>
            </ServerScriptStep>
            <ReturnStep id="_2Jij" retval="$(retVal)"/>
          </Procedure>
          <Procedure id="_2Jik" name="getValue">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Return the value of the given control.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@return  	The value of the component.

@author 	QFS,ue
@since 	4.4.0</comment>
            <ProcedureCall id="_2Jil"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jim" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2Jin">
              <code>global __uiauto_control

rc.setLocal("retVal", __uiauto_control.getValue())
</code>
            </ServerScriptStep>
            <ReturnStep id="_2Jio" retval="$(retVal)"/>
          </Procedure>
          <Procedure id="_2JaG" name="setAttribute">
            <variable name="value"/>
            <variable name="attribute">AXValue</variable>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Set a given attribute of a component.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	attribute	The attribute to be set.

@param 	value	The value to be set.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author 	QFS,ue
@since 	4.4.0</comment>
            <ProcedureCall id="_2JaH"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JaI" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JaJ">
              <code>global __uiauto_control

val = rc.lookup("value")
attr = rc.lookup("attribute")
__uiauto_control.setAttribute(attr, val)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2Jip" name="setValue">
            <variable name="value"/>
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Set a given value to a component.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param 	value	The value to be set.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@author 	QFS,ue
@since 	4.4.0</comment>
            <ProcedureCall id="_2Jiq"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jir" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2Jis">
              <code>global __uiauto_control

__uiauto_control.setFocused(True)
val = rc.lookup("value")
__uiauto_control.setValue(val)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2Jit" name="waitForComponent">
            <variable name="title"/>
            <variable name="label"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <variable name="timeout">10000</variable>
            <comment>Set the global variable __uiauto_control to the GUI element matching the given parameters in the given window. Wait for the component for timeout ms at the most. 

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for component recognition all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.

@param 	title	The attribute "Title" or "AXTitle" of the GUI element.

@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.

@param 	role	The attribute "Role" or "AXRole" of the GUI element.

@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.

@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.

@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@param 	timeout	The time in ms to wait for the component.

@throws	ComponentNotFoundException 	If the component is not found within the given time.

@author 	QFS,ue
@since 	4.4.0</comment>
            <ProcedureCall id="_2Jiu"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jiv" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="600" id="_2Jiw"
                            name="Repeat till found or timeout reached">
              <comment>with a loop time of min 0,5 s max timeout results in at least 5 min</comment>
              <TryStep id="_2Jix" name="get control">
                <ProcedureCall id="_2Jiy" procedure=".getControl">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <BreakStep id="_2Jiz"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2Ji+" maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2Ji-" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2Jj0" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2Jj1" procedure=".getControl">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <BreakStep id="_2Jj2"/>
              </IfSequence>
              <ElseSequence id="_2Jj3" name="one last try">
                <ProcedureCall id="_2Jj4" procedure=".getControl">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
        </Package>
        <Package id="_2JhB" name="helpers">
          <comment>Procedures used internally by the package qfs.automac.component.

@author	QFS
@since	4.4.0</comment>
          <Procedure id="_2JhC" name="checkIfMac">
            <variable name="version"/>
            <comment>Check if the operation system is MacOS. If not throw a user exception.

@param version	if not empty (default) check if the os version is equal or higher to the given version.
		valid values: the main verion of the operation system e.g. 9, 10, 11

@author	QFS,ue
@since	4.4.0</comment>
            <IfSequence id="_2JhD" test="${qftest:macos}">
              <IfSequence id="_2JhE"
                          test="&#34;$(version)&#34; != &#34;&#34;">
                <IfSequence id="_2JhF"
                            test="${qftest:os.mainversion} &lt; $(version)">
                  <ThrowStep id="_2JhG"
                             throwmessage="The procedure runs on MacOS $(version) and higher only."/>
                </IfSequence>
              </IfSequence>
              <ElseSequence id="_2JhH" name="not macOS">
                <ThrowStep id="_2JhI"
                           throwmessage="The procedure runs on MacOS only."/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JhJ" name="dumpComponent">
            <variable name="label"/>
            <variable name="title"/>
            <variable name="identifier"/>
            <variable name="role"/>
            <variable name="roleType"/>
            <variable name="index">0</variable>
            <variable name="subrole"/>
            <comment>Print information provided by the Accessibility Interface of the given GUI control to the QF-Test terminal:  role, role type, subrole, label, title, identifier and methods.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the following parameters all respective attributes of the element have to match.

@param	label	The attribute "Label" or "AXDescription" of the GUI element.
@param 	title	The attribute "Title" or "AXTitle" of the GUI element.
@param 	identifier	The attribute "Identifier" or "AXIdentifier" of the GUI element.
@param 	role	The attribute "Role" or "AXRole" of the GUI element.
@param 	roleType	The attribute "Type" or "AXRoleDescription" of the GUI element.
@param 	subrole	The attribute "Subrole" or "AXSubrole" of the GUI element.
@param 	index	The index of the GUI element in case more than one element matches the given parameters. 

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JhK"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JhL"
                           procedure="qfs.automac.component.getControl"/>
            <ServerScriptStep id="_2JcG"
                              name="print element info to the terminal">
              <code>import automac
global __uiauto_control

def printComp(comp):
    try:
        print "Role: ", comp.getRole()
    except:
        pass    
    try:
        print "Type: ", comp.getRoleDescription()
    except:
        pass    
    try:
        print "Subrole: ", comp.getSubrole()
    except:
        pass    
    try:
        print "Title: ", comp.getTitle()
    except:
        pass    
    try:
        print "Identifier ", comp.getIdentifier()
    except:
        pass    
    try:
        print "Label: ", comp.getDescription()
    except:
        pass    

printComp(__uiauto_control)
print dir(__uiauto_control)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JhM" name="dumpComponents">
            <variable name="title"/>
            <variable name="processId"/>
            <variable name="bundleFile"/>
            <variable name="bundleId"/>
            <variable name="maxDepth">6</variable>
            <comment>Print role, role type, subrole, label, title and identifier of the controls in the given window to the QF-Test terminal. The data is only listed if it is defined in the UIElement automation interface of the respective GUI control.

If the application has not been started yet and either the bundle file or the bundle id is provided the application will be started first.
The procedure sets the global jython variable "app". 

One of the following parameters needs to be provided.

@param title		The title of the application window.
@param processId	The pid as shown by the Activity Monitor.
@param bundleFile	The bundle file of the application.
@param bundleId	The bundle id of the application.
@param maxDepth	Defines to which level the children of nested components are processed. Default: 6

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JhN"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JcI" procedure="qfs.automac.app.connect"/>
            <ServerScriptStep id="_2JhO">
              <code>import automac

win = app.getChildren()[0]
automac.dumpControls(win, rc.getInt("maxDepth"))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JhP" name="dumpComponentsToFile">
            <variable name="title"/>
            <variable name="processId"/>
            <variable name="bundleFile"/>
            <variable name="bundleId"/>
            <variable name="maxDepth">6</variable>
            <variable name="file"/>
            <comment>Print role, type, subrole, label, title and identifier of the controls in the given window to a file. The data is only listed if it is defined in the UIElement accessability interface of the respective GUI control.

If the application has not been started yet and either the bundle file or the bundle id is provided the application will be started first.
The procedure sets the global jython variable "app". 

One of the following parameters needs to be provided.

@param title		The title of the application window.
@param processId	The pid as shown by the Activity Monitor.
@param bundleFile	The bundle file of the application.
@param bundleId	The bundle id of the application.
@param maxDepth	Defines to which level the children of nested components are processed. Default: 6

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JhQ"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2JcK" procedure="qfs.automac.app.connect"/>
            <ServerScriptStep id="_2JhR">
              <code>import automac

win = app.getChildren()[0]
automac.dumpControlsToFile(rc.lookup("file"), win, rc.getInt("maxDepth"))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JhS" name="dumpDesktopWindows">
            <comment>Print the title, process id, bundle id and bundle file of all windows on the desktop of to the QF-Test terminal.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2JhT"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ServerScriptStep id="_2JcH"
                              name="Write app info to the terminal">
              <code>import automac

apps = automac.runningApplications()
for app in apps:
    print "      ---------           "
    try:
        pid = app.processIdentifier
        a = automac.getApplicationAccessibilityObject(pid)
        title = a.getMainWindow().getTitle()
        print "Window title: ", title
    except:
        print "Window title: -"
    print "Process id: ", pid
    print "Bundle id: ", app.getBundleIdentifier()
    print "Bundle file: ", app.getBundleFile()

</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_2Jj5" name="menu">
          <comment>Procedures to select menu items and checkbox menu items in native macOS applications.

@author	QFS
@since	4.4.0</comment>
          <Procedure id="_2Jj6" name="selectItem">
            <variable name="menuLabel"/>
            <variable name="menuTitle"/>
            <variable name="menuIdentifier"/>
            <variable name="menuRole"/>
            <variable name="menuRoleType"/>
            <variable name="menuIndex">0</variable>
            <variable name="menuSubrole"/>
            <variable name="itemLabel"/>
            <variable name="itemTitle"/>
            <variable name="itemIdentifier"/>
            <variable name="itemRole"/>
            <variable name="itemRoleType"/>
            <variable name="itemIndex">0</variable>
            <variable name="itemSubrole"/>
            <variable name="timeout">10000</variable>
            <comment>Select an item from a menu.

The application in which to look for the GUI element is defined by the global Jython variable "app" set in the procedure "qfs.automac.startApp". 
In case you specify more than one of the parameters for a component all respective attributes of the element have to match.

@param	menuDescription	The attribute "Label" or "AXDescription" of the menu.

@param 	menuTitle		The attribute "Title" or "AXTitle" of the menu.

@param 	menuIdentifier		The attribute "Identifier" or "AXIdentifier" of the menu.

@param 	menuRole		The attribute "Role" or "AXRole" of the menu.

@param 	menuRoleDescription	The attribute "Type" or "AXRoleDescription" of the menu.

@param 	menuSubrole		The attribute "Subrole" or "AXSubrole" of the menu.

@param 	menuIndex		The index of the menu in case more than one element matches the given parameters. 

@param	itemDescription	The attribute "Label" or "AXDescription" of the menu item.

@param 	itemTitle		The attribute "Title" or "AXTitle" of the menu item.

@param 	itemIdentifier		The attribute "Identifier" or "AXIdentifier" of the menu item.

@param 	itemRole		The attribute "Role" or "AXRole" of the menu item.

@param 	itemRoleDescription	The attribute "Type" or "AXRoleDescription" of the menu item. 

@param 	itemSubrole		The attribute "Subrole" or "AXSubrole" of the menu item.

@param 	itemIndex		The index of the item in case more than one element matches the given parameters item. 

@param 	timeout		The time in ms to wait for the component.

@author	QFS,ue
@since	4.4.0</comment>
            <ProcedureCall id="_2Jj7"
                           procedure="qfs.automac.helpers.checkIfMac"/>
            <ProcedureCall id="_2Jeg" procedure="qfs.automac.component.click">
              <variable name="label">$(menuLabel)</variable>
              <variable name="title">$(menuTitle)</variable>
              <variable name="role">$(menuRole)</variable>
              <variable name="roleType">$(menuRoleType)</variable>
              <variable name="identifier">$(menuIdentifier)</variable>
              <variable name="index">$(menuIndex)</variable>
              <variable name="subrole">$(menuSubrole)</variable>
              <variable name="timeout">10000</variable>
            </ProcedureCall>
            <ProcedureCall id="_2Jeh" procedure="qfs.automac.component.click">
              <variable name="label">$(itemLabel)</variable>
              <variable name="title">$(itemTitle)</variable>
              <variable name="role">$(itemRole)</variable>
              <variable name="roleType">$(itemRoleType)</variable>
              <variable name="identifier">$(itemIdentifier)</variable>
              <variable name="index">$(itemIndex)</variable>
              <variable name="subrole">$(itemSubrole)</variable>
              <variable name="timeout">10000</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Procedure id="_2Jju" name="sendKey">
          <variable name="key"/>
          <variable name="qualifier"/>
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Send the given key along with the qualifier to the component having the focus.
The application is defined by the global Jython variable "app" set in the procedure "qfs.automac.connect.app".

@param qualifier The qualifier to send along with the key. Valid input: SHIFT, COMMAND, META, ALT or the empty string for no qualifier
@param key The key to be send along with the alt key. Valid input: a single letter of the latin alphabet, a digit or values for special keys like ENTER, DELETE, TAB, ESCAPE or F1 to F24.

@author QFS,ue
@since 4.4.0</comment>
          <ProcedureCall id="_2Jjv"
                         procedure="qfs.automac.helpers.checkIfMac"/>
          <ProcedureCall id="_2Jj-" procedure="qfs.automac.app.raise"/>
          <IfSequence id="_2Jjw"
                      test="rc.lookup(&#34;qualifier&#34;).upper() not in [&#34;&#34;, &#34;SHIFT&#34;, &#34;ALT&#34;, &#34;COMMAND&#34;, &#34;META&#34;, &#34;CMD&#34;]">
            <ThrowStep id="_2Jjx"
                       throwmessage="Invalid qualifier! Expected: SHIFT, CMD, META, ALT or the empty string for no qualifier. Got: $(qualifier)"/>
          </IfSequence>
          <SetGlobalStep id="_2Jjy" local="true" varname="key">
            <default>KeyEvent.VK_$[ rc.lookup("key").upper()]</default>
          </SetGlobalStep>
          <IfSequence id="_2JkA"
                      test="(&#34;$(qualifier)&#34;.upper() == &#34;COMMAND&#34;) or (&#34;$(qualifier)&#34;.upper() == &#34;CMD&#34;)">
            <SetGlobalStep id="_2Jk9" local="true" varname="quali">
              <default>KeyEvent.VK_META</default>
            </SetGlobalStep>
            <ElseSequence id="_2JkB">
              <SetGlobalStep id="_2Jjz" local="true" varname="quali">
                <default>KeyEvent.VK_$[ rc.lookup("qualifier").upper()]</default>
              </SetGlobalStep>
            </ElseSequence>
          </IfSequence>
          <ServerScriptStep id="_2Ja7" name="send key and qualifier">
            <code>from java.awt import Robot
from java.awt.event import KeyEvent;

robot = Robot()
robot.delay(10)

if rc.lookup("qualifier") != "":
    robot.keyPress($(quali))
robot.keyPress($(key))
robot.keyRelease($(key))
if rc.lookup("qualifier") != "":
    robot.keyRelease($(quali))
</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_1lZU" name="autoscreen">
        <comment>Procedures for testing based on images.

@author	QFS,mh
@since	3.5M1</comment>
        <Package id="_1oUU" name="fx">
          <comment>Procedures to replay events anywhere on a JavaFX application based on images.

@author	QFS,mh
@since	4.1.0</comment>
          <Procedure id="qfs.autoscreen.web.getComponentAtImage"
                     name="getComponentAtImage" uid="_1oUV">
            <variable name="target"/>
            <variable name="stage">${id:genericStage}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <comment>Find an image anywhere on a JavaFX application and return the component ID. The target image has to be provided as PNG-file. QF-Test tries to find this image on the JavaFX application by using an advanced image check algorithm.
Note: Does only work for currently displayed images without scrolling.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	stage	A target stage node which has been recorded, maybe genericStage.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@return	The component ID which represents the found component.
@throws	UserException If the target could not be found, an TestException will be thrown.
@author	QFS,mh
@since	4.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(stage)"
                             id="_1oUW"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oUl"
                              name="Find the target">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
def getNode(node, x, y):
    nodes = []
    nodes.extend(node.getChildrenUnmodifiable())
    nodes.reverse()
    for n in nodes:
        if qf.isInstance(n, "javafx.scene.Parent"):
            if n.contains(n.sceneToLocal(x, y)):
                return getNode(n, x, y)
        else:
            return n

stage = rc.getComponent(rc.lookup("stage"))
actual = iw.grabImage(stage, x=None, y=None, width=None, height=None)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"
try:
    rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)
except UserException, CheckFailedException:
    raise UserException("Target image could not be found on " + rc.lookup("stage") + ".")
except:
    raise

target = getNode(stage.getScene().getRoot(), rc.getInt("x") , rc.getInt("y"))
if not target:
    raise UserException("Could not locate component on " + rc.lookup("stage") + ".")

width = expected.getWidth()
height = expected.getHeight()
rc.overrideElement("PriorityFxWindow", target)
raise ReturnException("PriorityFxWindow")
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="qfs.autoscreen.web.clickAtImage" name="clickAtImage"
                     uid="_1oUY">
            <variable name="target"/>
            <variable name="stage">${id:genericStage}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="offsetX"/>
            <variable name="offsetY"/>
            <variable name="mouseButton">16</variable>
            <comment>Click at an image anywhere on a JavaFX application. The target image has to be provided as PNG-file. QF-Test tries to find this image on the JavaFX application by using an advanced image check algorithm. The click goes to the middle of the got region unless there are offsets defined.
Note: Does only work for currently displayed images without scrolling.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	stage	A target stage which has been recorded, maybe genericStage.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	offsetX	If defined use this x-offset instead of middle of got region.
@param	offsetY	If defined use this y-offset instead of middle of got region.
@param	mouseButton	An integer describing the mouse button to click with. A value of 16 will perform a left and a value of 4 a right click.
@throws	UserException If the target could not be found, an TestException will be thrown.
@author	QFS,mh
@since	4.1.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1oUm" local="true"
                           procedure="qfs.autoscreen.fx.getComponentAtImage"
                           retvarname="component">
              <variable name="target">$(target)</variable>
              <variable name="stage">$(stage)</variable>
              <variable name="algorithm">$(algorithm)</variable>
            </ProcedureCall>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oUn"
                              name="Calculate offset">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"

target = rc.getComponent(rc.lookup("component"))
actual = iw.grabImage(target, x=None, y=None, width=None, height=None)
rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

offsetX = 0
offsetY = 0
if rc.lookup("offsetX"):
    offsetX = rc.getInt("offsetX")
else:
    offsetX = width / 2
if rc.lookup("offsetY"):
    offsetY = rc.getInt("offsetY")
else:
    offsetY = height / 2

rc.setLocal("x", int(xrel + offsetX))
rc.setLocal("y", int(yrel + offsetY))</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(component)" event="MOUSE_MPRC"
                            id="_1oUo" modifiers="$(mouseButton)" x="$(x)"
                            y="$(y)"/>
          </Procedure>
        </Package>
        <Package id="_1lZV" name="screen">
          <comment>Procedures to replay events anywhere on the screen based on images.

@author	QFS,mh
@since	3.5M1</comment>
          <Procedure id="qfs.autoscreen.screen.getPositionOfImage"
                     name="getPositionOfImage" uid="_1lae">
            <variable name="target"/>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="width"/>
            <variable name="height"/>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="best">True</variable>
            <comment>Find an image anywhere on the screen and return its position. The target image has to be provided as PNG-file. QF-Test tries to find this image on the screen by using an advanced image check algorithm.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	x	The start x position of the partial image of the screen. Empty means 0.
@param	y	The start y position of the partial image of the screen. Empty means 0.
@param	width	The width of the partial image of the screen. Empty means maximum width.
@param	height	The height of the partial image of the screen. empty means maximum height.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	best	True means to find the best match. False means to find the first match which is better than the defined probability.
@return	The position as list like [x, y].
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1</comment>
            <ServerScriptStep id="_1lah" name="Find the target">
              <code>from imagewrapper import ImageWrapper
from java.awt import Toolkit

iw = ImageWrapper(None)
try:
    x = rc.getInt("x")
except:
    x = 0
try:
    y = rc.getInt("y")
except:
    y = 0
try:
    width = rc.getInt("width")
except:
    width = int(Toolkit.getDefaultToolkit().getScreenSize().getWidth())
try:
    height = rc.getInt("height")
except:
    height = int(Toolkit.getDefaultToolkit().getScreenSize().getHeight())
try:
    if rc.getBool("best"):
        mode = "best"
    else:
        mode = "anywhere"
except:
    mode = "best"
actual = iw.grabScreenshot(x, y, width, height)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=" + mode + "(x,y)"
try:
    rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)
except UserException, CheckFailedException:
    raise UserException("Target image could not be found on screen.")
except:
    raise

xret = rc.getInt("x") + x  
yret = rc.getInt("y") + y

raise ReturnException(str([xret, yret]))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="qfs.autoscreen.screen.clickAtImage"
                     name="clickAtImage" uid="_1lZW">
            <variable name="target"/>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="width"/>
            <variable name="height"/>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="best">True</variable>
            <variable name="offsetX"/>
            <variable name="offsetY"/>
            <variable name="mouseButton">16</variable>
            <comment>Click at an image anywhere on the screen. The target image has to be provided as PNG-file. QF-Test tries to find this image on the screen by using an advanced image check algorithm. The click goes to the middle of the got region unless there are offsets defined.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	x	The start x position of the partial image of the screen. Empty means 0.
@param	y	The start y position of the partial image of the screen. Empty means 0.
@param	width	The width of the partial image of the screen. Empty means maximum width.
@param	height	The height of the partial image of the screen. empty means maximum height.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	offsetX	If defined use this x-offset instead of middle of got region.
@param	offsetY	If defined use this y-offset instead of middle of got region.
@param	best	True means to find the best match. False means to find the first match which is better than the defined probability.
@param	mouseButton	An integer describing the mouse button to click with. A value of 16 will perform a left and a value of 4 a right click.
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1</comment>
            <ProcedureCall id="_1lag" local="true"
                           procedure="qfs.autoscreen.screen.getPositionOfImage"
                           retvarname="position">
              <variable name="target">$(target)</variable>
              <variable name="algorithm">$(algorithm)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
              <variable name="width">$(width)</variable>
              <variable name="height">$(height)</variable>
              <variable name="best">$(best)</variable>
            </ProcedureCall>
            <ServerScriptStep id="_1lZX" name="Click the target">
              <code>from imagewrapper import ImageWrapper
from java.awt import Robot

iw = ImageWrapper(rc)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")

x = $(position)[0]
y = $(position)[1]
width = expected.getWidth()
height = expected.getHeight()

offsetX = 0
offsetY = 0
if rc.lookup("offsetX"):
    offsetX = rc.getInt("offsetX")
else:
    offsetX = width / 2
if rc.lookup("offsetY"):
    offsetY = rc.getInt("offsetY")
else:
    offsetY = height / 2

robot = Robot()
robot.mouseMove(x + offsetX, y + offsetY)
mouseButton = rc.getInt("mouseButton")
robot.mousePress(mouseButton)
robot.mouseRelease(mouseButton)
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1lZY" name="swing">
          <comment>Procedures to replay events anywhere on a Swing application based on images.

@author	QFS,mh
@since	3.5M1</comment>
          <Procedure id="qfs.autoscreen.swing.getComponentAtImage"
                     name="getComponentAtImage" uid="_1lZZ">
            <variable name="target"/>
            <variable name="frame">${id:genericJFrame}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <comment>Find an image anywhere on a JFrame of a Swing application and return the component ID. The target image has to be provided as PNG-file. QF-Test tries to find this image on the JFrame by using an advanced image check algorithm.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	frame	A target JFrame which has been recorded, maybe genericJFrame.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@return	The component ID which represents the found component.
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(frame)"
                             id="_1oFV"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lZa"
                              name="Find the target">
              <code>from imagewrapper import ImageWrapper
from javax.swing import SwingUtilities
from java.awt import Point

iw = ImageWrapper(rc)
frame = rc.getComponent(rc.lookup("frame"))
actual = iw.grabImage(frame, x=None, y=None, width=None, height=None)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"
try:
    rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)
except UserException, CheckFailedException:
    raise UserException("Target image could not be found on " + rc.lookup("frame") + ".")
except:
    raise

xrel = rc.getInt("x") + frame.getInsets().left
yrel = rc.getInt("y") + frame.getInsets().top
width = expected.getWidth()
height = expected.getHeight()

target = SwingUtilities.getDeepestComponentAt(frame, xrel + (width / 2), yrel + (height / 2))
rc.overrideElement("PriorityAwtSwingComponent", target)
raise ReturnException("PriorityAwtSwingComponent")
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="qfs.autoscreen.swing.clickAtImage"
                     name="clickAtImage" uid="_1laJ">
            <variable name="target"/>
            <variable name="frame">${id:genericJFrame}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="offsetX"/>
            <variable name="offsetY"/>
            <variable name="mouseButton">16</variable>
            <comment>Click at an image anywhere on a JFrame of a swing application. The target image has to be provided as PNG-file. QF-Test tries to find this image on the JFrame by using an advanced image check algorithm. The click goes to the middle of the got region unless there are offsets defined.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	frame	A target JFrame which has been recorded, maybe genericJFrame
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	offsetX	If defined use this x-offset instead of middle of got region.
@param	offsetY	If defined use this y-offset instead of middle of got region.
@param	mouseButton	An integer describing the mouse button to click with. A value of 16 will perform a left and a value of 4 a right click.
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1laN" local="true"
                           procedure="qfs.autoscreen.swing.getComponentAtImage"
                           retvarname="component">
              <variable name="target">$(target)</variable>
              <variable name="frame">$(frame)</variable>
              <variable name="algorithm">$(algorithm)</variable>
            </ProcedureCall>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1laa"
                              name="Calculate offset">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"

target = rc.getComponent(rc.lookup("component"))
actual = iw.grabImage(target, x=None, y=None, width=None, height=None)
rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

offsetX = 0
offsetY = 0
if rc.lookup("offsetX"):
    offsetX = rc.getInt("offsetX")
else:
    offsetX = width / 2
if rc.lookup("offsetY"):
    offsetY = rc.getInt("offsetY")
else:
    offsetY = height / 2

rc.setLocal("x", int(xrel + offsetX))
rc.setLocal("y", int(yrel + offsetY))</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(component)" event="MOUSE_MPRC"
                            id="_1laL" modifiers="$(mouseButton)" x="$(x)"
                            y="$(y)"/>
          </Procedure>
        </Package>
        <Package id="_1lZl" name="swt">
          <comment>Procedures to replay events anywhere on a SWT application based on images.

@author	QFS,mh
@since	3.5M1</comment>
          <Procedure id="qfs.autoscreen.swt.getComponentAtImage"
                     name="getComponentAtImage" uid="_1lZs">
            <variable name="target"/>
            <variable name="shell">${id:genericShell}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <comment>Find an image anywhere on a Shell of a SWT application and return the component ID. The target image has to be provided as PNG-file. QF-Test tries to find this image on the Shell by using an advanced image check algorithm.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	frame	A target Shell which has been recorded, maybe genericShell.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@return	The component ID which represents the found component.
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(shell)"
                             id="_1oFX"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1lZt"
                              name="Find the target">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
shell = rc.getComponent(rc.lookup("shell"))
display = shell.getDisplay()
actual = iw.grabImage(shell, x=None, y=None, width=None, height=None)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"
try:
    rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)
except UserException, CheckFailedException:
    raise UserException("Target image could not be found on " + rc.lookup("shell") + ".")
except:
    raise

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

shellLoc = shell.getLocation()
offX = shellLoc.x
offY = shellLoc.y

currentCursorLocation = display.getCursorLocation()
display.setCursorLocation(xrel + (width / 2) + offX, yrel + (height / 2) + offY)
target = display.getCursorControl()
display.setCursorLocation(currentCursorLocation)

rc.overrideElement("PrioritySwtWidget", target)
raise ReturnException("PrioritySwtWidget")
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="qfs.autoscreen.swt.clickAtImage" name="clickAtImage"
                     uid="_1laO">
            <variable name="target"/>
            <variable name="shell">${id:genericShell}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="offsetX"/>
            <variable name="offsetY"/>
            <variable name="mouseButton">16</variable>
            <comment>Click at an image anywhere on a Shell of a SWT application. The target image has to be provided as PNG-file. QF-Test tries to find this image on the Shell by using an advanced image check algorithm. The click goes to the middle of the got region unless there are offsets defined.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	frame	A target Shell which has been recorded, maybe genericShell.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	offsetX	If defined use this x-offset instead of middle of got region.
@param	offsetY	If defined use this y-offset instead of middle of got region.
@param	mouseButton	An integer describing the mouse button to click with. A value of 16 will perform a left and a value of 4 a right click.
@throws	UserException If the target could not be found, an UserException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1laS" local="true"
                           procedure="qfs.autoscreen.swt.getComponentAtImage"
                           retvarname="component">
              <variable name="target">$(target)</variable>
              <variable name="shell">$(shell)</variable>
              <variable name="algorithm">$(algorithm)</variable>
            </ProcedureCall>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1lac"
                              name="Calculate offset">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"

target = rc.getComponent(rc.lookup("component"))
actual = iw.grabImage(target, x=None, y=None, width=None, height=None)
rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

offsetX = 0
offsetY = 0
if rc.lookup("offsetX"):
    offsetX = rc.getInt("offsetX")
else:
    offsetX = width / 2
if rc.lookup("offsetY"):
    offsetY = rc.getInt("offsetY")
else:
    offsetY = height / 2

rc.setLocal("x", xrel + offsetX)
rc.setLocal("y", yrel + offsetY)</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(component)" event="MOUSE_MPRC"
                            id="_1laQ" modifiers="$(mouseButton)" x="$(x)"
                            y="$(y)"/>
          </Procedure>
        </Package>
        <Package id="_1la0" name="web">
          <comment>Procedures to replay events anywhere on a Web application based on images.

@author	QFS,mh
@since	3.5M1</comment>
          <Procedure id="qfs.autoscreen.web.getComponentAtImage"
                     name="getComponentAtImage" uid="_1laB">
            <variable name="target"/>
            <variable name="webpage">${id:genericDocument}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <comment>Find an image anywhere on a web application and return the component ID. The target image has to be provided as PNG-file. QF-Test tries to find this image on the web application by using an advanced image check algorithm.
Note: Does only work for currently displayed images without scrolling.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	webpage	A target web page node which has been recorded, maybe genericDocument.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@return	The component ID which represents the found component.
@throws	UserException If the target could not be found, an TestException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(webpage)"
                             id="_1oFZ"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1laC"
                              name="Find the target">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
frame = rc.getComponent(rc.lookup("webpage")).getRootElement()
if not frame:
    # Should never happen because rc.getComponent triggers rescan
    frame = rc.getComponent("genericHtml")
actual = iw.grabImage(frame, x=None, y=None, width=None, height=None)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"
try:
    rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)
except UserException, CheckFailedException:
    raise UserException("Target image could not be found on " + rc.lookup("webpage") + ".")
except:
    raise

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

target = frame.evalJS(
"document.elementFromPoint("
+ str(xrel + (width / 2))
+ " ,"
+ str(yrel + (height / 2))
+ ")"
)

rc.overrideElement("PriorityWebComponent", target)
raise ReturnException("PriorityWebComponent")
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="qfs.autoscreen.web.clickAtImage" name="clickAtImage"
                     uid="_1laT">
            <variable name="target"/>
            <variable name="webpage">${id:genericDocument}</variable>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="offsetX"/>
            <variable name="offsetY"/>
            <variable name="mouseButton">16</variable>
            <comment>Click at an image anywhere on a web application. The target image has to be provided as PNG-file. QF-Test tries to find this image on the web application by using an advanced image check algorithm. The click goes to the middle of the got region unless there are offsets defined.
Note: Does only work for currently displayed images without scrolling.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	webpage	A target web page node which has been recorded, maybe genericDocument.
@param	algorithm	The algorithm used for finding the target. Best is to use the default one and adjust match probability if necessary.
@param	offsetX	If defined use this x-offset instead of middle of got region.
@param	offsetY	If defined use this y-offset instead of middle of got region.
@param	mouseButton	An integer describing the mouse button to click with. A value of 16 will perform a left and a value of 4 a right click.
@throws	UserException If the target could not be found, an TestException will be thrown.
@author	QFS,mh
@since	3.5M1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1laZ" local="true"
                           procedure="qfs.autoscreen.web.getComponentAtImage"
                           retvarname="component">
              <variable name="target">$(target)</variable>
              <variable name="webpage">$(webpage)</variable>
              <variable name="algorithm">$(algorithm)</variable>
            </ProcedureCall>
            <ComponentWaiter client="$(client)" component="$(component)"
                             id="_1oFa"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ComponentWaiter client="$(client)" component="$(webpage)"
                             id="_1oFb"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1lad"
                              name="Calculate offset">
              <code>from imagewrapper import ImageWrapper

iw = ImageWrapper(rc)
expected = iw.loadPng(rc.lookup("target"))
if not expected:
    raise UserException("Image not found in file system.")
algorithm = rc.lookup("algorithm") + ";find=best(x,y)"

target = rc.getComponent(rc.lookup("component"))
actual = iw.grabImage(target, x=None, y=None, width=None, height=None)
rc.checkImageAdvanced(actual, expected, "Find image for image based click.", algorithm, level=rc.EXCEPTION, report=False, nowrap=False)

xrel = rc.getInt("x")
yrel = rc.getInt("y")
width = expected.getWidth()
height = expected.getHeight()

offsetX = 0
offsetY = 0
if rc.lookup("offsetX"):
    offsetX = rc.getInt("offsetX")
else:
    offsetX = width / 2
if rc.lookup("offsetY"):
    offsetY = rc.getInt("offsetY")
else:
    offsetY = height / 2

rc.setLocal("x", xrel + offsetX)
rc.setLocal("y", yrel + offsetY)
</code>
            </ClientScriptStep>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1laV"
                              name="Set semihard mouse">
              <code>if rc.getComponent(rc.lookup("webpage")).isBrowserIE():
    rc.setOption("WebSemiHardMouseEvents", true)</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(component)" event="MOUSE_MPRC"
                            id="_1laW" modifiers="$(mouseButton)" x="$(x)"
                            y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1laX"
                              name="Unset semihard mouse">
              <code>rc.unsetOption("WebSemiHardMouseEvents")</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
      </Package>
      <Package id="_1j+D" name="autowin">
        <comment>Contains procedures to work with native windows of the operating system Windows.

All procedures use the Jython libraries autowin.py and uiauto.py, located in the jython/Lib folder of the current installation.
In the libraries there are even more methods for your needs.

@author QFS,mm
@since 3.1.4</comment>
        <Package id="_1kGm" name="acrobat">
          <comment>Contain procedures to handle Adobe Acrobat Reader specific tasks like SaveAs or SaveAs Text ...

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author QFS,tm
@since 3.4.0</comment>
          <Procedure id="qfs.autowin.acrobat.saveAsText" name="saveAsText"
                     uid="_2Jkk">
            <variable name="fileName"/>
            <variable name="title">.*Adobe.*Reader.*</variable>
            <variable name="titleRegexp">true</variable>
            <variable name="fileMenuTitle">Datei|File</variable>
            <variable name="saveAsTextMenuTitle">Als Text speichern...|Save as Text...</variable>
            <variable name="dialogTitle">Speichern unter.*|Save .s.*|Save a Copy.*|Kopie speichern.*</variable>
            <variable name="timeout">30000</variable>
            <variable name="overwriteExistingFile">false</variable>
            <variable name="windowtimer">30000</variable>
            <variable name="savetimer">2</variable>
            <variable name="enableFunctionsYDiff">30</variable>
            <variable name="enableFunctionsXDiff">175</variable>
            <variable name="useUIAutomation">true</variable>
            <comment>Save the current open PDF in Adobe Acrobat Reader as a text file with the given filename.
Note: It only 'knows' English and German buttons. Thus currently only the English and German versions of Adobe Acrobat Reader are supported.
Logs an error if the file is already existing but parameter overwriteExistingFile is set to false.

@param fileName The filename to save.
@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.
@param fileMenuTitle The title of the file menu.
@param saveAsTextMenuTitle The title of the 'save as text' menu item.
@param dialogTitle The title of the 'save as...'-dialog.
@param timeout Timeout for waiting to complete the save-operation.
@param overwriteExistingFile If set to true an already existing file gets overwritten
@param  windowtimer with default 30000 - Timeout for finding the acrobat window and the sub-dialogs.
@param  savetimer with default 2 - internal timer which is used to determine when the save operation has finished.
@param	enableFunctionsYDiff	The distance in pixel from the bottom of the menu bar to the "Enable all functions" button. In case of scaled ultraHD/4k resolution you might need to increase those value.
@param	enableFunctionsXDiff	The distance in pixel from the right edge of the main window bar to the "Enable all functions" button. In case of scaled ultraHD/4k resolution you might need to increase those value.
@param useUIAutomation Whether to use UIAutomation to handle the Acrobat menus.
@throws UserException if window is not visible or the file is already existing

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,tm,mks,mm,mh
@since 3.4.0</comment>
            <ProcedureCall id="_2Jkl"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <BasicSequence id="_2Jkm"
                           name="check if AcroRead32.exe is newer or equal as 19.010.20091">
              <variable name="file">c:\\Program Files (x86)\\Adobe\\Acrobat Reader DC\\Reader\\AcroRd32.exe </variable>
              <SetGlobalStep id="_2Jkn" local="true" varname="cmdSaveAsText">
                <default>6007</default>
              </SetGlobalStep>
              <TryStep id="_2Jko">
                <ShellClientStarter client="shell"
                                    command="wmic datafile where name='$(file)' get version"
                                    id="_2Jkp"/>
                <ProcessWaiter client="shell" id="_2Jkq" timeout="5000"/>
                <ServerScriptStep id="_2Jkr">
                  <code>output = rc.lookup("qftest", "client.output.shell", expand=false)
output = output.replace("Version","")
output = output.replace("\n","")
version = output.strip().rstrip()
splitversion = version.split(".")
#print splitversion
major = splitversion[0]
medium = splitversion[1]
minor = splitversion[2]

#print "major:",major
#print "medium:",medium
#print "minor:",minor

if int(major) &gt;= int(19):
    if int(major) &gt;= int(20):
        cmdSaveAsText = 6013
        if int(major) &gt;= int(22):
            cmdSaveAsText = 6031
        elif int(major) &gt;= int(21):
            if int(medium) &gt;= int(7):
                cmdSaveAsText = 6015
    elif int(medium) &gt;= int("09"):
        if int(medium) &gt;= int("12"):
            if int(minor) &gt;= 20034:
                cmdSaveAsText = 6013
            else:
               cmdSaveAsText = 6009 
        elif int(minor) &gt;= 20091:
            cmdSaveAsText = 6009

rc.setLocal("cmdSaveAsText", cmdSaveAsText)</code>
                </ServerScriptStep>
                <CatchSequence exception="TestException" id="_2Jks"
                               maxerror="0"/>
              </TryStep>
            </BasicSequence>
            <ServerScriptStep id="_2Jkt" name="saveAsText">
              <code>from java.io import File
from java.lang import System
import autowin
import jarray
from array import array
import time

'''
Try to click the Enable-all-functions button in locked pdfs.

@since 4.1.4
@author QFS,mm
'''
def confirmEnableAllFunctions(window):    
    cs = window.getChildWindows()
    for c in cs:
        ctext = c.getWindowText()
        style = c.getWindowStyle()
        if ctext == "AVNullDocHostView":
            break
    else: # no host window found, we need to enable pdf functions very likely
        for c in cs:
            ctext = c.getWindowText()
            style = c.getWindowStyle()
            #get the NullDocView and try to raise click on "enable all functions."
            if ctext == "AVNullDocView" and hex(style) == hex(0x46000000L):
                mainbounds = window.getBounds()
                
                #the button couldn't be found directly, so we need to calculate
                #its position - take the y co-ordinate from the menu bar and
                #the rightmost x co-ordinate from the main window, then try to hit the button
                
                bounds = c.getBounds()
                right = mainbounds.getRight()
                
                top = bounds.getTop()
                bottom = bounds.getBottom()
                tdiff = rc.getInt("default", "enableFunctionsYDiff:30")
                rdiff = rc.getInt("default", "enableFunctionsXDiff:175")
                top = top + tdiff
                right = right - rdiff
                
                #bring to foregound and raise click
                window.setForeground()
                time.sleep(0.5)
                autowin.doClickHard(right, top)
                time.sleep(2)                
                break

cmdSaveAsText = rc.getInt("cmdSaveAsText")
#print "cmd: " , cmdSaveAsText

windowtimer = rc.getInt("windowtimer")
savetimer = rc.getInt("savetimer")

fileName = rc.lookup("fileName").replace("/","\\")
aFile = File(fileName)
fileName = aFile.getAbsolutePath()
if aFile.exists():
   if not rc.getBool("overwriteExistingFile"):
      raise UserException("File already exists.\nPlease set the parameter overwriteExistingFile=true if you want to overwrite the file")
   else:
      #delete existing file
      rc.callProcedure("qfs.shellutils.deleteFile", {"file":fileName})

# start helpers ###############################################################

okButtonList = ['Ok','&amp;Ok','Ja','&amp;Ja']
cancelButtonList = ['Nein','&amp;Nein','No','&amp;No','Abbrechen','&amp;Abbrechen','Cancel','&amp;Cancel']
saveButtonList = ['Speichern','&amp;Speichern','Save','&amp;Save']

#returns a window with the given windowtext
def findWindowByText(parent,textlist):
    i = 0
    iTimeout = windowtimer / 1000
    while (i &lt; iTimeout):
        wins = parent.getChildWindows()
        for w in wins:
           if w.isVisible():
               wname = autowin.getWindowText(w)
               if wname in textlist:
                   return w
        i = i + 1
        time.sleep(1)
    return None

#returns a window for the given classname
def findWindowByClass(parent,classname):
    i = 0
    iTimeout = windowtimer / 1000
    while (i &lt; iTimeout):
        wins = parent.getChildWindows()
        for w in wins:
           if w.isVisible():
               cname = w.getWindowClassName()
               if cname == classname:
                   return w
        i = i + 1
        time.sleep(1)
    return None

# directly send the internal message to open SaveAsText-FileDialog
def openSaveAsText(window, checkProtectedMode=True):
    if (rc.getInt("qftest","os.mainversion") &gt;= 10) and rc.getBool("useUIAutomation"):
        rc.callProcedure("..component.click",{'window': rc.lookup("title"), 'name':rc.lookup("fileMenuTitle"),'controlType':'MenuItem'})
        rc.callProcedure("qfs.autowin.component.waitForComponent",{'window': rc.lookup("title"),'name':rc.lookup("saveAsTextMenuTitle"),'controlType':'MenuItem'})
        global __uiauto_control
        from java.awt import Robot
        robot = Robot()

        point = __uiauto_control.getClickablePoint()
        if point.x == 0 and point.y == 0:
            try:
                __uiauto_control.focus()
            except:
                pass
            point = __uiauto_control.getClickablePoint()
        robot.mouseMove(point.x,point.y)
        robot.mousePress(16)
        robot.mouseRelease(16)
    else:
        window.setForeground()
        window.postMessage(autowin.WM_COMMAND, cmdSaveAsText, 0)
    dialogTitle = rc.lookup("dialogTitle", expand=False)
    saveDialog = autowin.waitForWindow(5000, dialogTitle, true)
    
    #check for open save dialog, due to issues with protected mode
    if checkProtectedMode:
        saveDialog = autowin.waitForWindow(5000, dialogTitle, True)
        if not saveDialog:
            confirmEnableAllFunctions(window)
            openSaveAsText(window, False)

def closeSaveDialog(window):
    cancelButton = findWindowByText(window,cancelButtonList)
    if cancelButton != None:
        autowin.doClick(cancelButton, 5, 5)
    else:
        raise UserException("cancel-button cannot be determined")

def saveAs(filename):
   dialogTitle = rc.lookup("dialogTitle", expand=False)
   saveDialog = autowin.waitForWindow(windowtimer, dialogTitle, true)
   if saveDialog:
      editField = findWindowByClass(saveDialog,"Edit")
      saveButton = findWindowByText(saveDialog,saveButtonList)
      if editField != None:
          autowin.setWindowText(editField, filename)
          # Acrobat 11 workaround
          autowin.typeKey(editField, autowin.VK_SPACE)
      else:
          raise UserException("filename field cannot be determined")
      if saveButton != None:
          time.sleep(2)
          autowin.doClick(saveButton, 5, 5)
          time.sleep(2)
          saveWaiter(filename,saveDialog)
      else:
          raise UserException("save-button cannot be determined")
   else:
       raise UserException("Cannot find Save-dialog")

def saveWaiter(filename,saveDialog):
    aFile = File(filename)
    timeout = rc.getInt("timeout")
    starttime = System.currentTimeMillis()
    filesize = 0
    lastfilesize = -1

    while True:
        actualtime = System.currentTimeMillis()
        filesize = aFile.length()
        if actualtime-starttime &gt; timeout:
            if filesize == 0:
               rc.logError("The save-operation was not successful. You probably set an incorrect folder/filename.")
            else:
               rc.logError("The save-operation took longer than the timeout set.")
            break;
        if filesize == lastfilesize:
            rc.logMessage("save-operation finished")
            break;
        if filesize &gt; 0:
            lastfilesize = filesize
        time.sleep(savetimer)

# end helpers #################################################################

window = autowin.waitForWindow(windowtimer, rc.lookup("title") , rc.getBool("titleRegexp"))
if window:
    openSaveAsText(window)
    saveAs(fileName)
else:
    raise UserException("Cannot find an open Adobe Reader window")</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="qfs.autowin.acrobat.savePDF" name="savePDF"
                     uid="_1kGs">
            <variable name="fileName"/>
            <variable name="title">.*Adobe.*Reader.*</variable>
            <variable name="titleRegexp">true</variable>
            <variable name="dialogTitle">Speichern unter.*|Save .s.*|Save a Copy.*|Kopie speichern.*</variable>
            <variable name="timeout">30000</variable>
            <variable name="overwriteExistingFile">false</variable>
            <variable name="windowtimer">30000</variable>
            <variable name="savetimer">3</variable>
            <variable name="inlineDisplay">false</variable>
            <comment>Save the current open PDF in Adobe Acrobat Reader as a PDF file with the given filename.
Note: It simulates CTRL+SHIFT+S keystrokes to open the file dialog.
Logs an error if the file is already existing but parameter overwriteExistingFile is set to false.

@param fileName The filename to save.
@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.
@param dialogTitle The title of the 'save as...'-dialog.
@param timeout with default 30000 - Timeout for waiting to complete the save-operation.
@param overwriteExistingFile If set to true an already existing file gets overwritten
@param  windowtimer with default 30000 - Timeout for finding the acrobat window and the sub-dialogs.
@param  savetimer with default 3 - internal timer which is used to determine when the save operation has finished.
@param inlineDisplay - set to true if pdf is displayed inline (e.g. inside the browser window)

@throws UserException if window is not visible or the file is already existing

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,tm,mks
@since 3.4.0</comment>
            <ProcedureCall id="_2JR4"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_1kGq" name="savePDF">
              <code>from java.io import File
from java.lang import System
import autowin
import time
import re
windowtimer = rc.getInt("windowtimer")
savetimer = rc.getInt("savetimer")

fileName = rc.lookup("fileName").replace("/","\\")
if (fileName.find(".pdf")==-1):
    fileName += ".pdf"
aFile = File(fileName)
fileName = aFile.getAbsolutePath()
if aFile.exists():
   if not rc.getBool("overwriteExistingFile"):
      raise UserException("File already exists.\nPlease set the parameter overwriteExistingFile=true if you want to overwrite the file")
   else:
      #delete existing file
      rc.callProcedure("qfs.shellutils.deleteFile", {"file":fileName})
# start helpers ###############################################################

okButtonList = ['Ok','&amp;Ok','Ja','&amp;Ja']
cancelButtonList = ['Nein','&amp;Nein','No','&amp;No','Abbrechen','&amp;Abbrechen','Cancel','&amp;Cancel']
saveButtonList = ['Speichern','&amp;Speichern','Save','&amp;Save']

#returns a window with the given windowtext
def findWindowByText(parent,textlist):
    i = 0
    iTimeout = windowtimer / 1000
    while (i &lt; iTimeout):
        wins = parent.getChildWindows()
        for w in wins:
           if w.isVisible():
               wname = autowin.getWindowText(w)
               if wname in textlist:
                   return w
        i = i + 1
        time.sleep(1)
    return None

#returns a window for the given classname
def findWindowByClass(parent,classname, timeout=-1):
    i = 0
    if (timeout == -1):
        iTimeout = windowtimer / 1000
    else:
        iTimeout = timeout / 1000
    while (i &lt; iTimeout):
        wins = parent.getChildWindows()
        for w in wins:
           if w.isVisible():
               cname = w.getWindowClassName()
               if cname == classname:
                   return w
        i = i + 1
        time.sleep(1)
    return None

#simulates keys CTRL+SHIFT+S
def openSaveAsPDF(window):
    window.setForeground()
    autowin.doClick(window, 50, 50)
    window.setForeground()
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_SHIFT, 0)
    autowin.keybd_event(ord('S'), 0)
    autowin.keybd_event(ord('S'), autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_SHIFT, autowin.KEYEVENTF_KEYUP)

def closeSaveDialog(window):
    cancelButton = findWindowByText(window,cancelButtonList)
    if cancelButton != None:
        autowin.doClick(cancelButton, 5, 5)
    else:
        raise UserException("cancel-button cannot be determined")

def saveAs(filename):
   dialogTitle = rc.lookup("dialogTitle", expand=False)
   saveDialog = autowin.waitForWindow(windowtimer, dialogTitle, true)
   if saveDialog:
       #try to get rid of recent file dialogs, maximum three trials
      for i in range(3):
        dialogClass = saveDialog.getWindowClassName()
        if dialogClass == "AVL_AVDialog":
            win = findWindowByClass(saveDialog,"AVL_AVView",10000)
            if win:
                time.sleep(2) # wait until progress spinner is gone
                autowin.keybd_event(autowin.VK_ENTER, 0)
                autowin.keybd_event(autowin.VK_ENTER, autowin.KEYEVENTF_KEYUP)
                time.sleep(2)
            saveDialog = autowin.waitForWindow(windowtimer, dialogTitle, true)
        else:
            break

      dialogClass = saveDialog.getWindowClassName()
      editField = findWindowByClass(saveDialog,"Edit")
      saveButton = findWindowByText(saveDialog,saveButtonList)
      if editField != None:
          autowin.setWindowText(editField, filename)
          # Acrobat 11 workaround
          autowin.typeKey(editField, autowin.VK_SPACE)
      else:
          raise UserException("filename field cannot be determined")
      if saveButton != None:
          time.sleep(2)
          autowin.doClick(saveButton, 5, 5)
          time.sleep(2)
          saveWaiter(filename,saveDialog)
      else:
          raise UserException("save-button cannot be determined")
   else:
       raise UserException("Cannot find Save-Dialog")

def saveWaiter(filename,saveDialog):
    aFile = File(filename)

    timeout = rc.getInt("timeout")
    starttime = System.currentTimeMillis()
    filesize = 0
    lastfilesize = -1

    while True:
        actualtime = System.currentTimeMillis()
        filesize = aFile.length()
        if actualtime-starttime &gt; timeout:
            if filesize == 0:
               rc.logError("The save-operation was not successful. You probably set an incorrect folder/filename.")
            else:
               rc.logError("The save-operation took longer than the timeout set.")
            break;
        if filesize == lastfilesize:
            rc.logMessage("save-operation finished")
            break;
        if filesize &gt; 0:
            lastfilesize = filesize
        time.sleep(savetimer)

def findInlinePDFWindow():
    wins = autowin.getAllWindows()
    for w in wins:
      cname = w.getWindowClassName(); 
      if w.isVisible() and cname=="wxWindowNR":
         wname = w.getWindowText()
         if wname=="":
             childs = w.getChildWindows()
             for c in childs:         
                cText = c.getWindowText()
                name =  ".*Adobe.*Reader.*"
                reg = re.compile(name)
                if reg.match(cText):
                    window = c
                    return window
    return None
# end helpers #################################################################
window = None
if rc.lookup("inlineDisplay") == "true":            
    time.sleep(1)
    window = findInlinePDFWindow()
    if window == None:
       time.sleep(5)        
       window = findInlinePDFWindow()
else:
    window = autowin.waitForWindow(windowtimer, rc.lookup("title") , rc.getBool("titleRegexp"))
    
if window:
    openSaveAsPDF(window)
    saveAs(fileName)
else:
    raise UserException("Cannot find an open Adobe Reader window")</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_2JGf" name="keyevents">
          <comment>Procedures for replaying key events to a windows application.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author	QFS
@since	4.2.3</comment>
          <Procedure id="_2JM2" name="sendKey">
            <variable name="key"/>
            <variable name="qualifier"/>
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Send the given key along with the qualifier to the window with the given title.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.
@param qualifier The qualifier to send along with the key. Valid input: SHIFT, CTRL, ALT or the empty string for no qualifier
@param key The key to be send along with the alt key. Valid input: a single letter of the latin alphabet, a digit or values for special keys like ENTER, DELETE, TAB, ESCAPE or F1 to F24.

@throws ComponentNotFoundException if window is not visible

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure. If only a single keyboard shortcut should be send, the qfs.utils.sendKey method can be used.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JR5"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <IfSequence id="_2JMF"
                        test="rc.lookup(&#34;qualifier&#34;).upper() not in [&#34;&#34;, &#34;SHIFT&#34;, &#34;CTRL&#34;, &#34;ALT&#34;]">
              <ThrowStep id="_2JME"
                         throwmessage="Invalid qualifier! Expected: SHIFT, CTRL, ALT or the empty string for no qualifier. Got: $(qualifier)"/>
            </IfSequence>
            <SetGlobalStep id="_2JMC" local="true" varname="key">
              <default>autowin.VK_$[ rc.lookup("key").upper()]</default>
            </SetGlobalStep>
            <SetGlobalStep id="_2JMD" local="true" varname="quali">
              <default>autowin.VK_$[ rc.lookup("qualifier").upper()]</default>
            </SetGlobalStep>
            <ServerScriptStep id="_2JMG" name="Send key plus qualifier">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    #qualifier + given key
    if rc.lookup("qualifier") != "":    
        autowin.keybd_event($(quali), 0) #Press qualifier
    autowin.keybd_event($(key), 0)
    autowin.keybd_event($(key), autowin.KEYEVENTF_KEYUP)
    if rc.lookup("qualifier") != "":    
        autowin.keybd_event($(quali), autowin.KEYEVENTF_KEYUP) #Release qualifier
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JLz" name="pressCtrlA">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Perform Ctrl+a to the given window to mark all text of the compontent which has the focus.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JR6"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JLM" name="Send Ctrl+a">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    #Ctrl + A
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_A, 0)
    autowin.keybd_event(autowin.VK_A, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JL+" name="pressCtrlV">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Perform Ctrl+v to the given window to paste the content of the clipboard to the component with the focus.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JR7"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JGh" name="Send Ctrl+v">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_V, 0)
    autowin.keybd_event(autowin.VK_V, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JL-" name="pressCtrlX">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Perform Ctrl+x to the given window to cut the selected content of the component with the focus.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2</comment>
            <ProcedureCall id="_2JR8"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JHa" name="Send Ctrl+x">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_X, 0)
    autowin.keybd_event(autowin.VK_X, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JEh" name="pressDelete">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Replay DELETE to the given window.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JR9"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JEi" name="Send DELETE">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    autowin.keybd_event(autowin.VK_DELETE, 0)
    autowin.keybd_event(autowin.VK_DELETE, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JLT" name="pressEnter">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Replay ENTER to the given window.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JRA"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JLU" name="Send ENTER">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    autowin.keybd_event(autowin.VK_ENTER, 0)
    autowin.keybd_event(autowin.VK_ENTER, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JEv" name="pressTab">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Replay TAB to the given window.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JRB"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JEw" name="Send TAB">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    autowin.keybd_event(autowin.VK_TAB, 0)
    autowin.keybd_event(autowin.VK_TAB, autowin.KEYEVENTF_KEYUP)
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_2JFD" name="dependencies">
          <comment>Dependencies for starting/stopping a native windows application.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author	QFS
@since	4.2.3</comment>
          <Dependency id="_3Cs" name="SUT_started">
            <discriminator>dialogtitle</discriminator>
            <discriminator>titleRegexp</discriminator>
            <discriminator>executable</discriminator>
            <discriminator>autowinClient</discriminator>
            <variable name="executable"/>
            <variable name="workdir"/>
            <variable name="dialogtitle">dummy</variable>
            <variable name="titleRegexp">true</variable>
            <variable name="expectedOutput"/>
            <variable name="checkOutput">true</variable>
            <variable name="autowinClient">autowinClient</variable>
            <comment>Start a native windows application as the SUT (system under test) using the dependency funtionality. This implies stopping the SUT when a different dependency is called or when the value of one of the characteristic variables (dialogtitle, executable, path, titleRegexp) changes as compared to the last time the dependency was called. For more information about dependencies please refer to the tutorial or the the manual, chapter 'Organizing the test-suite', section 'Dependency nodes'.


When starting the application you can specify via the parameter checkOutput that QF-Test retrieves the output written by the application to standard out during startup and compare it to the given expected output.

The global variable "window" is set to the dialogtitle. In the cleanup sequence it will be deleted again.

@param executable	The fully qualified name of the native windows application to be started.
		Instead of the fully qualified name you may also specify a path relative to the test-suite.
@param workdir	The working directory for the application.
@param dialogtitle	The title of the application window when it is first started.
@param titleRegexp	True (default) if the dialogtitle is specified as a regular expression, false otherwise. For more details on regular expressions please refer to the respective in the manual.
@param expectedOutput	The output that ought to appear in standard out during startup of the application. The parameter is only evaluated if the parameter checkOutput is set to true.
@param checkOutput	See above. 

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,ue
@since 4.2.3</comment>
            <SetupSequence id="_3Ac" name="start SUT if not running">
              <SetGlobalStep id="_1p6F" varname="window">
                <default>$(dialogtitle)</default>
                <comment>Set the global variable 'window' to the dialog title.</comment>
              </SetGlobalStep>
              <TryStep id="_2JI-"
                       name="Start application if not already running">
                <ProcedureCall id="_2JDl"
                               procedure="qfs.autowin.checkForExistence">
                  <variable name="title">$(dialogtitle)</variable>
                  <variable name="titleRegexp">$(titleRegexp)</variable>
                  <variable name="timeout">0</variable>
                  <variable name="errorLevel">EXCEPTION</variable>
                  <variable name="appearInReport">0</variable>
                </ProcedureCall>
                <CatchSequence exception="UserException" id="_2JDm"
                               maxerror="0">
                  <ServerScriptStep id="_2JJZ">
                    <code>p = rc.lookup("executable").replace("\\", "/")
rc.setLocal("exe", p)</code>
                  </ServerScriptStep>
                  <ShellClientStarter client="$(autowinClient)"
                                      command="$(exe)" directory="$(workdir)"
                                      id="_2JDq"/>
                  <TryStep id="_2JDu" name="check if SUT started">
                    <ProcedureCall id="_2JJ0"
                                   procedure="qfs.autowin.checkForExistence">
                      <variable name="title">$(dialogtitle)</variable>
                      <variable name="titleRegexp">$(titleRegexp)</variable>
                      <variable name="timeout">30000</variable>
                      <variable name="errorLevel">EXCEPTION</variable>
                      <variable name="appearInReport">0</variable>
                    </ProcedureCall>
                    <CatchSequence exception="UserException" id="_2JJ1"
                                   maxerror="0">
                      <ServerScriptStep id="_2JJ2">
                        <code>rc.setLocal("output", rc.lookup("qftest", "client.output.$(autowinClient)", expand=false))

</code>
                      </ServerScriptStep>
                      <ThrowStep id="_2JJ3"
                                 throwmessage="Error when starting $(executable)! Programmausgabe: &#34;$(output)&#34;"/>
                    </CatchSequence>
                  </TryStep>
                  <IfSequence id="_2JHv" test="$(checkOutput)">
                    <ServerScriptStep id="_2J9L">
                      <code>rc.setLocal("output", rc.lookup("qftest", "client.output.$(autowinClient)", expand=false))

</code>
                    </ServerScriptStep>
                    <IfSequence id="_2J9N"
                                test="rc.lookup(&#34;output&#34;) != &#34;$(expectedOutput)&#34;">
                      <ThrowStep id="_2J9M"
                                 throwmessage="Unexpected output when starting $(executable): &#34;$(output)&#34;"/>
                    </IfSequence>
                  </IfSequence>
                </CatchSequence>
              </TryStep>
            </SetupSequence>
            <CleanupSequence id="_2JDn" name="Close SUT">
              <TryStep id="_2JJ4" name="Close window">
                <ProcedureCall id="_2JDo"
                               procedure="qfs.autowin.checkForExistenceAndClose">
                  <variable name="title">$(dialogtitle)</variable>
                  <variable name="titleRegexp">$(titleRegexp)</variable>
                  <variable name="timeout">0</variable>
                  <variable name="errorLevel">EXCEPTION</variable>
                  <variable name="appearInReport">1</variable>
                  <variable name="close_timeout">2000</variable>
                  <variable name="close_errorLevel">EXCEPTION</variable>
                </ProcedureCall>
                <CatchSequence exception="UserException" id="_2JFN"
                               maxerror="0">
                  <catchmessage>Couldn't find window with title: '$(dialogtitle)'.</catchmessage>
                </CatchSequence>
                <CatchSequence exception="UserException" id="_2JFL"
                               maxerror="0">
                  <catchmessage>Couldn't close window with title: '$(dialogtitle)'.</catchmessage>
                  <ProcedureCall id="_2JLv" procedure="qfs.run-log.logError">
                    <variable name="message">Error when trying to close window '$(dialogtitle)'!
The process will be killed.</variable>
                    <variable name="withScreenshots">false</variable>
                  </ProcedureCall>
                </CatchSequence>
                <FinallySequence id="_2JLw"
                                 name="Make sure process is stopped">
                  <ClientStopper client="$(autowinClient)" id="_2JLN"/>
                  <ProcessWaiter client="$(autowinClient)" id="_2JLx"/>
                </FinallySequence>
              </TryStep>
              <ServerScriptStep id="_2JFP"
                                name="Delete global variable 'window'">
                <code>rc.setGlobal("window", None)</code>
              </ServerScriptStep>
            </CleanupSequence>
          </Dependency>
        </Package>
        <Package id="_2JFC" name="helpers">
          <comment>Procedures used internally by the package qfs.autowin.component.

@author	QFS
@since	4.2.3</comment>
          <Procedure id="_2JWH" name="checkIfWindows">
            <variable name="version"/>
            <comment>Check if the operation system is Microsoft Windows. If not throw a user exception.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param version	if not empty (default) check if the os version is equal or higher to the given version.
		valid values: the main version of the operating system e.g. 9, 10, 11

@author	QFS,ue
@since	4.2.4</comment>
            <IfSequence id="_2JWI" test="${qftest:windows}">
              <IfSequence id="_2JWJ"
                          test="&#34;$(version)&#34; != &#34;&#34;">
                <IfSequence id="_2JZY"
                            test="${qftest:os.mainversion} &lt; $(version)">
                  <ThrowStep id="_2JZZ"
                             throwmessage="The procedure runs on Microsoft Windows $(version) and higher only."/>
                </IfSequence>
              </IfSequence>
              <ElseSequence id="_2JZa" name="not windows">
                <ThrowStep id="_2JZb"
                           throwmessage="The procedure runs on Microsoft Windows only."/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JQx" name="dumpComponent">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <comment>Print information provided by the IUIAutomationElement Interface of the given GUI control to the QF-Test terminal: name, value, clickable point, class name, bounding rectangle, control type, automation id and methods.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JRP"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JQy"
                           procedure="qfs.autowin.component.getControl"/>
            <ServerScriptStep id="_2JQz">
              <code>import uiauto
global __uiauto_control

print "API of the control:              ------------------------------------------"
print dir(__uiauto_control)
try:
    print "name: ", __uiauto_control.getName()
except:
    print "no name"
try:
    print "value: ", __uiauto_control.getValue()
except:
    print "no value"
try:
    cp = __uiauto_control.getClickablePoint()
    print "clickable point: (%d,%d)" %(cp.x, cp.y)
except:
    print "no clickable point"
try:
    print "class name: ", __uiauto_control.getClassName()
except:
    print "no class name"
try:
    print "bounding rectangle: ", __uiauto_control.getBoundingRectangle()
except:
    try:
        print "bounding rectangle of underlying automation element: ", __uiauto_control.getElement().getBoundingRectangle()
    except:
        print "no bounding rectangle"
try:
    controlTypeValue = __uiauto_control.getElement().getControlType()
    print "control type: ", uiauto.getControlTypeByValue(controlTypeValue)
except:
    print "no control type"
try:
    print "automation id: ", __uiauto_control().getElement().getAutomationId()
except:
    print "no automation id"
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JJ6" name="dumpComponents">
            <variable name="window"/>
            <variable name="maxDepth">6</variable>
            <comment>Print name, class name, control type and automation id of controls in the given windows to the QF-Test terminal. The data is only listed if it is defined in the IUIAutomationElement Interface of the respective GUI control.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param window	The title of the window containing the GUI element. It has to be a regular expression.
@param maxDepth	Defines to which level the children of nested components are processed. Default: 6

@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JRQ"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ServerScriptStep id="_2JBb">
              <code>import uiauto

winName = rc.lookup("window")

if winName:
    __uiauto_window = uiauto.getDesktopWindow(qf.asPattern(winName),1)
        
    uiauto.dumpControls(__uiauto_window, rc.getInt("maxDepth"))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2J37" name="dumpComponentsToFile">
            <variable name="window"/>
            <variable name="maxDepth">6</variable>
            <variable name="file"/>
            <comment>Write name, class name, control type and automation id of controls in the given windows to a file. The data is only listed if it is defined in the IUIAutomationElement Interface of the respective GUI control.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param window	The title of the window containing the GUI element. It has to be a regular expression.
@param maxDepth	Defines to which level the children of nested components are processed. Default: 6
@param file		The file where to write the data to. Either a fully qualified file name or with a path relative to the test-suite.

@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JRR"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ServerScriptStep id="_2J38">
              <code>import uiauto

winName = rc.lookup("window")
if winName:
    __uiauto_window = uiauto.getDesktopWindow(qf.asPattern(winName),1)
        
uiauto.dumpControlsToFile(rc.lookup("file"), __uiauto_window, rc.getInt("maxDepth"))
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1xN-" name="dumpDesktopWindows">
            <comment>Print the titles of all windows on the desktop of Microsoft Windows to the QF-Test terminal.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JRS"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ServerScriptStep id="_1xO0">
              <code>import uiauto

windows = uiauto.getDesktopWindows()

for window in windows:
    print "%s: %s" % (window.getNativeWindowHandle().toString(), window.getName())
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JOX" name="setWindowToForeground">
            <variable name="title"/>
            <variable name="titleRegexp">true</variable>
            <comment>Set the window with the given title to the foreground on the desktop.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws ComponentNotFoundException if the window is not found

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure. For simple cases, the qfs.utils.setWindowToForeground method can be used.
@author QFS,ue
@since 4.2.3</comment>
            <ProcedureCall id="_2JRT"
                           procedure="qfs.autowin.helpers.checkIfWindows"/>
            <ServerScriptStep id="_2JOY" name="Set window to foreground">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))

if window != None:
    window.setForeground()
else:
    raise ComponentNotFoundException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_2JMJ" name="component">
          <comment>Basic procedures for interacting with a component of a native windows application.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author	QFS
@since	4.2.3</comment>
          <Procedure id="_2JMK" name="checkGeometry">
            <variable name="left"/>
            <variable name="top"/>
            <variable name="width"/>
            <variable name="height"/>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Check the position, width and height of the component on the screen.

@param 	left	The expected number of pixels from the left border of the screen to the left border of the component. 
		Empty string: skip check.
@param 	top	The expected number of pixels from the top of the screen to the top of the component. 
		Empty string: skip check.
@param 	width	The expected number of pixels for the width of the component. 
		Empty string: skip check.
@param 	height	The expected number of pixels for the height of the component. 
		Empty string: skip check.
@param 	errorLevel   	The kind of error, which should be logged. 
		Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZd"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JML" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <SetGlobalStep id="_2JMM" local="true" varname="now">
              <default>$(start)</default>
            </SetGlobalStep>
            <WhileSequence id="_2JMN"
                           test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &lt; rc.getInt(&#34;timeout&#34;)">
              <TryStep id="_2JMO">
                <ProcedureCall id="_2JMP" procedure=".waitForComponent">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2JMQ">
                  <code>global __uiauto_control

level = rc.EXCEPTION

appearInReport = rc.getInt("appearInReport")
    
rec = __uiauto_control.getBoundingRectangle()

left = rec.left
right = rec.right
top = rec.top
bottom = rec.bottom
height = bottom - top
width = right - left

if rc.lookup("left") != "":
    rc.checkEqual(left, rc.getInt("left"), 'Left', level, appearInReport)
if rc.lookup("top") != "":
    rc.checkEqual(top, rc.getInt("top"), 'Top', level, appearInReport)
if rc.lookup("height") != "":
    rc.checkEqual(height, rc.getInt("height"), 'Height', level, appearInReport)
if rc.lookup("width") != "":
    rc.checkEqual(width, rc.getInt("width"), 'Width', level, appearInReport)</code>
                </ServerScriptStep>
                <ReturnStep id="_2JMR"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JMS" maxerror="0"/>
                <CatchSequence exception="UserException" id="_2JQr"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JMT" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
            </WhileSequence>
            <TestStep id="_2JMU" name="Last try if time is up">
              <ProcedureCall id="_2JMV" procedure=".waitForComponent">
                <variable name="timeout">500</variable>
              </ProcedureCall>
              <ServerScriptStep id="_2JMW">
                <code>global __uiauto_control

level = rc.ERROR
if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")
    
rec = __uiauto_control.getBoundingRectangle()

left = rec.left
right = rec.right
top = rec.top
bottom = rec.bottom
height = bottom - top
width = right - left

if rc.lookup("left") != "":
    rc.checkEqual(left, rc.getInt("left"), 'Left', level, appearInReport)
if rc.lookup("top") != "":
    rc.checkEqual(top, rc.getInt("top"), 'Top', level, appearInReport)
if rc.lookup("height") != "":
    rc.checkEqual(height, rc.getInt("height"), 'Height', level, appearInReport)
if rc.lookup("width") != "":
    rc.checkEqual(width, rc.getInt("width"), 'Width', level, appearInReport)</code>
              </ServerScriptStep>
            </TestStep>
          </Procedure>
          <Procedure id="_2JMX" name="checkImage">
            <variable name="target"/>
            <variable name="algorithm">algorithm=similarity;expected=0.99</variable>
            <variable name="best">True</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="window"/>
            <variable name="automationId"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Check the image of a given component. The target image has to be provided as PNG-file. QF-Test tries to match this image to the image of the component on the screen by using an advanced image check algorithm.

@param	target	An image as PNG-file, e.g. C:\temp\target.png
@param	algorithm	The algorithm used for finding the target. 
		Best is to use the default one and adjust match probability if necessary.
@param	best	True means to find the best match. 
		False means to find the first match which is better than the defined probability.
@param 	errorLevel   	The kind of error to be logged. 
		Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZe"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JMY" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="120" id="_2JMZ"
                            name="Repeat till found or timeout reached">
              <comment>with a loop time of min 1 s max timeout results in at least 2 min</comment>
              <TryStep id="_2JMa" name="image found?">
                <ProcedureCall id="_2JMb" local="true"
                               procedure=".getGeometry" retvarname="geometry">
                  <variable name="timeout">1000</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2JMc"
                                  name="fetch geometry of the component">
                  <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                </ServerScriptStep>
                <ProcedureCall id="_2JMd"
                               procedure="qfs.autoscreen.screen.getPositionOfImage">
                  <variable name="target">$(target)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                  <variable name="width">$(width)</variable>
                  <variable name="height">$(height)</variable>
                  <variable name="algorithm">$(algorithm)</variable>
                  <variable name="best">$(best)</variable>
                </ProcedureCall>
                <BreakStep id="_2JMe"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JMf" maxerror="0"/>
                <CatchSequence exception="UserException" id="_2JQs"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JMg" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2JMh" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2JMi" local="true"
                               procedure=".getGeometry" retvarname="geometry">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2JMj"
                                  name="fetch geometry of the component">
                  <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                </ServerScriptStep>
                <IfSequence id="_2JMk"
                            test="&#34;$(errorLevel)&#34; == &#34;ERROR&#34;">
                  <BasicSequence id="_2JMl" maxerror="2"
                                 name="Reduce max. errorlevel to &#34;Error&#34;">
                    <ProcedureCall id="_2JMm"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </BasicSequence>
                  <ElseifSequence id="_2JMn"
                                  test="&#34;$(errorLevel)&#34; == &#34;WARNING&#34;">
                    <BasicSequence id="_2JMo" maxerror="1"
                                   name="Reduce max. errorlevel to &#34;Warning&#34;">
                      <ProcedureCall id="_2JMp"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseifSequence id="_2JMq"
                                  test="&#34;$(errorLevel)&#34; == &#34;MESSAGE&#34;">
                    <BasicSequence id="_2JMr" maxerror="0"
                                   name="Reduce max. errorlevel to &#34;Message&#34;">
                      <ProcedureCall id="_2JMs"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseSequence id="_2JMt" name="EXCEPTION">
                    <ProcedureCall id="_2JMu"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
                <BreakStep id="_2JMv"/>
              </IfSequence>
              <ElseSequence id="_2JMw" name="one last try">
                <ProcedureCall id="_2JMx" local="true"
                               procedure=".getGeometry" retvarname="geometry">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ServerScriptStep id="_2JMy"
                                  name="fetch geometry of the component">
                  <code>left,top,width,height = rc.lookup("geometry").split(",")

rc.setLocal("x", left)
rc.setLocal("y", top) 
rc.setLocal("width", width)            
rc.setLocal("height", height)
</code>
                </ServerScriptStep>
                <IfSequence id="_2JMz"
                            test="&#34;$(errorLevel)&#34; == &#34;ERROR&#34;">
                  <BasicSequence id="_2JM+" maxerror="2"
                                 name="Reduce max. errorlevel to &#34;Error&#34;">
                    <ProcedureCall id="_2JM-"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </BasicSequence>
                  <ElseifSequence id="_2JN0"
                                  test="&#34;$(errorLevel)&#34; == &#34;WARNING&#34;">
                    <BasicSequence id="_2JN1" maxerror="1"
                                   name="Reduce max. errorlevel to &#34;Warning&#34;">
                      <ProcedureCall id="_2JN2"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseifSequence id="_2JN3"
                                  test="&#34;$(errorLevel)&#34; == &#34;MESSAGE&#34;">
                    <BasicSequence id="_2JN4" maxerror="0"
                                   name="Reduce max. errorlevel to &#34;Message&#34;">
                      <ProcedureCall id="_2JN5"
                                     procedure="qfs.autoscreen.screen.getPositionOfImage">
                        <variable name="target">$(target)</variable>
                        <variable name="x">$(x)</variable>
                        <variable name="y">$(y)</variable>
                        <variable name="width">$(width)</variable>
                        <variable name="height">$(height)</variable>
                        <variable name="algorithm">$(algorithm)</variable>
                        <variable name="best">$(best)</variable>
                      </ProcedureCall>
                    </BasicSequence>
                  </ElseifSequence>
                  <ElseSequence id="_2JN6" name="EXCEPTION">
                    <ProcedureCall id="_2JN7"
                                   procedure="qfs.autoscreen.screen.getPositionOfImage">
                      <variable name="target">$(target)</variable>
                      <variable name="x">$(x)</variable>
                      <variable name="y">$(y)</variable>
                      <variable name="width">$(width)</variable>
                      <variable name="height">$(height)</variable>
                      <variable name="algorithm">$(algorithm)</variable>
                      <variable name="best">$(best)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_2JN8" name="checkName">
            <variable name="expectedName"/>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="timeout">10000</variable>
            <comment>Compare the given name to the name of a component according to the compareMode.

@param 	expectedName	The expected value.
@param	checkMessage	The message, which should be written into the run-log for that check.
@param	compareMode	The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@throws  UserException, if wrong comparison mode has been set.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZf"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JN9" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="120" id="_2JNA">
              <TryStep id="_2JNB" name="check value">
                <ProcedureCall id="_2JNC" local="true" procedure=".getName"
                               retvarname="componentName">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JND"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentName)</variable>
                  <variable name="expected">$(expectedName)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">EXCEPTION</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <BreakStep id="_2JNE"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JNF" maxerror="0">
                  <BasicSequence id="_2JNG" name="Wait 0,5 s"
                                 postdelay="500"/>
                </CatchSequence>
                <CatchSequence exception="UserException" id="_2JQt"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JNH" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2JNI" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2JNJ" local="true" procedure=".getName"
                               retvarname="componentName">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNK"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentText)</variable>
                  <variable name="expected">$(expectedText)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <BreakStep id="_2JNL"/>
              </IfSequence>
              <ElseSequence id="_2JNM" name="one last try">
                <ProcedureCall id="_2JNN" local="true" procedure=".getName"
                               retvarname="componentName">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNO"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentText)</variable>
                  <variable name="expected">$(expectedText)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_2JNP" name="checkText">
            <variable name="expectedText"/>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="timeout">10000</variable>
            <comment>Wrapper procedure to either check the value of a component or, if no value exists, the name.

@param 	expectedText	The expected text.
@param	checkMessage	The message, which should be written into the run-log for that check.
@param	compareMode	The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@throws  UserException, if wrong comparison mode has been set.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZg"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JNQ" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <SetGlobalStep id="_2JNR" local="true" varname="now">
              <default>$(start)</default>
            </SetGlobalStep>
            <WhileSequence id="_2JNS"
                           test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &lt; rc.getInt(&#34;timeout&#34;)">
              <TryStep id="_2JNT">
                <ProcedureCall id="_2JNU" local="true" procedure=".getText"
                               retvarname="componentText">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNV"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentText)</variable>
                  <variable name="expected">$(expectedText)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <ReturnStep id="_2JNW"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JNX" maxerror="0"/>
                <CatchSequence exception="UserException" id="_2JQu"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JNY" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
            </WhileSequence>
            <TestStep id="_2JNZ" name="Last try if time is up">
              <ProcedureCall id="_2JNa" local="true" procedure=".getText"
                             retvarname="componentText">
                <variable name="timeout">500</variable>
              </ProcedureCall>
              <ProcedureCall id="_2JNb"
                             procedure="qfs.check.compareTwoStringValues">
                <variable name="got">$(componentText)</variable>
                <variable name="expected">$(expectedText)</variable>
                <variable name="checkMessage">$(checkMessage)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </TestStep>
          </Procedure>
          <Procedure id="_2JNc" name="checkValue">
            <variable name="expectedValue"/>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <variable name="timeout">10000</variable>
            <comment>Compare the given value to the value of a component according to the compareMode.

@param 	expectedValue	The expected value.
@param	checkMessage	The message, which should be written into the run-log for that check.
@param	compareMode	The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                	If this is set to 1, the check will be shown in the report.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@throws  UserException, if wrong comparison mode has been set.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZh"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JNd" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="120" id="_2JNe">
              <TryStep id="_2JNf" name="check value">
                <ProcedureCall id="_2JNg" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNh"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentValue)</variable>
                  <variable name="expected">$(expectedValue)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">EXCEPTION</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <BreakStep id="_2JNi"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JNj" maxerror="0" regexp="true"/>
                <CatchSequence exception="UserException" id="_2JQv"
                               maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JNk" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2JNl" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2JNm" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNn"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentValue)</variable>
                  <variable name="expected">$(expectedValue)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
                <BreakStep id="_2JNo"/>
              </IfSequence>
              <ElseSequence id="_2JNp" name="one last try">
                <ProcedureCall id="_2JNq" local="true" procedure=".getValue"
                               retvarname="componentValue">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <ProcedureCall id="_2JNr"
                               procedure="qfs.check.compareTwoStringValues">
                  <variable name="got">$(componentText)</variable>
                  <variable name="expected">$(expectedText)</variable>
                  <variable name="checkMessage">$(checkMessage)</variable>
                  <variable name="compareMode">$(compareMode)</variable>
                  <variable name="errorLevel">$(errorLevel)</variable>
                  <variable name="appearInReport">$(appearInReport)</variable>
                </ProcedureCall>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_2JNs" name="click">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Click a given component.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZi"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JNt" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JNu">
              <code>global __uiauto_control

try:
    if ${default:debug:false}: print "Click component"
    __uiauto_control.click()
except:
    if ${default:debug:false}: print "Try robot"

    from java.awt import Robot
    robot = Robot()

    point = __uiauto_control.getClickablePoint()
    if point.x == 0 and point.y == 0:
        try:
            __uiauto_control.focus()
        except:
            pass
        point = __uiauto_control.getClickablePoint()
    robot.mouseMove(point.x,point.y)
    robot.mousePress(16)
    robot.mouseRelease(16)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JNv" name="getControl">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Set the global variable __uiauto_control to the GUI element matching the given parameters in the given window.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3</comment>
            <ProcedureCall id="_2JZj"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ServerScriptStep id="_2JNy">
              <code>import uiauto
global __uiauto_control

winName = rc.lookup("window")
try:
    __uiauto_window = uiauto.getDesktopWindow(qf.asPattern(winName),1)
except:
    raise ComponentNotFoundException("Window '%s' could not be found" %winName)

automationId = rc.lookup("automationId")
if automationId:
    try:
        __uiauto_control = __uiauto_window.getControlByAutomationId(automationId)
    except:
        raise ComponentNotFoundException("Component with automationId '%s' not found!" % automationId)
else:
    name = rc.lookup("name")
    index = rc.lookup("index")
    controlTypeName = rc.lookup("controlType")
    className = rc.lookup("className")
    if controlTypeName:
       controlType = uiauto.getControlTypeByName(controlTypeName)  #Control type object(!) holen
       if name:
           try:
                __uiauto_control = __uiauto_window.getControlByControlType(qf.asPattern(name),controlType)
           except:
               raise ComponentNotFoundException("Component with controlType '%s' and name '%s' (as a regular expression) not found!" % (controlTypeName, name))
       elif index:
           try:
                __uiauto_control = __uiauto_window.getControlByControlType(rc.getInt("index"), controlType)
           except:
               raise ComponentNotFoundException("Component with controlType '%s' and index '%s' not found!" % (controlTypeName, index))
       else:
           try:
                __uiauto_control = __uiauto_window.getControlByControlType(0,controlType)
           except:
               raise ComponentNotFoundException("No component with controlType '%s' found!" % controlTypeName)

    elif className:
       if name:
           try:
                __uiauto_control = __uiauto_window.getControlByClassName(qf.asPattern(name),className)
           except:
               raise ComponentNotFoundException("Component with class name '%s' and name '%s' (as a regular expression) not found!" % (className, name))
       elif index:
           try:
                __uiauto_control = __uiauto_window.getControlByClassName(rc.getInt("index"), className)
           except:
               raise ComponentNotFoundException("Component with className '%s' and index '%s' not found!" % (className, index))
       else:
           try:
                __uiauto_control = __uiauto_window.getControlByClassName(0,className)
           except:
               raise ComponentNotFoundException("No component with class name '%s' found!" % className)
    else:
        try:
            __uiauto_control = __uiauto_window.getControlByName(qf.asPattern(name))
        except:
            raise ComponentNotFoundException("No Component with name '%s' (as a regular expression) found!" % name)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JNz" name="getGeometry">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Fetch the screen coordinates for the left border, top, width and height for the component.

@return	The geometry data as a comma-separaed list: left,top,width,height.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZk"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JN+" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JN-" name="get position of checkmark">
              <code>global __uiauto_control

rec = __uiauto_control.getBoundingRectangle()

left = rec.left
right = rec.right
top = rec.top
bottom = rec.bottom
height = bottom - top
width = right - left

rc.setLocal("retVal", "%s,%s,%s,%s" % (left, top, width, height))</code>
            </ServerScriptStep>
            <ReturnStep id="_2JO0" retval="$(retVal)"/>
          </Procedure>
          <Procedure id="_2JO1" name="getName">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Return the name of the given control.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@return  	The name of the component.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZl"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JO2" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JO3">
              <code>global __uiauto_control

rc.setLocal("currentText", __uiauto_control.getName())
</code>
            </ServerScriptStep>
            <ReturnStep id="_2JO4" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_2JO5" name="getText">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Return the value or, if it does not exist, the name of the given control.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@return  	The value or name of the component.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3


</comment>
            <ProcedureCall id="_2JZm"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JO6" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JO7">
              <code>global __uiauto_control

try:
    text = __uiauto_control.getValue()
    if ${default:debug:false}: print "Value: ", text
except:
    try:
        text = __uiauto_control.getText()
        if ${default:debug:false}: print "Value: ", text
    except:
        try:
            text = __uiauto_control.getName()
            if ${default:debug:false}: print "Name: ", text
        except:
             raise UserException('The compontent supports neither getName() nor getValue()')
        
if text == "&lt;Empty&gt;":
    text = __uiauto_control.getName()
    if ${default:debug:false}: print "Name: ", text

rc.setLocal("retVal", text)
</code>
            </ServerScriptStep>
            <ReturnStep id="_2JO8" retval="$(retVal)"/>
          </Procedure>
          <Procedure id="_2JO9" name="getValue">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Return the value of the given control.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@return  	The value of the component.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZn"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JOA" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JOB">
              <code>global __uiauto_control

rc.setLocal("retVal", __uiauto_control.getValue())
</code>
            </ServerScriptStep>
            <ReturnStep id="_2JOC" retval="$(retVal)"/>
          </Procedure>
          <Procedure id="_2JOD" name="setText">
            <variable name="text"/>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Set a given text to a component if the method setText() is implemented by the IUIAutomationElement Interface of the component. If not try setValue() instead.

@param 	text	Text to be set.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZo"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JOE" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JOF">
              <code>global __uiauto_control

text = rc.lookup("text")
__uiauto_control.setText(text)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JOG" name="setValue">
            <variable name="value"/>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Set a given value to a component.


@param 	value	The value to be set.
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZp"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JOH" procedure=".waitForComponent"/>
            <ServerScriptStep id="_2JOI">
              <code>global __uiauto_control

val = rc.lookup("value")
__uiauto_control.setValue(val)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JOJ" name="waitForComponent">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="automationId"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Set the global variable __uiauto_control to the GUI element matching the given parameters in the given window. Wait for the component for timeout ms at the most. 

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

@throws	ComponentNotFoundException 	If the component is not found within the given time.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author 	QFS,ue
@since 	4.2.3</comment>
            <ProcedureCall id="_2JZq"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JOK" local="true"
                           procedure="qfs.utils.getTimestamp"
                           retvarname="start"/>
            <RepeatSequence count="600" id="_2JOL"
                            name="Repeat till found or timeout reached">
              <comment>with a loop time of min 0,5 s max timeout results in at least 5 min</comment>
              <TryStep id="_2JOM" name="get control">
                <ProcedureCall id="_2JON" procedure=".getControl">
                  <variable name="timeout">500</variable>
                </ProcedureCall>
                <BreakStep id="_2JOO"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_2JOP" maxerror="0"/>
              </TryStep>
              <ProcedureCall id="_2JOR" local="true"
                             procedure="qfs.utils.getTimestamp"
                             retvarname="now"/>
              <IfSequence id="_2JOS" name="one last try if time is up"
                          test="rc.getInt(&#34;now&#34;) - rc.getInt(&#34;start&#34;) &gt; rc.getInt(&#34;timeout&#34;)">
                <ProcedureCall id="_2JOT" procedure=".getControl">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
                <BreakStep id="_2JOU"/>
              </IfSequence>
              <ElseSequence id="_2JOV" name="one last try">
                <ProcedureCall id="_2JOW" procedure=".getControl">
                  <variable name="timeout">0</variable>
                </ProcedureCall>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
        </Package>
        <Package id="_2JJM" name="menu">
          <comment>Procedures to select menu items and checkbox menu items in native windows applications.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author	QFS
@since	4.2.3</comment>
          <Procedure id="_2JJN" name="selectItem">
            <variable name="window"/>
            <variable name="menuName"/>
            <variable name="menuControlType"/>
            <variable name="menuAutomationId"/>
            <variable name="menuIndex"/>
            <variable name="menuClassName"/>
            <variable name="itemName"/>
            <variable name="itemControlType"/>
            <variable name="itemAutomationId"/>
            <variable name="itemIndex"/>
            <variable name="itemClassName"/>
            <variable name="timeout">10000</variable>
            <comment>Select an item from a menu.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	menuAutomationId	The AutomationId of the GUI element.
@param 	menuName	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	menuControlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	menuIndex	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	menuClassName	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 

@param 	itemAutomationId	The AutomationId of the GUI element.
@param 	itemName	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	itemControlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	itemIndex	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	itemClassName	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3
</comment>
            <ProcedureCall id="_2JZr"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JJO" procedure="..component.click">
              <variable name="window">$(window)</variable>
              <variable name="name">$(menuName)</variable>
              <variable name="controlType">$(menuControlType)</variable>
              <variable name="index">$(menuIndex)</variable>
              <variable name="automationId">$(menuAutomationId)</variable>
              <variable name="className">$(menuClassName)</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JDy" procedure="..component.click">
              <variable name="window">$(window)</variable>
              <variable name="name">$(itemName)</variable>
              <variable name="controlType">$(itemControlType)</variable>
              <variable name="index">$(itemIndex)</variable>
              <variable name="automationId">$(itemAutomationId)</variable>
              <variable name="className">$(itemClassName)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_2JJP" name="checkbox">
          <comment>Procedures to get and set the state of checkboxes in native windows applications.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by the procedures in this package.
@author	QFS
@since	4.2.3</comment>
          <Procedure id="_2JAG" name="checkValue">
            <variable name="expectedValue">true</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="automationId"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Check the value of the given component.

Write an error into the run-log or throw an exception, if the check fails.

@param expectedValue	true if the checkbox should be checked (on), false otherwise.
@param errorLevel	ERROR or EXCEPTION
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3
</comment>
            <ProcedureCall id="_2JZs"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2JAK" local="true" procedure=".getValue"
                           retvarname="actValue"/>
            <IfSequence id="_2JAM" test="$(expectedValue)!= $(actValue)">
              <IfSequence id="_2JAN"
                          test="&#34;$(errorLevel)&#34; == &#34;EXCEPTION&#34;">
                <ThrowStep id="_2JAO"
                           throwmessage="Checkbox should be checked: $(expectedValue). Got: $(actValue)"/>
                <ElseSequence id="_2JAP">
                  <ProcedureCall id="_2JAL" procedure="qfs.run-log.logError">
                    <variable name="message">Checkbox should be checked: $(expectedValue). Got: $(actValue)</variable>
                    <variable name="withScreenshots">true</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JJQ" name="deselect">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="automationId"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Deselect a checkbox. If the checkbox is already deselected, no action is performed.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3

</comment>
            <ProcedureCall id="_2JZt"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2J9v" local="true" procedure=".getValue"
                           retvarname="isChecked"/>
            <IfSequence id="_2J9w" test="$(isChecked)">
              <ProcedureCall id="_2J9x" procedure="..component.click"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JJR" name="getValue">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="automationId"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Return the value of a checkbox.
It's either 1 if box is selected or 0 if box is not selected.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@return	The state of the checkbox.

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3

</comment>
            <ProcedureCall id="_2JZu"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2J9n" local="true"
                           procedure="..component.waitForComponent"
                           retvarname="isChecked"/>
            <ServerScriptStep id="_2J9q">
              <code>global __uiauto_control

status = __uiauto_control.getToggleState().getValue()
rc.setLocal("state", status)
</code>
            </ServerScriptStep>
            <ReturnStep id="_2JJS" retval="$(state)"/>
          </Procedure>
          <Procedure id="_2JJT" name="select">
            <variable name="window"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="automationId"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3

</comment>
            <ProcedureCall id="_2JZv"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <ProcedureCall id="_2J9m" local="true" procedure=".getValue"
                           retvarname="isChecked"/>
            <IfSequence id="_2J9u" test="not $(isChecked)">
              <ProcedureCall id="_2J9t" procedure="..component.click"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JJU" name="set">
            <variable name="check">true</variable>
            <variable name="window"/>
            <variable name="name"/>
            <variable name="controlType"/>
            <variable name="index"/>
            <variable name="automationId"/>
            <variable name="className"/>
            <variable name="timeout">10000</variable>
            <comment>Set checkbox to the given state.

@param	check	The check value to be set (either true or false).
@param 	window	The title of the window containing the GUI element. 
		It has to be a regular expression.
@param 	automationId	The AutomationId of the GUI element.
@param 	name	The name of the GUI element as a regular expression. 
		Either alone or in combination with controlType or className.
@param 	controlType	The ControlType of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
		The allowed control types are defined by the IUIAutomationElement Interface. 
		Examples: Button, CheckBox, ComboBox, DataGrid, Edit, List, Tab, Text.
@param 	index	The index of the GUI element of the given control type. 
		Only in combination with controlType or className.
@param 	className	The class name of the GUI element. 
		Can be combined with name or index. 
		If neither name nor index is given then index 0 is assumed. 
@param 	timeout	The time in ms to wait for the component.

&lt;p&gt;Parameter precedences: &lt;/p&gt;
1. automationId takes precedence over the rest. 
2. controlType alone or in combination with name or index takes precedence over the rest.
3. className alone or in combination with name or index takes precedence over name only.
4. name

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author	QFS,ue
@since	4.2.3
</comment>
            <ProcedureCall id="_2JZw"
                           procedure="qfs.autowin.helpers.checkIfWindows">
              <variable name="version">10</variable>
            </ProcedureCall>
            <IfSequence id="_2JJV" test="$(check)">
              <ProcedureCall id="_2JJW" procedure=".select">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ElseSequence id="_2JJX">
                <ProcedureCall id="_2JJY" procedure=".deselect">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Procedure id="qfs.autowin.checkForExistenceAndClose"
                   name="checkForExistenceAndClose" uid="_1j+r">
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <variable name="timeout">15000</variable>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <variable name="close_timeout">2000</variable>
          <variable name="close_errorLevel">ERROR</variable>
          <comment>Check, whether a native window on the operating system Windows is opened and close it.
If the window is a result of your test you can configure it to provide an error or an exception, if the window does not appear.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.
@param  timeout   The timeout to wait for the dialog to appear.
@param errorLevel  MESSAGE if a message should be logged in case the window is not visible.
	WARNING if a warning should be logged in case the window is not visible.
	EXCEPTION if an exception should be raised in case the window is not visible.
	in any other case an error will be logged in case the window is not visible.
@param appearInReport  set this to 1, if you want to track a message or warning, which should also be part of the report later.
@param close_timeout    Timeout how long to wait till window disappears after closing.
@param close_errorLevel  MESSAGE if a message should be logged in case the window wasn't closed.
	WARNING if a warning should be logged in case the window wasn't closed.
	EXCEPTION if an exception should be raised in case the window wasn't closed.
	in any other case an error will be logged in case the window wasn't closed.


@throws UserException if window is not visible and parameter errorLevel is set to EXCEPTION or if window hasn't been closed and close_errorLevel is set to EXCEPTION.

@author QFS,mm
@since 3.1.4</comment>
          <ProcedureCall id="_2JRI"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ProcedureCall id="_1j+E" procedure="qfs.autowin.checkForExistence">
            <variable name="title">$(title)</variable>
            <variable name="titleRegexp">$(titleRegexp)</variable>
            <variable name="timeout">$(timeout)</variable>
            <variable name="errorLevel">$(errorLevel)</variable>
            <variable name="appearInReport">$(appearInReport)</variable>
          </ProcedureCall>
          <ProcedureCall id="_1j+F" procedure="qfs.autowin.close">
            <variable name="timeout">$(close_timeout)</variable>
            <variable name="errorLevel">$(close_errorLevel)</variable>
            <variable name="title">$(title)</variable>
            <variable name="titleRegexp">$(titleRegexp)</variable>
            <variable name="appearInReport">$(appearInReport)</variable>
          </ProcedureCall>
        </Procedure>
        <Procedure id="qfs.autowin.checkForExistence" name="checkForExistence"
                   uid="_1j+s">
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <variable name="timeout">15000</variable>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Check, whether a native window on the operating system Windows is opened.
If the window is a result of your test you can configure it to provide an error or an exception, if the window does not appear.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.
@param  timeout   The timeout to wait for the dialog to appear.
@param errorLevel  MESSAGE if a message should be logged in case the window is not visible.
	WARNING if a warning should be logged in case the window is not visible.
	EXCEPTION if an exception should be raised in case the window is not visible.
	in any other case an error will be logged in case the window is not visible.
@param appearInReport  set this to 1, if you want to track a message or warning, which should also be part of the report later.

@throws UserException if window is not visible and parameter errorLevel is set to EXCEPTION

@author QFS,mm
@since 3.1.4</comment>
          <ProcedureCall id="_2JRJ"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ServerScriptStep id="_1j+B" name="find window and log result">
            <code>import autowin

appearInReport = rc.getInt("appearInReport")
window = autowin.waitForWindow(rc.getNum("timeout"), rc.lookup("title"), rc.getBool("titleRegexp"))

if window == None:
    if rc.lookup("errorLevel").upper() == "EXCEPTION":
        raise UserException("Couldn't find window with title: '" + rc.lookup("title") + "'.")
    elif rc.lookup("errorLevel").upper() == "WARNING":
        rc.logWarning("Couldn't find window with title: '" + rc.lookup("title") + "'.", report=appearInReport)
    elif rc.lookup("errorLevel").upper() == "MESSAGE":
        rc.logMessage("Couldn't find window with title: '" + rc.lookup("title") + "'.", report=appearInReport)
    else:
        rc.logError("Couldn't find window with title: '" + rc.lookup("title") + "'.")

</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.autowin.close" name="close" uid="_1j+t">
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <variable name="appearInReport">1</variable>
          <variable name="timeout">2000</variable>
          <variable name="errorLevel">ERROR</variable>
          <comment>Close a window.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false
@param appearInReport  set this to 1, if you want to track a message or warning, which should also be part of the report later.
@param timeout    Timeout how long to wait till window disappears
@param errorLevel  MESSAGE if a message should be logged in case the window wasn't closed.
	WARNING if a warning should be logged in case the window wasn't closed.
	EXCEPTION if an exception should be raised in case the window wasn't closed.
	in any other case an error will be logged in case the window wasn't closed.

@throws UserException if window wasn't closed and parameter errorLevel is set to EXCEPTION

@author QFS,mm
@since 3.1.4</comment>
          <ProcedureCall id="_2JRK"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <SetGlobalStep id="_1oHH" local="true" varname="iMaxWait">
            <default>$[$(timeout)/500]</default>
          </SetGlobalStep>
          <ServerScriptStep id="_1j+A" name="find and close window">
            <code>import autowin

appearInReport = rc.getInt("appearInReport")
window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))

if window == None:
	rc.logMessage("Couldn't find window with title: '" + rc.lookup("title") + "'.", report=appearInReport)
else:
	autowin.closeWindow(window, True)


</code>
          </ServerScriptStep>
          <RepeatSequence count="$(iMaxWait)" id="waitForAutowinWindowToClose"
                          name="waitForWindowToClose" uid="_1oHJ">
            <ProcedureCall id="_1oCR" procedure="qfs.utils.sleep">
              <variable name="sleeptime">500</variable>
            </ProcedureCall>
            <SetGlobalStep id="_1oHL" local="true" varname="bFound">
              <default>true</default>
            </SetGlobalStep>
            <ServerScriptStep id="_1oHP" name="find window">
              <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))

if window == None:
	rc.setLocal("bFound", "false")
else:
	rc.setLocal("bFound", "true")


</code>
            </ServerScriptStep>
            <IfSequence id="_1oHM" name="window is closed"
                        test="(not $(bFound))">
              <BreakStep id="_1oHN" loopid="waitForAutowinWindowToClose"/>
            </IfSequence>
          </RepeatSequence>
          <ServerScriptStep id="_1oCQ"
                            name="check for existence and throw error if required">
            <code>import autowin

appearInReport = rc.getInt("appearInReport")
window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))

if window != None:
    if rc.lookup("errorLevel").upper() == "EXCEPTION":
        raise UserException("Couldn't close window with title: '" + rc.lookup("title") + "'.")
    elif rc.lookup("errorLevel").upper() == "WARNING":
        rc.logWarning("Couldn't close window with title: '" + rc.lookup("title") + "'.", report=appearInReport)
    elif rc.lookup("errorLevel").upper() == "MESSAGE":
        rc.logMessage("Couldn't close window with title: '" + rc.lookup("title") + "'.", report=appearInReport)
    else:
        rc.logError("Couldn't close window with title: '" + rc.lookup("title") + "'.")



</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.autowin.getURLFromIE" name="getURLFromIE"
                   uid="_1kHi">
          <variable name="title">.*Internet Explorer.*</variable>
          <variable name="titleRegexp">true</variable>
          <comment>Read the URL from an InternetExplorer window.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws UserException if the browser window is not visible or the URL cannot be determined.

@author QFS
@since 3.2.0</comment>
          <ProcedureCall id="_2JRL"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ServerScriptStep id="_1j+i">
            <code>import autowin

browserWnd = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
rc.logMessage("browserWnd: %s" % browserWnd)
if not browserWnd:
    raise UserException("Browser window not found.")

abr = autowin.findChildWindows(browserWnd, clazz="Address Band Root")
rc.logMessage("abr: %s" % abr)
if not abr:
    # Legacy attempt for IE6
    abr = autowin.findChildWindows(browserWnd, clazz="ReBarWindow32")
    if not abr:
        raise UserException("Address Band Root not found.")

edt = autowin.findChildWindows(abr[0], clazz="Edit")
rc.logMessage("edt: %s" % edt)
if not edt:
    raise UserException("Edit not found.")
ret = autowin.getWindowText(edt[0])
rc.logMessage("returning %s" % ret)
raise ReturnException(ret)</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.autowin.logChildWindows" name="logChildWindows"
                   uid="_1kHj">
          <variable name="titleRe"/>
          <comment>Write all children of a window to the run-log.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.

@param titleRe  The title of the window as regular expression.

@author QFS, rl
@since 3.2.0</comment>
          <ProcedureCall id="_2JRM"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ServerScriptStep id="_B3S" name="Child window hierarchy">
            <code>import autowin
from de.qfs.apps.qftest.shared.script.modules.helper.Wnd import Point

def printAllChildren(wnd, indent=0, result=[]):
    r = wnd.getWindowRect()
    lt = Point(r.left, r.top)
    rb = Point(r.right, r.bottom)
    p = wnd.getParent()
    if p.getValue() != 0:
        lt = p.screenToClient(r.left, r.top)
        rb = p.screenToClient(r.right, r.bottom)
    s = indent * " "
    s += wnd.getWindowClassName()
    s += " [%d, %d, %d, %d]" %(lt.getX(), lt.getY(), rb.getX(), rb.getY())
    s += " '%s'" %(autowin.getWindowText(wnd))
    s += " Style:%s" %(hex(wnd.getWindowStyle()))
    s += " ExStyle:%s" %(hex(wnd.getWindowExStyle()))
    result.append(s)
    children = wnd.getChildren()
    for c in children:
        printAllChildren(c, indent + 4, result)
    return result

titleRe = rc.lookup("titleRe")
wnd = autowin.findWindow(titleRe, 1)
if wnd != None:
    s = printAllChildren(wnd)
    rc.logMessage("\n".join(s))
else:
    rc.logError("Window not found.")
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2K0x" name="logUIAToplevels">
          <comment>This method logs the top-level objects (windows) accessible via the Windows UIAutomation API.

Note: It is preferable to make use of QF-Test's ability to control native Windows applications directly, but in simple cases this procedure can still be useful.</comment>
          <UnitStep client="Execution Environment" id="_1xsJ"
                    interpreter="groovy">
            <includefiles name="1">${qftest:dir.version}/lib/ui-automation.jar</includefiles>
            <code>import mmarquee.automation.UIAutomation
import mmarquee.automation.controls.AutomationControlFactory
import mmarquee.uiautomation.TreeScope

@Test
void printTops()
{
    def res = "PID    TYPE       CLASS          NAME\n"
    def automation = UIAutomation.getInstance()
    def cond = automation.createTrueCondition()
    def tops = automation.rootElement.findAll(new TreeScope(TreeScope.CHILDREN), cond)
    tops.each {
        def ctrl = AutomationControlFactory.get(null, it)
        def type = ctrl.getClass().getSimpleName().replace("Automation", "")
        def pid = ctrl.getElement().getProcessId()
        res += "$pid  ${type}  ${ctrl.getClassName()}  ${ctrl.getName()}\n"
    }
    rc.logMessage(res)
}</code>
          </UnitStep>
          <ClientStopper client="Execution Environment" id="_2K0y"/>
        </Procedure>
        <Procedure id="qfs.autowin.markAllAndCopy" name="markAllAndCopy"
                   uid="_1kHH">
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Perform Ctrl+A and then Ctrl+C to a given window.

Afterwards you should have the text in the Clipboard, which enables you to insert the text somewhere for checking.

@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@throws UserException if window is not visible

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,mm,mks
@since 3.4.0</comment>
          <ProcedureCall id="_2JRN"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ServerScriptStep id="_1kGu" name="Send Ctrl+a and Ctrl+c">
            <code>import autowin

window = autowin.findWindow(rc.lookup("title"), rc.getBool("titleRegexp"))
if window != None:
    window.setForeground()
    #Ctrl + a
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_A, 0)
    autowin.keybd_event(autowin.VK_A, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
    #Ctrl + c
    autowin.keybd_event(autowin.VK_CONTROL, 0)
    autowin.keybd_event(autowin.VK_C, 0)
    autowin.keybd_event(autowin.VK_C, autowin.KEYEVENTF_KEYUP)
    autowin.keybd_event(autowin.VK_CONTROL, autowin.KEYEVENTF_KEYUP)
else:
    raise UserException("Cannot find an open window '" + rc.lookup("title") + "'.")    </code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.autowin.saveTextToFileViaClipboard"
                   name="saveTextToFileViaClipboard" uid="_1kHI">
          <variable name="fileName">aFileName</variable>
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Mark and copy the whole text of a given document via Ctrl+A and Ctrl+C.
Then it fetches the text from the clipboard and saves it into a given file.

@param fileName The filename to save.
@param title	The title of the window.
@param titleRegexp  true, if the given title is a regular expression, otherwise

@throws UserException if window is not visible

@deprecated QF-Test can control native windows applications directly. Most of the time direct control improves test stability over the scripting based approach used by this procedure.
@author QFS,mm
@since 3.4.0</comment>
          <ProcedureCall id="_2JRO"
                         procedure="qfs.autowin.helpers.checkIfWindows"/>
          <ProcedureCall id="_1kG-" procedure="qfs.autowin.markAllAndCopy">
            <variable name="title">$(title)</variable>
            <variable name="titleRegexp">$(titleRegexp)</variable>
          </ProcedureCall>
          <ProcedureCall id="_1kH0" local="true"
                         procedure="qfs.utils.clipboard.getTextFromClipboard"
                         retvarname="theText"/>
          <ProcedureCall id="_1kH1"
                         procedure="qfs.utils.writeMessageIntoFile">
            <variable name="message">$(theText)</variable>
            <variable name="file">$(fileName)</variable>
            <variable name="addLinebreak">false</variable>
          </ProcedureCall>
        </Procedure>
      </Package>
      <Package id="_46V" name="awt">
        <comment>Procedures for advanced manipulation of awt components.

@author	QFS
@since	2.1.0</comment>
        <Package id="_46W" name="menu">
          <comment>Procedures to select menu items.

(AWT components &lt;code&gt;java.awt.MenuItem&lt;/code&gt; from &lt;code&gt;java.awt.Menu&lt;/code&gt;)

Plain AWT Menus are not supported by QF-Test out of the box, but you can use the procedures of this package to work with those menus.

@author	QFS
@since	2.1.0</comment>
          <Procedure id="_46X" name="selectItem">
            <variable name="frame">${id:aFrame}</variable>
            <variable name="menu">text of menu</variable>
            <variable name="item">text of item</variable>
            <comment>Select an item from a menu.

For example: for the "File" -&gt; "Open" action, the label of  "File" is the menu, and the label for "Open" is the item.

@param	client	The name of the SUT client.
@param	frame	The id of the frame, which contains the menu.
@param	menu	The label of the menu, e.g. "File".
@param	item	The label of menu item, e.g. "Open".

@author	QFS
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(frame)"
                             id="_1oFd"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_47A">
              <code>from java.awt.event import ActionEvent
from javax.swing import SwingUtilities
from java.lang import Runnable

class InvokeListeners(Runnable):
    def __init__(self, event, listeners):
        self._event = event
        self._listeners = listeners
    def run(self):
        for i in range(len(self._listeners)):
            self._listeners[i].actionPerformed(self._event)

f = rc.getComponent(rc.lookup("frame"))
menubar = f.getMenuBar()
if menubar==None:
    raise TestException ("Could not find an AWT-menu at specified Frame!")
menuCount = menubar.getMenuCount()
item = None

for i in range(menuCount):
	oneMenu = menubar.getMenu(i)
	label = oneMenu.getLabel()
	if label == rc.lookup("menu"):
		itemCount = oneMenu.getItemCount()
		for j in range(itemCount):
			oneItem = oneMenu.getItem(j)
			itemLabel = oneItem.getLabel()
			if itemLabel == rc.lookup("item"):
				item = oneItem
				break
		if item != None:
			break

if item != None:
	event = ActionEvent(item, ActionEvent.ACTION_PERFORMED, item.getActionCommand())
	listeners = item.getActionListeners()
	SwingUtilities.invokeLater(InvokeListeners(event, listeners))
else:
	raise TestException ("Could not find specified menu-item!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1oCH" name="selectItemWithSubMenu">
            <variable name="frame">${id:aFrame}</variable>
            <variable name="menu">text of menu</variable>
            <variable name="submenu">text of sub-menu</variable>
            <variable name="item">text of item</variable>
            <comment>Select an item from a menu.

For example: for the "File" -&gt; "Save as" -&gt; "File" action, the label of  "File" is the menu, the label for submenu is "Save as", and the label of "Open" is the item.

@param	client	The name of the SUT client.
@param	frame	The id of the frame, which contains the menu.
@param	menu	The label of the menu, e.g. "File".
@param	submenu	The label of the sub-menu, e.g. "Save as".
@param	item	The label of menu item, e.g. "Open".

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(frame)"
                             id="_1oFe"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1oCI">
              <code>from java.awt.event import ActionEvent
from javax.swing import SwingUtilities
from java.lang import Runnable

class InvokeListeners(Runnable):
    def __init__(self, event, listeners):
        self._event = event
        self._listeners = listeners
    def run(self):
        for i in range(len(self._listeners)):
            self._listeners[i].actionPerformed(self._event)


def checkMenu(oneMenu, targetMenu, menuItem):
    label = oneMenu.getLabel()
    item = None
    if label == targetMenu:
        itemCount = oneMenu.getItemCount()
        for j in range(itemCount):
            oneItem = oneMenu.getItem(j)
            itemLabel = oneItem.getLabel()
            if itemLabel == menuItem:                
                if qf.isInstance(oneItem, "java.awt.Menu"):
                    return checkMenu(oneItem, menuItem, rc.lookup("item"))
                item = oneItem
                break
            if item != None:
                break         
    return item
                
f = rc.getComponent(rc.lookup("frame"))
menubar = f.getMenuBar()
if menubar==None:
    raise TestException ("Could not find an AWT-menu at specified Frame!")
menuCount = menubar.getMenuCount()
item = None


for i in range(menuCount):
	oneMenu = menubar.getMenu(i)
        item = checkMenu(oneMenu, rc.lookup("menu"), rc.lookup("submenu"))
        if item != None:
            break

print "found", item
if item != None:
	event = ActionEvent(item, ActionEvent.ACTION_PERFORMED, item.getActionCommand())
	listeners = item.getActionListeners()
	SwingUtilities.invokeLater(InvokeListeners(event, listeners))
else:
	raise TestException ("Could not find specified menu-item!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1oCL" name="setCheckItem">
            <variable name="frame">${id:aFrame}</variable>
            <variable name="menu">text of menu</variable>
            <variable name="checkItem">text of check menu</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox item from a menu.

For example: for the "File" -&gt; "Open" action, the label of  "File" is the menu, and the label for "Open" is the item.

@param	client	The name of the SUT client.
@param	frame	The id of the frame, which contains the menu.
@param	menu	The label of the menu, e.g. "File".
@param	checkItem		The label of menu item, e.g. "Open".
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(frame)"
                             id="_1oFf"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1oCM">
              <code>f = rc.getComponent(rc.lookup("frame"))
menubar = f.getMenuBar()
if menubar==None:
    raise TestException ("Could not find an AWT-menu at specified Frame!")

menuCount = menubar.getMenuCount()
item = None

for i in range(menuCount):
	oneMenu = menubar.getMenu(i)
	label = oneMenu.getLabel()
	if label == rc.lookup("menu"):
		itemCount = oneMenu.getItemCount()
		for j in range(itemCount):
			oneItem = oneMenu.getItem(j)
			itemLabel = oneItem.getLabel()
			if itemLabel == rc.lookup("checkItem"):
				item = oneItem
				break
		if item != None:
			break

if item != None:
	item.setState(rc.getBool("checkItemValue"))
else:
	raise TestException ("Could not find specified menu-item!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1oCJ" name="setSubCheckItem">
            <variable name="frame">${id:aFrame}</variable>
            <variable name="menu">text of menu</variable>
            <variable name="submenu">text of sub-menu</variable>
            <variable name="subCheckItem">text of check menu</variable>
            <variable name="subCheckItemValue">true</variable>
            <comment>Select a checkbox item from a menu in a sub-menu.

For example: for the "File" -&gt; "Save as" -&gt; "File" action, the label of  "File" is the menu, the label for submenu is "Save as", and the label of "Open" is the item.

@param	client	The name of the SUT client.
@param	frame	The id of the frame, which contains the menu.
@param	menu	The label of the menu, e.g. "File".
@param	submenu	The label of the sub-menu, e.g. "Save as".
@param	subCheckItem		The label of menu item, e.g. "Open".
@param	subCheckItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(frame)"
                             id="_1oFg"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1oCK">
              <code>
def checkMenu(oneMenu, targetMenu, menuItem):
    label = oneMenu.getLabel()
    item = None
    if label == targetMenu:
        itemCount = oneMenu.getItemCount()
        for j in range(itemCount):
            oneItem = oneMenu.getItem(j)
            itemLabel = oneItem.getLabel()
            if itemLabel == menuItem:                
                if qf.isInstance(oneItem, "java.awt.Menu"):
                    return checkMenu(oneItem, menuItem, rc.lookup("subCheckItem"))
                item = oneItem
                break
            if item != None:
                break         
    return item
                
f = rc.getComponent(rc.lookup("frame"))
menubar = f.getMenuBar()
if menubar==None:
    raise TestException ("Could not find an AWT-menu at specified Frame!")

menuCount = menubar.getMenuCount()
item = None

for i in range(menuCount):
	oneMenu = menubar.getMenu(i)
        item = checkMenu(oneMenu, rc.lookup("menu"), rc.lookup("submenu"))
        if item != None:
            break

if item != None:
	item.setState(rc.getBool("subCheckItemValue"))
else:
	raise TestException ("Could not find specified menu-item!")</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
      </Package>
      <Package id="_129" name="cleanup">
        <comment>The procedures in this package are useful for generic cleanup after an exception is thrown. In some cases a menu or modal dialog may have been left open, causing future events for the SUT to be blocked.


@author	QFS
@since	1.05.0
@deprecated	This package is deprecated because according cleanup-procedures are implemented in the qfs.swing resp. qfs.swt package. Please use the technology specific procedures.
</comment>
        <Procedure id="_6s" name="closeAllModalDialogs">
          <variable name="maxDialogs">5</variable>
          <comment>Close all modal dialogs.
A modal dialog that is left open will cause events for the SUT to be blocked. Ensuring that modal dialogs are closed is a good operation to conduct in a setup/cleanup sequence.


@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS
@since	1.05.0
@deprecated	Please use the technology specific procedures in the qfs.swing or qfs.swt package according to your SUT.
</comment>
          <ProcedureCall id="_3DG"
                         procedure="qfs.swing.cleanup.closeAllModalDialogs"/>
        </Procedure>
        <Procedure id="_2FG" name="closeAllDialogs">
          <variable name="maxDialogs">6</variable>
          <comment>Close all dialogs.

@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of dialogs that are tried to be closed. (Optional, default 6)

@author	QFS
@since	1.05.0
@deprecated	Please use the technology specific procedures in the qfs.swing or qfs.swt package according to your SUT.
</comment>
          <ProcedureCall id="_3DF"
                         procedure="qfs.swing.cleanup.closeAllDialogs"/>
        </Procedure>
        <Procedure id="_Sf" name="closeAllMenus">
          <comment>Close all menus unconditionally.
A menu left open (or even just selected) will cause events for the SUT to be blocked. This procedure is recommended for cleanup after an exception occurs.

@param	client	The name of the SUT client.

@author	QFS
@since	1.05.0
@deprecated	Please use the technology specific procedures in the qfs.swing or qfs.swt package according to your SUT.
</comment>
          <ProcedureCall id="_3DE"
                         procedure="qfs.swing.cleanup.closeAllMenus"/>
        </Procedure>
        <Procedure id="_12A" name="implicitExceptionHandler">
          <comment>This procedure encompasses the usage of other cleanup procedures in this package and is the recommended operation to perform after an exception occurs and is implicitly caught.

Calling this procedure should be the first step in the cleanup
sequence of any Test node with the "Implicitly catch exceptions" attribute set.

@param	client	The name of the SUT client.

@author	QFS
@since	1.05.0
@deprecated	Please use the technology specific procedures in the qfs.swing or qfs.swt package according to your SUT.
</comment>
          <ProcedureCall id="_12B"
                         procedure="qfs.swing.cleanup.implicitExceptionHandler"/>
        </Procedure>
      </Package>
      <Package id="_1k0W" name="client">
        <comment>Procedures for interacting with (SUT)  clients.

@author	QFS
@since	3.4</comment>
        <Procedure id="_1k0X" name="renameClient">
          <variable name="oldName">The current name of the client.</variable>
          <variable name="newName">The new name of the client.</variable>
          <variable name="trueName"/>
          <variable name="checkBeforeRename">false</variable>
          <comment>Rename an SUT client. This is especially useful when interacting with sub-processes of an SUT where you don't have full control over the client name during startup.

@param	oldName	The current name of the client.
@param	newName	The new name of the client.
@param	trueName	An optional name to use for recording which may include variable syntax with escaped $, e.g. $$(subclient).
@param	checkBeforeRename  If this is set to true, QF-Test will check whether a client with newName is already running.

@author	QFS,mm
@since	3.4</comment>
          <IfSequence id="_1lrw" test="$(checkBeforeRename)">
            <TryStep id="_1lry"
                     name="Check whether client with newName is already running?">
              <ClientWaiter client="$(newName)" id="_1lrx" timeout="1"/>
              <ThrowStep id="_1lr+"
                         throwmessage="Client with $(newName) is already running!"/>
              <CatchSequence exception="ClientNotConnectedException"
                             id="_1lrz" maxerror="0"
                             name="no client running -&gt; ok"/>
            </TryStep>
          </IfSequence>
          <ServerScriptStep id="_1kGg">
            <code>from de.qfs.apps.qftest import ScriptAccess

ScriptAccess.renameClient(rc.lookup("oldName"), rc.lookup("newName"), rc.lookup("trueName"))</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1lRT" name="sendInput">
          <variable name="input">The input to send</variable>
          <variable name="addNewline">true</variable>
          <variable name="newline">${system:line.separator}</variable>
          <comment>Write a string to the stdin stream of a process started by QF-Test.

@param	client	The name of the client.
@param	input	The input to send

@param	addNewline	Whether to append a line separator to the input.
@param	newline	The newline character to send. Can be specified as \n.
@throws	NoSuchClientException	If there is no such client.
@throws	UserException		It the output cannot be written.

@author	QFS,gs
@since	3.4.8</comment>
          <ServerScriptStep id="_1lRU">
            <code>from java.lang import System
from java.io import OutputStreamWriter
from de.qfs.apps.qftest import ScriptAccess
clname = rc.lookup("client")
out = ScriptAccess.getClientInput(clname)

writer = OutputStreamWriter(out)
writer.write(rc.lookup("input"))
if rc.getBool("addNewline"):
    nl = rc.lookup("newline")
    if nl and nl[0] == "\\":
        nl = eval('"""%s"""' % nl)
    writer.write(nl)
writer.flush()
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1kIz" name="startLogging">
          <variable name="levels">Classes and levels to log</variable>
          <variable name="bufsize">10000</variable>
          <variable name="logfile"/>
          <comment>Helper method for turning on internal logging. For QFS support and debugging use only.

@param	levels	Classes and levels to log (class=level, comma separated)
@param	logfile	The name of file where the log should be saved
@param	bufsize	Number of last log entries to log if parameter logfile is not set
@param	guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. If empty or undefined, the primariy engine of the SUT is used.

@author	QFS
@since	3.4</comment>
          <ClientScriptStep client="$(client)" engine="${default:guiengine:}"
                            id="_1kI-" interpreter="groovy">
            <code>import de.qfs.lib.log.FileLogWriter
import de.qfs.lib.log.Log
import de.qfs.lib.log.LogEntry
import de.qfs.lib.log.LogFilter
import de.qfs.lib.log.Logger

class LogBuffer implements LogFilter {
    def size, buffer
    LogBuffer(size) {
        this.size = size
        buffer = new ArrayList ()
    }

    synchronized boolean filter(LogEntry entry)
    {
        buffer.add(entry)
        def todel = buffer.size() - size
        if (todel &gt; 0) {
            for (i in 0..todel) {
                buffer.remove(0)
            }
        }
        return true
    }

    synchronized LogEntry[] filter(LogEntry[] entries)
    {
        for (entry in entries) {
            buffer.add(entry)
        }
        def todel = buffer.size() - size
        if (todel &gt; 0) {
            for (i in 0..todel) {
                buffer.remove(0)
            }
        }
        return entries
    }
}


// one-time initialization
try {
    __lb == null
} catch (Throwable ex) {
    __lb = null
    __lvls = null
    __flw = null
}

qfStartLogging = {levels, size=10000-&gt;
    if (__lb != null) {
        Log.removeFilter(__lb)
    }
    __lb = new LogBuffer(size)
    Log.addFilter(__lb)
    qfSetLevels(levels)
}

qfSetLevels = {levels-&gt;
    __lvls = levels
    if (__lvls != null) {
        for (level in __lvls) {
            lvl = level.trim()
            if (lvl != "") {
                nv = lvl.split('=')
                Logger.setLogLevel(nv[0], Integer.parseInt(nv[1]))
            }
        }
    }
}

qfStopLogging = {limit -&gt;
    def ret = ""
    if (__lb != null) {
        synchronized (__lb) {
            Log.removeFilter(__lb)
            def sb = new StringBuffer (__lb.buffer.size() * 100)
            for (e in __lb.buffer) {
                s = e.toString()
                if (limit &gt; 0 &amp;&amp; s.length() &gt; limit) {
                    sb.append(s.substring(0, limit))
                } else {
                    sb.append(s)
                }
                sb.append("\n")
            }
            ret = sb.toString()
            __lb = null
        }
    } else if (__flw != null) {
        Log.removeFilter(__flw)
        __flw = null
    }
    if (__lvls != null) {
        for (level in __lvls) {
            nv = level.split('=')
            Logger.removeLogLevel(nv[0])
        }
        __lvls = null
    }
    return ret
}

def logfile = rc.lookup("logfile")
if (logfile != "") {
    if (! new File(logfile).isAbsolute()) {
        logfile = rc.lookup("qftest","dir.root") + "/log/" + logfile
    }
    __flw = FileLogWriter.logToFile("qftest", logfile, FileLogWriter.MODE_APPEND, true)
    __flw.setLevel(10)
    Log.setPreQueueLevel(10)
    qfSetLevels(rc.lookup("levels").split(","))
} else {
    qfStartLogging(rc.lookup("levels").split(","), rc.getInt("bufsize"))
}
</code>
          </ClientScriptStep>
        </Procedure>
        <Procedure id="_1kI+" name="stopLogging">
          <variable name="dontcompactify">true</variable>
          <variable name="messagesizelimit">0</variable>
          <comment>Helper method for turning off internal logging. For QFS support and debugging use only.

@param dontcompactify Whether to prevent the resulting log entry from compactification.
@param messagesizelimit Limit for the size of individual messages. 0 = unlimited.
@param guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. If empty or undefined, the primariy engine of the SUT is used.

@author	QFS
@since	3.4</comment>
          <ClientScriptStep client="$(client)" engine="${default:guiengine:}"
                            id="_325" interpreter="groovy">
            <code>def msgs = qfStopLogging(rc.getInt("messagesizelimit"))
if (msgs != "") {
    rc.logMessage(msgs, dontcompactify: rc.getBool("dontcompactify"))
}</code>
          </ClientScriptStep>
        </Procedure>
      </Package>
      <Package id="_4pn" name="check">
        <comment>Procedures for checking components or comparing various kinds of values.

@author QFS,mm
@since 2.1.0</comment>
        <Procedure id="_6Kb" name="checkEnabledStatus">
          <variable name="id">${id:aComponentId}</variable>
          <variable name="enabled">true</variable>
          <variable name="throwExc">false</variable>
          <variable name="reportName"/>
          <variable name="timeout">3000</variable>
          <comment>Check the state of a given component.

It writes an error into the run-log, if the check fails.

@param id		ID of the component.
@param enabled  	true, if component should be enabled.
	   	otherwise, if component should be disabled.
@param throwExc	whether the check should throw an exception on failure.
@param reportName	the Name for the check in the report.
@param timeout	Timeout for the checked condition to happen.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
          <CheckBooleanStep checktype="enabled" client="$(client)"
                            component="$(id)" id="_6Kd" name="$(reportName)"
                            raise="$(throwExc)" state="$(enabled)"
                            timeout="$(timeout)"/>
        </Procedure>
        <Procedure id="_6PZ" name="checkSelectedStatus">
          <variable name="id">${id:aComponentId}</variable>
          <variable name="selected">true</variable>
          <variable name="throwExc">false</variable>
          <variable name="reportName"/>
          <variable name="timeout">3000</variable>
          <comment>Check if given component is selected.

It writes an error into the run-log, if the check fails.

@param id		ID of the component.
@param selected  	true, if component should be selected.
	   	otherwise, if component shouldn't be selected.
@param throwExc	whether the check should throw an exception on failure.
@param reportName	the Name for the check in the report.
@param timeout	Timeout for the checked condition to happen.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid
</comment>
          <CheckBooleanStep checktype="selected" client="$(client)"
                            component="$(id)" id="_6Pe" name="$(reportName)"
                            raise="$(throwExc)" state="$(selected)"
                            timeout="$(timeout)"/>
        </Procedure>
        <Procedure id="_6Kg" name="checkText">
          <variable name="id">${id:aComponentId}</variable>
          <variable name="text"/>
          <variable name="regexp">false</variable>
          <variable name="negate">false</variable>
          <variable name="reportName"/>
          <variable name="nameCheckType">default</variable>
          <variable name="throwExc">false</variable>
          <variable name="timeout">3000</variable>
          <comment>Check the text of a given component.

It writes an error into the run-log, if the check fails.

@param id		ID of the component.
@param text	  	text, which should be checked.
@param regexp	if this value is set to true, the text will be checks as regular-expression.
@param negate	if, the check should check for anything but the given text.
@param nameCheckType	the value for "name of check type" attribute.
@param throwExc	whether the check should throw an exception on failure.
@param reportName	the Name for the check in the report.
@param timeout	Timeout for the checked condition to happen.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid
</comment>
          <CheckStringStep checktype="$(nameCheckType)" client="$(client)"
                           component="$(id)" id="_6PX" name="$(reportName)"
                           notcheck="$(negate)" raise="$(throwExc)"
                           regexp="$(regexp)" timeout="$(timeout)">
            <text>$(text)</text>
          </CheckStringStep>
        </Procedure>
        <Procedure id="_1ju-" name="checkValueToBeEqual">
          <variable name="got"/>
          <variable name="expected"/>
          <variable name="checkMessage"/>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Compare two values for their equality.

It uses the rc.checkEqual() method from QF-Test.

@param	got	The got value for comparison.
@param	expected	The expected value for comparison.
@param	checkMessage	The message, which should be written into the run-log for that check.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@author QFS,mm
@since  3.1.1</comment>
          <ServerScriptStep id="_1jv0" name="perform check">
            <code>level = rc.ERROR

if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")

rc.checkEqual(rc.lookup("got"), rc.lookup("expected"), rc.lookup("checkMessage"), level, appearInReport)</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1jwr" name="compareDates">
          <variable name="got"/>
          <variable name="expected"/>
          <variable name="gotFormat">dd.MM.yyyy</variable>
          <variable name="expectedFormat">dd.MM.yyyy</variable>
          <variable name="gotLocale"/>
          <variable name="expectedLocale"/>
          <variable name="checkMessage"/>
          <variable name="compareMode">=</variable>
          <variable name="returnOnly">false</variable>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Compare two date strings.

Formatting rules:
If a format and a locale are specified the date will be formated using both values.
If only a format is specified the date will be formatted only with that format.
If only a locale is specified the date will be formatted according to the locale-format.


@param	got		The received date for comparison.
@param	expected		The expected date.
@param	gotFormat		The format in which the got date is formatted.
			You can specify this via the SimpleDateFormat in Java, e.g. MM/dd/yyyy.
			dd means two digits for the day.
			MM means two digits for month.
			yyyy means four digits for year.
@param	expectedFormat	The format in which the expected date is formatted.
			You can specify this via the SimpleDateFormat in Java, e.g. MM/dd/yyyy.
			dd means two digits for the day.
			MM means two digits for month.
			yyyy means four digits for year.
@param 	gotLocale		The locale of the got date, e.g. de, us, it, es, fr, zh, ko, ru, pt, ar
			or specific locales as en_gb, de_ch etc.
@param 	expectedLocale	The locale of the expected date, e.g. de, us, it, es, fr, zh, ko, ru, pt, ar
			or specific locales as en_gb, de_ch etc.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param	compareMode		The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
//========================  RETURN Options =============================
@param	reuturnOnly	Decides wheter to return boolean value, or directly write to run-log
		True:	returns the compare result
		False:	log directly in report - see below
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

Further samples:
MMM stands for the name of the month, e.g. 'Feb'.
E stands for the day of the week, e.g. 'Mon'.
w stands for week in the year.
Further samples can be found at SimpleDateFormat documentation at Java's documentation.

@throws  UserException, if wrong comparison mode has been set, or if the date cannot be parsed.

@author QFS,ys,mm

@since  4.0.3
</comment>
          <ServerScriptStep id="_2JkC" name="Perform comparison">
            <code># imports
from java.text import ParseException
from java.text import SimpleDateFormat
from java.util import Date, Locale
from java.text import DateFormat

# get parameters
dateStringGot = rc.lookup("got")
dateStringExpected = rc.lookup("expected")
dateStringFormatGot = rc.lookup("gotFormat")
dateStringFormatExpected = rc.lookup("expectedFormat")
gotLocale = rc.lookup("gotLocale")
expectedLocale = rc.lookup("expectedLocale")
message = rc.lookup("checkMessage")
method = rc.lookup("compareMode")

returnOnly = rc.getBool("returnOnly")
errorLvl = rc.lookup("errorLevel")
appearInReport = rc.getBool("appearInReport")
# some useful functions (defined them, but maybe there's no need to call them ...)
def stringToDate(string, format, locale):
    try:   
        exceptionText = ""
        if format and locale:
            parts = locale.split("_")
            theLocale = None
            if len(parts) == 1: 
                theLocale = Locale(locale)
            else:
                theLocale = Locale(parts[0], parts[1])
            sdf = SimpleDateFormat(format, theLocale)
            exceptionText = "given format '" + format + "' and locale '" + locale + "'"    
        elif format:            
            sdf = SimpleDateFormat(format)            
            exceptionText = "given format '" + format + "'"
        elif locale:       
            parts = locale.split("_")
            if len(parts) == 1:     
                sdf = SimpleDateFormat.getDateInstance(DateFormat.LONG, Locale(locale)) 
            else:
                sdf = SimpleDateFormat.getDateInstance(DateFormat.LONG, Locale(parts[0], parts[1])) 
            exceptionText = "given locale '" + locale + "'"
        return sdf.parse(string)
    except:
        fullExcText = "Given date '" + string + "'"
        if exceptionText != "":
            fullExcText = fullExcText + " and " + exceptionText + " don't match default formatting"
        else:
            fullExcText = fullExcText + " doesn't match default formatting"
                       
        raise UserException("Exception while parsing Date '%s'. (format: '%s', locale: '%s') -\n %s." % (string, format, locale, fullExcText))

def parseErrorLvl(lvl):
    if lvl.upper() == "EXCEPTION":
        return rc.EXCEPTION
    if lvl.upper() == "WARNING":
        return rc.WARNING
    if lvl.upper() == "MESSAGE":
        return rc.OK
    return rc.ERROR

def cmpDate(d1, d2):
    return d1.compareTo(d2)

compare = \
    cmpDate(
        stringToDate(dateStringGot, dateStringFormatGot, gotLocale), \
        stringToDate(dateStringExpected, dateStringFormatExpected, expectedLocale) \
    )

#clean method string first
method = method.strip()



# now check
if method == "&gt;":
    result = compare &gt; 0
    rc.setLocal("returnValue", result)
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be greater than " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
elif method == "&gt;=":
    result = compare &gt;= 0
    rc.setLocal("returnValue", result) 
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be greater or equal than " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
elif method == "&lt;":
    result = compare &lt; 0
    rc.setLocal("returnValue", result)
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be less than " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
elif method == "&lt;=":
    result = compare &lt;= 0
    rc.setLocal("returnValue", result)
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be less or equal than " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
elif method == "=" or method == "==":
    result = compare == 0
    rc.setLocal("returnValue", result) 
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be equal to " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
elif method == "!=":
    result = compare != 0
    rc.setLocal("returnValue", result) 
    if not returnOnly:
        rc.check(result, message + "\n\n" + dateStringGot + " should be unequal to " + dateStringExpected, parseErrorLvl(errorLvl), appearInReport)
else:
    raise UserException("Unknown compare mode '%s'. Please use one of the following compare modes:  '=', '!=', '&lt;', '&gt;', '&lt;=' or '&gt;='" % method)</code>
          </ServerScriptStep>
          <ReturnStep id="_2JAl" retval="$(returnValue)"/>
        </Procedure>
        <Procedure id="_1oHW" name="compareTwoNumbers">
          <variable name="got"/>
          <variable name="expected"/>
          <variable name="checkMessage"/>
          <variable name="compareMode">=</variable>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Compare two values for their equality. Both values should be numbers.

It uses the rc.check() method from QF-Test.

@param	got		The received value for comparison.
@param	expected		The expected value.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param	compareMode		The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since  3.1.1</comment>
          <ServerScriptStep id="_1oHX" name="Perform comparison">
            <code>level = rc.ERROR

if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")

#clean method string first
method = rc.lookup("compareMode")
method = method.strip()

if method == "&gt;":
    rc.check($(got) &gt; $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should be greater than: '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&gt;=":
    rc.check($(got) &gt;= $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should be greater or equal than: '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&lt;":
    rc.check($(got) &lt; $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should be less than: '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&lt;=":
    rc.check($(got) &lt;= $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should be less or equal than: '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "=" or method == "==":
    rc.check($(got) == $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should be equal to: '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "!=":
    rc.check($(got) != $(expected), rc.lookup("checkMessage") + " with value: '" + rc.lookup("got") + "' should not be equal to: '" + rc.lookup("expected") + "'.", level, appearInReport)
else:
    raise UserException("Unsupported value for 'compareMode'! Use either '=', '!=', '&lt;', '&gt;', '&lt;=' or '&gt;='!")
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1mHC" name="compareTwoStringValues">
          <variable name="got"/>
          <variable name="expected"/>
          <variable name="checkMessage"/>
          <variable name="compareMode">=</variable>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Compare two values for their equality. The values should be string values.

It uses the rc.check() method from QF-Test.

@param	got		The received value for comparison.
@param	expected		The expected value.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param	compareMode		The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since  3.1.1</comment>
          <ServerScriptStep id="_1mHD" name="Perform comparison">
            <code>level = rc.ERROR

if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")

#clean method string first
method = rc.lookup("compareMode")
method = method.strip()

if method == "&gt;":
    rc.check(rc.lookup("got") &gt; rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should be greater than '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&gt;=":
    rc.check(rc.lookup("got") &gt;= rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should be greater or equal than '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&lt;":
    rc.check(rc.lookup("got") &lt; rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should be less than '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "&lt;=":
    rc.check(rc.lookup("got") &lt;= rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should be less or equal than '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "=" or method == "==":
    rc.check(rc.lookup("got") == rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should be equal '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method == "!=":
    rc.check(rc.lookup("got") != rc.lookup("expected"), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should not be equal '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method.upper() == "REGEXP":
    from java.util.regex import Matcher, Pattern
    rc.check(Pattern.compile(rc.lookup("expected")).matcher(rc.lookup("got")).matches(), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should match '" + rc.lookup("expected") + "'.", level, appearInReport)
elif method.upper() == "REGEXPNEGATE":
    from java.util.regex import Matcher, Pattern
    rc.check(not Pattern.compile(rc.lookup("expected")).matcher(rc.lookup("got")).matches(), rc.lookup("checkMessage") + " for '" + rc.lookup("got") + "' should not match '" + rc.lookup("expected") + "'.", level, appearInReport)
else:
    raise UserException("Unsupported value for 'compareMode'! Use either '=', '&lt;', '&gt;', '&lt;=' or '&gt;='!")
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1lTH" name="checkImageAgainstFile">
          <variable name="id">${id:aComponentId}</variable>
          <variable name="file">c:\temp\img.png</variable>
          <variable name="algorithm"/>
          <variable name="checkMessage"/>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Check image of a component against a file.

It writes an error into the run-log, if the check fails.

@param id		ID of the component.
@param file 	                      The full path to the expected file.
@param algorithm                 If an algorithm is defined, use it. If empty, execute a classic check.
@param checkMessage	The message, which should be written into the run-log for that check.
@param errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport        Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                       If this is set to 1, the check will be shown in the report.
@param guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.

@author QFS,mh
@since 3.4.9

@ignoreanalyzerefcid
</comment>
          <ComponentWaiter client="$(client)" component="$(id)" id="_1oFh"
                           timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
            <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
          </ComponentWaiter>
          <ClientScriptStep client="$(client)" engine="${default:guiengine:}"
                            id="_1lTK">
            <code>from imagewrapper import ImageWrapper
level = rc.ERROR

if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")
algorithm = rc.lookup("algorithm")

iw = ImageWrapper(rc)
actual = iw.grabImage(rc.getComponent(rc.lookup("id")), x=None, y=None, width=None, height=None)
expected = iw.loadPng(rc.lookup("file"))

if expected and algorithm and algorithm != "":
    rc.checkImageAdvanced(actual, expected, rc.lookup("checkMessage"), algorithm, level, appearInReport)
elif expected and not algorithm:
    rc.checkImage(actual, expected, rc.lookup("checkMessage"), level, appearInReport)
elif not expected:
    raise UserException("File not found: " + rc.lookup("file"))
else:
    raise UserException("Exception occured")</code>
          </ClientScriptStep>
        </Procedure>
        <Procedure id="_1mJ8" name="checkValueInRange">
          <variable name="value"/>
          <variable name="minimum"/>
          <variable name="maximum"/>
          <variable name="includingMinimum">true</variable>
          <variable name="includingMaximum">true</variable>
          <variable name="checkMessage"/>
          <variable name="errorLevel">ERROR</variable>
          <variable name="appearInReport">1</variable>
          <comment>Check whether a value is in a given range.

@param	value		The value to check.
@param	minimum		The minimum of the range.
@param	maximum		The maximum of the range.
@param	includingMinimum    	If minimum itself is ok.
@param	includingMaximum    	If maximum itself is ok.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport   	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@author QFS,mm
@since  4.0</comment>
          <ServerScriptStep id="_1mJ9" name="perform check">
            <code>level = rc.ERROR

if rc.lookup("errorLevel").upper() == "EXCEPTION":
    level = rc.EXCEPTION
elif rc.lookup("errorLevel").upper() == "WARNING":
    level = rc.WARNING
elif rc.lookup("errorLevel").upper() == "MESSAGE":
    level = rc.OK

appearInReport = rc.getInt("appearInReport")

if not rc.lookup("value"):
    raise UserException("No value for 'value' parameter specified.")
    
if not rc.lookup("minimum"):
    raise UserException("No value for 'minimum' parameter specified.")
    
if not rc.lookup("maximum"):
    raise UserException("No value for 'maximum' parameter specified.")
    

value = rc.getNum("value")
mini = rc.getNum("minimum")
maxi = rc.getNum("maximum")

minInc = rc.getBool("includingMinimum")
maxInc = rc.getBool("includingMaximum")

msg = " Value " + str(value) + " in range! It should be: "

"of minimum " + str(mini) + " and maximum " + str(maxi) + "."
minOK = False
msg = msg + str(mini) 
if minInc:
    minOK = mini &lt;= value
    msg = msg + " &lt;= " 
else:
    minOK = mini &lt; value
    msg = msg + " &lt; "     
    
msg = msg + str(value)
maxOK = False
if maxInc:
    maxOK = maxi &gt;= value
    msg = msg + " &lt;= "  
else:
    maxOK = maxi &gt; value
    msg = msg + " &lt; "  
    
msg = msg + str(maxi) + "."
rc.check(minOK and maxOK, rc.lookup("checkMessage") + msg, level, appearInReport)

</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_6cI" name="daemon">
        <comment>Procedures to work with a QF-Test daemon.

@author QFS
@since 2.9.9</comment>
        <Procedure id="qfs.daemon.startRemoteSUT" name="startRemoteSUT"
                   uid="_1kHk">
          <variable name="daemonhost"/>
          <variable name="daemonport"/>
          <variable name="commandline"/>
          <comment>Start a client application on a remote host via the QF-Test daemon.

@param daemonhost    The host name or IP address of the QF-Test daemon.
@param daemonport    The port where the daemon is listening.
@param commandline  The commandline used by the daemon to launch the client. Arguments containing spaces must be wrapped into quotes.

@author QFS
@since 2.9.9</comment>
          <ServerScriptStep id="_6cJ">
            <code>if rc.lookup("daemonhost") == "" \
        or rc.lookup("daemonport") == "" \
        or rc.lookup("commandline") == "":
    raise TestException("Undefined parameters in procedure call")
try:
    int(rc.lookup("daemonport"))
except:
    raise TestException("Numeric port required")

cmd = rc.lookup("commandline")
cmd = cmd.replace('"', "'")
rc.setLocal("commandline", cmd)
</code>
          </ServerScriptStep>
          <SUTClientStarter client="$(client)"
                            directory="${qftest:dir.version}/bin"
                            executable="${qftest:executable}" id="_1jur">
            <parameter>-batch</parameter>
            <parameter>-nomessagewindow</parameter>
            <parameter>-calldaemon</parameter>
            <parameter>-daemonhost</parameter>
            <parameter>$(daemonhost)</parameter>
            <parameter>-daemonport</parameter>
            <parameter>$(daemonport)</parameter>
            <parameter>-startsut</parameter>
            <parameter>$(commandline)</parameter>
          </SUTClientStarter>
        </Procedure>
        <Procedure id="qfs.daemon.locateDaemons" name="locateDaemons"
                   uid="_1j+p">
          <variable name="timeout">180000</variable>
          <comment>Locate all running daemons and writes them into the run-log and prints a list of running daemons to the terminal.
If no daemons can be found it logs an error.

@param timeout   Timeout for waiting for running daemons.

@author QFS,mm
@since  3.3.0</comment>
          <ServerScriptStep id="_1j+n">
            <code>from de.qfs.apps.qftest.daemon import DaemonLocator

timeout = rc.lookup("timeout")

print "Try to locate running daemons ..."
allDaemons = DaemonLocator.instance().internalLocateDaemons(long(timeout))

gotDaemon = False
if allDaemons:
    print "Running daemons: %s" % allDaemons
    for d in allDaemons:
        try:
            msg = d.getHost() + ":" + str(d.getPort())
            print msg
            rc.logMessage(msg)
            gotDaemon = True
        except:
            msg = "Daemon not accesible: %s" % d
            print msg
            rc.logMessage(msg)

if not gotDaemon:
    msg = "No usable daemons found"
    print msg
    rc.logError(msg)

print "... script done."</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.daemon.instrumentRemoteSwt"
                   name="instrumentRemoteSwt" uid="_1kHl">
          <variable name="daemonhost"/>
          <variable name="daemonport"/>
          <variable name="sutdir"/>
          <variable name="plugin"/>
          <variable name="forceInstrumentation">true</variable>
          <comment>Starts remote instrumentation procedure for an Eclipse/RCP based or standalone SWT application via a given daemon. See procedure qfs.swt.instrument.setup for further information.

@param daemonhost    The host name or IP address of the QF-Test daemon.
@param daemonport    The port where the daemon is listening.
@param sutdir    The installation directory of the SUT at the destination machine.
@param plugin    Optional: The specific plugin to instrument. Useful in case the directories are not layed out as expected.
@param	forceInstrumentation Whether to force instrumentation even if not required.

@author QFS, gs
@since  3.3.0</comment>
          <ServerScriptStep id="_1j-0">
            <code>from de.qfs.apps.qftest.daemon import DaemonLocator, DaemonRunContext
from java.util import Properties

if rc.lookup("daemonhost") == "" or rc.lookup("daemonport") == "":
    raise TestException("Undefined parameters in procedure call")
try:
    port = int(rc.lookup("daemonport"))
except:
    raise TestException("Numeric port required")

host = rc.lookup("daemonhost")

daemon = DaemonLocator.instance().internalLocateDaemon(host, port)

if daemon == None:
    msg = "No daemon found"
    rc.logError(msg)
    raise ReturnException()

strd = daemon.getSharedTestRunDaemon()

if strd == None:
    msg = "No shared test run daemon found"
    rc.logError(msg)
    raise ReturnException()

sc = strd.getSharedContext()

if sc == None:
    msg = "No shared run context found"
    rc.logError(msg)
    raise ReturnException()

bindings = Properties()
bindings.setProperty("sutdir", rc.lookup("sutdir"));
bindings.setProperty("plugin", rc.lookup("plugin"));
bindings.setProperty("forceInstrumentation", rc.lookup("forceInstrumentation"));

ret = sc.callProcedure("${qftest:dir.version}/include/qfs.qft#qfs.swt.instrument.setup", bindings)
if ret:
    msg = "Remote SWT instrumentation procedure started."
    rc.logMessage(msg)
    print msg
else:
    msg = "Remote SWT instrumentation: Procedure or suite not found."
    rc.logMessage(msg)
    print msg
    raise ReturnException()

ret = sc.waitForRunState(DaemonRunContext.STATE_FINISHED, 30000)
if not ret:
    msg = "Remote SWT instrumentation did not finish."
    rc.logError(msg)
    print msg
    raise ReturnException()

result = sc.getResult()
if result &lt; 1:
    msg = "Remote SWT instrumentation successful."
    rc.logMessage(msg)
    print msg
elif result &lt; 2:
    msg = "Remote SWT instrumentation successful with warnings."
    rc.logWarning(msg)
    print msg
else:
    msg = "Remote SWT instrumentation failed."
    rc.logError(msg)
    print msg
log = sc.getRunLog()
if log:
    rc.addDaemonLog(log)
</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_46O" name="database">
        <comment>Procedures to work with databases.

@author QFS,mm
@since 2.1.0
</comment>
        <Procedure id="_46P" name="executeSelectStatement">
          <variable name="driver">aDriver</variable>
          <variable name="connectionString">aConnectionString</variable>
          <variable name="dbUser">aUser</variable>
          <variable name="dbPass">aPasswd</variable>
          <variable name="statement">aStatement</variable>
          <variable name="resultGroupName">resultGroup</variable>
          <variable name="throwExceptionOnDuplicateColumns">true</variable>
          <variable name="commit">auto</variable>
          <comment>Build up connection to a given database and executes a specified select-sql-statement.
You can configure the procedure to store all results in a group QF-Test variable.

NOTE: The SQL-statement should be a select statement!
NOTE: The class of the database driver must be either in QF-Test's plugin directory or in the CLASSPATH environment variable before QF-Test startup!

For more information about connection-strings please see www.connectionstrings.com.

@param driver		The class-name of the database driver.
@param connectionString 	The connection-string to the database.
@param dbUser 	The user for establishing database-connection.
@param dbPass 	The password for establishing database-connection.
@param statement 	The SQL-statement, it should be a select statement.
@param  resultGroupName  	If this name is specified the result is stored in a Propertygroup, which an be accessed via ${resultGroup:'Columnname'.'RowIdx'}. ${resultGroup:'count'} gives the number of rows in the result set.
@param throwExceptionOnDuplicateColumns	  If the result set has two columns with the same name (which could happen if you join tables), then you will get an exception.
@param commit	true, false or auto. Whether to explicitly execute db.commit() at the end. Some databases / connection modes reuqire the execution of this statement. When this option is set to auto, QF-Test tries to determine if that is possible.

@throws TestException If something went wrong with the database or execution of statement.
@throws TestException If there are duplicate in column names, which could happen in case of joins on tables.

@return  Set a global variable 'resultRows', which contains all result-rows. You can access this variable in any Server-script.

@author QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_46Q">
            <code>from com.ziclix.python.sql import zxJDBC

global resultRows

user = rc.lookup("dbUser")
password = rc.lookup("dbPass")
dbclass = rc.lookup("driver")
theColumns = None

# check whether we need to execute db.commit()
lst = [
    "org.apache.derby.jdbc.ClientDriver"
]
commit = rc.lookup("commit")
if commit.lower() == "auto":
    commit = dbclass in lst
else:
    commit = rc.getBool("commit")

#access DB
db = zxJDBC.connect(rc.lookup("connectionString"), user, password, dbclass)
cursor = db.cursor()
try:
    try:
        cursor.execute(rc.lookup("statement"))
        resultRows = cursor.fetchall()
        theColumns = cursor.description
        if commit:
            db.commit()
    except Exception, err:
        raise TestException("Exception during executing statement " + str(err))
finally:
    cursor.close()
    db.close()

#set properties, if variable is set
resultGroupName = rc.lookup("resultGroupName")
duplicateColNames = []
if resultGroupName and theColumns:
    rc.clearProperties(resultGroupName)
    rc.setProperty(resultGroupName, "count", str(len(resultRows)))
    for rowIdx in range(len(resultRows)):
        oneRow = resultRows[rowIdx]
        colNames = []
        for colIdx in range(len(oneRow)):                
            theCol = theColumns[colIdx][0]        
            rowValue = oneRow[colIdx]
            #check for duplicate columns in first row
            if rowIdx == 0:
                if theCol in colNames and theCol not in duplicateColNames:                    
                    duplicateColNames.append(theCol)
            
            colNames.append(theCol)                    
                            
            if rowValue is None:
                rowValue = ""
            varName = theCol + "." + str(rowIdx)
            rc.setProperty(resultGroupName, varName, rowValue)      
            
if rc.getBool("throwExceptionOnDuplicateColumns"):  
    if len(duplicateColNames) &gt; 0:
        raise TestException ("There are duplicate column names in result set, please check your statement\nDuplicate column names:" + str(duplicateColNames))
           </code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_46R" name="executeStatement">
          <variable name="driver">aDriver</variable>
          <variable name="connectionString">aConnectionString</variable>
          <variable name="dbUser">aUser</variable>
          <variable name="dbPass">aPasswd</variable>
          <variable name="statement">aStatement</variable>
          <comment>Build up connection to a given database and execute a specified SQL-statement.

NOTE: The class of the database driver must be either in QF-Test's plugin directory or in the CLASSPATH environment variable before QF-Test startup!

For more information about connection-strings please see www.connectionstrings.com.

@param driver		The class-name of the database driver.
@param connectionString 	The connection-string to the database.
@param dbUser 	The user for establishing database-connection.
@param dbPass 	The password for establishing database-connection.
@param statement 	The SQL-statement.

@throws TestException If something went wrong with the database or execution of statement.

@return result  1 If result has been executed, otherwise 0.
	 (Only for backward compatibility.)

@author QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_46S">
            <code>from com.ziclix.python.sql import zxJDBC

user = rc.lookup("dbUser")
password = rc.lookup("dbPass")
dbclass = rc.lookup("driver")

db = zxJDBC.connect(rc.lookup("connectionString"), user, password, dbclass)
cursor = db.cursor()
result = 0
try:
    try:
        cursor.execute(rc.lookup("statement"))
        try:
            db.commit()
        except:
            rc.logWarning("Commit on database didn't work properly.")
        result = 1
    except Exception, err:
        raise TestException("Exception during executing statement " + str(err))
finally:
    rc.setLocal("result", result)
    cursor.close()
    db.close()
</code>
          </ServerScriptStep>
          <ReturnStep id="_46U" retval="$(result)"/>
        </Procedure>
      </Package>
      <Package id="_1ex" name="databinder">
        <comment>Procedures to bind data for data-driven testing.

@author QFS
@since 2.2.0
</comment>
        <Procedure id="_1e+" name="bindList">
          <variable name="identifier">Driver loop identifier</variable>
          <variable name="varname">Name of the variable to bind the list values to</variable>
          <variable name="values">List of values separated by whitespace unless separator is defined</variable>
          <variable name="separator"/>
          <variable name="counter"/>
          <variable name="intervals"/>
          <comment>Create and register a databinder that binds a list of values to a variable.

@param varname	The name of the variable to bind to.
@param values		The values to bind.
@param separator	Optional separator character for splitting the values. Default is whitespace.
@param counter                       Optional variable name for the iteration counter.
@param intervals                      Optional ranges of indices, separated by comma, e.g. "0,2-3"

@author QFS
@since 2.2.0
</comment>
          <ServerScriptStep id="_1e-">
            <code>import databinder

separator = rc.lookup("separator")
if separator == "":
    separator = None
counter = rc.lookup("counter")
if counter == "":
    counter = None
intervals = rc.lookup("intervals")
if intervals == "":
    intervals = None
databinder.bindList(rc, rc.lookup("identifier"), rc.lookup("varname"),
                    rc.lookup("values"), separator, counter, intervals)
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1f0" name="bindSets">
          <variable name="identifier">Driver loop identifier</variable>
          <variable name="varnames">Names of the variable to bind the values to</variable>
          <variable name="values">Lists of value-sets, one set per line</variable>
          <variable name="separator"/>
          <variable name="counter"/>
          <variable name="intervals"/>
          <comment>Create and register a databinder that binds a list of value-sets to a set of variables.

@param loopname	The name for which to register the databinder.
@param varnames	The names of the variables to bind to.
@param values		The values to bind. Value-sets are separated by linebreaks.
@param separator	Optional separator character for splitting the varnames and value-sets. Default is whitespace.
@param counter                       Optional variable name for the iteration counter.
@param intervals                      Optional ranges of indices, separated by comma, e.g. "0,2-3"

@author QFS
@since 2.2.0
</comment>
          <ServerScriptStep id="_6Q+">
            <code>import databinder

separator = rc.lookup("separator")
if separator == "":
    separator = None
counter = rc.lookup("counter")
if counter == "":
    counter = None
intervals = rc.lookup("intervals")
if intervals == "":
    intervals = None
values = rc.lookup("values")
if values and values.endswith("\n"):
    values = values[:-1]
databinder.bindSets(rc, rc.lookup("identifier"), rc.lookup("varnames"),
                    values, separator, counter, intervals)
</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_6Yv" name="dialogs">
        <comment>Procedures for showing dialogs during the test-run.

@author 	QFS
@since 	3.0</comment>
        <Procedure id="_6cs" name="showInformationMessageDialog">
          <variable name="title"/>
          <variable name="msg"/>
          <variable name="timeout">10000</variable>
          <variable name="alwaysOnTop">True</variable>
          <variable name="wraplength">160</variable>
          <comment>Show an information dialog with an OK option.

@param title		The title of the dialog.
@param msg		The message to be shown.
@param timeout	The timeout for closing the dialog in ms. -1 means no timeout.
@param alwaysOnTop 	Try to bring the dialog to front. Supported for JDKs &gt;= 1.5.
@param wraplength           Approximate line length of the message text (0 to avoid line breaks).

@return 	The code for the clicked button.  0 for OK and -1 for timeout.

@author 	QFS
@since 	3.0</comment>
          <ProcedureCall id="_6cx" local="true"
                         procedure="qfs.dialogs.showConfigurabableDialog"
                         retvarname="result">
            <variable name="messagetype">INFORMATION_MESSAGE</variable>
            <variable name="optiontype">DEFAULT_OPTION</variable>
            <variable name="title">$(title)</variable>
            <variable name="msg">$(msg)</variable>
            <variable name="timeout">$(timeout)</variable>
            <variable name="alwaysOnTop">$(alwaysOnTop)</variable>
            <variable name="wraplength">$(wraplength)</variable>
          </ProcedureCall>
          <ReturnStep id="_6c+" retval="$(result)"/>
        </Procedure>
        <Procedure id="_6Z2" name="showYes_No_Cancel_Dialog">
          <variable name="title"/>
          <variable name="msg"/>
          <variable name="timeout">10000</variable>
          <variable name="alwaysOnTop">True</variable>
          <variable name="wraplength">160</variable>
          <comment>Show an information dialog with a YES, NO and CANCEL option.

@param title	    	The title of the dialog.
@param msg	    	The message to be shown.
@param timeout   	The timeout for closing the dialog in ms. -1 means no timeout.
@param alwaysOnTop 	Try to bring the dialog to front. Supported for JDKs &gt;= 1.5.
@param wraplength           Approximate line length of the message text (0 to avoid line breaks).

@return 	The code for the clicked button.  0 for YES, 1 for NO, 2 for CANCEL and -1 for timeout or closed.

@author 	QFS
@since 	3.0</comment>
          <ProcedureCall id="_6cy" local="true"
                         procedure="qfs.dialogs.showConfigurabableDialog"
                         retvarname="result">
            <variable name="messagetype">QUESTION_MESSAGE</variable>
            <variable name="optiontype">YES_NO_CANCEL_OPTION</variable>
            <variable name="title">$(title)</variable>
            <variable name="msg">$(msg)</variable>
            <variable name="timeout">$(timeout)</variable>
            <variable name="alwaysOnTop">$(alwaysOnTop)</variable>
            <variable name="wraplength">$(wraplength)</variable>
          </ProcedureCall>
          <ReturnStep id="_6c-" retval="$(result)"/>
        </Procedure>
        <Procedure id="_6cd" name="showYes_No_Dialog">
          <variable name="title"/>
          <variable name="msg"/>
          <variable name="timeout">10000</variable>
          <variable name="alwaysOnTop">True</variable>
          <variable name="wraplength">160</variable>
          <comment>Show an information dialog with a YES and NO option.

@param title		The title of the dialog.
@param msg 		The message to be shown.
@param timeout 	The timeout for closing the dialog in ms. -1 means no timeout.
@param alwaysOnTop 	Try to bring the dialog to front. Supported for JDKs &gt;= 1.5.
@param wraplength           Approximate line length of the message text (0 to avoid line breaks).

@return 	The code for the clicked button. 0 for YES, 1 for NO and -1 for timeout.

@author 	QFS
@since 	3.0</comment>
          <ProcedureCall id="_6cz" local="true"
                         procedure="qfs.dialogs.showConfigurabableDialog"
                         retvarname="result">
            <variable name="messagetype">QUESTION_MESSAGE</variable>
            <variable name="optiontype">YES_NO_OPTION</variable>
            <variable name="title">$(title)</variable>
            <variable name="msg">$(msg)</variable>
            <variable name="timeout">$(timeout)</variable>
            <variable name="alwaysOnTop">$(alwaysOnTop)</variable>
            <variable name="wraplength">$(wraplength)</variable>
          </ProcedureCall>
          <ReturnStep id="_6d0" retval="$(result)"/>
        </Procedure>
        <Procedure id="_6co" name="showConfigurabableDialog">
          <variable name="title"/>
          <variable name="msg"/>
          <variable name="timeout">10000</variable>
          <variable name="alwaysOnTop">True</variable>
          <variable name="wraplength">160</variable>
          <variable name="messagetype">INFORMATION_MESSAGE</variable>
          <variable name="optiontype">DEFAULT_OPTION</variable>
          <comment>Show a configurable dialog equivalent to JOptionPane.

@param title	           The title of the dialog.
@param msg	           The message to be shown.
@param timeout         The timeout for closing the dialog in ms. -1 means no timeout.
@param alwaysOnTop Try to bring the dialog to front. Supported for JDKs &gt;= 1.5.
@param wraplength           Approximate line length of the message text (0 to avoid line breaks).
@param messagetype The message type, one of ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, PLAIN_MESSAGE .
@param optiontype     The option type, one of DEFAULT_OPTION, YES_NO_OPTION, YES_NO_CANCEL_OPTION or OK_CANCEL_OPTION.

@return 	The code for the clicked button.  0 for YES/OK, 1  for NO, 2 for CANCEL, and -1 for timeout.

@author 	QFS
@since 	3.0</comment>
          <BasicSequence id="_6cp">
            <variable name="result">-1</variable>
            <ServerScriptStep id="_6cq" name="ShowDialog">
              <code>from javax.swing import JOptionPane, SwingUtilities
from java.lang import Runnable, Thread, StringBuilder

global dialog_closed

class TimeoutOptionPane(Runnable):
    def __init__(self, rc, msg, title):
        self.pane = None
        self.dialog = None
        self.rc = rc
        self.msg = msg
        self.title = title

    def run(self):
        if self.dialog == None:
            global dialog_closed
            self.pane = JOptionPane(self.msg, JOptionPane.$(messagetype), JOptionPane.$(optiontype))
            self.dialog = self.pane.createDialog(None, self.title)
            self.dialog.setName("InteractiveOptionDialog")
            if self.rc.lookup("alwaysOnTop") == "True":
                try:
                    #only avaialbe since JDK1.5
                    self.dialog.setAlwaysOnTop(True)
                except:
                    pass
            self.dialog.setVisible(True)
            dialog_closed = True
            self.dialog.dispose()
            res = self.pane.getValue()
            if res != None and not res == JOptionPane.UNINITIALIZED_VALUE:
                self.rc.setLocal("result", res)
        else:
            self.dialog.dispose()
            res = self.pane.getValue()
            if res != None and not res == JOptionPane.UNINITIALIZED_VALUE:
                result = res

def wrapText(s):
    buf = StringBuilder(len(s))
    wi = 0
    for c in s:
        if c == '\n':
            wi = 0
        else:
            wi += 1
        if c == ' ' and wi &gt;= wraplen:
            buf.append('\n')
            wi = 0
        else:
            buf.append(c)
    return buf.toString()


msg = rc.lookup("msg")
title = rc.lookup("title")
wraplen = rc.getNum("wraplength")
if wraplen &gt; 0:
    msg = wrapText(msg)
dialog_closed = False
pane = TimeoutOptionPane(rc, msg, title)
timeout = rc.getNum("timeout")
if timeout &gt;= 0:
    SwingUtilities.invokeLater(pane)
    closed = False
    while timeout &gt; 0:
        Thread.sleep(500)
        timeout = timeout - 500
        if dialog_closed:
            break
    if not dialog_closed:
        # timeout expired -&gt; close
        SwingUtilities.invokeAndWait(pane)
else:
    SwingUtilities.invokeAndWait(pane)
</code>
            </ServerScriptStep>
            <ReturnStep id="_6cr" retval="$(result)"/>
          </BasicSequence>
        </Procedure>
      </Package>
      <Package id="_1nB6" name="fx">
        <comment>Procedures for advanced manipulation of fx components.

@author	QFS
@since	4.0</comment>
        <Package id="_1nBV" name="checkbox">
          <comment>Procedures to get and set the state of checkboxes.
(fx component &lt;code&gt;javafx.scene.control.CheckBox&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Procedure id="_1nBW" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nBX">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nBY"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nBZ"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nBa" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nBb" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nBc">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nBd"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nBe"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nBf" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nBg" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.

@return	The state of the checkbox.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nBh">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nBi"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1nBj" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1nBk"
                             maxerror="0">
                <ReturnStep id="_1nBl" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nBm" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nBn">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nBo"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nBp"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nBq" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nBr" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nBs">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nBt"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nBu"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nBv" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nBw" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nBx" test="$(check)">
              <ProcedureCall id="_1nBy" procedure=".select">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ElseSequence id="_1nBz">
                <ProcedureCall id="_1nB+" procedure=".deselect">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1nB-" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nC0" test="$(check)">
              <ProcedureCall id="_1nC1" procedure=".selectWithCoordinates">
                <variable name="id">$(id)</variable>
                <variable name="x">$(x)</variable>
                <variable name="y">$(y)</variable>
              </ProcedureCall>
              <ElseSequence id="_1nC2">
                <ProcedureCall id="_1nC3"
                               procedure=".deselectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_1nB7" name="cleanup">
          <comment>The procedures in this package are useful for generic cleanup after an exception is thrown. In some cases a menu or modal dialog may have been left open, causing future events for the SUT to be blocked.

@author	QFS,gs
@since	4.0
</comment>
          <Procedure id="_1nB8" name="closeAllModalDialogs">
            <variable name="maxDialogs">5</variable>
            <comment>Close all modal dialogs.
A modal dialog that is left open will cause events for the SUT to be blocked. Ensuring that modal dialogs are closed is a good operation to conduct in a setup/cleanup sequence.


@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,gs
@since	4.0</comment>
            <RepeatSequence count="$(maxDialogs)" id="_1nB9">
              <comment>There may be more than one modal dialog. We can't use an endless loop though, in case
a dialog cannot be closed.</comment>
              <TryStep id="_1nBA" name="Check for modal dialog">
                <ComponentWaiter client="$(client)"
                                 component="genericFxModalDialog" id="_1nBB"
                                 timeout="50"/>
                <WindowEventStep client="$(client)"
                                 component="genericFxModalDialog"
                                 event="WINDOW_CLOSING" id="_1nBC">
                  <comment>The WINDOW_CLOSING event is equivalent to closing the dialog through the
window manager. We can't press a generic OK button, since the results could
be disastrous. Cancelling a dialog should always have the least consequences.</comment>
                </WindowEventStep>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_1nBD" maxerror="0" name="Finished">
                  <BreakStep id="_1nBE"/>
                </CatchSequence>
              </TryStep>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_1nBQ" name="closeAllMenus">
            <comment>Close all menus unconditionally.
A menu left open (or even just selected) will cause events for the SUT to be blocked. This procedure is recommended for cleanup after an exception occurs.

@param	client	The name of the SUT client.

@author	QFS,gs
@since	4.0</comment>
            <RepeatSequence count="5" id="_1nWh">
              <comment>We may need more than one attempt in case we're closing a sub-menu. We can't use an endless loop though, in case a menu cannot be closed.</comment>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1nBR">
                <code>from javafx.stage import Window
from java.lang import Throwable
wins = rc.engine.tracker.getAllWindows()

toRemove = []
for win in wins:
    if qf.isInstance(win, "javafx.stage.PopupWindow") and \
        win.isShowing():
        toRemove.append(win)
if len(toRemove) == 0:
    raise BreakException()
for win in toRemove:
    owner = win.getOwnerWindow()
    while not qf.isInstance(owner, "javafx.stage.Stage"):
        owner = owner.getOwnerWindow()
    rc.logMessage("Hiding PopupWindow %s with owner %s" % (win, owner))
    rc.overrideElement("PriorityFxWindow", owner)
    rc.callProcedure(".closeMenu", {'id': "PriorityFxWindow"})
        
    </code>
              </ClientScriptStep>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_1nPW" name="closeMenu">
            <comment>Close a menu by replaying an [Escape] keystroke on a Window.

@param	client	The name of the SUT client.
@param	id	The id of the Window with the menu.

@author	QFS,gs
@since	4.0</comment>
            <KeyEventStep client="$(client)" component="$(id)" event="KEY_PTR"
                          id="_1nWg" keychar="27" keycode="27" modifiers="0"/>
          </Procedure>
          <Procedure id="_1nBS" name="implicitExceptionHandler">
            <variable name="maxDialogs">5</variable>
            <comment>This procedure encompasses the usage of other cleanup procedures in this package and is the recommended operation to perform after an exception occurs and is implicitly caught.

Calling this procedure should be the first step in the error handler of a base dependency or the cleanup sequence of any Test node with the "Implicitly catch exceptions" attribute set.

@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,gs
@since	4.0</comment>
            <ProcedureCall id="_1nBU" procedure=".closeAllModalDialogs">
              <variable name="maxDialogs">$(maxDialogs)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1nBT" procedure=".closeAllMenus"/>
          </Procedure>
        </Package>
        <Package id="_1nC4" name="combobox">
          <comment>Procedures to handle comboboxes.
(fx component &lt;code&gt;javafx.scene.control.ComboBox&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Procedure id="_1nC5" name="getIndexOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param	id	ID of the combobox.
@param	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index	The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1nC6" local="true" varname="index"/>
            <ReturnStep id="_1nC7" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1o43" name="getItemCount">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the number of items of a given combobox.
It uses the method &lt;code&gt;getItems().getSize()&lt;/code&gt; to get the number.

@param	id	The component-ID of the combobox.
@return 	itemCount

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oFp"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nt4">
              <code>combobox = rc.getComponent(rc.lookup("id"))

itemCount = combobox.getItems().size()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1o44" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1nCB" name="getValue">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the text of a given combobox.

@param	id	ID of the combobox.

@return  	The text of the combobox.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1nCC"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1nCD" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1nCE" name="getValueOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param 	id  	ID of the combobox.
@param 	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1nCF"
                           local="true" varname="value"/>
            <ReturnStep id="_1nCG" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1nCH" name="setValue">
            <variable name="id">${id:aComboboxButton}</variable>
            <variable name="listId">${id:aList}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <variable name="btnX"/>
            <variable name="btnY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select specified value of a given combobox.

If the given value is empty, no action will take place.

You should use this procedure for any standard selections.

@param	client	The name of the SUT client.
@param 	id	ID of the button to open the list.
@param	listId	ID of the list containing values.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	btnX	The x coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	btnY	The y coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nCI" test="rc.lookup(&#34;value&#34;)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_1nCJ" modifiers="16"
                              x="$(btnX)" y="$(btnY)"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(listId)$(separator)$(value)"
                              event="MOUSE_MPRC" id="_1nCK" modifiers="16"
                              x="$(itemX)" y="$(itemY)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1nCL" name="setValueViaIndex">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Set a value in the combobox.

You should use this procedure if setValue doesn't work correctly.

@param	client	The name of the SUT client.
@param 	id	ID of the combobox.
@param 	value  	The value to be set.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_1nCM"
                            local="true" varname="idx"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nCN">
              <code>combo = rc.getComponent(rc.lookup("id"))
if rc.getInt("idx") &gt;= 0:
    combo.getSelectionModel().select(rc.getInt("idx"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nCO" name="setValueViaSUTScript">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Select specified value of a given combobox using a SUT script.
It uses the API-method &lt;code&gt;getSelectionModel.select()&lt;/code&gt; of &lt;code&gt;javafx.scene.control.ComboBox&lt;/code&gt;

If the given value is empty, no action will take place.

You should use this procedure only if setValue and setValueViaIndex don't work for your use-case.

@param	client	The name of the SUT client.
@param 	id	ID of the combobox.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nCP" test="rc.lookup(&#34;value&#34;)">
              <IfSequence id="_1nCQ"
                          test="&#34;$(separator)&#34; == &#34;@&#34;">
                <ComponentWaiter client="$(client)" component="$(id)"
                                 id="_1oFr"
                                 timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                  <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
                </ComponentWaiter>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:fx}" id="_1nCR"
                                  name="getComboboxValueWithGetSelectedItem">
                  <code>
from de.qfs.apps.qftest.shared.data import SubItemIndex

combo = rc.getComponent(rc.lookup("id"))
value = rc.lookup("value")
found = False

for i in range(combo.getItems().size()):
    item = combo.getItems().get(i)
    if item and str(item) == value:
        found = True
        if item != combo.getSelectionModel().getSelectedItem():
            combo.getSelectionModel().select(i)
        break

if not found:
    raise IndexNotFoundException(SubItemIndex(value))
</code>
                </ClientScriptStep>
                <ElseSequence id="_1nCS" name="other separator">
                  <ProcedureCall id="_1nCT" procedure=".setValueViaIndex">
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                    <variable name="separator">$(separator)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_1nDK" name="general">
          <comment>Procedures which work for any fx component.

@author	QFS,mm
@since 	4.0
</comment>
          <Procedure id="_1nDL" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nDM" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_1nDN" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1nDO" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client	The name of the SUT client.
@param	id	The Id of the target-component.
@param	click	If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nDP" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_1nDQ"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1nDR" name="deleteOverrideComponent">
            <comment>Delete the current association of PriorityFxNode.

@param	client		The name of the SUT client.

@author	QFS,mm
@since	4.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nDS">
              <code>rc.overrideElement("PriorityFxNode", None)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nDT" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1nDU" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nDV" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client	The name of the SUT client.
@param	id	The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1nDW"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1nDX" name="doSelect">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="detail"/>
            <comment>Send a selection event to a given component. That's not a mouse-click.
Selection events are special events for menus or list selection.

@param	client	The name of the SUT client.
@param	id	The Id of the target-component.
@param	detail	The detail of the selection. Important for closing dialogs etc. For menu items leave it blank.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="$(detail)" disabled="true"
                                event="SELECTION" id="_1nDY">
              <comment>Not implemented yet</comment>
            </SelectionEventStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1oC5" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nDZ" name="setLocation">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set the location of a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x		The new x-coordinate of the location.
@param	y		The new y-coordinate of the location.

@author	QFS,gs
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oFs"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nDa">
              <code>comp = rc.getComponent(rc.lookup("id"))

if qf.isInstance(comp, "javafx.stage.Window"):
    comp.setX($(x))
    comp.setY($(y))
else:
    comp.relocate($(x), $(y))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nDb" name="setOverrideComponent">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Set a given component to the PriorityFxNode.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oFt"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nDc">
              <code>comp = rc.getComponent(rc.lookup("id"))

rc.overrideElement("PriorityFxNode", comp)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nDd" name="setSize">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="width"/>
            <variable name="height"/>
            <comment>Set the width and the height of a given component.

It uses setSize(width, height) to set the size.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	width		The new width of the component.
@param	height		The new height of the component.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oFu"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oFM">
              <code>comp = rc.getComponent(rc.lookup("id"))

if qf.isInstance(comp, "javafx.stage.Window"):
    comp.setWidth($(width))
    comp.setHeight($(height))
else:
    comp.resize($(width), $(height))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nDf" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1nDg"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_1nDh" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_1nDi" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_1nDj" name="list">
          <comment>Procedures for accessing lists.
(fx component &lt;code&gt;javafx.scene.control.ListView&lt;/code&gt;)

@author	QFS,mm
@since 	4.0</comment>
          <Package id="_1nDk" name="checks">
            <comment>Procedures for checking a list.

@author	QFS,mm
@since	4.0</comment>
            <Procedure id="_1nDl" name="checkNumberOfItems">
              <variable name="id">${id:listid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of items of a given list according to a specified comparison mode.

It uses &lt;code&gt;getItems().size()&lt;/code&gt; to get the number.
Sample usage:
You can check, that a list has exactly 6 items or that the table has less then 10 items.

@param	id 		The id of the list.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of items.
			&lt;, if the compareValue should be greater than the actual amount of items.
			&gt;, if the compareValue should be less than the actual amount of items.
			&lt;=, if the compareValue should be greater or equal than the actual amount of items.
			&gt;=, if the compareValue should be less or equal the actual amount of items.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport   	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                		If this is set to 1, the check will be shown in the report.


@throws  	UserException, if wrong comparison mode has been set.

@author 	QFS,mm
@since  	4.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1nDm" local="true"
                             procedure="..getItemCount"
                             retvarname="itemCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1nDn"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of items of list '$(id)'</variable>
                <variable name="got">$(itemCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1o7m" name="selection">
            <comment>Procedures to (de-)select certain items of a list.

@author 	QFS,mm
@since 	4.0</comment>
            <Procedure id="_1o7n" name="deselectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Deselect all items. It uses &lt;code&gt;clearSelection&lt;/code&gt;.

@param 	id	ID of the list.

@author 	QFS,ue
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFv"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o7o">
                <code>list = rc.getComponent(rc.lookup("id"))

list.getSelectionModel().clearSelection()
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o7p" name="deselectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Deselect a given item, specified by its index. It uses &lt;code&gt;clearSelection(item)&lt;/code&gt;.

@param 	id	ID of the list.
@param 	item	The index of the item.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFw"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o7q">
                <code>list = rc.getComponent(rc.lookup("id"))
item = rc.getInt("item")

list.getSelectionModel().clearSelection(item)
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o7r" name="deselectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Deselect a range of items, specified by their index. It uses &lt;code&gt;clearSelection(item)&lt;/code&gt;.

@param 	id	ID of the list.
@param	startItem	The index of first item to be deselected.
@param	endItem	The index of last item to be deselected.

@author 	QFS,ue
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFx"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o7s">
                <code>list = rc.getComponent(rc.lookup("id"))
#list is of the type javafx.scene.control.ListView

startItem = rc.getInt("startItem")
endItem = rc.lookup("endItem")
items = list.getItems().size()

if endItem == None or endItem == '':
	endItem = items
else:
	endItem = int(endItem)+1

for item in range(int(startItem),endItem):
    list.getSelectionModel().clearSelection(item)

</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o7t" name="selectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Select all items. It uses &lt;code&gt;selectAll()&lt;/code&gt;.

@param 	id	ID of the list.

@author 	QFS, mzs
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFy"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1oC1">
                <code>list = rc.getComponent(rc.lookup("id"))
if list != None:
    list.getSelectionModel().selectAll()</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o7v" name="selectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Select a given item, specified by its index. It uses &lt;code&gt;select(item)&lt;/code&gt;.

@param 	id	ID of the list.
@param 	row	The index of the item.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFz"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o7w">
                <code>list = rc.getComponent(rc.lookup("id"))
item = rc.getInt("item")
if item != None:
    list.getSelectionModel().select(item)
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o7x" name="selectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Select a range of items, specified by their index.

@param 	id	ID of the list.
@param	startItem	The index of first item to be selected.
@param	endItem	The index of last item to be selected.

@author 	QFS,ue
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oF+"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o7y">
                <code>list = rc.getComponent(rc.lookup("id"))
#list is of the type javafx.scene.control.ListView

startItem = rc.getInt("startItem")
endItem = rc.lookup("endItem")
items = list.getItems().size()

if endItem == None or endItem == '':
	endItem = items
else:
	endItem = int(endItem) + 1

list.getSelectionModel().selectRange(startItem, endItem)</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1nD-" name="clickItemWithDetails">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given item by a mouse-click on it.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param 	id  	ID of the list.
@param 	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1nE0"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1o7z" name="getItemCount">
            <variable name="id">${id:listid}</variable>
            <comment>Return the number of items of a given list.
It uses the method &lt;code&gt;getItems().size()&lt;/code&gt; to get the number.

@param 	id	The component-ID of the list.
@return 	itemCount

@author 	QFS, mm, ue
@since 	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oF-"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1o7+">
              <code>list = rc.getComponent(rc.lookup("id"))
#list is of the type javafx.scene.control.ListView
itemCount = list.getItems().size()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1o7-" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1nE4" name="getIndexOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param 	id  	ID of the list.
@param 	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index	The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1nE5" local="true" varname="index"/>
            <ReturnStep id="_1nE6" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1nE7" name="getValueOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param 	id  	ID of the list.
@param 	item 	The item.
@param 	itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1nE8"
                           local="true" varname="value"/>
            <ReturnStep id="_1nE9" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1o80" name="selectItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Select a given item by a mouse-click on it.

@param 	id  	ID of the list.
@param	item 	The item.
@param 	itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.


@author 	QFS,mm,ue
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" id="_1o81" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_1nEC" name="menu">
          <comment>Procedures to select menu items and checkbox menu items.
(fx components &lt;code&gt;javafx.scene.control.RadioMenuItem&lt;/code&gt; and &lt;code&gt;javafx.scene.control.CheckMenuItem&lt;/code&gt; from &lt;code&gt;javafx.scene.control.MenuItem&lt;/code&gt;)

@author	QFS
@since	4.0</comment>
          <Procedure id="_1nED" name="selectItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of menu item.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nEE" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nEF" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nEG" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nEH" name="selectItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of menu item.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nEI" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nEJ" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nEK" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
          </Procedure>
          <Procedure id="_1nEL" name="selectSubItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu.

For example: for the View -&gt; Terminal -&gt; Show action, the component ID of "View" is the menu, the ID for "Terminal" is the item, and the ID for "Show" is the sub-item to select.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nEM" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nEN" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nEO" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nEP" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nEQ" name="selectSubItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subItemX"/>
            <variable name="subItemY"/>
            <comment>Select an item within a submenu.

For example: for the View -&gt; Terminal -&gt; Show action, the component ID of "View" is the menu, the ID for "Terminal" is the item, and the ID for "Show" is the sub-item to select.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subItemX	The x coordinate for the click on the subitem, default is empty to click in the middle.
@param	subItemY	The y coordinate for the click on the subitem, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nER" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nES" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nET" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nEU" modifiers="16" x="$(subItemX)"
                            y="$(subItemY)"/>
          </Procedure>
          <Procedure id="_1nEV" name="setCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item.

For example: for the View -&gt; Show Details action, the component ID of "View" is the menu, and the ID for "Show Details" is the checkbox item to set (to true or false).

@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nEW" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nEX" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nEY" timeout="3000"/>
            <TryStep id="_1nEZ" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nEa"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nEb" test="$(checkItemValue)">
                <ProcedureCall id="_1nEc"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nEd">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nEe" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nEf"
                             maxerror="0">
                <IfSequence id="_1nEg" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nEh" modifiers="16"/>
                  <ElseSequence id="_1nEi">
                    <ProcedureCall id="_1nEj"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nEk" name="setCheckItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="checkItemX"/>
            <variable name="checkItemY"/>
            <comment>Select a checkbox menu item.

For example: for the View -&gt; Show Details action, the component ID of "View" is the menu, and the ID for "Show Details" is the checkbox item to set (to true or false).

@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	checkItemX		The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	checkItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nEl" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nEm" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nEn" timeout="3000"/>
            <TryStep id="_1nEo" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nEp"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nEq" test="$(checkItemValue)">
                <ProcedureCall id="_1nEr"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nEs">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nEt" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nEu"
                             maxerror="0">
                <IfSequence id="_1nEv" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nEw" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                  <ElseSequence id="_1nEx">
                    <ProcedureCall id="_1nEy"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nEz" name="setSubCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within within a submenu.

For example: for the View -&gt; Terminal -&gt; Wrap Lines action, the component ID of "View" is the menu,  the ID for "Terminal" is the item and the ID for "Wrap Lines" is the checkbox menu item to set (to true or false).


@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	item		The id of the item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nE+" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nE-" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nF0" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nF1" timeout="3000"/>
            <TryStep id="_1nF2" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nF3"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nF4" test="$(checkItemValue)">
                <ProcedureCall id="_1nF5"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nF6">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nF7"
                                  modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nF8"
                             maxerror="0">
                <IfSequence id="_1nF9" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nFA"
                                  modifiers="16"/>
                  <ElseSequence id="_1nFB">
                    <ProcedureCall id="_1nFC"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nFD" name="setSubCheckItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subCheckItemX"/>
            <variable name="subCheckItemY"/>
            <comment>Select a checkbox menu item within within a submenu.

For example: for the View -&gt; Terminal -&gt; Wrap Lines action, the component ID of "View" is the menu,  the ID for "Terminal" is the item and the ID for "Wrap Lines" is the checkbox menu item to set (to true or false).


@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	item		The id of the item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX		The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY		The y coordinate for the click on the item, default is empty to click in the middle.
@param	subCheckItemX	The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	subCheckItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nFE" procedure="..cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nFF" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nFG" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nFH" timeout="3000"/>
            <TryStep id="_1nFI" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nFJ"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nFK" test="$(checkItemValue)">
                <ProcedureCall id="_1nFL"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nFM">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nFN" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nFO"
                             maxerror="0">
                <IfSequence id="_1nFP" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nFQ" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                  <ElseSequence id="_1nFR">
                    <ProcedureCall id="_1nFS"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nFT" name="selectMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="item">${id:aMenuItem}</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select an item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "File" -&gt; "Close" you set menu to the component id "mFile" and item to "mClose" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Search text" you set menu to the component id "mFile.mSearch" and item to "mSearchText" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	item		The id of menu item.
@param	menustringSeparator	The value, which separates the path of the parent menu.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1nFU" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.fx.general.doClick", {"id" : m})</code>
            </ServerScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nFV" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nFW"
                     name="selectMenuItemInHierarchyWithCoordinates">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="item">${id:aMenuItem}</variable>
            <variable name="menustringSeparator">.</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select an item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
You can specify the coordinates for clicking.

Samples:
If you want to select at "File" -&gt; "Close" you set menu to the component id "mFile" and item to "mClose" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Search text" you set menu to the component id "mFile.mSearch" and item to "mSearchText" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	item		The id of menu item.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX		The x coordinate for the click on the menu item, default is empty to click in the middle.
@param	itemY		The y coordinate for the click on the menu item, default is empty to click in the middle.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1nFX" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.fx.general.doClickWithDetails", {"id" : m, "x" : rc.lookup("menuX"), "y" : rc.lookup("menuY")})</code>
            </ServerScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nFY" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
          </Procedure>
          <Procedure id="_1nFZ" name="selectCheckMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="checkItem">${id:aMenuItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select a checkbox menu item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "View" -&gt; "Show terminal" you set menu to the component id "mView" and item to "mShowTerminal" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Exclude digits" you set menu to the component id "mFile.mSearch" and item to "mExcludeDigits" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1nFa" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.fx.general.doClick", {"id" : m})</code>
            </ServerScriptStep>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nFb" timeout="3000"/>
            <TryStep id="_1nFc" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nFd"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nFe" test="$(checkItemValue)">
                <ProcedureCall id="_1nFf"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nFg">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nFh" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nFi"
                             maxerror="0">
                <IfSequence id="_1nFj" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nFk" modifiers="16"/>
                  <ElseSequence id="_1nFl">
                    <ProcedureCall id="_1nFm"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nFn"
                     name="selectCheckMenuItemInHierarchyWithCoordinates">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="checkItem">${id:aMenuItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menustringSeparator">.</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="checkItemX"/>
            <variable name="checkItemY"/>
            <comment>Select a checkbox menu item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "View" -&gt; "Show terminal" you set menu to the component id "mView" and item to "mShowTerminal" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Exclude digits" you set menu to the component id "mFile.mSearch" and item to "mExcludeDigits" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	checkItemX		The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	checkItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1nFo" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.fx.general.doClickWithDetails", {"id" : m, "x" : rc.lookup("menuX"), "y" : rc.lookup("menuY")})</code>
            </ServerScriptStep>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nFp" timeout="3000"/>
            <TryStep id="_1nFq" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nFr"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nFs" test="$(checkItemValue)">
                <ProcedureCall id="_1nFt"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nFu">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nFv" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nFw"
                             maxerror="0">
                <IfSequence id="_1nFx" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nFy" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                  <ElseSequence id="_1nFz">
                    <ProcedureCall id="_1nF+"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1nJI" name="popupmenu">
          <comment>Procedures to select items and checkbox menu items from popup menus.

Note that for all procedures, the popup menu &lt;strong&gt;must&lt;/strong&gt; first be opened by the calling test-suite, as the popup menu is component-dependent.

See package "menu" for more details about menus and sub-menus.
(fx components &lt;code&gt;javafx.scene.control.RadioMenuItem&lt;/code&gt; and &lt;code&gt;javafx.scene.control.CheckMenuItem&lt;/code&gt; from &lt;code&gt;javafx.scene.control.MenuItem&lt;/code&gt;)

@author	QFS
@since	4.0
</comment>
          <Procedure id="_1nJJ" name="clickItemWithDetails">
            <variable name="item">${id:anItem}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <comment>Select an item in a popup menu. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client	The name of the SUT client.
@param	item	The id of menu item.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.

@author	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(item)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1nJK"
                            modifiers="$(modifier)" x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1nJL" name="selectItem">
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item in a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of menu item.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nJM" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nJN" name="selectSubItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu of a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nJO" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nJP" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nJQ" name="selectSubItemWithCoordinates">
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subItemX"/>
            <variable name="subItemY"/>
            <comment>Select an item within a submenu of a popup menu.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subItemX	The x coordinate for the click on the subitem, default is empty to click in the middle.
@param	subItemY	The y coordinate for the click on the subitem, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nJR" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nJS" modifiers="16" x="$(subItemX)"
                            y="$(subItemY)"/>
          </Procedure>
          <Procedure id="_1nJT" name="setCheckItem">
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item in a popup menu.

@param	client		The name of the SUT client.
@param	checkItem		The id of the menu checkbox item.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nJU" timeout="3000"/>
            <TryStep id="_1nJV" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nJW"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nJX" test="$(checkItemValue)">
                <ProcedureCall id="_1nJY"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nJZ">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nJa" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nJb"
                             maxerror="0">
                <IfSequence id="_1nJc" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nJd" modifiers="16"/>
                  <ElseSequence id="_1nJe">
                    <ProcedureCall id="_1nJf"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nJg" name="setCheckItemWithCoordinates">
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox menu item in a popup menu. You can specify the coordinates for clicking.

@param	client		The name of the SUT client.
@param	checkItem		The id of the menu checkbox item.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	x		The x coordinate for the click, default is empty to click in the middle.
@param	y		The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nJh" timeout="3000"/>
            <TryStep id="_1nJi" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nJj"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nJk" test="$(checkItemValue)">
                <ProcedureCall id="_1nJl"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nJm">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nJn" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nJo"
                             maxerror="0">
                <IfSequence id="_1nJp" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nJq" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                  <ElseSequence id="_1nJr">
                    <ProcedureCall id="_1nJs"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nJt" name="setSubCheckItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within a submenu of a popup menu.

@param	client		The name of the SUT client.
@param	item		The id of item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(item)" id="_1nJu"
                             timeout="3000"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nJv" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nJw" timeout="3000"/>
            <TryStep id="_1nJx" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nJy"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nJz" test="$(checkItemValue)">
                <ProcedureCall id="_1nJ+"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nJ-">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nK0"
                                  modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nK1"
                             maxerror="0">
                <IfSequence id="_1nK2" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nK3"
                                  modifiers="16"/>
                  <ElseSequence id="_1nK4">
                    <ProcedureCall id="_1nK5"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nK6" name="setSubCheckItemWithCoordinates">
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subCheckItemX"/>
            <variable name="subCheckItemY"/>
            <comment>Select a checkbox menu item within a submenu of a popup menu.
You can specify the coordinates for clicking.

@param	client		The name of the SUT client.
@param	item		The id of item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	itemX		The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY		The y coordinate for the click on the item, default is empty to click in the middle.
@param	subCheckItemX	The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	subCheckItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(item)" id="_1nK7"
                             timeout="3000"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nK8" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nK9" timeout="3000"/>
            <TryStep id="_1nKA" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nKB"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nKC" test="$(checkItemValue)">
                <ProcedureCall id="_1nKD"
                               procedure="..cleanup.closeAllMenus"/>
                <ElseSequence id="_1nKE">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nKF" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nKG"
                             maxerror="0">
                <IfSequence id="_1nKH" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nKI" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                  <ElseSequence id="_1nKJ">
                    <ProcedureCall id="_1nKK"
                                   procedure="..cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1nKL" name="radiobutton">
          <comment>Procedures to set and get the state of radio buttons.
(fx component &lt;code&gt;javax.fx.JRadioButton&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Procedure id="_1nKM" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  	The state of the checkbox.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nKN">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nKO"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1nKP" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1nKQ"
                             maxerror="0">
                <ReturnStep id="_1nKR" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nKS" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the radio button is already selected, no action is performed.

@param	id	The id of the radio button.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nKT">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nKU"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nKV"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nKW" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nKX" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nKY">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1nKZ"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1nKa"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1nKb" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1nKc" name="slider">
          <comment>Procedures to access sliders.
(fx component &lt;code&gt;javafx.scene.control.Slider&lt;/code&gt;)

@author	QFS, mm
@since	4.0</comment>
          <Package id="_1nKd" name="checks">
            <comment>Procedure for checking slider values.

@author	QFS, mm
@since	4.0</comment>
            <Procedure id="_1nKe" name="checkValue">
              <variable name="id">${id:sliderid}</variable>
              <variable name="value"/>
              <variable name="regexp">false</variable>
              <variable name="negate">false</variable>
              <variable name="reportName"/>
              <variable name="nameCheckType">default</variable>
              <variable name="throwExc">false</variable>
              <variable name="timeout">3000</variable>
              <comment>Check the value of a slider component.

@param 	id		The component ID of the slider.
@param 	value		The value to be checked,
@param 	regexp		if this value is set to true, the text will be checks as regular-expression.
@param 	negate		if, the check should check for anything but the given text.
@param 	nameCheckType	the value for "name of check type" attribute.
@param 	throwExc		whether the check should throw an exception on failure.
@param 	reportName		the Name for the check in the report.
@param 	timeout		Timeout for the checked condition to happen.

@author	QFS, mm
@since	4.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1nKf" procedure="qfs.check.checkText">
                <variable name="text">$(value)</variable>
                <variable name="id">$(id)</variable>
                <variable name="regexp">$(regexp)</variable>
                <variable name="negate">$(negate)</variable>
                <variable name="reportName">$(reportName)</variable>
                <variable name="nameCheckType">$(nameCheckType)</variable>
                <variable name="throwExc">$(throwExc)</variable>
                <variable name="timeout">$(timeout)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_1nKg" name="getValue">
            <variable name="id">${id:sliderid}</variable>
            <comment>Return the value of a slider component.

@param 	id	The component ID of the slider.

@return	The current value of the slider.

@author	QFS, mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1nKh"
                           local="true" varname="currentValue"/>
            <ReturnStep id="_1nKi" retval="$(currentValue)"/>
          </Procedure>
          <Procedure id="_1nKj" name="setValue">
            <variable name="id">${id:sliderid}</variable>
            <variable name="value">aValue</variable>
            <comment>Set the value of a slider component.

@param 	id	The component ID of the slider.
@param 	value	The value to set.

@author	QFS, mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oG0"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1nKk">
              <code>slider = rc.getComponent(rc.lookup("id"))

slider.setValue(rc.getNum("value"))</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Package id="_1nME" name="tabbedpane">
          <comment>Procedures to work with TabbedPanes.
(fx component &lt;code&gt;javafx.scene.control.TabPane&lt;/code&gt; or any other TabFolder implementations)

@author 	QFS,mm
@since 	4.0</comment>
          <Procedure id="_1o82" name="closeTab">
            <variable name="id">idOfTab</variable>
            <comment>Close a tab via a selection event.

@param 	id  	ID of tab, which should be closed.

@author 	QFS,gs
@since	4.0</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="close" event="SELECTION" id="_1oC6">
              <comment>Not perfect but reliable</comment>
            </SelectionEventStep>
          </Procedure>
          <Procedure id="_1nMI" name="getIndexOfTab">
            <variable name="id">${id:aTabFolderId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Return the index of a given tab in a TabPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to look for.

@return	The index of the tab.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_1nMJ"
                            local="true" varname="index"/>
            <ReturnStep id="_1nMK" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2YNU" name="getItemCount">
            <variable name="id">${id:aTabfolder}</variable>
            <comment>Return the number of items of a given tabbedpane.


@param id 		The component-ID of the tabbedpane.
@return itemCount

@author QFS
@since 5.3.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YNV"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                            id="_2YNc" local="true" varname="itemCount"/>
            <ReturnStep id="_2YNd" retval="$[$(itemCount)+1]"/>
          </Procedure>
          <Procedure id="_1nML" name="getValueOfTab">
            <variable name="id">${id:aTabFolderId}</variable>
            <variable name="separator">&amp;</variable>
            <variable name="value"/>
            <comment>Return the text of a given tab in a TabPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The index to look for.

@return	The value of the tab.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(separator)$(value)" id="_1nMM"
                           local="true" varname="value"/>
            <ReturnStep id="_1nMN" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1nMO" name="selectTab">
            <variable name="id">${id:aTabFolderId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Select a tab in a given TabPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane to select.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to select.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)"
                               component="$(id)$(separator)$(value)"
                               heightvarname="h" id="_1nMP" widthvarname="w"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(value)"
                            event="MOUSE_MPRC" id="_1nMQ" modifiers="16"
                            x="$[$(w)/2]" y="$[$(h)/2]"/>
          </Procedure>
        </Package>
        <Package id="_1nKz" name="table">
          <comment>Procedures to access tables.
(fx component &lt;code&gt;javafx.scene.control.TableView&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Package id="_1nK+" name="checkbox">
            <comment>Procedures to set the state of checkboxes in a table-cell.
These procedures become necessary, because checkboxes in tables cannot be treated like normal checkboxes.

@author	QFS,mm
@since	4.0</comment>
            <Procedure id="_1nK-" name="deselect">
              <variable name="id">aCheckboxId</variable>
              <comment>Deselect a checkbox in a table-cell. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.

@author	QFS,gs
@since	4.0</comment>
              <TryStep id="_1nL0">
                <CheckBooleanStep checktype="item_checked" client="$(client)"
                                  component="$(id)" id="_1oFN" raise="true"
                                  state="false" timeout="10"/>
                <CatchSequence exception="CheckFailedException" id="_1nL2"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)@:CheckBox"
                                  event="MOUSE_MPRC" id="_1nL3"
                                  modifiers="16"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1nL4" name="deselectWithCoordinates">
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Deselect a checkbox in a table-cell. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates (relative to the table-cell) for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,gs
@since	4.0</comment>
              <TryStep id="_1nL5">
                <CheckBooleanStep checktype="item_checked" client="$(client)"
                                  component="$(id)" id="_1oFO" raise="true"
                                  state="false" timeout="10"/>
                <CatchSequence exception="CheckFailedException" id="_1nL7"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1nL8" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1nL9" name="select">
              <variable name="id">aCheckboxId</variable>
              <comment>Select a checkbox in a table-cell. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.


@author	QFS,gs
@since	4.0</comment>
              <TryStep id="_1nLA">
                <CheckBooleanStep checktype="item_checked" client="$(client)"
                                  component="$(id)" id="_1oDd" raise="true"
                                  timeout="10"/>
                <CatchSequence exception="CheckFailedException" id="_1nLC"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)@:CheckBox"
                                  event="MOUSE_MPRC" id="_1nLD"
                                  modifiers="16"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1nLE" name="selectWithCoordinates">
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Select a checkbox in a table-cell. If the checkbox is already selected, no action is performed.
You can specify the coordinates (relative to the table-cell) for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.


@author	QFS,gs
@since	4.0</comment>
              <TryStep id="_1nLF">
                <CheckBooleanStep checktype="item_checked" client="$(client)"
                                  component="$(id)" id="_1oFP" raise="true"
                                  timeout="10"/>
                <CatchSequence exception="CheckFailedException" id="_1nLH"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1nLI" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1nLJ" name="set">
              <variable name="check">true</variable>
              <variable name="id">aCheckboxId</variable>
              <comment>Set checkbox in a table-cell to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	check	The check value to be set (either true or false).

@author	QFS,mm
@since	4.0</comment>
              <IfSequence id="_1nLK" test="$(check)">
                <ProcedureCall id="_1nLL" procedure=".select">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
                <ElseSequence id="_1nLM">
                  <ProcedureCall id="_1nLN" procedure=".deselect">
                    <variable name="id">$(id)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </Procedure>
            <Procedure id="_1nLO" name="setWithCoordinates">
              <variable name="check">true</variable>
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Set checkbox in a table-cell to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
              <IfSequence id="_1nLP" test="$(check)">
                <ProcedureCall id="_1nLQ" procedure=".selectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
                <ElseSequence id="_1nLR">
                  <ProcedureCall id="_1nLS"
                                 procedure=".deselectWithCoordinates">
                    <variable name="id">$(id)</variable>
                    <variable name="x">$(x)</variable>
                    <variable name="y">$(y)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </Procedure>
          </Package>
          <Package id="_1nLT" name="checks">
            <comment>Procedures for checking a table.

@author	QFS,mm
@since	4.0</comment>
            <Procedure id="_1nLU" name="checkNumberOfRows">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of rows of a given table according to a specified comparison mode.
It uses the method &lt;code&gt;getItems().size()&lt;/code&gt; to get the number.

Sample usage:
You can check, that a table has exactly 6 rows or that the table has less then 10 rows.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param 	appearInReport   	Flag, whether to show check in report, if a message or warning are set as errorLevel.
	               		If this is set to 1, the check will be shown in the report.

@throws  	UserException 		if wrong comparison mode has been set.

@author	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1nLV" local="true" procedure="..getRowCount"
                             retvarname="rowCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1nLW"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1o87" name="selection">
            <comment>Procedures to (de-)select certain rows of a table.

@author	QFS,mm
@since 	4.0</comment>
            <Procedure id="_1o88" name="deselectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Deselect all rows. It uses &lt;code&gt;getSelectionModel().clearSelection()&lt;/code&gt;.

@param 	id	ID of the table.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG1"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o89">
                <code>table = rc.getComponent(rc.lookup("id"))

table.getSelectionModel().clearSelection()
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o8A" name="deselectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Deselect a given row, specified by its index. It uses &lt;code&gt;clearSelection(row)&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author 	QFS,mzs
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG2"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o8B">
                <code>table = rc.getComponent(rc.lookup("id"))
row = rc.getInt("row")

if row != None:
    table.getSelectionModel().clearSelection(row)
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o8C" name="deselectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Deselect a range of rows, specified by their index. It uses &lt;code&gt;clearSelection(row)&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author 	QFS,mzs
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG3"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1oC4">
                <code>table = rc.getComponent(rc.lookup("id"))
#list is of the type javafx.scene.control.TableView

startRow = rc.getInt("startRow")
endRow = rc.lookup("endRow")
items = table.getItems().size()

if endRow == None or endRow == '':
	endRow = items
else:
	endRow = int(endRow)+1

for item in range(int(startRow),endRow):
    table.getSelectionModel().clearSelection(item)

</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o8E" name="selectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Select all rows. It uses &lt;code&gt;selectAll()&lt;/code&gt;

@param 	id	ID of the table.

@author 	QFS,mzs
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG4"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1oC2">
                <code>table = rc.getComponent(rc.lookup("id"))

if table != None:
    table.getSelectionModel().selectAll()
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o8G" name="selectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Select a given row, specified by its index. It uses &lt;code&gt;select(row)&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG5"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1o8H">
                <code>table = rc.getComponent(rc.lookup("id"))
row = rc.getInt("row")

if row != None:
    table.getSelectionModel().select(row)
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1o8J" name="selectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Select a range of rows, specified by their index. It uses &lt;code&gt;selectRange&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author	QFS,mzs
@since 	4.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oG6"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1oC3">
                <code>table = rc.getComponent(rc.lookup("id"))
#list is of the type javafx.scene.control.TableView

startRow = rc.getInt("startRow")
endRow = rc.lookup("endRow")
items = table.getItems().size()

if endRow == None or endRow == '':
	endRow = items
else:
	endRow = int(endRow) + 1

table.getSelectionModel().selectRange(startRow, endRow)</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1nLk" name="clickCellWithDetails">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given cell.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param	id  		ID of the table.
@param	column 		The column.
@param	row		The row.
@param 	columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param 	rowSeparator		Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x		The x coordinate for the click, default is empty to click in the middle.
@param	y		The y coordinate for the click, default is empty to click in the middle.
@param	clickCount		Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier		Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard		True, if hard event should be replayed. Default is false.
@param	popupTrigger		True, if click should open a popup. Default is false.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1nLl"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1o8L" name="getColumnCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of columns of a given table.
It uses the method &lt;code&gt;getColumns().size()&lt;/code&gt; to get the number.

@param	 id 	The component-ID of the table.
@return 	columnCount

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oG7"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1o8M">
              <code>table = rc.getComponent(rc.lookup("id"))

colCount = table.getColumns().size()

rc.setLocal("columnCount", colCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1o8N" retval="$(columnCount)"/>
          </Procedure>
          <Procedure id="_1nLp" name="getIndexOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">@</variable>
            <comment>Return the current index of a given column.

Sample usage:
Can be used to determine the numeric index of a column like 'Price'.

@param 	id  		ID of the table.
@param 	column 		The column.
@param 	columnSeparator	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   		The current index of the column, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)"
                            id="_1nLq" local="true" varname="index"/>
            <ReturnStep id="_1nLr" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1nLs" name="getNameOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">&amp;</variable>
            <comment>Return the header text of a given column.

Sample usage:
Determine the title of the second column.

@param 	id  		ID of the table.
@param 	column 		The column.
@param 	columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   		The name of the column.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)"
                           id="_1nLt" local="true" varname="name"/>
            <ReturnStep id="_1nLu" retval="$(name)"/>
          </Procedure>
          <Procedure id="_1o8O" name="getRowCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of rows of a given table.
It uses the method &lt;code&gt;getItems().size()&lt;/code&gt; to get the number.

@param 	id 	The component-id of the table.
@return 	rowCount

@author 	QFS,ue
@since 	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oG8"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1o8P">
              <code>table = rc.getComponent(rc.lookup("id"))
rowCount = table.getItems().size()

rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1o8Q" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1nLy" name="getRowIndexOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Return the row number of a given cell.

Sample usage:
Can be used to determine in which row a dedicated cell is located.

@param 	id  		ID of the table.
@param 	column 		The column.
@param 	row		The row.
@param 	columnSeparator	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param 	rowSeparator		Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   		The current index of the row, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            id="_1nLz" local="true" varname="index"/>
            <ReturnStep id="_1nL+" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1nL-" name="getValueOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">&amp;</variable>
            <comment>Return the text of a given cell.

Sample usage:
Can be used to determine the text of the cell in the first column and first row.

@param 	id  		ID of the table.
@param 	column 		The column.
@param 	row		The row.
@param 	columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param 	rowSeparator		Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value   		The current value of the row, which has been read by the 'Fetch text' node of QF-Test.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                           id="_1nM0" local="true" varname="value"/>
            <ReturnStep id="_1nM1" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1nM2" name="resizeColumn">
            <variable name="idColumn">aColumnId</variable>
            <variable name="width">aWidth</variable>
            <variable name="absolute">true</variable>
            <comment>Resize width of a table column.

@param 	client	The name of the client.
@param 	idColumn	The id of the table column to be resized.
@param 	width	The new width - additional or absolute, dependent on the 'absolute' parameter.
                                            For additional width also negative values are possible to shrink the column size.
@param 	absolute	True, if the with value shall be the absolute new column width (default is 'true').

@author	QFS,mm
@since	4.0</comment>
            <BasicSequence id="_1nM3">
              <variable name="currentWidth"/>
              <FetchGeometryStep client="$(client)" component="$(idColumn)"
                                 id="_1nM4" local="true"
                                 widthvarname="currentWidth"/>
              <IfSequence id="_1nM5" test="not $(absolute)">
                <SetGlobalStep id="_1nM7" local="true" varname="width">
                  <default>$[$(currentWidth) + $(width)]</default>
                </SetGlobalStep>
              </IfSequence>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_MOVED"
                              hardevent="true" id="_1nM8" modifiers="0"
                              x="$(currentWidth)"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(idColumn)" event="MOUSE_PRESSED"
                              hardevent="true" id="_1nM9" modifiers="16"
                              x="$(currentWidth)"/>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_DRAGGED"
                              hardevent="true" id="_1nMA" modifiers="16"
                              x="$(width)"/>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_RELEASED"
                              hardevent="true" id="_1nMB" modifiers="16"
                              x="$(width)"/>
            </BasicSequence>
          </Procedure>
          <Procedure id="_1nMC" name="selectCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Select a given cell.

@param 	id  		ID of the table.
@param 	column 		The column.
@param 	row		The row.
@param 	columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param 	rowSeparator		Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" id="_1nMD" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_1nMR" name="text">
          <comment>Procedures to access text fields and text areas.
(fx components &lt;code&gt;javafx.scene.control.TextField&lt;/code&gt; and &lt;code&gt;javafx.scene.control.TextArea&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Procedure id="_1nMS" name="clearArea">
            <variable name="id">${id:aTextArea}</variable>
            <comment>Clear a multi-line text area.

@param	client	The name of the SUT client.
@param	id	The id of the text area.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_1nMT" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_1nMU" name="clearField">
            <variable name="id">${id:aTextfield}</variable>
            <comment>Clear a simple text field.

@param	client	The name of the SUT client.
@param	id	The id of the text field.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_1nMV" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_1nMW" name="getText">
            <variable name="id">${id:aTextfield}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  	The text of the textfield.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1nMX"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1nMY" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1nMZ" name="setText">
            <variable name="id">${id:aTextfield}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

If the text is empty, no action will take place.

@param	id		ID of the textfield.
@param 	text		Text to be set.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1nMa" test="rc.lookup(&#34;text&#34;)">
              <ServerScriptStep id="_1nMb">
                <code>global parts

text = rc.lookup("text")
newline = rc.lookup("newline")
parts = text.split(newline)
rc.setLocal("iterations", len(parts))
</code>
              </ServerScriptStep>
              <RepeatSequence count="$(iterations)" id="_1nMc" var="i">
                <ServerScriptStep id="_1nMd">
                  <code>global parts
rc.setLocal("text", parts[$(i)].replace('$$', '$$$$'))
</code>
                </ServerScriptStep>
                <IfSequence id="_1nMe" test="$(i) == 0">
                  <IfSequence id="_1nMf"
                              test="&#34;$(append)&#34; == &#34;true&#34;">
                    <IfSequence id="_1nMg"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_1nMh">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_1nMi">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_1nMj" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                    <ElseSequence id="_1nMk">
                      <IfSequence id="_1nMl"
                                  test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                        <TextInputStep clear="true" client="$(client)"
                                       component="$(id)" id="_1nMm">
                          <text>$(text)</text>
                        </TextInputStep>
                        <ElseSequence id="_1nMn">
                          <TextInputStep clear="true" client="$(client)"
                                         component="$(id)" id="_1nMo"
                                         single="false">
                            <text>$(text)</text>
                          </TextInputStep>
                        </ElseSequence>
                      </IfSequence>
                    </ElseSequence>
                  </IfSequence>
                  <ElseSequence id="_1nMp">
                    <IfSequence id="_1nMq"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_1nMr">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_1nMs">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_1nMt" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                  </ElseSequence>
                </IfSequence>
                <IfSequence id="_1nMu" test="$(i) &lt; ($(iterations) - 1)">
                  <KeyEventStep client="$(client)" component="$(id)"
                                event="KEY_PTR" id="_1nMv" keychar="13"
                                keycode="10" modifiers="0"/>
                </IfSequence>
              </RepeatSequence>
              <ElseSequence id="_1nMw">
                <IfSequence id="_1nMx"
                            test="&#34;$(clear)&#34; == &#34;true&#34;">
                  <TextInputStep clear="true" client="$(client)"
                                 component="$(id)" id="_1nMy" single="false">
                    <text></text>
                  </TextInputStep>
                </IfSequence>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1nMz" name="setTextFromFile">
            <variable name="id">${id:aTextfield}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param id 	The id of the text-field to set.
@param file	The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nM+" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1nM-" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_1nN0" name="tree">
          <comment>Procedures to access trees.
(fx component &lt;code&gt;javafx.scene.control.TreeView&lt;/code&gt;)

@author	QFS,mm
@since	4.0</comment>
          <Package id="_2J2W" name="checks">
            <comment>Procedures for checking a tree.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_2J2p" name="checkNumberOfChildNodes">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of child nodes of a given tree node according to a specified comparison mode.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 		Separator to use for the node syntax. Default is 				@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2J2q" local="true"
                             procedure="qfs.fx.tree.getChildNodeCount"
                             retvarname="nodeCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2J2r"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of child nodes of tree '$(id)$(nodeSeparator)$(node)'</variable>
                <variable name="got">$(nodeCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2J2X" name="checkNumberOfRows">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of visible nodes under a given tree or tree node according to a specified comparison mode.
If no node is specified, you will get the visible nodes or all loaded nodes.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 		Separator to use for the node syntax. Default is 						@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2J2Y" local="true"
                             procedure="qfs.fx.tree.getRowCount"
                             retvarname="rowCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2J2Z"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of visible rows of tree '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_1o9W" name="_expandNodesR">
            <variable name="treeid">${id:treeid}</variable>
            <variable name="root"/>
            <variable name="callbackProc"/>
            <comment>Internal procedure.

@ignoreanalyzerefcid</comment>
            <SetGlobalStep id="_1o9X" local="true" varname="node">
              <default>$(root)</default>
              <comment>Force variable expansion</comment>
            </SetGlobalStep>
            <TryStep id="_1o9Y">
              <ProcedureCall id="_1o9Z" procedure=".expandNode">
                <variable name="id">$(treeId)</variable>
                <variable name="node">$(node)</variable>
                <variable name="separator">&amp;</variable>
              </ProcedureCall>
              <IfSequence id="_1o9a"
                          test="&#34;$(callbackProc)&#34; != &#34;&#34;">
                <ProcedureCall id="_1o9b" procedure="$(callbackProc)">
                  <variable name="treeId">$(treeId)</variable>
                  <variable name="node">$(node)</variable>
                </ProcedureCall>
              </IfSequence>
              <CatchSequence exception="ComponentNotFoundException" id="_1o9c"
                             maxerror="0">
                <ReturnStep id="_1o9d"/>
              </CatchSequence>
            </TryStep>
            <RepeatSequence count="1000" id="_1o9e" var="i">
              <SetGlobalStep id="_1o9f" local="true" varname="subnode">
                <default>$(node)/$(i)</default>
              </SetGlobalStep>
              <TryStep id="_1o9g">
                <ComponentWaiter client="$(client)"
                                 component="$(treeId)&amp;$(subnode)"
                                 disabled="true" id="_1o9h" timeout="0"/>
                <CheckBooleanStep checktype="visible" client="$(client)"
                                  component="$(treeId)&amp;$(subnode)"
                                  id="_1o9i" raise="true" timeout="0"/>
                <CatchSequence exception="CheckFailedException" id="_1o9j"
                               maxerror="0">
                  <BreakStep id="_1o9k"/>
                </CatchSequence>
                <CatchSequence disabled="true"
                               exception="ComponentNotFoundException"
                               id="_1o9l" maxerror="0">
                  <BreakStep id="_1o9m"/>
                </CatchSequence>
              </TryStep>
              <ProcedureCall id="_1o9n" procedure="qfs.fx.tree._expandNodesR">
                <variable name="treeId">$(treeId)</variable>
                <variable name="root">$(subnode)</variable>
                <variable name="callbackProc">$(callbackProc)</variable>
              </ProcedureCall>
            </RepeatSequence>
          </Procedure>
          <Procedure disabled="true" id="_1o9o" name="callbackPrintNodeText">
            <variable name="treeid">${id:treeid}</variable>
            <variable name="node"/>
            <comment>Example for a callback procedure used by expandNodes.

@param	treeId  	The id of the tree.
@param	node  	The index of the node.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(treeId)&amp;$(node)" id="_1oFQ"
                           local="true" varname="text"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1o9p"
                              name="Print node text">
              <code>print rc.lookup("text")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1nNM" name="clickNodeWithDetails">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given node.
You can specify the coordinates for clicking and all other details of that mouse click.

@param 	id  	ID of the tree.
@param 	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param 	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1nNN"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oBG" name="collapse">
            <variable name="node">tree.item</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.

@author	QFS,mm
@since	4.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oBH">
              <code>ID = rc.lookup('node')
if ID.find('&amp;/') &gt; 0:
    treeID = ID.split('&amp;')[0]
elif ID.find('@/') &gt; 0:
    treeID = ID.split('@')[0]
elif ID.find('%/') &gt; 0:
    treeID = ID.split('%')[0]
else:
    raise UserException('Invalid id %s' %ID)
   
rc.setLocal('tree', treeID)
  

</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBI" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(tree)"
                          event="KEY_PTR" id="_1oBJ" keychar="65535"
                          keycode="37" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBK" modifiers="16"/>
          </Procedure>
          <Procedure id="_1oBL" name="collapseWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oBM">
              <code>ID = rc.lookup('node')
if ID.find('&amp;/') &gt; 0:
    treeID = ID.split('&amp;')[0]
elif ID.find('@/') &gt; 0:
    treeID = ID.split('@')[0]
elif ID.find('%/') &gt; 0:
    treeID = ID.split('%')[0]
else:
    raise UserException('Invalid id %s' %ID)
   
rc.setLocal('tree', treeID)
  

</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBN" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(tree)"
                          event="KEY_PTR" id="_1oBO" keychar="65535"
                          keycode="37" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBP" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oBQ" name="collapseNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBR" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(id)" event="KEY_PTR"
                          id="_1oBS" keychar="65535" keycode="37"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBT" modifiers="16"/>
          </Procedure>
          <Procedure id="_1oBU" name="collapseNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBV" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(id)" event="KEY_PTR"
                          id="_1oBW" keychar="65535" keycode="37"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBX" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oBY" name="collapseNodes">
            <variable name="id"/>
            <comment>Collapse a tree node recursively.

@param	id  	The id of the tree node.

@author	QFS,gs
@since	4.0</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oFU"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oBZ">
              <code>ID = rc.lookup('id')
if ID.find('&amp;/') &gt; 0:
    pass
elif ID.find('@/') &gt; 0:
    pass
elif ID.find('%/') &gt; 0:
    pass
else:
    raise UserException('Invalid id %s' %ID)

cell = rc.getComponent(ID)
#print cell, cell.getTreeItem()

def collapseAll(item):
    for i in item.getChildren():
        collapseAll(i)
    item.setExpanded(false)

collapseAll(cell.getTreeItem())
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1oBa" name="expand">
            <variable name="node">tree.item</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.

@author	QFS,mm
@since	4.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oBb">
              <code>ID = rc.lookup('node')
if ID.find('&amp;/') &gt; 0:
    treeID = ID.split('&amp;')[0]
elif ID.find('@/') &gt; 0:
    treeID = ID.split('@')[0]
elif ID.find('%/') &gt; 0:
    treeID = ID.split('%')[0]
else:
    raise UserException('Invalid id %s' %ID)
   
rc.setLocal('tree', treeID)
  

</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBc" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(tree)"
                          event="KEY_PTR" id="_1oBd" keychar="65535"
                          keycode="39" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBe" modifiers="16"/>
          </Procedure>
          <Procedure id="_1oBf" name="expandWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_1oBg">
              <code>ID = rc.lookup('node')
if ID.find('&amp;/') &gt; 0:
    treeID = ID.split('&amp;')[0]
elif ID.find('@/') &gt; 0:
    treeID = ID.split('@')[0]
elif ID.find('%/') &gt; 0:
    treeID = ID.split('%')[0]
else:
    raise UserException('Invalid id %s' %ID)
   
rc.setLocal('tree', treeID)
  

</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBh" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(tree)"
                          event="KEY_PTR" id="_1oBi" keychar="65535"
                          keycode="39" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1oBj" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oBk" name="expandNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.


@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBl" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(id)" event="KEY_PTR"
                          id="_1oBm" keychar="65535" keycode="39"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBn" modifiers="16"/>
          </Procedure>
          <Procedure id="_1oBo" name="expandNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBp" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(id)" event="KEY_PTR"
                          id="_1oBq" keychar="65535" keycode="39"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1oBr" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oBs" name="expandNodes">
            <variable name="id"/>
            <variable name="callbackProc"/>
            <variable name="script">false</variable>
            <comment>Expand a tree node recursively.

@param	id  	The id of the tree node.
@param	callbackProc  	The name of a procedure to be called for every visited node.
@param	script	True to expand via script, in which case there are no callbacks.

@author	QFS,gs
@since	4.0</comment>
            <IfSequence id="_1oFR" name="Expand via script?" test="$(script)">
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oFn"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1oFS">
                <code>ID = rc.lookup('id')
if ID.find('&amp;/') &gt; 0:
    pass
elif ID.find('@/') &gt; 0:
    pass
elif ID.find('%/') &gt; 0:
    pass
else:
    raise UserException('Invalid id %s' %ID)

cell = rc.getComponent(ID)
print cell, cell.getTreeItem()

def expandAll(item):
    item.setExpanded(true)
    for i in item.getChildren():
        expandAll(i)

expandAll(cell.getTreeItem())
</code>
              </ClientScriptStep>
              <ElseSequence id="_1oFT">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1oBt" modifiers="16"/>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:fx}" id="_1oBu">
                  <code>
def setTreeAndIdx():
    ID = rc.lookup('id')
    if ID.find('&amp;/') &gt; 0:
        parts = ID.split('&amp;')
        rc.setLocal('tree', parts[0])
        rc.setLocal('idx', parts[1])
        return
    elif ID.find('@/') &gt; 0:
        treeID = ID.split('@')[0]
    elif ID.find('%/') &gt; 0:
        treeID = ID.split('%')[0]
    else:
        raise UserException('Invalid id %s' %ID)
    tree, itemIdx = rc.getComponent(ID)
    treepath = tree.getPathForRow(itemIdx)
    rc.logMessage("itemIdx: %d, path: %s" % (itemIdx, treepath))
    idx = []
    for i in range(treepath.getPathCount()):
        if i == 0:
            if tree.isRootVisible():
                idx.append('0')
        else:
            node = treepath.getPathComponent(i)
            pnode = treepath.getPathComponent(i - 1)
            idx.append(str(tree.getModel().getIndexOfChild(pnode, node)))
    rc.setLocal('tree', treeID)
    rc.setLocal('idx', '/' + '/'.join(idx))

setTreeAndIdx()
</code>
                </ClientScriptStep>
                <ProcedureCall id="_1oBv" procedure="._expandNodesR">
                  <variable name="treeId">$(tree)</variable>
                  <variable name="root">$(idx)</variable>
                  <variable name="callbackProc">$(callbackProc)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2J2l" name="getChildNodeCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of child nodes.

@param id 		The component-id of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the items of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 

@return nodeCount

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_2J2m"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_2J2n">
              <code>tree = None
item = None
nodeCount = 0
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if not rc.lookup("node") or not rc.lookup("nodeSeparator"):
    raise UserException("No value for 'node' parameter specified!")    

item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))

item = item.getTreeItem()
if not onlyVisibleNodes:
    cs = item.getChildren()
    if cs:
        nodeCount = len(cs)
                    
elif item.isExpanded():
    cs = item.getChildren()
    if cs:
        nodeCount = len(cs)
            
rc.setLocal("nodeCount", nodeCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2J2o" retval="$(nodeCount)"/>
          </Procedure>
          <Procedure id="_1nO2" name="getIndexOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">@</variable>
            <variable name="linear">false</variable>
            <comment>Return the current index of a given node.

Sample usage:
Can be used to determine the numeric index of a node like '/Root/Price'.

@param 	id  		ID of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'.
@param 	nodeSeparator	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param 	linear		If true, return the linear index, ignoring the tree structure, otherwise return a hierarchical index like /0/1.
@return	index   		The current index of the node, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1nO3" name="Override option">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:fx}" id="_1nO4"
                                name="Set legacy option">
                <code>rc.setOption("LegacyFetchIndex", rc.getBool("linear"))</code>
              </ClientScriptStep>
              <FetchIndexStep client="$(client)"
                              component="$(id)$(nodeSeparator)$(node)"
                              id="_1nO5" local="true" varname="index"/>
              <ReturnStep id="_1nO6" retval="$(index)"/>
              <FinallySequence id="_1nO7" name="Reset option">
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:fx}" id="_1nO8"
                                  name="Unset legacy option">
                  <code>rc.unsetOption("LegacyFetchIndex")</code>
                </ClientScriptStep>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2J2R" name="getRowCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of visible nodes under a given tree or tree-node.
If no node is specified, you will get the visible nodes or all loaded nodes of the entire tree.

@param id 		The component-id of the tree.
@param node 		The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the nodes of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@return rowCount

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_2J2S"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:fx}" id="_2J2a">
              <code>def getNumberOfChildren(node, checkVisibility):
    if checkVisibility or node.isExpanded():
        cs = node.getChildren()
        count = 0
        if cs:
            count = len(cs)    
        child_count = 0    
        for c in cs:
            if checkVisibility or c.isExpanded():
                child_count = child_count + getNumberOfChildren(c, checkVisibility)
        return count + child_count
    else:
        return 0
    
tree = None
item = None
rowCount = 0
root = None
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if rc.lookup("node") and rc.lookup("nodeSeparator"):
    item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))
    item = item.getTreeItem()
else:
    tree = rc.getComponent(rc.lookup("id"))
    item = tree.getRoot()


if not onlyVisibleNodes:
    rowCount = getNumberOfChildren(item, True) + 1         
elif item.isExpanded():
    rowCount = getNumberOfChildren(item, False) + 1       
else:
    rowCount = 1

rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2J2U" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1nOC" name="getValueOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">&amp;</variable>
            <comment>Return the text of a given node.

Sample usage:
Determine the text value for a node referenced by index like /0/1.

@param 	id  		ID of the tree.
@param 	node 		The node. It should be something like '/Root/Price' or '/0/0'.
@param 	nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   		The value of the node.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(nodeSeparator)$(node)" id="_1nOD"
                           local="true" varname="value"/>
            <ReturnStep id="_1nOE" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1nOF" name="selectNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Select a given node.

@param 	id  	ID of the tree.
@param 	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param 	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author 	QFS,mm
@since 	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1nOG" modifiers="16"/>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2YM1" name="jib">
        <comment>Procedures for JiB (Java in Browsers).</comment>
        <Package id="_2YMK" name="options">
          <comment>Procedures for setting special options for JiB (Java in Browsers) tests.

@author	QFS
@since	5.2.0</comment>
          <Procedure id="_2YMh" name="replayFXHardMouseEventAs">
            <variable name="clicktype">fx</variable>
            <comment>Set the type of event for replaying a hard JavaFX mouse event.

@param clicktype 	"hard", "semihard" or "soft" for click in web or "fx" for click in JavaFX.	
@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMi" interpreter="groovy"
                              name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_HARD_MOUSE_EVENT_AS, rc.lookup("clicktype"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMj" name="replayFXSoftMouseEventAs">
            <variable name="clicktype">fx</variable>
            <comment>Set the type of event for replaying a soft JavaFX mouse event.

@param clicktype 	"hard", "semihard" or "soft" for click in web or "fx" for click in JavaFX.	
@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMk" interpreter="groovy"
                              name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_SOFT_MOUSE_EVENT_AS, rc.lookup("clicktype"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMl" name="replayFXDnDEventAs">
            <variable name="type">fx</variable>
            <comment>Set the type of event for Replaying JavaFX drag and drop.

@param type 	"web" for drag and drop in web or "fx" for drag and drop in JavaFX.	
@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMm" interpreter="groovy"
                              name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_DND_EVENT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMn" name="replayFXKeyEventAs">
            <variable name="type">fx</variable>
            <comment>Set the type of event for replaying a JavaFX keystroke.

@param type 	"web" for replay in web or "fx" to replay in JavaFX	.

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMo" interpreter="groovy"
                              name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_KEY_EVENT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMp" name="replayFXTextInputAs">
            <variable name="type">fx</variable>
            <comment>Set the type of event for replaying JavaFX text input.

@param type 	"web" for replay in web or "fx" to replay in JavaFX	.

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMq" interpreter="groovy"
                              name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_TEXT_INPUT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMr" name="replayFXImageCheckAs">
            <variable name="type">fx</variable>
            <comment>Set where to fetch the image when replaying a JavaFX image check.

@param type 	"web" to fetch the image from the browser or "fx" to check in JavaFX.

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)" engine="${default:engine:fx}"
                              id="_2YMs" interpreter="groovy"
                              name="set image check">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_FX_IMAGE_CHECK_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMA" name="replaySwingHardMouseEventAs">
            <variable name="clicktype">swing</variable>
            <comment>Set the type of event for replaying a hard Swing mouse event.

@param clicktype 	"hard", "semihard" or "soft" for click in web or "swing" for click in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMB"
                              interpreter="groovy" name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_HARD_MOUSE_EVENT_AS, rc.lookup("clicktype"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMP" name="replaySwingSoftMouseEventAs">
            <variable name="clicktype">swing</variable>
            <comment>Set the type of event for replaying a soft Swing mouse event.

@param clicktype 	"hard", "semihard" or "soft" for click in web or "swing" for click in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMQ"
                              interpreter="groovy" name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_SOFT_MOUSE_EVENT_AS, rc.lookup("clicktype"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMV" name="replaySwingDnDEventAs">
            <variable name="type">swing</variable>
            <comment>Set the type of event for Replaying Swing drag and drop.

@param type 	"web" for drag and drop in web or "swing" for drag and drop in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMW"
                              interpreter="groovy" name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_DND_EVENT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMd" name="replaySwingKeyEventAs">
            <variable name="type">swing</variable>
            <comment>Set the type of event for replaying a Swing keystroke.

@param type 	"web" for replay in web or "swing" to replay in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMe"
                              interpreter="groovy" name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_KEY_EVENT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMf" name="replaySwingTextInputAs">
            <variable name="type">swing</variable>
            <comment>Set the type of event for replaying Swing text input.

@param type 	"web" for replay in web or "swing" to replay in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMg"
                              interpreter="groovy" name="set web events">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_TEXT_INPUT_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2YMb" name="replaySwingImageCheckAs">
            <variable name="type">swing</variable>
            <comment>Set where to fetch the image for replaying a Swing image check.

@param type 	"web" to fetch the image from the browser or "swing" to check in Swing.	

@author	QFS
@since	5.2.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:engine:awt}" id="_2YMc"
                              interpreter="groovy" name="set image check">
              <code>rc.setOption(Options.OPT_JIB_REPLAY_SWING_IMAGE_CHECK_AS, rc.lookup("type"))</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2JAp" name="pdf">
        <comment>Procedures for PDF testing.

@author	QFS
@since	4.2</comment>
        <Package id="_2JCH" name="highlight">
          <comment>Procedures in order to highlight components.

@author	QFS,ys
@since	4.2</comment>
          <Procedure id="_2JCo" name="_ensurePDFMenuViewOpen">
            <comment>Internal procedure.

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="genericPDFMenuShowORHideComponents"
                             id="_2JCv" local="true" raise="false"
                             resvarname="showOrHideComponents" timeout="1"/>
            <IfSequence id="_2JCw" test="not $(showOrHideComponents)">
              <MouseEventStep clicks="1" client="$(client)"
                              component="genericPDFMenuView"
                              event="MOUSE_MPRC" id="_2JCp" modifiers="16"/>
              <ComponentWaiter client="$(client)"
                               component="genericPDFMenuShowORHideComponents"
                               errorlevel="0" id="_2JCx" timeout="10000"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JCS" name="showBordersAroundComponents">
            <comment>Show borders around each recognized component.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JD2"
                           procedure="qfs.pdf.highlight._ensurePDFMenuViewOpen"/>
            <ComponentWaiter client="$(client)"
                             component="genericPDFMenuShowComponents"
                             id="_2JD6" local="true" raise="false"
                             resvarname="showComponents" timeout="1"/>
            <IfSequence id="_2JCW" test="$(showComponents)">
              <MouseEventStep clicks="1" client="$(client)"
                              component="genericPDFMenuShowComponents"
                              event="MOUSE_MPRC" id="_2JCU" modifiers="16"/>
              <ElseSequence id="_2JCX">
                <MouseEventStep clicks="1" client="$(client)"
                                component="genericPDFMenuView"
                                event="MOUSE_MPRC" id="_2JCY" modifiers="16"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JCZ" name="hideBordersAroundComponents">
            <comment>Hide borders around each recognized component.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JD3"
                           procedure="qfs.pdf.highlight._ensurePDFMenuViewOpen"/>
            <ComponentWaiter client="$(client)"
                             component="genericPDFMenuHideComponents"
                             id="_2JD7" local="true" raise="false"
                             resvarname="hideComponents" timeout="1"/>
            <IfSequence id="_2JCc" test="$(hideComponents)">
              <MouseEventStep clicks="1" client="$(client)"
                              component="genericPDFMenuHideComponents"
                              event="MOUSE_MPRC" id="_2JCd" modifiers="16"/>
              <ElseSequence id="_2JCe">
                <MouseEventStep clicks="1" client="$(client)"
                                component="genericPDFMenuView"
                                event="MOUSE_MPRC" id="_2JCf" modifiers="16"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JCh" name="toggleBordersAroundComponents">
            <comment>Toggle borders around each recognized component.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JD4"
                           procedure="qfs.pdf.highlight._ensurePDFMenuViewOpen"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="genericPDFMenuShowORHideComponents"
                            event="MOUSE_MPRC" id="_2JD5" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_2JCF" name="navigation">
          <comment>Procedures to navigate inside a PDF document.

@author	QFS,ys
@since	4.2</comment>
          <Procedure id="_2JD8" name="iterate">
            <variable name="order">forward</variable>
            <variable name="exclude"/>
            <variable name="procedureToCall"/>
            <comment>Iterate over all pages in a PDF document. It's possible to call a procedure on every page.

@param	order	The order in which to iterate over the pages of the PDF document.
		Possible values: "forward" (will iterate over all pages in forward order), "reversed" (will iterate over all pages in reversed order), "random" (will iterate over all pages in random order).
@param	exclude	Comma-separated list of pages to exclude from iteration.
@param	procedureToCall	On each page a certain procedure gets called (specified via this argument). The current pageNumber will be passed to the procedure as argument. The procedure may break the iteration by throwing a BreakException.

@return The list of (comma-separated) page numbers which got 'true' returned by the called 'procedureToCall' parameter.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JD9" local="true"
                           procedure="qfs.pdf.page.getPageCount"
                           retvarname="numberOfPages"/>
            <ServerScriptStep id="_2JDH">
              <code>global returnLst
returnLst = []</code>
            </ServerScriptStep>
            <TestStep id="_4q" name="Iterate over pages">
              <DataDriver id="_4r" name="pageIterator">
                <ServerScriptStep id="_2JDA">
                  <code>import random, databinder

# get the number of 
excludeLst = []
try: excludeLst = [int(x.strip()) for x in rc.lookup("exclude").split(",")]
except: pass # empty list

# get the list of page numbers to iterate over ...
pageNumbers = [i+1 for i in range(rc.getInt("numberOfPages")) if i+1 not in excludeLst]

# maybe change order
order = rc.lookup("order")
if order == "forward":
    pass # nothing to do
elif order == "reversed":
    pageNumbers = pageNumbers[::-1]
elif order == "random":
    random.shuffle(pageNumbers)
else: raise UserException("Unknown argument '%s' for order" % order)

# bind
databinder.bindList(rc, "pageIterator", "pageNumber", pageNumbers)</code>
                </ServerScriptStep>
              </DataDriver>
              <SelectionEventStep client="$(client)"
                                  component="genericPDFWindow"
                                  detail="goto:$(pageNumber)"
                                  event="SELECTION" id="_3y"/>
              <SetGlobalStep id="_2JDP" local="true" varname="state">
                <default>needToExecuteProcCall</default>
              </SetGlobalStep>
              <WhileSequence id="_2JDO"
                             test="&#34;$(state)&#34; == &#34;needToExecuteProcCall&#34;">
                <comment>While-Hack to "catch" the BreakException</comment>
                <ProcedureCall id="_2JDE" local="true"
                               procedure="$(procedureToCall)"
                               retvarname="result">
                  <variable name="pageNumber">$(pageNumber)</variable>
                </ProcedureCall>
                <IfSequence id="_2JDJ" test="$(result)">
                  <ServerScriptStep id="_2JDK">
                    <code>global returnLst
returnLst.append(rc.lookup("pageNumber"))</code>
                  </ServerScriptStep>
                </IfSequence>
                <SetGlobalStep id="_2JDQ" local="true" varname="state">
                  <default>procEnded</default>
                </SetGlobalStep>
              </WhileSequence>
              <IfSequence id="_2JDR"
                          test="&#34;$(state)&#34; == &#34;needToExecuteProcCall&#34;">
                <ServerScriptStep id="_2JDS">
                  <code>global returnLst
raise ReturnException(",".join(returnLst))</code>
                </ServerScriptStep>
              </IfSequence>
            </TestStep>
            <ServerScriptStep id="_2JDI">
              <code>global returnLst
raise ReturnException(",".join(returnLst))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_2JB5" name="openFirstPage">
            <comment>Open the first page of the PDF document.

@author	QFS,ys
@since	4.2</comment>
            <SelectionEventStep client="$(client)"
                                component="genericPDFWindow" detail="goto:1"
                                event="SELECTION" id="_2JB6"/>
          </Procedure>
          <Procedure id="_2JB8" name="openLastPage">
            <comment>Open the last page of the PDF document.

@author	QFS,ys
@since	4.2</comment>
            <SelectionEventStep client="$(client)"
                                component="genericPDFWindow" detail="goto:-1"
                                event="SELECTION" id="_2JBA"/>
          </Procedure>
          <Procedure id="_2JBC" name="openNextPage">
            <variable name="lastPageStrategy">exception</variable>
            <comment>Open/Goto the next page of the PDF document.

@param	lastPageStrategy	May either be "exception", "stay", "first page" or "random".
			If lastPageStrategy equals to "exception" and this method get's called a TestException is thrown.
			If lastPageStrategy equals to "stay" and this method get's called nothing will be done.
			If lastPageStrategy equals to "first page" and this method get's called, the first page will be opened.
			If lastPageStrategy equals to "random" and this method get's called a random page will get opened.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JBD" local="true"
                           procedure="qfs.pdf.page.getPageCount"
                           retvarname="nrPages"/>
            <TryStep id="_2JBE">
              <ProcedureCall id="_2JBF" local="true"
                             procedure="qfs.pdf.page.getCurrentPageNumber"
                             retvarname="currentPage"/>
              <CatchSequence exception="TestException" id="_2JBG"
                             maxerror="0">
                <catchmessage>PDFClient: No page selected!</catchmessage>
                <ProcedureCall id="_2JBS"
                               procedure="qfs.pdf.navigation.openFirstPage"/>
                <ReturnStep id="_2JBT"/>
              </CatchSequence>
            </TryStep>
            <IfSequence id="_2JBU" test="$(nrPages) == $(currentPage)">
              <IfSequence id="_2JBI"
                          test="rc.lookup(&#34;lastPageStrategy&#34;) == &#34;exception&#34;">
                <ThrowStep id="_2JBQ"
                           throwmessage="You have reached the last page of your PDF!"/>
                <ElseifSequence id="_2JBL"
                                test="rc.lookup(&#34;lastPageStrategy&#34;) == &#34;stay&#34;">
                  <ReturnStep id="_2JBR"/>
                </ElseifSequence>
                <ElseifSequence id="_2JBO"
                                test="rc.lookup(&#34;lastPageStrategy&#34;) == &#34;first page&#34;">
                  <ProcedureCall id="_2JBV"
                                 procedure="qfs.pdf.navigation.openFirstPage"/>
                  <ReturnStep id="_2JBW"/>
                </ElseifSequence>
                <ElseifSequence id="_2JBP"
                                test="rc.lookup(&#34;lastPageStrategy&#34;) == &#34;random&#34;">
                  <ProcedureCall id="_2JBf"
                                 procedure="qfs.pdf.navigation.openRandomPage"/>
                  <ReturnStep id="_2JBX"/>
                </ElseifSequence>
                <ElseSequence id="_2JBM">
                  <ThrowStep id="_2JBN"
                             throwmessage="Illegal lastPageStrategy-String"/>
                </ElseSequence>
              </IfSequence>
              <ElseSequence id="_2JBg">
                <SelectionEventStep client="$(client)"
                                    component="genericPDFWindow"
                                    detail="goto:$[$(currentPage)+1]"
                                    event="SELECTION" id="_2JBh"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JC1" name="openPage">
            <variable name="pageNumber">1</variable>
            <comment>Open a specific page of the PDF document.

@param	pageNumber	The number of the page to open

@author	QFS,ys
@since	4.2</comment>
            <SelectionEventStep client="$(client)"
                                component="genericPDFWindow"
                                detail="goto:$(pageNumber)" event="SELECTION"
                                id="_2JC2"/>
          </Procedure>
          <Procedure id="_2JC4" name="openPrevPage">
            <variable name="firstPageStrategy">exception</variable>
            <comment>Open/Goto the previous page of the PDF document.

@param	firstPageStrategy	May either be "exception", "stay", "last page" or "random".
			If firstPageStrategy equals to "exception" and this method get's called a TestException is thrown.
			If firstPageStrategy equals to "stay" and this method get's called nothing will be done.
			If firstPageStrategy equals to "last page" and this method get's called, the last page will be opened.
			If firstPageStrategy equals to "random" and this method get's called a random page will get opened.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JC5" local="true"
                           procedure="qfs.pdf.page.getPageCount"
                           retvarname="nrPages"/>
            <TryStep id="_2JC6">
              <ProcedureCall id="_2JBj" local="true"
                             procedure="qfs.pdf.page.getCurrentPageNumber"
                             retvarname="currentPage"/>
              <CatchSequence exception="TestException" id="_2JBk"
                             maxerror="0">
                <catchmessage>PDFClient: No page selected!</catchmessage>
                <ProcedureCall id="_2JBl"
                               procedure="qfs.pdf.navigation.openLastPage"/>
                <ReturnStep id="_2JBm"/>
              </CatchSequence>
            </TryStep>
            <IfSequence id="_2JBn" test="$(currentPage) == 1">
              <IfSequence id="_2JBo"
                          test="rc.lookup(&#34;firstPageStrategy&#34;) == &#34;exception&#34;">
                <ThrowStep id="_2JBp"
                           throwmessage="You have reached the first page of your PDF!"/>
                <ElseifSequence id="_2JBq"
                                test="rc.lookup(&#34;firstPageStrategy&#34;) == &#34;stay&#34;">
                  <ReturnStep id="_2JBr"/>
                </ElseifSequence>
                <ElseifSequence id="_2JBs"
                                test="rc.lookup(&#34;firstPageStrategy&#34;) == &#34;last page&#34;">
                  <ProcedureCall id="_2JBt"
                                 procedure="qfs.pdf.navigation.openLastPage"/>
                  <ReturnStep id="_2JBu"/>
                </ElseifSequence>
                <ElseifSequence id="_2JBv"
                                test="rc.lookup(&#34;firstPageStrategy&#34;) == &#34;random&#34;">
                  <ProcedureCall id="_2JBw"
                                 procedure="qfs.pdf.navigation.openRandomPage"/>
                  <ReturnStep id="_2JBx"/>
                </ElseifSequence>
                <ElseSequence id="_2JBy">
                  <ThrowStep id="_2JBz"
                             throwmessage="Illegal firstPageStrategy-String"/>
                </ElseSequence>
              </IfSequence>
              <ElseSequence id="_2JB+">
                <SelectionEventStep client="$(client)"
                                    component="genericPDFWindow"
                                    detail="goto:$[$(currentPage)-1]"
                                    event="SELECTION" id="_2JB-"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2JBZ" name="openRandomPage">
            <comment>Open a random page of the PDF document.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JBa" local="true"
                           procedure="qfs.pdf.page.getPageCount"
                           retvarname="result"/>
            <ProcedureCall id="_2JBd" local="true"
                           procedure="qfs.utils.random.getNumberFromRange"
                           retvarname="randomNumber">
              <variable name="lowest">1</variable>
              <variable name="highest">$[$(result) + 1]</variable>
            </ProcedureCall>
            <SelectionEventStep client="$(client)"
                                component="genericPDFWindow"
                                detail="goto:$(randomNumber)"
                                event="SELECTION" id="_2JBe"/>
          </Procedure>
        </Package>
        <Package id="_2JCE" name="page">
          <comment>Procedures to get/interact with the current page / all pages.

@author	QFS,ys
@since	4.2</comment>
          <Procedure id="_2JAx" name="getCurrentPageName">
            <comment>Return the name of the currently selected page in the PDF document.

@author	QFS,ys
@since	4.2

@throws TestException If no page is selected.</comment>
            <ClientScriptStep client="$(client)"
                              engine="${qftest:engine.genericPDFPageTree}"
                              id="_2JAy">
              <code>tree = rc.getComponent("genericPDFPageTree")
path = tree.getSelectionPath()
if path.pathCount &lt;= 1:
    raise TestException("PDFClient: No page selected!")
val = str(path.getLastPathComponent())
val = val.split("-", 1)
page = ""
if len(val) == 1:
    page = ""
else:
    page = val[1][1:]

rc.setLocal("page", page)</code>
            </ClientScriptStep>
            <ReturnStep id="_2JDU" retval="$(page)"/>
          </Procedure>
          <Procedure id="_2JB3" name="getCurrentPageNumber">
            <comment>Return the index/number of the currently selected page in the PDF document.

@author	QFS,ys
@since	4.2

@throws TestException If no page is selected.</comment>
            <ClientScriptStep client="$(client)"
                              engine="${qftest:engine.genericPDFPageTree}"
                              id="_2JB4">
              <code>tree = rc.getComponent("genericPDFPageTree")
path = tree.getSelectionPath()
if path.pathCount &lt;= 1:
    raise TestException("PDFClient: No page selected!")
rc.setLocal("page", str(path.getLastPathComponent().getPageNum()))</code>
            </ClientScriptStep>
            <ReturnStep id="_2JDW" retval="$(page)"/>
          </Procedure>
          <Procedure id="_2JAq" name="getPageCount">
            <comment>Return the number of pages in a PDF document.

@author	QFS,ys
@since	4.2</comment>
            <ProcedureCall id="_2JAt" local="true"
                           procedure="qfs.swing.tree.getRowCount"
                           retvarname="result">
              <variable name="id">genericPDFPageTree</variable>
              <variable name="node">.*</variable>
              <variable name="nodeSeparator">%</variable>
              <variable name="countOnlyVisibleNodes">True</variable>
            </ProcedureCall>
            <ReturnStep id="_2JAu" retval="$[$(result)-1]"/>
          </Procedure>
          <Procedure id="_2JC7" name="refreshCurrentPage">
            <comment>Refresh the currently opened page.

@author	QFS,ys
@since	4.2</comment>
            <TryStep id="_2JC8">
              <ProcedureCall id="_2JC9" local="true"
                             procedure="qfs.pdf.page.getCurrentPageNumber"
                             retvarname="currentPage"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="genericPDFPageTree%/.*"
                              event="MOUSE_MPRC" id="_2JCB" modifiers="16"/>
              <ProcedureCall id="_2JCA"
                             procedure="qfs.pdf.navigation.openPage">
                <variable name="pageNumber">$(currentPage)</variable>
              </ProcedureCall>
              <CatchSequence exception="TestException" id="_2JCC"
                             maxerror="0">
                <catchmessage>PDFClient: No page selected!</catchmessage>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2FS" name="run-log">
        <comment>Procedures for writing log-entries.

@author        QFS,mm
@since 2.1.0</comment>
        <Package id="_6W5" name="screenshots">
          <comment>Procedures to write screenshots into the run-log.

@author        QFS,mm
@since 3.0</comment>
          <Procedure id="_6WC" name="getMonitorCount">
            <variable name="inSUT">false</variable>
            <comment>Return the total number of monitors.

@param inSUT	Whether to take the screenshot in a SUT script. Should be true, if you start the SUT remotely.
@param  guiengine	The name of the engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.

@return The total number of monitors.

@author        QFS,mm
@since 3.0</comment>
            <IfSequence id="_1juW" test="$(inSUT)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_6WD"
                                name="count monitors in SUT script.">
                <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)
rc.setLocal("monitorcount", iw.getMonitorCount())</code>
              </ClientScriptStep>
              <ReturnStep id="_6WE" retval="$(monitorcount)"/>
              <ElseSequence id="_1juY">
                <ServerScriptStep id="_1jub"
                                  name="count monitors in server script.">
                  <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)
rc.setLocal("monitorcount", iw.getMonitorCount())</code>
                </ServerScriptStep>
                <ReturnStep id="_1jua" retval="$(monitorcount)"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1jyn" name="logScreenshot">
            <variable name="inSUT">false</variable>
            <variable name="title"/>
            <variable name="dontcompactify">false</variable>
            <variable name="report">false</variable>
            <comment>Write a screenshot of the whole screen into the run-log.

@param inSUT	Whether to take the screenshot in a SUT script. Should be true, if you start the SUT remotely.
@param title An optional title for the image.
@param dontcompactify If true, the screenshot will not be removed from the run-log. Use with care!
@param report If true, the screenshot will be shown in the report. Implies dontcompactify.
@param  guiengine	The name of the engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.

@author        QFS,mm
@since 3.0</comment>
            <IfSequence id="_1jyo" test="$(inSUT)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_1jyp"
                                name="screenshot in SUT script">
                <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)

rc.logImage(iw.grabScreenshot(),
            title=rc.lookup("title"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))</code>
              </ClientScriptStep>
              <ElseSequence id="_1jyq">
                <ServerScriptStep id="_1jyr"
                                  name="screenshot in server script">
                  <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)

rc.logImage(iw.grabScreenshot(),
            title=rc.lookup("title"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))</code>
                </ServerScriptStep>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_6WA" name="logImageOfComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="title"/>
            <variable name="dontcompactify">false</variable>
            <variable name="report">false</variable>
            <comment>Write an image of a component into the run-log.

@param	client	The name of the SUT client.
@param  id   The ID of the component to be written into the run-log.
@param title An optional title for the image.
@param dontcompactify If true, the screenshot will not be removed from the run-log. Use with care!
@param report If true, the screenshot will be shown in the report. Implies dontcompactify.
@param  guiengine	The name of the engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.


@author        QFS,mm
@since 3.0

@ignoreanalyzerefcid
</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oG9"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <RepeatSequence count="2" id="_1nzQ">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_6WB"
                                name="grab an image of a component">
                <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)

com = rc.getComponent(rc.lookup("id"))
if qf.isInstance(com, "org.python.core.PyTuple"):
    com = com[0]
try:
    ir = iw.grabImage(com)
except:
    ir = None
if ir:    
    rc.logImage(ir,
            title=rc.lookup("title"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))
    raise ReturnException()
</code>
              </ClientScriptStep>
              <BasicSequence id="_1nzS" name="delay" postdelay="500"/>
            </RepeatSequence>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:}" id="_1nzR"
                              name="log image failed">
              <code>com = rc.getComponent(rc.lookup("id"))
if qf.isInstance(com, "org.python.core.PyTuple"):
    com = com[0]
msg = "Failed to grab an image for %s" %(str(com))
try:
    loc = com.getLocationOnScreen()
    msg += " " + str(loc)
except:
    pass
rc.logWarning(msg)
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6W6" name="logScreenshotOfMonitor">
            <variable name="monitor">0</variable>
            <variable name="inSUT">false</variable>
            <variable name="title"/>
            <variable name="dontcompactify">false</variable>
            <variable name="report">false</variable>
            <comment>Write a screenshots of a given monitor into the run-log.

@param monitor  The index of the monitor, the first one is 0, the second 1 etc.
@param inSUT	Whether to take the screenshot in a SUT script. Should be true, if you start the SUT remotely.
@param title An optional title for the image.
@param dontcompactify If true, the screenshot will not be removed from the run-log. Use with care!
@param report If true, the screenshot will be shown in the report. Implies dontcompactify.
@param  guiengine	The name of the engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.


@author        QFS,mm
@since 3.0</comment>
            <IfSequence id="_1juR" test="$(inSUT)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_6W7"
                                name="screenshot in SUT script">
                <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)

rc.logImage(iw.grabScreenshots($(monitor)),
            title=rc.lookup("title"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))</code>
              </ClientScriptStep>
              <ElseSequence id="_1juT">
                <ServerScriptStep id="_1juV"
                                  name="screenshot in server script">
                  <code>import imagewrapper

iw = imagewrapper.ImageWrapper(rc)

rc.logImage(iw.grabScreenshots($(monitor)),
            title=rc.lookup("title"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))</code>
                </ServerScriptStep>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_1lVJ" name="web">
          <comment>Procedures to write web specifics into run-log.

@author	QFS,mm
@since 	3.4.9</comment>
          <Procedure id="_1lVK" name="logSourcecode">
            <variable name="docId">${id:genericDocument}</variable>
            <variable name="frameName"/>
            <variable name="msgLevel">MESSAGE</variable>
            <comment>Write a document's source code into the run-log.
It also logs the source code of all child documents of the given document.
If you want to log only one dedicated frame you can specify the name of the frame. If this frame has child frames, those children will also be logged.

@param	docId	The Id of the web page.
@param 	frameName	The name of the frame to provide source code.
@param 	msgLevel   	The level of the message, which should be logged. Either ERROR, WARNING or MESSAGE. If no msgLevel or any wrong level is specified it will log the message as message.

@author	QFS, mm
@since	3.4.9

@ignoreanalyzerefcid
</comment>
            <ComponentWaiter client="$(client)" component="$(docId)"
                             id="_1oGA"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1lVL"
                              name="Source code for all frames">
              <code>def logSource(source):
    msgLevel = rc.lookup("msgLevel")
    if msgLevel == None:
        msgLevel = ""

    if msgLevel.upper() == "WARNING":
        rc.logWarning(source)
    elif msgLevel.upper() == "ERROR":
        rc.logError(source)
    else:
        rc.logMessage(source,dontcompactify=True)

def logChildSources(doc, framename):
    frames = doc.getFrames()
    totalRet = -1

    if len(frames) == 0:
        return 0
    for frame in frames:
        cdoc = frame.getChildDocument()
        if framename == "" or frame.getFrameName() == framename:
            source = cdoc.getSourcecode()
            logSource(source)
            logChildSources(cdoc, "")
            totalRet = 1
        else: #try to find a child in another frame with that name
            ret = logChildSources(cdoc, framename)
            if ret == 1:
                totalRet = 1
    return totalRet

doc = rc.getComponent("$(docId)")
framename = rc.lookup("frameName")
if not framename:
    framename = ""

source = doc.getSourcecode()
sourceRet = -1
if framename == "":
    logSource(source)
    sourceRet = 1

ret = logChildSources(doc, framename)

if sourceRet != 1 and ret != 1:
    raise UserException("No frame with name '" + framename + "' visible.")
    </code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Procedure id="_2FT" name="logError">
          <variable name="message"/>
          <variable name="withScreenshots">false</variable>
          <comment>Write an error into the run-log.

@param client  The name of the SUT client.
@param message The message, which should be written.
@param withScreenshots	If true, try to take screenshots from individual SUT windows.
@param  guiengine	The name of the engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.


@author        QFS,mm
@since 2.1.0</comment>
          <TryStep id="_1kJU">
            <IfSequence id="_1juL" test="$(withScreenshots)">
              <ServerScriptStep id="_2YdE"
                                name="Set option to log screenshots for all SUT windows">
                <code>rc.setOption(Options.OPT_LOG_CONTENT_SCREENSHOT_ALL_WINDOWS, true)</code>
              </ServerScriptStep>
            </IfSequence>
            <ServerScriptStep id="_1kJW"
                              name="log error in server script - only screenshot of the whole screen is taken">
              <code>rc.logError(rc.lookup("message", expand=false))</code>
            </ServerScriptStep>
            <FinallySequence id="_2YdF">
              <IfSequence id="_2YdG" test="$(withScreenshots)">
                <ServerScriptStep id="_2YdH"
                                  name="Set option to log screenshots for all SUT windows">
                  <code>rc.unsetOption(Options.OPT_LOG_CONTENT_SCREENSHOT_ALL_WINDOWS)</code>
                </ServerScriptStep>
              </IfSequence>
            </FinallySequence>
          </TryStep>
        </Procedure>
        <Procedure id="_2FX" name="logMessage">
          <variable name="message"/>
          <variable name="dontcompactify">false</variable>
          <variable name="report">false</variable>
          <comment>Write a message into the run-log.

@param message The message, which should be written.
@param dontcompactify If true, the message will not be removed from the run-log. Use with care!
@param report If true, the message will be shown in the report. Implies dontcompactify.


@author        QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_2FY" name="log a message">
            <code>rc.logMessage(rc.lookup("message"),
            dontcompactify=rc.getBool("dontcompactify"),
            report=rc.getBool("report"))</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2FV" name="logWarning">
          <variable name="message"/>
          <variable name="report">false</variable>
          <comment>Write a warning into the run-log.

@param message The message, which should be written.
@param report If true, the warning will be shown in the report.



@author        QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_2FW" name="log a warning">
            <code>rc.logWarning(rc.lookup("message"), report=rc.getBool("report"))</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_6SJ" name="shellutils">
        <comment>Utility procedures for shell commands.

@author	QFS,mm
@since	2.2</comment>
        <Procedure id="_6T5" name="copy">
          <variable name="source">aSource</variable>
          <variable name="target">aTarget</variable>
          <comment>Copy a given file or directory to a given target. If the target is a directory, copy source into that directory. If target's parent directory does not exist, create it.

@param	source 	The source to be copied.
@param	target	The target to be copied to.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_1kGk">
            <code>from de.qfs.lib.util import Files, Misc
from java.io import File, IOException

def copyDir(source, target):
    if source.isFile():
        if target.isDirectory():
            raise UserException("Cannot copy file '%s' to '%s' because the target is a directory." %
                                (Misc.getBestPath(source), Misc.getBestPath(target)))
        pdir = File(target.getParent())
        pdir.mkdirs()
        try:
            Files.copyFile(source, target)
        except IOException, ex:
            raise UserException("Error while copying file '%s' to '%s': %s." %
                                (Misc.getBestPath(source), Misc.getBestPath(target),
                                 ex.getLocalizedMessage()))
    else:
        if target.isFile():
            raise UserException("Cannot copy directory '%s' to '%s' because the target is a file." %
                                (Misc.getBestPath(source), Misc.getBestPath(target)))
        target.mkdirs()
        files = source.listFiles()
        if files:
            for file in files:
                copyDir(file, File(target, file.getName()))

source = rc.lookup("source")
target = rc.lookup("target")
source = File(source)
target = File(target)
if not source.exists():
    raise UserException("Cannot copy '%s': No such file or directory." % Misc.getBestPath(source))
if target.isDirectory():
    target = File(target, source.getName())

spath = Misc.getBestPath(source)
tpath = Misc.getBestPath(target)
if (source.isDirectory()):
    if tpath.startswith(spath):
        if len(tpath) == len(spath) or tpath[len(spath)] == '/' or tpath[len(spath)] == '\\':
            raise UserException("Cannot copy directory '%s' into itself ('%s')." % (spath, tpath))
else:
    if spath == tpath:
        raise UserException("Source and target are the same file ('%s')." % spath)

copyDir(source, target)
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6Sz" name="deleteFile">
          <variable name="file">aFile</variable>
          <comment>Delete a file.

@param	file	The file to remove.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6T0">
            <code>from java.io import File

file = rc.lookup("file")
file = File(file)
file.delete()

if file.exists():
    rc.logMessage("File still exists. Waiting 1000 ms")
    from java.lang import Thread
    Thread.sleep(1000)
    if file.exists():
        file.delete()
        if file.exists():
            raise UserException("Cannot delete file " + file.getCanonicalPath() + ". Perhaps you don't have the required permissions!")</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2JkD" name="exec">
          <variable name="cmd"/>
          <variable name="dir"/>
          <variable name="timeout">60000</variable>
          <variable name="expectedExitCode"/>
          <variable name="errorLvl">ERROR</variable>
          <variable name="stdoutVar"/>
          <variable name="stderrVar"/>
          <variable name="exitCodeVar">exitCode</variable>
          <comment>Execute a shell command.

@param	cmd		The command to execute.
@param	dir		The working directory.
@param	timeout		The maximal amount of time to wait for the program to finish.
@param	expectedExitCode	The expected error level (or "" (without quotes, that means an empty string) in order to disable this check).
@param	errorLvl		Whether to log a IGNORE, WARNING, ERROR or EXCEPTION in case the program did not finish within the specified amount of time or with an unexpected exit code.
@param	stdoutVar		The name of the global variable in which to save the stdout of the program.
@param	stderrVar		The name of the global variable in which to save the stderr of the program.
@param	exitCodeVar		The name of the global variable in which to save the exitCode of the program.
@return	The stdout/stderr output of the program.

@author	QFS,ys
@since	4.5</comment>
          <ServerScriptStep id="_2JkN">
            <code># check input
if rc.lookup("cmd", expand=False).strip() == "":
    rc.logWarning("Executing empty command!")</code>
          </ServerScriptStep>
          <ServerScriptStep id="_2JkF">
            <code>import random
from java.lang import System

def normalizeClientName(name):
    return name.lower().split(":")[0].strip()

def clientNameExists(name):
    name = normalizeClientName(name)
    clientsStr = rc.lookup("qftest", "clients.all")
    clients = [normalizeClientName(client) for client in clientsStr.split("\n")]
    return name in clients

def generateRandomClientName():
    client = "shellCmd_%s_%s" % (System.currentTimeMillis(), random.randint(0, 9999999999))
    if clientNameExists(client):
        return generateRandomClientName()
    return client

rc.setLocal("unusedClientName", generateRandomClientName())</code>
          </ServerScriptStep>
          <ShellClientStarter client="$(unusedClientName)" command="$(cmd)"
                              directory="$(dir)" id="_2JkE"/>
          <IfSequence id="_2JkH"
                      test="rc.lookup(&#34;errorLvl&#34;).strip().upper() == &#34;IGNORE&#34;">
            <SetGlobalStep id="_2JkO" local="true" varname="lvl">
              <default>$[rc.OK]</default>
            </SetGlobalStep>
            <ProcessWaiter client="$(unusedClientName)" errorlevel="0"
                           id="_2JkG" raise="false" timeout="$(timeout)"/>
            <ElseifSequence id="_2JkI"
                            test="rc.lookup(&#34;errorLvl&#34;).strip().upper() == &#34;WARNING&#34;">
              <SetGlobalStep id="_2JkP" local="true" varname="lvl">
                <default>$[rc.WARNING]</default>
              </SetGlobalStep>
              <ProcessWaiter client="$(unusedClientName)" errorlevel="1"
                             id="_2JkJ" raise="false" timeout="$(timeout)"/>
            </ElseifSequence>
            <ElseifSequence id="_2JkR"
                            test="rc.lookup(&#34;errorLvl&#34;).strip().upper() == &#34;ERROR&#34;">
              <SetGlobalStep id="_2JkS" local="true" varname="lvl">
                <default>$[rc.ERROR]</default>
              </SetGlobalStep>
              <ProcessWaiter client="$(unusedClientName)" id="_2JkT"
                             raise="false" timeout="$(timeout)"/>
            </ElseifSequence>
            <ElseSequence id="_2JkK">
              <SetGlobalStep id="_2JkQ" local="true" varname="lvl">
                <default>$[rc.EXCEPTION]</default>
              </SetGlobalStep>
              <ProcessWaiter client="$(unusedClientName)" id="_2JkL"
                             timeout="$(timeout)"/>
            </ElseSequence>
          </IfSequence>
          <ServerScriptStep id="_2JkM">
            <code>def setVar(variableNameP, qftestVarName, clientName):
    variableName = ""
    try: variableName = rc.lookup(variableNameP)
    except: pass
    content = rc.lookup("qftest", "client.%s.%s" % (qftestVarName, clientName), expand=False)
    if variableName != None and variableName != "":
        rc.setGlobal(variableName, content)
    return content

clientName = rc.lookup("unusedClientName")
output = setVar("outputVar", "output", clientName)
stdout = setVar("stdoutVar", "stdout", clientName)
stderr = setVar("stderrVar", "stderr", clientName)
exitCode = setVar("exitCodeVar", "exitcode", clientName)

if rc.lookup("expectedExitCode") != "":
    expectedExitCode = rc.getInt("expectedExitCode")
    rc.check(int(exitCode) == expectedExitCode, "Expected exitcode %s, got exitcode %s" % (expectedExitCode, exitCode), level=rc.getInt("lvl"), report=True, nowrap=False)

raise ReturnException(output)</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6Se" name="exists">
          <variable name="file">aFileOrADirectory</variable>
          <comment>Check whether a given file or directory exists.

@param	file	The path of the file or directory to check.
@return	exists	true if file exists
		false if file does not exist

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6Sf">
            <code>from java.io import File

dir = rc.lookup("file")

dir = File(dir)

rc.setLocal("exists", dir.exists())</code>
          </ServerScriptStep>
          <ReturnStep id="_6Sg" retval="$(exists)"/>
        </Procedure>
        <Procedure id="_6Sv" name="getBasename">
          <variable name="file">aFileOrADirectory</variable>
          <comment>Return the basename of the given file or directory. If the root directory is specified as parameter an empty string will returned.

@param	file	The file or directory.
@return	The basename of the file or directory.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6Sw">
            <code>from java.io import File

file = rc.lookup("file")
file = File(file)
fileName = file.getName()

if fileName == None:
	fileName = ""

rc.setLocal("fileName", fileName)</code>
          </ServerScriptStep>
          <ReturnStep id="_6Sx" retval="$(fileName)"/>
        </Procedure>
        <Procedure id="_6Sr" name="getParentdirectory">
          <variable name="file">aFileOrADirectory</variable>
          <comment>Return the parent directory of the given file or directory. If the root directory is specified as parameter an empty string will returned.

@param	file	The file or directory.
@return	The parent directory of the file or directory.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6Ss">
            <code>from java.io import File

file = rc.lookup("file")
file = File(file)
cPath = file.getParent()

if cPath == None:
	cPath = ""

rc.setLocal("path", cPath)</code>
          </ServerScriptStep>
          <ReturnStep id="_6St" retval="$(path)"/>
        </Procedure>
        <Procedure id="_6T7" name="mkdir">
          <variable name="directory">aDirectory</variable>
          <comment>Create a given directory. It also creates non-existing parent directories.

@param	directory	The directory to create.
@throws	UserException, if the directory couldn't be created

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6T8">
            <code>from java.io import File

directory = rc.lookup("directory")
directory = File(directory)
directory.mkdirs()

if directory.exists() == 0:
	raise UserException("Creating directory " + directory.getCanonicalPath() + " didn't work! Perhaps you have no permissions!")</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6T2" name="move">
          <variable name="source">aSource</variable>
          <variable name="target">aTarget</variable>
          <comment>Move a given file or directory to a given target. If the target is a directory, copy source into that directory. If target's parent directory does not exist, create it. If an error happens during copying, source is not changed.

@param	source 	The source to be moved.
@param	target	The target to be moved.

@author	QFS,mm
@since	2.2</comment>
          <ProcedureCall id="_1kGl" procedure="qfs.shellutils.copy">
            <variable name="source">$(source)</variable>
            <variable name="target">$(target)</variable>
          </ProcedureCall>
          <ServerScriptStep id="_6T3">
            <code>from java.io import File

source = rc.lookup("source")
source = File(source)
if source.isDirectory():
    import shutil
    try:
        shutil.rmtree(source.getPath())
    except Exception, ex:
        raise UserException("Cannot remove directory %s: %s" % (source.getPath(), ex))
else:
    source.delete()
    if source.exists():
        raise UserException("Cannot remove file %s" % source.getPath())</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6Sc" name="removeDirectory">
          <variable name="directory">aDirectory</variable>
          <comment>Remove a given directory.

@param	directory	The directory to remove.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6Sd">
            <code>import shutil

directory = rc.lookup("directory")
try:
	shutil.rmtree (directory)
except:
	raise UserException("Removing directory " + directory + " didn't work! Perhaps you have no permissions!")

</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6Sn" name="touch">
          <variable name="file">aFile</variable>
          <comment>Create a given file or update the last modified date of an existing file.

For creation it also creates non-existing parent directories.

@param	file	The file to touch.

@author	QFS,mm
@since	2.2</comment>
          <ServerScriptStep id="_6So">
            <code>from java.io import File
from java.lang import System

theFile = rc.lookup("file")
theFile = File(theFile)

if theFile.exists():
    now = System.currentTimeMillis()
    theFile.setLastModified(now)
else:
    cPath = File(theFile.getParent())
    if cPath != None:
    	cPath.mkdirs()

    try:
    	theFile.createNewFile()
    except:
	raise UserException("Creating file '" + theFile.getCanonicalPath() + "' didn't work! Perhaps you have no permissions!")

    if theFile.exists() == 0:
	raise UserException("Creating file '" + theFile.getCanonicalPath() + "' didn't work! Perhaps you have no permissions!")</code>
          </ServerScriptStep>
        </Procedure>
      </Package>
      <Package id="_1dF" name="swing">
        <comment>Procedures for advanced manipulation of swing components.

@author	QFS
@since	1.05.0</comment>
        <Package id="_3CU" name="cleanup">
          <comment>The procedures in this package are useful for generic cleanup after an exception is thrown. In some cases a menu or modal dialog may have been left open, causing future events for the SUT to be blocked.

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_3CV" name="closeAllModalDialogs">
            <variable name="maxDialogs">5</variable>
            <comment>Close all modal dialogs.
A modal dialog that is left open will cause events for the SUT to be blocked. Ensuring that modal dialogs are closed is a good operation to conduct in a setup/cleanup sequence.


@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,mm
@since	2.1.0</comment>
            <RepeatSequence count="$(maxDialogs)" id="_3CW">
              <comment>There may be more than one modal dialog. We can't use an endless loop though, in case
a dialog cannot be closed.</comment>
              <TryStep id="_3CX" name="Check for modal dialog">
                <ComponentWaiter client="$(client)"
                                 component="genericModalDialog" id="_3CY"
                                 timeout="50"/>
                <WindowEventStep client="$(client)"
                                 component="genericModalDialog"
                                 event="WINDOW_CLOSING" id="_3CZ">
                  <comment>The WINDOW_CLOSING event is equivalent to closing the dialog through the
window manager. We can't press a generic OK button, since the results could
be disastrous. Cancelling a dialog should always have the least consequences.</comment>
                </WindowEventStep>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_3Ca" maxerror="0" name="Finished">
                  <BreakStep id="_3Cb"/>
                </CatchSequence>
              </TryStep>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_3Cc" name="closeAllDialogs">
            <variable name="maxDialogs">6</variable>
            <comment>Close all dialogs.

@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of dialogs that are tried to be closed. (Optional, default 6)

@author	QFS,mm
@since	2.1.0</comment>
            <RepeatSequence count="$[($(maxDialogs) + 1) / 2]" id="_3Cd">
              <comment>There may be more than one modal dialog. We can't use an endless loop though, in case
a dialog cannot be closed.</comment>
              <TryStep id="_3Ce" name="Check for modal dialog">
                <ComponentWaiter client="$(client)"
                                 component="genericModalDialog" id="_3Cf"
                                 timeout="50"/>
                <WindowEventStep client="$(client)"
                                 component="genericModalDialog"
                                 event="WINDOW_CLOSING" id="_3Cg">
                  <comment>The WINDOW_CLOSING event is equivalent to closing the dialog through the
window manager. We can't press a generic OK button, since the results could
be disastrous. Cancelling a dialog should always have the least consequences.</comment>
                </WindowEventStep>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_3Ch" maxerror="0" name="Finished">
                  <TryStep id="_3Ci" name="Check for non-modal dialog">
                    <ComponentWaiter client="$(client)"
                                     component="genericNonModalDialog"
                                     id="_3Cj" timeout="50"/>
                    <WindowEventStep client="$(client)"
                                     component="genericNonModalDialog"
                                     event="WINDOW_CLOSING" id="_3Ck">
                      <comment>The WINDOW_CLOSING event is equivalent to closing the dialog through the
window manager. We can't press a generic OK button, since the results could
be disastrous. Cancelling a dialog should always have the least consequences.</comment>
                    </WindowEventStep>
                    <CatchSequence exception="ComponentNotFoundException"
                                   id="_3Cl" maxerror="0" name="Finished">
                      <BreakStep id="_3Cm"/>
                    </CatchSequence>
                  </TryStep>
                </CatchSequence>
              </TryStep>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_3Cn" name="closeAllMenus">
            <comment>Close all menus unconditionally.
A menu left open (or even just selected) will cause events for the SUT to be blocked. This procedure is recommended for cleanup after an exception occurs.

@param	client	The name of the SUT client.

@author	QFS,mm
@since	2.1.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_3Co">
              <code>from javax.swing import MenuSelectionManager

MenuSelectionManager.defaultManager().clearSelectedPath()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_3Cp" name="implicitExceptionHandler">
            <variable name="maxDialogs">5</variable>
            <comment>This procedure encompasses the usage of other cleanup procedures in this package and is the recommended operation to perform after an exception occurs and is implicitly caught.

Calling this procedure should be the first step in the cleanup
sequence of any Test node with the "Implicitly catch exceptions" attribute set.

@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,mm
@since	2.1.0</comment>
            <ProcedureCall id="_3Cq"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <ProcedureCall id="_3Cr"
                           procedure="qfs.swing.cleanup.closeAllModalDialogs">
              <variable name="maxDialogs">$(maxDialogs)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_3" name="checkbox">
          <comment>Procedures to set the state of checkboxes.
(Swing component &lt;code&gt;javax.swing.JCheckBox&lt;/code&gt;)

@author	QFS,mm
@since	1.05.0</comment>
          <Procedure id="_9" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,mm
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_A">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_B"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_C"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC" id="_D"
                                modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n9L" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n9M">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1n9N"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1n9O"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1n9Q" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1l97" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1l9B">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1l9A"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1l99" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1l9C"
                             maxerror="0">
                <ReturnStep id="_1l9D" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2K1Q" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,mm
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2K1R">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_6"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_7"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1mIH" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n9R" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n9S">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1n9T"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1n9U"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1n9W" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1dG" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).

@author	QFS,mm
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1dH" test="$(check)">
              <ProcedureCall id="_1dI" procedure="qfs.swing.checkbox.select">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ElseSequence id="_1dJ">
                <ProcedureCall id="_1dK"
                               procedure="qfs.swing.checkbox.deselect">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1n9X" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1n9Y" test="$(check)">
              <ProcedureCall id="_1n9Z"
                             procedure="qfs.swing.checkbox.selectWithCoordinates">
                <variable name="id">$(id)</variable>
                <variable name="x">$(x)</variable>
                <variable name="y">$(y)</variable>
              </ProcedureCall>
              <ElseSequence id="_1n9a">
                <ProcedureCall id="_1n9b"
                               procedure="qfs.swing.checkbox.deselectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_4nt" name="combobox">
          <comment>Procedures to handle comboboxes.
(Swing component &lt;code&gt;javax.swing.JComboBox&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_1l9z" name="getIndexOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the combobox.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1l9+" local="true" varname="index"/>
            <ReturnStep id="_1l9-" retval="$(index)"/>
          </Procedure>
          <Procedure id="_6YP" name="getItemCount">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the number of items of a given combobox.
It uses the method getModel().getSize() to get the number.

@param id 		The component-ID of the combobox.
@return itemCount

@author QFS,mm
@since 3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGB"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_6YQ">
              <code>cb = rc.getComponent(rc.lookup("id"))

itemCount = cb.getModel().getSize()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_6YR" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1l94" name="getValue">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the text of a given combobox.

@param	id	ID of the combobox.

@return  The text of the combobox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l95"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l96" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1lA0" name="getValueOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the combobox.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1lA1"
                           local="true" varname="value"/>
            <ReturnStep id="_1lA2" retval="$(value)"/>
          </Procedure>
          <Procedure id="_4nu" name="setValue">
            <variable name="id">${id:aComboboxButton}</variable>
            <variable name="listId">${id:aComboboxList}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <variable name="btnX"/>
            <variable name="btnY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select specified value of a given combobox.

If the given value is empty, no action will take place.

You should use this procedure for any standard selections.

@param	client	The name of the SUT client.
@param 	id	ID of the button to open the list.
@param	listId	ID of the list containing values.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	btnX	The x coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	btnY	The y coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_4ok" test="rc.lookup(&#34;value&#34;)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_2v" modifiers="16"
                              x="$(btnX)" y="$(btnY)"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(listId)$(separator)$(value)"
                              event="MOUSE_MPRC" id="_2w" modifiers="16"
                              x="$(itemX)" y="$(itemY)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_6mh" name="setValueViaIndex">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Set a value in the combobox.

You should use this procedure if setValue doesn't work correctly.

@param	client	The name of the SUT client.
@param 	id	ID of the combobox.
@param 	value  	The value to be set.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since 	3.1.2

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_1kJ5"
                            local="true" varname="idx"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_6jx">
              <code>combo = rc.getComponent(rc.lookup("id"))
if rc.getInt("idx") &gt;= 0:
    combo.setSelectedIndex(rc.getInt("idx"))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_4nv" name="setValueViaSUTScript">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Select specified value of a given combobox using a SUT script.
It uses the API-method &lt;code&gt;setSelectedItem()&lt;/code&gt; of &lt;code&gt; javax.swing.JCombobox&lt;/code&gt;

If the given value is empty, no action will take place.

You should use this procedure only if setValue and setValueViaIndex don't work for your use-case.

@param	client	The name of the SUT client.
@param 	id	ID of the combobox.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_4oL" test="rc.lookup(&#34;value&#34;)">
              <IfSequence id="_1kJ6"
                          test="&#34;$(separator)&#34; == &#34;@&#34;">
                <ComponentWaiter client="$(client)" component="$(id)"
                                 id="_1oGC"
                                 timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                  <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
                </ComponentWaiter>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:awt}" id="_4ny"
                                  name="getComboboxValueWithGetSelectedItem">
                  <code>
from de.qfs.apps.qftest.shared.data import SubItemIndex

combo = rc.getComponent(rc.lookup("id"))
value = rc.lookup("value")
found = False

for i in range(combo.getItemCount()):
    item = combo.getItemAt(i)
    if item and str(item) == value:
        found = True
        if item != combo.getSelectedItem():
            combo.setSelectedItem(item)
        break

if not found:
    raise IndexNotFoundException(SubItemIndex(value))
</code>
                </ClientScriptStep>
                <ElseSequence id="_1kJ7" name="other separator">
                  <ProcedureCall id="_1kJ8" procedure=".setValueViaIndex">
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                    <variable name="separator">$(separator)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_1lbs" name="dialogs">
          <comment>Procedures to handle Dialogs.
(Swing component &lt;code&gt;javax.swing.JDialog&lt;/code&gt;)

@author	QFS,kk
@since	3.4.14</comment>
          <Procedure id="_1mHJ" name="handleSecurityWarning">
            <variable name="timeout">120</variable>
            <variable name="dialogTitleRegExp">.*Sicherheit.*|.*Security.*</variable>
            <variable name="runButtonLabelRegExp">Ausfhren|Run</variable>
            <comment>Wait for the client to connect and check whether a Java security dialog blocks the JRE start which need to be confirmed.

@deprecated
This procedure is deprecated because security dialogs are now handled by the qfs.swing.startup.setSecurityDialogSpec procedure at a different level.

Note: If the dialog needs a two way confirmation, like a checkbox  with "I accept the risk...", this cannot be handled automatically but need to be confirmed by hand including the permanent permission for content of this vendor.

@param timeout       	   Seconds to wait for the client to connect.
@param dialogTitleRegExp 	   Regular expression matching the dialog title text.
@param runButtonLabelRegExp  Regular expression matching the run button text.

@throws UserException "Client finally not connected" in case the client doesn't connect within the timeout

@author QFS,kk
@since 3.4.14</comment>
            <RepeatSequence count="$(timeout)" id="_1mHK">
              <comment>This is now done automatically, running this procedure in its old state could hurt more than help, so we're just waiting for the client to connect.</comment>
              <TryStep id="_1mHL"
                       name="Either wait for client to connect or security dialog to appear">
                <ClientWaiter client="$(client)" id="_1mHM" timeout="1000">
                  <comment>Any engine.</comment>
                </ClientWaiter>
                <ClientWaiter client="$(client)" engine="awt" id="_1mHh"
                              timeout="1000">
                  <comment>Make sure that the main engine has connected and we're not just stuck in the gap between connection of the security engine and display of the security dialog.</comment>
                </ClientWaiter>
                <BreakStep id="_1mHi"/>
                <CatchSequence exception="ClientNotConnectedException"
                               id="_1mHj" maxerror="0"/>
              </TryStep>
              <ElseSequence id="_1mHk" name="No client not connected">
                <ThrowStep id="_1mHl"
                           throwmessage="Client finally not connected"/>
              </ElseSequence>
            </RepeatSequence>
          </Procedure>
        </Package>
        <Package id="_12R" name="filechooser">
          <comment>Procedures for accessing file chooser dialogs.
(Swing component &lt;code&gt;javax.swing.JFileChooser&lt;/code&gt;)

@author	QFS
@since	1.05.0 </comment>
          <Procedure id="_12S" name="enableNameResolver">
            <comment>Install the &lt;code&gt;JFileChooser&lt;/code&gt; name resolver. The effect is similar to assigning names to the most important components in &lt;code&gt;JFileChooser dialogs&lt;/code&gt; with setName().

@param	client	The name of the SUT client.

@author	QFS
@since	1.05.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_12T">
              <code>from de.qfs.apps.qftest.extensions import JFileChooserResolver

JFileChooserResolver.install()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_12U" name="disableNameResolver">
            <comment>Uninstall the &lt;code&gt;JFileChooser&lt;/code&gt; name resolver.

@param	client	The name of the SUT client.

@author	QFS
@since	1.05.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_12V">
              <code>from de.qfs.apps.qftest.extensions import JFileChooserResolver

JFileChooserResolver.uninstall()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_12W" name="selectFile">
            <variable name="file">aFile</variable>
            <comment>Select a file in a &lt;code&gt;JFileChooser&lt;/code&gt; dialog.

The filechooser dialog &lt;strong&gt;must&lt;/strong&gt; already be open (or at least be triggered to open).

@param	client	The name of the SUT client.
@param	file	The file to select (absolute or relative absolute to the filechooser's current directory).

@author	QFS
@since	1.05.0</comment>
            <TryStep id="_1e2" name="Wait until the list has been populated">
              <ComponentWaiter client="$(client)"
                               component="JFileChooser.List&amp;1" id="_1e1"
                               timeout="2000"/>
              <CatchSequence exception="ComponentNotFoundException" id="_1e3"
                             maxerror="0"/>
            </TryStep>
            <TextInputStep clear="true" client="$(client)"
                           component="JFileChooser.Filename" id="_3K"
                           single="false">
              <text>$(file)</text>
            </TextInputStep>
            <TryStep id="_12Y"
                     name="Paranoia: Ensure that the filename is set correctly">
              <CheckStringStep client="$(client)"
                               component="JFileChooser.Filename" id="_12c"
                               raise="true" timeout="100">
                <text>$(file)</text>
              </CheckStringStep>
              <CatchSequence exception="CheckFailedException" id="_12Z"
                             maxerror="3">
                <ProcedureCall id="_12a"
                               procedure="qfs.swing.text.clearField">
                  <variable name="id">JFileChooser.Filename</variable>
                </ProcedureCall>
                <TextInputStep client="$(client)"
                               component="JFileChooser.Filename" id="_12b">
                  <text>$(file)</text>
                </TextInputStep>
                <CheckStringStep client="$(client)"
                                 component="JFileChooser.Filename" id="_12d"
                                 raise="true" timeout="100">
                  <text>$(file)</text>
                </CheckStringStep>
              </CatchSequence>
            </TryStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="JFileChooser.OK" event="MOUSE_MPRC"
                            id="_3L" modifiers="16"/>
            <TryStep id="_1WV"
                     name="Paranoia: Ensure that dialog is really closed">
              <ComponentWaiter absence="true" client="$(client)"
                               component="JFileChooser.Dialog" id="_1WU"
                               timeout="5000"/>
              <CatchSequence exception="ComponentFoundException" id="_1WW"
                             maxerror="3">
                <MouseEventStep clicks="1" client="$(client)"
                                component="JFileChooser.OK" event="MOUSE_MPRC"
                                id="_1WX" modifiers="16"/>
                <ComponentWaiter absence="true" client="$(client)"
                                 component="JFileChooser.Dialog" id="_1WY"
                                 timeout="5000"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lsU" name="selectFiles">
            <variable name="files">someFiles</variable>
            <comment>Select several files in a &lt;code&gt;JFileChooser&lt;/code&gt; dialog.

The filechooser dialog &lt;strong&gt;must&lt;/strong&gt; already be open (or at least be triggered to open).

@param	client	The name of the SUT client.
@param	files	The files to select (absolute or relative to the filechooser's current directory) as a comma-separated list.

@author	QFS,gs
@since	3.5.1</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1kkH">
              <code>files = rc.lookup("files").split(",")
files = " ".join(['"%s"' % f.strip() for f in files])
rc.callProcedure(".selectFile", {"file": files})</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Package id="_4pA" name="general">
          <comment>Procedures which work for any Swing component.

@author QFS,mm
@since 2.1.0
</comment>
          <Procedure id="_6VN" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.


@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_6VS" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_6VT" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1n7D" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1n7E" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_1n7F"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1j-w" name="deleteOverrideComponent">
            <comment>Delete the current association of PriorityAwtSwingComponent.

@param	client		The name of the SUT client.

@author	QFS,mm
@since	3.3.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1j-x">
              <code>rc.overrideElement("PriorityAwtSwingComponent", None)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_4pT" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1mII" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n7B" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1n7C"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1lTF" name="doSelect">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="detail"/>
            <comment>Send a selection event to a given component. That's not a mouse-click.
Selection events are special events for menus or list selection.

@param	client	The name of the SUT client.
@param	id	The Id of the target-component.
@param	detail	The detail of the selection. Important for closing dialogs etc. For menu items leave it blank.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="$(detail)" event="SELECTION"
                                id="_1lTG"/>
          </Procedure>
          <Procedure id="_6Qf" name="setLocation">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set the location of a given component.

It uses setLocation(x,y) to set the location.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x		The new x-coordinate of the location.
@param	y		The new y-coordinate of the location.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGD"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_6Qh">
              <code>comp = rc.getComponent(rc.lookup("id"))

comp.setLocation($(x), $(y))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1j-p" name="setOverrideComponent">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Set a given component to the PriorityAwtSwingComponent.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	3.3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGE"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1j-r">
              <code>comp = rc.getComponent(rc.lookup("id"))

rc.overrideElement("PriorityAwtSwingComponent", comp)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6Qi" name="setSize">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="width"/>
            <variable name="height"/>
            <comment>Set the width and the height of a given component.

It uses setSize(width, height) to set the size.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	width		The new width of the component.
@param	height		The new height of the component.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGF"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_6Qj">
              <code>comp = rc.getComponent(rc.lookup("id"))

comp.setSize($(width), $(height))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1mJ1" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1mJ3"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_1n5p" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_1n5q" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_1n4b" name="list">
          <comment>Procedures for accessing lists.
(Swing component &lt;code&gt;javax.swing.JList&lt;/code&gt;)

@author	QFS,mm
@since 3.0</comment>
          <Package id="_1n4c" name="checks">
            <comment>Procedures for checking a list.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_1n4d" name="checkNumberOfItems">
              <variable name="id">${id:listid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of items of a given list according to a specified comparison mode.

It uses JList.getModel().getSize() to get the number.
Sample usage:
You can check, that a list has exactly 6 items or that the table has less then 10 items.

@param	id 		The id of the list.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of items.
			&lt;, if the compareValue should be greater than the actual amount of items.
			&gt;, if the compareValue should be less than the actual amount of items.
			&lt;=, if the compareValue should be greater or equal than the actual amount of items.
			&gt;=, if the compareValue should be less or equal the actual amount of items.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since  3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1n4e" local="true"
                             procedure="qfs.swing.list.getItemCount"
                             retvarname="itemCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1n4f"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of items of list '$(id)'</variable>
                <variable name="got">$(itemCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1n4g" name="selection">
            <comment>Procedures to (de-)select certain items of a list.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_1n4h" name="deselectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Deselect all items. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGG"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4i">
                <code>mylist = rc.getComponent(rc.lookup("id"))

items = mylist.getModel().getSize()
if items &gt; 0:
	mylist.removeSelectionInterval(0, items-1)

</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1n4j" name="deselectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Deselect a given item, specified by its index. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.
@param 	item	The index of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGH"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4k">
                <code>mylist = rc.getComponent(rc.lookup("id"))

selItem = rc.lookup("item")
if selItem != None:
	mylist.removeSelectionInterval(int(selItem), int(selItem))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1n4l" name="deselectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Deselect a range of items, specified by their index. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.
@param	startItem	The index of first item to be selected.
@param	endItem	The index of last item to be selected.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGI"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4m">
                <code>mylist = rc.getComponent(rc.lookup("id"))

startItem = rc.lookup("startItem")
endItem = rc.lookup("endItem")

items = mylist.getModel().getSize()

if endItem == None or endItem == '':
	endItem = items -1
else:
	endItem = int(endItem)

mylist.removeSelectionInterval(int(startItem), endItem)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1n4n" name="selectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Select all items. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGJ"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4o">
                <code>mylist = rc.getComponent(rc.lookup("id"))

items = mylist.getModel().getSize()

if items &gt; 0:
	mylist.setSelectionInterval(0, items-1)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1n4p" name="selectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Select a given item, specified by its index. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.
@param 	row	The index of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGK"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4q">
                <code>mylist = rc.getComponent(rc.lookup("id"))

selItem = rc.lookup("item")
if selItem != None:
	mylist.setSelectionInterval(int(selItem), int(selItem))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1n4r" name="selectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Select a range of items, specified by their index. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the list.
@param	startItem	The index of first item to be selected.
@param	endItem	The index of last item to be selected.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGL"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1n4s">
                <code>mylist = rc.getComponent(rc.lookup("id"))

startItem = rc.lookup("startItem")
endItem = rc.lookup("endItem")

items = mylist.getModel().getSize()

if endItem == None or endItem == '':
	endItem = items -1
else:
	endItem = int(endItem)

mylist.setSelectionInterval(int(startItem), endItem)</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1n7G" name="clickItemWithDetails">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given item by a mouse-click on it.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n7I"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1n4t" name="getItemCount">
            <variable name="id">${id:listid}</variable>
            <comment>Return the number of items of a given list.
It uses the method getModel().getSize() to get the number.

@param id 		The component-ID of the list.
@return itemCount

@author QFS,mm
@since 3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGM"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1n4u">
              <code>list = rc.getComponent(rc.lookup("id"))

itemCount = list.getModel().getSize()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1n4v" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1n4w" name="getIndexOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1n4x" local="true" varname="index"/>
            <ReturnStep id="_1n4y" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1n4z" name="getValueOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1n4+"
                           local="true" varname="value"/>
            <ReturnStep id="_1n4-" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1n50" name="selectItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Select a given item by a mouse-click on it.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The x coordinate for the click, default is empty to click in the middle.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" id="_1n51" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_1n52" name="menu">
          <comment>Procedures to select menu items and checkbox menu items.
(Swing components &lt;code&gt;javax.swing.JMenuItem&lt;/code&gt; and &lt;code&gt;javax.swing.JCheckBoxMenuItem&lt;/code&gt; from &lt;code&gt;javax.swing.JMenu&lt;/code&gt;)

@author	QFS
@since	1.05.0</comment>
          <Procedure id="_1n53" name="selectItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of menu item.


@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n54"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1n55" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1n56" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nB2" name="selectItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of menu item.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.


@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nB3"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nB4" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nB5" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
          </Procedure>
          <Procedure id="_1n57" name="selectSubItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu.

For example: for the View -&gt; Terminal -&gt; Show action, the component ID of "View" is the menu, the ID for "Terminal" is the item, and the ID for "Show" is the sub-item to select.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.


@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n58"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1mIM" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1mIN" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1n59" modifiers="16"/>
          </Procedure>
          <Procedure id="_1nAz" name="selectSubItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subItemX"/>
            <variable name="subItemY"/>
            <comment>Select an item within a submenu.

For example: for the View -&gt; Terminal -&gt; Show action, the component ID of "View" is the menu, the ID for "Terminal" is the item, and the ID for "Show" is the sub-item to select.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subItemX	The x coordinate for the click on the subitem, default is empty to click in the middle.
@param	subItemY	The y coordinate for the click on the subitem, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nA+"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nA-" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nB0" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nB1" modifiers="16" x="$(subItemX)"
                            y="$(subItemY)"/>
          </Procedure>
          <Procedure id="_1n5A" name="setCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item.

For example: for the View -&gt; Show Details action, the component ID of "View" is the menu, and the ID for "Show Details" is the checkbox item to set (to true or false).

@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.


@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n5B"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1mIJ" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1n5C" timeout="3000"/>
            <TryStep id="_1n5D" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1n5E"
                                raise="true" timeout="0"/>
              <IfSequence id="_1n5F" test="$(checkItemValue)">
                <ProcedureCall id="_1n5G"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1n5H">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1n5I" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1n5J"
                             maxerror="0">
                <IfSequence id="_1n5K" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1mIK" modifiers="16"/>
                  <ElseSequence id="_1n5L">
                    <ProcedureCall id="_1n5M"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nAk" name="setCheckItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="checkItemX"/>
            <variable name="checkItemY"/>
            <comment>Select a checkbox menu item.

For example: for the View -&gt; Show Details action, the component ID of "View" is the menu, and the ID for "Show Details" is the checkbox item to set (to true or false).

@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	checkItemX		The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	checkItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nAl"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nAm" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nAn" timeout="3000"/>
            <TryStep id="_1nAo" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nAp"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nAq" test="$(checkItemValue)">
                <ProcedureCall id="_1nAr"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1nAs">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nAt" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nAu"
                             maxerror="0">
                <IfSequence id="_1nAv" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nAw" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                  <ElseSequence id="_1nAx">
                    <ProcedureCall id="_1nAy"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n5N" name="setSubCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within within a submenu.

For example: for the View -&gt; Terminal -&gt; Wrap Lines action, the component ID of "View" is the menu,  the ID for "Terminal" is the item and the ID for "Wrap Lines" is the checkbox menu item to set (to true or false).


@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	item		The id of the item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.


@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n5O"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1mIO" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1mIP" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1n5P" timeout="3000"/>
            <TryStep id="_1n5Q" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1n5R"
                                raise="true" timeout="0"/>
              <IfSequence id="_1n5S" test="$(checkItemValue)">
                <ProcedureCall id="_1n5T"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1n5U">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1mIQ"
                                  modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1n5V"
                             maxerror="0">
                <IfSequence id="_1n5W" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1mIR"
                                  modifiers="16"/>
                  <ElseSequence id="_1n5X">
                    <ProcedureCall id="_1n5Y"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nAU" name="setSubCheckItemWithCoordinates">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subCheckItemX"/>
            <variable name="subCheckItemY"/>
            <comment>Select a checkbox menu item within within a submenu.

For example: for the View -&gt; Terminal -&gt; Wrap Lines action, the component ID of "View" is the menu,  the ID for "Terminal" is the item and the ID for "Wrap Lines" is the checkbox menu item to set (to true or false).


@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	item		The id of the item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	menuX	The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY	The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subCheckItemX	The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	subCheckItemY	The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1nAV"
                           procedure="qfs.swing.cleanup.closeAllMenus"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(menu)"
                            event="MOUSE_MPRC" id="_1nAW" modifiers="16"
                            x="$(menuX)" y="$(menuY)"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nAX" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nAY" timeout="3000"/>
            <TryStep id="_1nAZ" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nAa"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nAb" test="$(checkItemValue)">
                <ProcedureCall id="_1nAc"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1nAd">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nAe" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nAf"
                             maxerror="0">
                <IfSequence id="_1nAg" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nAh" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                  <ElseSequence id="_1nAi">
                    <ProcedureCall id="_1nAj"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n5Z" name="selectMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select an item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "File" -&gt; "Close" you set menu to the component id "mFile" and item to "mClose" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Search text" you set menu to the component id "mFile.mSearch" and item to "mSearchText" (Of course you need to set your component id's).

@param	client	The name of the SUT client.
@param	menu	The path of the parent menus. The path is specified as list of component-ids.
@param	item	The id of menu item. When item is an empty string, the last component id of 'menu' will be used as 'item'.
@param	menustringSeparator	The value, which separates the path of the parent menu.

@author	QFS,mm
@since	3.5

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1n5a" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)

if rc.lookup("item") == "":
    lastItem = menus.pop()
    rc.setLocal("item", lastItem)

for m in menus:
    if m:
        rc.callProcedure("qfs.swing.general.doClick", {"id" : m})</code>
            </ServerScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1n5b" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n7J"
                     name="selectMenuItemInHierarchyWithCoordinates">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="menustringSeparator">.</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select an item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
You can specify the coordinates for clicking.

Samples:
If you want to select at "File" -&gt; "Close" you set menu to the component id "mFile" and item to "mClose" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Search text" you set menu to the component id "mFile.mSearch" and item to "mSearchText" (Of course you need to set your component id's).

@param	client	The name of the SUT client.
@param	menu	The path of the parent menus. The path is specified as list of component-ids.
@param	item	The id of menu item.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	itemX		The x coordinate for the click on the menu item, default is empty to click in the middle.
@param	itemY		The y coordinate for the click on the menu item, default is empty to click in the middle.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1n7K" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.swing.general.doClickWithDetails", {"id" : m, "x" : rc.lookup("menuX"), "y" : rc.lookup("menuY")})</code>
            </ServerScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1n7L" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
          </Procedure>
          <Procedure id="_1n5c" name="selectCheckMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="checkItem">${id:anItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select a checkbox menu item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "View" -&gt; "Show terminal" you set menu to the component id "mView" and item to "mShowTerminal" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Exclude digits" you set menu to the component id "mFile.mSearch" and item to "mExcludeDigits" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.

@author	QFS,mm
@since	3.5

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1n5d" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.swing.general.doClick", {"id" : m})</code>
            </ServerScriptStep>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1n5e" timeout="3000"/>
            <TryStep id="_1n5f" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1n5g"
                                raise="true" timeout="0"/>
              <IfSequence id="_1n5h" test="$(checkItemValue)">
                <ProcedureCall id="_1n5i"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1n5j">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1n5k" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1n5l"
                             maxerror="0">
                <IfSequence id="_1n5m" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1mIL" modifiers="16"/>
                  <ElseSequence id="_1n5n">
                    <ProcedureCall id="_1n5o"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nAG"
                     name="selectCheckMenuItemInHierarchyWithCoordinates">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="checkItem">${id:anItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menustringSeparator">.</variable>
            <variable name="menuX"/>
            <variable name="menuY"/>
            <variable name="checkItemX"/>
            <variable name="checkItemY"/>
            <comment>Select a checkbox menu item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "View" -&gt; "Show terminal" you set menu to the component id "mView" and item to "mShowTerminal" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Exclude digits" you set menu to the component id "mFile.mSearch" and item to "mExcludeDigits" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.
@param	menuX		The x coordinate for the click on the menu, default is empty to click in the middle.
@param	menuY		The y coordinate for the click on the menu, default is empty to click in the middle.
@param	checkItemX		The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	checkItemY		The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1nAH" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.swing.general.doClickWithDetails", {"id" : m, "x" : rc.lookup("menuX"), "y" : rc.lookup("menuY")})</code>
            </ServerScriptStep>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1nAI" timeout="3000"/>
            <TryStep id="_1nAJ" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1nAK"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nAL" test="$(checkItemValue)">
                <ProcedureCall id="_1nAM"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1nAN">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nAO" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nAP"
                             maxerror="0">
                <IfSequence id="_1nAQ" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1nAR" modifiers="16" x="$(checkItemX)"
                                  y="$(checkItemY)"/>
                  <ElseSequence id="_1nAS">
                    <ProcedureCall id="_1nAT"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1mHo" name="optionpane">
          <comment>Procedures for accessing standard error/message dialogs.
(Swing component &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt;)

@author	QFS
@since	1.07.0 </comment>
          <Procedure id="_1lw4" name="checkMessage">
            <variable name="newline">\n</variable>
            <variable name="expectedMsg"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <comment>Check the message of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.
@param	newline	The newline character used in the JOptionPane dialog.
@param	expectedMsg	The string representing the expected message.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param	compareMode		The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as a regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as a regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws	UserException If wrong comparison mode has been set this exception will be thrown.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1lw8" local="true"
                           procedure="qfs.swing.optionpane.getMessage"
                           retvarname="message">
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1mHB"
                           procedure="qfs.check.compareTwoStringValues">
              <variable name="got">$(message)</variable>
              <variable name="expected">$(expectedMsg)</variable>
              <variable name="checkMessage">$(checkMessage)</variable>
              <variable name="compareMode">$(compareMode)</variable>
              <variable name="errorLevel">$(errorLevel)</variable>
              <variable name="appearInReport">$(appearInReport)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1luK" name="checkTitle">
            <variable name="expectedTitle"/>
            <variable name="checkMessage"/>
            <variable name="compareMode">=</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <comment>Check the title of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.
@param	expectedTitle	The string representing the expected title.
@param	checkMessage		The message, which should be written into the run-log for that check.
@param	compareMode		The comparison mode.
			= or ==, asserts got == expected
			&lt;, asserts got &lt; expected
			&gt;, asserts got &gt; expected
			&lt;=, asserts got &lt;= expected
			&gt;=, asserts got &gt;= expected
			!=, asserts got != expected
			regexp, the expected value should be treated as regular expression, that matches the received value.
			regexpNegate, the expected value should be treated as regular expression, that doesn't match the received value.
@param 	errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws	UserException If wrong comparison mode has been set this exception will be thrown.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1lwE" local="true"
                           procedure="qfs.swing.optionpane.getTitle"
                           retvarname="title"/>
            <ProcedureCall id="_1mHA"
                           procedure="qfs.check.compareTwoStringValues">
              <variable name="got">$(title)</variable>
              <variable name="expected">$(expectedTitle)</variable>
              <variable name="checkMessage">$(checkMessage)</variable>
              <variable name="compareMode">$(compareMode)</variable>
              <variable name="errorLevel">$(errorLevel)</variable>
              <variable name="appearInReport">$(appearInReport)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1mFm" name="clickCancelButton">
            <comment>Click on the Cancel Button of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mFn" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mFo">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mFp" test="not $(installed)">
              <ProcedureCall id="_1mFq"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mFr">
              <MouseEventStep clicks="1" client="$(client)"
                              component="JOptionPane.CANCEL"
                              event="MOUSE_MPRC" id="_1mFs" modifiers="16"/>
              <FinallySequence id="_1n5+">
                <IfSequence id="_1n66" test="not $(installed)">
                  <ProcedureCall id="_1n67"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1mFX" name="clickNoButton">
            <comment>Click on the No Button of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mFY" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mFZ">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mFa" test="not $(installed)">
              <ProcedureCall id="_1mFb"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mFc">
              <MouseEventStep clicks="1" client="$(client)"
                              component="JOptionPane.NO" event="MOUSE_MPRC"
                              id="_1mFd" modifiers="16"/>
              <FinallySequence id="_1n68">
                <IfSequence id="_1mFj" test="not $(installed)">
                  <ProcedureCall id="_1mFk"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1mF0" name="clickOkButton">
            <comment>Click on the OK Button of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mF2" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mF3">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mF4" test="not $(installed)">
              <ProcedureCall id="_1mF5"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mF6">
              <MouseEventStep clicks="1" client="$(client)"
                              component="JOptionPane.OK" event="MOUSE_MPRC"
                              id="_1mF7" modifiers="16"/>
              <FinallySequence id="_1n69">
                <IfSequence id="_1mFC" test="not $(installed)">
                  <ProcedureCall id="_1mFD"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1mFI" name="clickYesButton">
            <comment>Click on the Yes Button of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mFJ" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mFK">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mFL" test="not $(installed)">
              <ProcedureCall id="_1mFM"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mFN">
              <MouseEventStep clicks="1" client="$(client)"
                              component="JOptionPane.YES" event="MOUSE_MPRC"
                              id="_1mFO" modifiers="16"/>
              <FinallySequence id="_1n6A">
                <IfSequence id="_1mFU" test="not $(installed)">
                  <ProcedureCall id="_1mFV"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1mHr" name="disableNameResolver">
            <comment>Uninstall the &lt;code&gt;JOptionPane&lt;/code&gt; name resolver.

The name resolver is automatically enabled and disabled by the other procedures of this packages. Therefore you typically don't need to do this explicitely.

@param	client	The name of the SUT client.

@author	QFS
@since	1.07.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mHs">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

JOptionPaneResolver.uninstall()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1mHp" name="enableNameResolver">
            <comment>Install the &lt;code&gt;JOptionPane&lt;/code&gt; name resolver. The effect is similar to assigning names to the most important components in &lt;code&gt;JOptionPane dialogs&lt;/code&gt; with setName().

The name resolver is automatically enabled and disabled by the other procedures of this packages. Therefore you typically don't need to do this explicitely.

@param	client	The name of the SUT client.

@author	QFS
@since	1.07.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mHq">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

JOptionPaneResolver.install()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1luy" name="getMessage">
            <variable name="newline">\n</variable>
            <comment>Get the message of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.
@param	newline	The newline character used in the JOptionPane dialog.

@return	The message of the optionpane dialog.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1lvy" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lvz">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1lv0" test="not $(installed)">
              <ProcedureCall id="_1lv1"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <SetGlobalStep id="_1lv-" local="true" varname="result">
              <comment>Don't delete this node because then, a dialog with an empty message will result in an exception.</comment>
            </SetGlobalStep>
            <RepeatSequence count="20" id="_1n6p" var="j">
              <SetGlobalStep id="_1mIC" local="true" varname="i">
                <default>$[$(j)+1]</default>
              </SetGlobalStep>
              <TryStep id="_1mHx">
                <ComponentWaiter client="$(client)"
                                 component="JOptionPane.genericLabel"
                                 id="_1mH8" local="true" timeout="0"/>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:awt}"
                                  id="_1mHv">
                  <code>label = rc.getComponent("JOptionPane.genericLabel")
parent = label.getParent()
coms = parent.getComponents()

result = ""
for c in coms:
    if qf.isInstance(c, "javax.swing.JLabel"):
        try:
            if result == "":
                result = c.getText()
            else:
                result = result + "$(newline)" + c.getText()
        except:
            pass

rc.setLocal("result", result)</code>
                </ClientScriptStep>
                <BreakStep id="_1mIB"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_1mHy" maxerror="0"/>
              </TryStep>
            </RepeatSequence>
            <IfSequence id="_1lv2" test="not $(installed)">
              <ProcedureCall id="_1lv3"
                             procedure="qfs.swing.optionpane.disableNameResolver"/>
            </IfSequence>
            <ReturnStep id="_1lw1" retval="$(result)"/>
          </Procedure>
          <Procedure id="_1lvV" name="getOptionPaneMessageType">
            <comment>Return the message Type of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@return	This function returns one of the following Strings:
	ErrorDialog, if an error dialog was detected;
	InfoDialog, if an info dialog was detected;
	WarningDialog, if a warning dialog was detected;
	PlainDialog, if a plain dialog was detected;
	QuestionDialog, if a question dialog was detected.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no JOptionPane dialog was found, this exception will be thrown!
@throws	UserException with the message "Unknown dialog!" if non of these dialogs could be detected.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1lvq"
                           procedure="qfs.swing.optionpane.isOptionPane">
              <variable name="throwExc">true</variable>
            </ProcedureCall>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lvt">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1lvr" test="not $(installed)">
              <ProcedureCall id="_1lvs"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1n6R" name="checkMessageType">
              <ProcedureCall id="_1n6Q" local="true"
                             procedure="qfs.swing.optionpane.isErrorDialog"
                             retvarname="errorDialog">
                <variable name="throwExc">false</variable>
              </ProcedureCall>
              <IfSequence id="_1n6P" name="error dialog?"
                          test="$(errorDialog)">
                <ReturnStep id="_1n6T" retval="ErrorDialog"/>
              </IfSequence>
              <ProcedureCall id="_1n6U" local="true"
                             procedure="qfs.swing.optionpane.isInfoDialog"
                             retvarname="infoDialog">
                <variable name="throwExc">false</variable>
              </ProcedureCall>
              <IfSequence id="_1n6V" name="info dialog?" test="$(infoDialog)">
                <ReturnStep id="_1n6W" retval="InfoDialog"/>
              </IfSequence>
              <ProcedureCall id="_1n6X" local="true"
                             procedure="qfs.swing.optionpane.isPlainDialog"
                             retvarname="plainDialog">
                <variable name="throwExc">false</variable>
              </ProcedureCall>
              <IfSequence id="_1n6Y" name="plain dialog?"
                          test="$(plainDialog)">
                <ReturnStep id="_1n6Z" retval="PlainDialog"/>
              </IfSequence>
              <ProcedureCall id="_1n6a" local="true"
                             procedure="qfs.swing.optionpane.isQuestionDialog"
                             retvarname="questionDialog">
                <variable name="throwExc">false</variable>
              </ProcedureCall>
              <IfSequence id="_1n6b" name="question dialog?"
                          test="$(questionDialog)">
                <ReturnStep id="_1n6c" retval="QuestionDialog"/>
              </IfSequence>
              <ProcedureCall id="_1n6d" local="true"
                             procedure="qfs.swing.optionpane.isWarningDialog"
                             retvarname="warningDialog">
                <variable name="throwExc">false</variable>
              </ProcedureCall>
              <IfSequence id="_1n6e" name="Warning dialog?"
                          test="$(warningDialog)">
                <ReturnStep id="_1n6f" retval="WarningDialog"/>
              </IfSequence>
              <ThrowStep id="_1n6g" throwmessage="Unknown dialog!"/>
              <FinallySequence id="_1n6S">
                <IfSequence id="_1lvu" test="not $(installed)">
                  <ProcedureCall id="_1lvv"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lY8" name="getTitle">
            <comment>Get the title of the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.

@return	Returns the title of the current optionpane dialog.

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1lu8"
                           procedure="qfs.swing.optionpane.isOptionPane">
              <variable name="throwExc">true</variable>
            </ProcedureCall>
            <FetchTextStep client="$(client)" component="genericModalDialog"
                           id="_1luF" local="true" varname="result">
              <comment>all JOptionPane dialogs are also modal dialogs</comment>
            </FetchTextStep>
            <ReturnStep id="_1luG" retval="$(result)"/>
          </Procedure>
          <Procedure id="_1mEm" name="hasCancelButton">
            <variable name="throwExc">false</variable>
            <comment>Check if the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog has an Cancel Button.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw a ComponentNotFoundException, if the optionpane dialog has no Cancel button.

@return	The result of the check ('true' if Cancel Button was found otherwise 'false').

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog or no Cancel Button was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mEn" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mEo">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mEp" test="not $(installed)">
              <ProcedureCall id="_1mEq"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mEr">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.CANCEL" id="_1mEs"
                               local="true" raise="$(throwExc)"
                               resvarname="hasCancel" timeout="0"/>
              <FinallySequence id="_1n6q">
                <IfSequence id="_1mEx" test="not $(installed)">
                  <ProcedureCall id="_1mEy"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1mE-" retval="$(hasCancel)"/>
          </Procedure>
          <Procedure id="_1mEW" name="hasNoButton">
            <variable name="throwExc">false</variable>
            <comment>Check if the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog has an NO Button.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw a ComponentNotFoundException, if the optionpane dialog has no NO button.

@return	The result of the check ('true' if NO Button was found otherwise 'false').

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog or no No Button was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mEX" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mEY">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mEZ" test="not $(installed)">
              <ProcedureCall id="_1mEa"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mEb">
              <ComponentWaiter client="$(client)" component="JOptionPane.NO"
                               id="_1mEc" local="true" raise="$(throwExc)"
                               resvarname="hasNo" timeout="0"/>
              <FinallySequence id="_1n6r">
                <IfSequence id="_1mEh" test="not $(installed)">
                  <ProcedureCall id="_1mEi"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1mEl" retval="$(hasNo)"/>
          </Procedure>
          <Procedure id="_1mD-" name="hasOkButton">
            <variable name="throwExc">false</variable>
            <comment>Check if the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog has an OK Button.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw a ComponentNotFoundException, if the optionpane dialog has no OK button.

@return	The result of the check ('true' if OK Button was found otherwise 'false').

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog or no Ok Button was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mEE" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mE0">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mE1" test="not $(installed)">
              <ProcedureCall id="_1mE2"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mEA">
              <ComponentWaiter client="$(client)" component="JOptionPane.OK"
                               id="_1mE9" local="true" raise="$(throwExc)"
                               resvarname="hasOk" timeout="0"/>
              <FinallySequence id="_1n6s">
                <IfSequence id="_1mE3" test="not $(installed)">
                  <ProcedureCall id="_1mE4"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1mE7" retval="$(hasOk)"/>
          </Procedure>
          <Procedure id="_1mEG" name="hasYesButton">
            <variable name="throwExc">false</variable>
            <comment>Check if the current &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog has an YES Button.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw a ComponentNotFoundException, if the optionpane dialog has no YES button.

@return	The result of the check ('true' if YES Button was found otherwise 'false').

@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.
@throws	ComponentNotFoundException If no optionpane dialog or no Yes Button was found, this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ProcedureCall id="_1mEH" local="true"
                           procedure="qfs.swing.optionpane.getOptionPaneMessageType"
                           retvarname="type"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1mEI">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mEJ" test="not $(installed)">
              <ProcedureCall id="_1mEK"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1mEL">
              <ComponentWaiter client="$(client)" component="JOptionPane.YES"
                               id="_1mEM" local="true" raise="$(throwExc)"
                               resvarname="hasYes" timeout="0"/>
              <FinallySequence id="_1n6t">
                <IfSequence id="_1mER" test="not $(installed)">
                  <ProcedureCall id="_1mES"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1mEV" retval="$(hasYes)"/>
          </Procedure>
          <Procedure id="_1mH5" name="isErrorDialog">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; ErrorDialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane ErrorDialog wasn't found.

@return	This function returns true if current window is a JOptionPane error dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lsS">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1mH6" test="not $(installed)">
              <ProcedureCall id="_1mH7"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1luL">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.ErrorDialog" id="_1mHt"
                               local="true" raise="$(throwExc)"
                               resvarname="error" timeout="0"/>
              <FinallySequence id="_1n6u">
                <IfSequence id="_1lsa" test="not $(installed)">
                  <ProcedureCall id="_1lsb"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1lse" retval="$(error)"/>
          </Procedure>
          <Procedure id="_1lsf" name="isInfoDialog">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; InfoDialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane InfoDialog wasn't found.

@return	This function returns true if current window is a JOptionPane info dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lsg">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1lsh" test="not $(installed)">
              <ProcedureCall id="_1lsi"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1luQ">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.InfoDialog" id="_1lsp"
                               local="true" raise="$(throwExc)"
                               resvarname="info" timeout="0"/>
              <FinallySequence id="_1n6v">
                <IfSequence id="_1lsk" test="not $(installed)">
                  <ProcedureCall id="_1lsl"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1lso" retval="$(info)"/>
          </Procedure>
          <Procedure id="_1lYD" name="isOptionPane">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; dialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane dialog wasn't found.

@return	This function returns true if current window is a JOptionPane dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <TryStep id="_1ltj" name="check dialogs">
              <ProcedureCall id="_1ltd"
                             procedure="qfs.swing.optionpane.isErrorDialog">
                <variable name="throwExc">true</variable>
              </ProcedureCall>
              <CatchSequence exception="ComponentNotFoundException" id="_1ltk"
                             maxerror="0">
                <TryStep id="_1ltn">
                  <ProcedureCall id="_1ltf"
                                 procedure="qfs.swing.optionpane.isInfoDialog">
                    <variable name="throwExc">true</variable>
                  </ProcedureCall>
                  <CatchSequence exception="ComponentNotFoundException"
                                 id="_1lto" maxerror="0">
                    <TryStep id="_1ltp">
                      <ProcedureCall id="_1ltg"
                                     procedure="qfs.swing.optionpane.isWarningDialog">
                        <variable name="throwExc">true</variable>
                      </ProcedureCall>
                      <CatchSequence exception="ComponentNotFoundException"
                                     id="_1ltx" maxerror="0">
                        <TryStep id="_1lu0">
                          <ProcedureCall id="_1lth"
                                         procedure="qfs.swing.optionpane.isQuestionDialog">
                            <variable name="throwExc">true</variable>
                          </ProcedureCall>
                          <CatchSequence exception="ComponentNotFoundException"
                                         id="_1lu1" maxerror="0">
                            <TryStep id="_1lu2">
                              <ProcedureCall id="_1lti"
                                             procedure="qfs.swing.optionpane.isPlainDialog">
                                <variable name="throwExc">true</variable>
                              </ProcedureCall>
                              <CatchSequence exception="ComponentNotFoundException"
                                             id="_1lu3" maxerror="0">
                                <IfSequence id="_1lu4" test="$(throwExc)">
                                  <RethrowStep id="_1lu5"/>
                                  <ElseSequence id="_1lu6">
                                    <ReturnStep id="_1lu7" retval="false"/>
                                  </ElseSequence>
                                </IfSequence>
                              </CatchSequence>
                            </TryStep>
                          </CatchSequence>
                        </TryStep>
                      </CatchSequence>
                    </TryStep>
                  </CatchSequence>
                </TryStep>
              </CatchSequence>
            </TryStep>
            <ReturnStep id="_1ltm" retval="true"/>
          </Procedure>
          <Procedure id="_1ltA" name="isPlainDialog">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; PlainDialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane dialog wasn't found.

@return	This function returns true if current window is a JOptionPane plain dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1ltB">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1ltC" test="not $(installed)">
              <ProcedureCall id="_1ltD"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1luf">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.PlainDialog" id="_1ltK"
                               local="true" raise="$(throwExc)"
                               resvarname="plain" timeout="0"/>
              <FinallySequence id="_1n6w">
                <IfSequence id="_1ltF" test="not $(installed)">
                  <ProcedureCall id="_1ltG"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1ltJ" retval="$(plain)"/>
          </Procedure>
          <Procedure id="_1ls-" name="isQuestionDialog">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; QuestionDialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane QuestionDialog wasn't found.

@return	This function returns true if current window is a JOptionPane question dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lt0">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1lt1" test="not $(installed)">
              <ProcedureCall id="_1lt2"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1lua">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.QuestionDialog"
                               id="_1lt9" local="true" raise="$(throwExc)"
                               resvarname="question" timeout="0"/>
              <FinallySequence id="_1n6x">
                <IfSequence id="_1lt4" test="not $(installed)">
                  <ProcedureCall id="_1lt5"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1lt8" retval="$(question)"/>
          </Procedure>
          <Procedure id="_1lsq" name="isWarningDialog">
            <variable name="throwExc">false</variable>
            <comment>Check, if current window is a &lt;code&gt;javax.swing.JOptionPane&lt;/code&gt; WarningDialog.

@param	client	The name of the SUT client.
@param	throwExc	Whether to throw an exception, if the JOptionPane WarningDialog wasn't found.

@return	This function returns true if current window is a JOptionPane warning dialog, otherwise false.
@throws	ClientNotConnectedException If SUT wasn't started this exception will be thrown.

@author	QFS,ys
@since	3.5.3</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lsr">
              <code>from de.qfs.apps.qftest.extensions import JOptionPaneResolver

rc.setLocal("installed", JOptionPaneResolver.isInstalled())</code>
            </ClientScriptStep>
            <IfSequence id="_1lss" test="not $(installed)">
              <ProcedureCall id="_1lst"
                             procedure="qfs.swing.optionpane.enableNameResolver"/>
            </IfSequence>
            <TryStep id="_1luV">
              <ComponentWaiter client="$(client)"
                               component="JOptionPane.WarningDialog"
                               id="_1ls+" local="true" raise="$(throwExc)"
                               resvarname="warning" timeout="0"/>
              <FinallySequence id="_1n5z">
                <IfSequence id="_1lsv" test="not $(installed)">
                  <ProcedureCall id="_1lsw"
                                 procedure="qfs.swing.optionpane.disableNameResolver"/>
                </IfSequence>
              </FinallySequence>
            </TryStep>
            <ReturnStep id="_1lsz" retval="$(warning)"/>
          </Procedure>
        </Package>
        <Package id="_1dL" name="popupmenu">
          <comment>Procedures to select items and checkbox menu items from popup menus.

Note that for all procedures, the popup menu &lt;strong&gt;must&lt;/strong&gt; first be opened by the calling test-suite, as the popup menu is component-dependent.

See package "menu" for more details about menus and sub-menus.
(Swing components &lt;code&gt;javax.swing.JMenuItem&lt;/code&gt; and &lt;code&gt;javax.swing.JCheckBoxMenuItem&lt;/code&gt; from &lt;code&gt;javax.swing.JPopupMenu&lt;/code&gt;)

@author	QFS
@since	1.05.0
</comment>
          <Procedure id="_1n7M" name="clickItemWithDetails">
            <variable name="item">${id:anItem}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <comment>Select an item in a popup menu. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client	The name of the SUT client.
@param	item	The id of menu item.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(item)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1n7N"
                            modifiers="$(modifier)" x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_g" name="selectItem">
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item in a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of menu item.

@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_j" modifiers="16"/>
          </Procedure>
          <Procedure id="_1dQ" name="selectSubItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu of a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.

@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1mIS" modifiers="16"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1mIT" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n9+" name="selectSubItemWithCoordinates">
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subItemX"/>
            <variable name="subItemY"/>
            <comment>Select an item within a submenu of a popup menu.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subItemX	The x coordinate for the click on the subitem, default is empty to click in the middle.
@param	subItemY	The y coordinate for the click on the subitem, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1n9-" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(subItem)" event="MOUSE_MPRC"
                            id="_1nA0" modifiers="16" x="$(subItemX)"
                            y="$(subItemY)"/>
          </Procedure>
          <Procedure id="_1dV" name="setCheckItem">
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item in a popup menu.

@param	client		The name of the SUT client.
@param	checkItem		The id of the menu checkbox item.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1dY" timeout="3000"/>
            <TryStep id="_1dZ" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1da"
                                raise="true" timeout="0"/>
              <IfSequence id="_1db" test="$(checkItemValue)">
                <ProcedureCall id="_1dc"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1dd">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1de" modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1df"
                             maxerror="0">
                <IfSequence id="_1dg" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1mIU" modifiers="16"/>
                  <ElseSequence id="_1di">
                    <ProcedureCall id="_1dj"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n7O" name="setCheckItemWithCoordinates">
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox menu item in a popup menu. You can specify the coordinates for clicking.

@param	client		The name of the SUT client.
@param	checkItem		The id of the menu checkbox item.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1n7P" timeout="3000"/>
            <TryStep id="_1n7Q" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1n7R"
                                raise="true" timeout="0"/>
              <IfSequence id="_1n7S" test="$(checkItemValue)">
                <ProcedureCall id="_1n7T"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1n7U">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1n7V" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1n7W"
                             maxerror="0">
                <IfSequence id="_1n7X" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(checkItem)" event="MOUSE_MPRC"
                                  id="_1n7Y" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                  <ElseSequence id="_1n7Z">
                    <ProcedureCall id="_1n7a"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1dk" name="setSubCheckItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within a submenu of a popup menu.

@param	client		The name of the SUT client.
@param	item		The id of item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(item)" id="_1dn"
                             timeout="3000"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1mIV" modifiers="16"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1dp" timeout="3000"/>
            <TryStep id="_1ds" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1dt"
                                raise="true" timeout="0"/>
              <IfSequence id="_1du" test="$(checkItemValue)">
                <ProcedureCall id="_1dv"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1dw">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1mIW"
                                  modifiers="16"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1dy"
                             maxerror="0">
                <IfSequence id="_1dz" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1mIX"
                                  modifiers="16"/>
                  <ElseSequence id="_1d-">
                    <ProcedureCall id="_1e0"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1nA1" name="setSubCheckItemWithCoordinates">
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <variable name="subCheckItemX"/>
            <variable name="subCheckItemY"/>
            <comment>Select a checkbox menu item within a submenu of a popup menu.
You can specify the coordinates for clicking.

@param	client		The name of the SUT client.
@param	item		The id of item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.
@param	subCheckItemX	The x coordinate for the click on the checkbox item, default is empty to click in the middle.
@param	subCheckItemY	The y coordinate for the click on the checkbox item, default is empty to click in the middle.

@author	QFS
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(item)" id="_1nA2"
                             timeout="3000"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(item)"
                            event="MOUSE_MPRC" id="_1nA3" modifiers="16"
                            x="$(itemX)" y="$(itemY)"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_1nA4" timeout="3000"/>
            <TryStep id="_1nA5" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_1nA6"
                                raise="true" timeout="0"/>
              <IfSequence id="_1nA7" test="$(checkItemValue)">
                <ProcedureCall id="_1nA8"
                               procedure="qfs.swing.cleanup.closeAllMenus"/>
                <ElseSequence id="_1nA9">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nAA" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1nAB"
                             maxerror="0">
                <IfSequence id="_1nAC" test="$(checkItemValue)">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(subCheckItem)"
                                  event="MOUSE_MPRC" id="_1nAD" modifiers="16"
                                  x="$(subCheckItemX)" y="$(subCheckItemY)"/>
                  <ElseSequence id="_1nAE">
                    <ProcedureCall id="_1nAF"
                                   procedure="qfs.swing.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1lA9" name="radiobutton">
          <comment>Procedures to get and set the state of radio buttons.
(Swing component &lt;code&gt;javax.swing.JRadioButton&lt;/code&gt;)

@author	QFS,mm
@since	3.5.0</comment>
          <Procedure id="_1lAF" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1lAG">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1lAH"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1lAI" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1lAJ"
                             maxerror="0">
                <ReturnStep id="_1lAK" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lAL" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.

@param	id	The id of the radio button.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1lAM">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1lAN"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1lAO"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1lAP" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n7b" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n7c">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1n7d"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1n7e"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1n7f" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1kJa" name="slider">
          <comment>Procedures to access sliders.
(Swing component &lt;code&gt;javax.swing.JSlider&lt;/code&gt;)

@author	QFS, mm
@since	3.4.1</comment>
          <Package id="_1kJd" name="checks">
            <comment>Procedure for checking slider values.

@author	QFS, mm
@since	3.4.1</comment>
            <Procedure id="_1kJe" name="checkValue">
              <variable name="id">${id:sliderid}</variable>
              <variable name="value"/>
              <variable name="regexp">false</variable>
              <variable name="negate">false</variable>
              <variable name="reportName"/>
              <variable name="nameCheckType">default</variable>
              <variable name="throwExc">false</variable>
              <variable name="timeout">3000</variable>
              <comment>Check the value of a slider component

@param id		The component ID of the slider.
@param value		The value to be checked,
@param regexp	if this value is set to true, the text will be checks as regular-expression.
@param negate	if, the check should check for anything but the given text.
@param nameCheckType	the value for "name of check type" attribute.
@param throwExc	whether the check should throw an exception on failure.
@param reportName	the Name for the check in the report.
@param timeout	Timeout for the checked condition to happen.

@author	QFS, mm
@since	3.4.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1kJg" procedure="qfs.check.checkText">
                <variable name="text">$(value)</variable>
                <variable name="id">$(id)</variable>
                <variable name="regexp">$(regexp)</variable>
                <variable name="negate">$(negate)</variable>
                <variable name="reportName">$(reportName)</variable>
                <variable name="nameCheckType">$(nameCheckType)</variable>
                <variable name="throwExc">$(throwExc)</variable>
                <variable name="timeout">$(timeout)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_1kJc" name="getValue">
            <variable name="id">${id:sliderid}</variable>
            <comment>Return the value of a slider component.

@param id	The component ID of the slider.

@return	The current vale of the slider.

@author	QFS, mm
@since	3.4.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1kJo"
                           local="true" varname="currentValue"/>
            <ReturnStep id="_1kJp" retval="$(currentValue)"/>
          </Procedure>
          <Procedure id="_1kJm" name="setValue">
            <variable name="id">${id:sliderid}</variable>
            <variable name="value">aValue</variable>
            <comment>Set the value of a slider component.

@param id	The component ID of the slider.
@param value	The value to set.

@author	QFS, mm
@since	3.4.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGN"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1kJn">
              <code>slider = rc.getComponent(rc.lookup("id"))

slider.setValue(rc.getInt("value"))</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Package id="_1lB1" name="startup">
          <comment>Procedures for startup of swing applications.

@author	QFS, gs
@since	3.4.14</comment>
          <Procedure id="_1lB2" name="setDelays">
            <variable name="delay-1">0</variable>
            <variable name="delay0">0</variable>
            <variable name="delay10">0</variable>
            <variable name="delay1">0</variable>
            <variable name="delay11">0</variable>
            <variable name="delay2">0</variable>
            <variable name="delay3">0</variable>
            <variable name="delay13">0</variable>
            <variable name="delay4">0</variable>
            <variable name="delay5">0</variable>
            <variable name="delay6">0</variable>
            <variable name="delay7">0</variable>
            <variable name="delay8">0</variable>
            <variable name="delay20">0</variable>
            <comment>Set delays for the QF-Test SUT initialization process.

Note: Values that are documented to have a default will pick up that default when you set them to 0. Use 1 to disable the default.

The Java WebStart launcher has several race conditions where initialization of QF-Test SUT client wrapper can lead to problems, even to crashes. Newer versions of the Java applet plugin exhibit similar problems. QF-Test therefore delays certain steps in the SUT connection process to allow the SUT to get past the critical points.

By calling this procedure before SUT startup with one or more of the following parameters it is possible to fine-tune these delays. Unfortunately there is no single optimal setting. In case you experience problems with SUT startup you will need to experiment with these values. Start with few parameters and values between 5000 and 10000.

@param	delay-1	  Earliest place, called once. Default is 3000 for WebStart and applets. Good choice up to 30000.
@param	delay0	  Before checking ThreadGroups. Called often, use small values.
@param	delay10	  After checking ThreadGroups. Called often, use small values.
@param	delay1	  Before checking ThreadGroups for security engine. Called often, use small values.
@param	delay11	  After checking ThreadGroups for security engine. Called often, use small values.
@param	delay2	  Applet plugin only, good choice for that.
@param	delay3	  Before initializing RMI, normal engine. Good choice. Default 3000.
@param	delay13	  Before initializing RMI, security engine. Good choice. Default 2000.
@param	delay4	  Before creating security engine. Rarely useful.
@param	delay5	  Before installing EventQueue. Rarely useful.
@param	delay6	  After installing EventQueue. Rarely useful.
@param	delay7	  Before connecting with QF-Test. Rarely useful.
@param	delay8	  WebStart only. Before initializing the engine on the system ThreadGroup which should be avoided if possible. Default 30000.
@param	delay20	  WebStart and applet only. Before automatically closing security dialogs. Can be set to enable manual interaction. Default 300.

@since	3.4.14
@author	QFS,gs
</comment>
            <ServerScriptStep id="_1lB3">
              <code>
for num in [-1, 0, 10, 1, 11, 2, 3, 13, 4, 5, 6, 7, 8, 20]:
    delay = rc.getInt("delay%s" % num)
    if delay &lt;= 0:
        delay = None
    rc.setProperty("env", "QFTEST_STARTUP_DELAY_%s" % num, delay)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1mHH" name="setSecurityDialogSpec">
            <variable name="title"/>
            <variable name="button"/>
            <variable name="permanent"/>
            <variable name="checkbox"/>
            <comment>Define properties for recognizing WebStart and applet security dialogs that should be closed automatically. Default values, which handle English and German security dialogs in current versions of Java 6, 7 and 8 apply in case of empty parameters.

Do disable automatic handling of security dialogs, set the title parameter to '-'.

@param	title	A regular expression matching the dialog title. Set to '-' to disable automatic handling of security dialogs. Default: .*(Security|Sicherheit|Deprecation warning|Veraltet - Warnung).*"
@param	button	A regular expression matching the text of the button to click. Default: (OK|Yes|Run|Continue|Ja|Ausf.hren|Fortfahren|Weiter)
@param	permanent	Whether to accept the certificate permanently. Default is false.
@param	checkbox	A regular expression matching the text of the checkbox to select in order to accept the certificate permanently. Default: .*(not show this|lways trust|nicht (mehr|wieder) anzeigen|immer vertrauen).*

@since	3.5.2
@author	QFS,gs
</comment>
            <ServerScriptStep id="_1mHI">
              <code>from de.qfs.apps.qftest.shared import Util

title = rc.lookup("title")
if title:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_TITLE", Util.to7Bit(title))
else:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_TITLE", None)

button = rc.lookup("button")
if button:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_BUTTON", Util.to7Bit(button))
else:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_BUTTON", None)

permanent = rc.lookup("permanent")
if permanent:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_PERMANENT", permanent)
else:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_PERMANENT", None)

checkbox = rc.lookup("checkbox")
if checkbox:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_CHECKBOX", Util.to7Bit(checkbox))
else:
    rc.setProperty("env", "QFTEST_STARTUP_SECURITY_CHECKBOX", None)
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1lrk" name="startAppletSUT">
            <variable name="executable"/>
            <variable name="browsertype">no</variable>
            <variable name="args"/>
            <variable name="url">anUrl</variable>
            <variable name="profileTemplateDir"/>
            <variable name="waitForClientTimeout">120000</variable>
            <variable name="threadDelay">10000</variable>
            <variable name="syncStart">true</variable>
            <variable name="dialogTimeout">-1</variable>
            <comment>Start an applet as SUT in a browser.

It is ensured a new browser default is used, otherwise the applet is not properly recognized by QF-Test.

This procedure just delegates to qfs.web.browser.general.startAsNewProcess.
Therefore parameter description can be found at http://www.qfs.de/include/qfs_pkgdoc/qfs_pkgdoc.html#qfs.web.browser.general.startAsNewProcess

@author	QFS,kk
@since	3.5</comment>
            <ProcedureCall id="_1lrv"
                           procedure="qfs.web.browser.general.startAsNewProcess">
              <variable name="executable">$(executable)</variable>
              <variable name="browsertype">$(browsertype)</variable>
              <variable name="args">$(args)</variable>
              <variable name="url">$(url)</variable>
              <variable name="profileTemplateDir">$(profileTemplateDir)</variable>
              <variable name="waitForClientTimeout">$(waitForClientTimeout)</variable>
              <variable name="threadDelay">$(threadDelay)</variable>
              <variable name="syncStart">$(syncStart)</variable>
              <variable name="dialogTimeout">$(dialogTimeout)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1lrO" name="startWebstartSUT">
            <variable name="jnlp">jnlpFile</variable>
            <variable name="exec">javaws</variable>
            <variable name="waitForClientTimeout">120000</variable>
            <comment>Start a Webstart SUT.

@param	client    		The client.
@param	exec		The Java webstart executable. Default is javaws.
@param	jnlp		The jnlp Descriptor file either given local or as URL.
@param	waitForClientTimeout 	Time in ms to wait for the client to connect. Default is 120000.

@author	QFS,kk
@since	3.5</comment>
            <BasicSequence id="_1lrj"
                           name="Start java webstart with given jnlp">
              <IfSequence id="_1lrP" test="${qftest:windows} ">
                <SUTClientStarter client="$(client)" executable="$(exec)"
                                  id="_1lrd">
                  <parameter>$(jnlp)</parameter>
                </SUTClientStarter>
                <ElseSequence id="_1lrc">
                  <comment>On Linux a sleep is necessary. Otherwise webstart gets stuck.</comment>
                  <ServerScriptStep id="_2YMt" interpreter="groovy"
                                    name="Ensure proper quoting for use in shell command node">
                    <code>jnlp = rc.lookup("jnlp").trim()
if (! (jnlp.startsWith("\"") || jnlp.endsWith("\"")
       || jnlp.startsWith("\'") || jnlp.endsWith("\'"))) {
    rc.setLocal("jnlp", "'" + jnlp + "'")
}

</code>
                  </ServerScriptStep>
                  <ShellClientStarter client="$(client)"
                                      command="sleep 3; $(exec) $(jnlp)"
                                      id="_S"/>
                </ElseSequence>
              </IfSequence>
            </BasicSequence>
            <ClientWaiter client="$(client)" id="_1mHn"
                          timeout="$(waitForClientTimeout)"/>
          </Procedure>
        </Package>
        <Package id="_1e9" name="table">
          <comment>Procedures to access tables.
(Swing component &lt;code&gt;javax.swing.JTable&lt;/code&gt;)

@author	QFS,mm
@since	1.08.4</comment>
          <Package id="_6YA" name="checkbox">
            <comment>Procedures to set the state of checkboxes in a table-cell.
These procedures become necessary, because checkboxes in tables cannot be treated like normal checkboxes.

@author	QFS,mm
@since	3.0</comment>
            <Procedure id="_6YF" name="deselect">
              <variable name="id">aCheckboxId</variable>
              <comment>Deselect a checkbox in a table-cell. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.

@author	QFS,mm
@since	3.0</comment>
              <TryStep id="_6YG">
                <CheckStringStep client="$(client)" component="$(id)"
                                 id="_6YH" raise="true" timeout="0">
                  <text>false</text>
                </CheckStringStep>
                <CatchSequence exception="CheckFailedException" id="_6YI"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1mIY" modifiers="16"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1n7g" name="deselectWithCoordinates">
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Deselect a checkbox in a table-cell. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
              <TryStep id="_1n7h">
                <CheckStringStep client="$(client)" component="$(id)"
                                 id="_1n7i" raise="true" timeout="0">
                  <text>false</text>
                </CheckStringStep>
                <CatchSequence exception="CheckFailedException" id="_1n7j"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1n7k" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_6YB" name="select">
              <variable name="id">aCheckboxId</variable>
              <comment>Select a checkbox in a table-cell. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.


@author	QFS,mm
@since	3.0</comment>
              <TryStep id="_6YC">
                <CheckStringStep client="$(client)" component="$(id)"
                                 id="_3DW" raise="true" timeout="0">
                  <text>true</text>
                </CheckStringStep>
                <CatchSequence exception="CheckFailedException" id="_6YD"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1mIZ" modifiers="16"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1n7l" name="selectWithCoordinates">
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Select a checkbox in a table-cell. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.


@author	QFS,mm
@since	4.0</comment>
              <TryStep id="_1n7m">
                <CheckStringStep client="$(client)" component="$(id)"
                                 id="_1n7n" raise="true" timeout="0">
                  <text>true</text>
                </CheckStringStep>
                <CatchSequence exception="CheckFailedException" id="_1n7o"
                               maxerror="0">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1n7p" modifiers="16" x="$(x)"
                                  y="$(y)"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_6YK" name="set">
              <variable name="check">true</variable>
              <variable name="id">aCheckboxId</variable>
              <comment>Set checkbox in a table-cell to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	check	The check value to be set (either true or false).

@author	QFS,mm
@since	3.0</comment>
              <IfSequence id="_6YL" test="$(check)">
                <ProcedureCall id="_6YM"
                               procedure="qfs.swing.table.checkbox.select">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
                <ElseSequence id="_6YN">
                  <ProcedureCall id="_6YO"
                                 procedure="qfs.swing.table.checkbox.deselect">
                    <variable name="id">$(id)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </Procedure>
            <Procedure id="_1n7u" name="setWithCoordinates">
              <variable name="check">true</variable>
              <variable name="id">aCheckboxId</variable>
              <variable name="x"/>
              <variable name="y"/>
              <comment>Set checkbox in a table-cell to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox, including the table-id and the addressing of the cell.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
              <IfSequence id="_1n7v" test="$(check)">
                <ProcedureCall id="_1n7w"
                               procedure="qfs.swing.table.checkbox.selectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
                <ElseSequence id="_1n7x">
                  <ProcedureCall id="_1n7y"
                                 procedure="qfs.swing.table.checkbox.deselectWithCoordinates">
                    <variable name="id">$(id)</variable>
                    <variable name="x">$(x)</variable>
                    <variable name="y">$(y)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </Procedure>
          </Package>
          <Package id="_1jus" name="checks">
            <comment>Procedures for checking a table.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_7SI" name="checkNumberOfRows">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of rows of a given table according to a specified comparison mode.
It uses the method JTable.getRowCount() to get the number.

Sample usage:
You can check, that a table has exactly 6 rows or that the table has less then 10 rows.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_7SJ" local="true"
                             procedure="qfs.swing.table.getRowCount"
                             retvarname="rowCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1jwJ"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_6QF" name="selection">
            <comment>Procedures to (de-)select certain rows of a table.

@author QFS,mm
@since 2.1.0</comment>
            <Procedure id="_6QI" name="deselectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Deselect all rows. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGO"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QM">
                <code>table = rc.getComponent(rc.lookup("id"))

rows = table.getRowCount()
if rows &gt; 0:
	table.removeRowSelectionInterval(0, rows-1)

</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QH" name="deselectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Deselect a given row, specified by its index. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGP"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QL">
                <code>table = rc.getComponent(rc.lookup("id"))

selRow = rc.lookup("row")
if selRow != None:
	table.removeRowSelectionInterval(int(selRow), int(selRow))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QQ" name="deselectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Deselect a range of rows, specified by their index. It uses &lt;code&gt;removeSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGQ"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QR">
                <code>table = rc.getComponent(rc.lookup("id"))

startRow = rc.lookup("startRow")
endRow = rc.lookup("endRow")

rows = table.getRowCount()

if endRow == None or endRow == '':
	endRow = rows -1
else:
	endRow = int(endRow)

table.removeRowSelectionInterval(int(startRow), endRow)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QJ" name="selectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Select all rows. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGR"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QN">
                <code>table = rc.getComponent(rc.lookup("id"))

rows = table.getRowCount()

if rows &gt; 0:
	table.setRowSelectionInterval(0, rows-1)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QG" name="selectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Select a given row, specified by its index. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGS"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QK">
                <code>table = rc.getComponent(rc.lookup("id"))

selRow = rc.lookup("row")
if selRow != None:
	table.setRowSelectionInterval(int(selRow), int(selRow))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QO" name="selectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Select a range of rows, specified by their index. It uses &lt;code&gt;setSelectionInterval&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGT"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_6QP">
                <code>table = rc.getComponent(rc.lookup("id"))

startRow = rc.lookup("startRow")
endRow = rc.lookup("endRow")

rows = table.getRowCount()

if endRow == None or endRow == '':
	endRow = rows -1
else:
	endRow = int(endRow)

table.setRowSelectionInterval(int(startRow), endRow)</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1n7q" name="clickCellWithDetails">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given cell.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n7t"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_4op" name="getColumnCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of columns of a given table.
It uses the method &lt;code&gt;getColumnCount()&lt;/code&gt; to get the number.

@param id 		The component-ID of the table.
@return columnCount

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGU"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_4oq">
              <code>table = rc.getComponent(rc.lookup("id"))

columnCount = table.getColumnCount()

rc.setLocal("columnCount", columnCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_4or" retval="$(columnCount)"/>
          </Procedure>
          <Procedure id="_1jv4" name="getIndexOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">@</variable>
            <comment>Return the current index of a given column.

Sample usage:
Can be used to determine the numeric index of a column like 'Price'.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the column, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)"
                            id="_1jv5" local="true" varname="index"/>
            <ReturnStep id="_1jv6" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1jv1" name="getNameOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">&amp;</variable>
            <comment>Return the header text of a given column.

Sample usage:
Determine the title of the second column.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   The name of the column.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)"
                           id="_1jv2" local="true" varname="name"/>
            <ReturnStep id="_1jv3" retval="$(name)"/>
          </Procedure>
          <Procedure id="_3EP" name="getRowCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of rows of a given table.
It uses the method JTable.getRowCount() to get the number.

@param id 		The component-id of the table.
@return rowCount

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGV"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_3EQ">
              <code>table = rc.getComponent(rc.lookup("id"))

rowCount = table.getRowCount()

rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_3ER" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1jux" name="getRowIndexOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Return the row number of a given cell.

Sample usage:
Can be used to determine in which row a dedicated cell is located.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the row, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            id="_1ju+" local="true" varname="index"/>
            <ReturnStep id="_1juz" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1juu" name="getValueOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">&amp;</variable>
            <comment>Return the text of a given cell.

Sample usage:
Can be used to determine the text of the cell in the first column and first row.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value   The current value of the row, which has been read by the 'Fetch text' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                           id="_1juv" local="true" varname="value"/>
            <ReturnStep id="_1juw" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2F8" name="resizeColumn">
            <variable name="idColumn">aColumnId</variable>
            <variable name="width">aWidth</variable>
            <variable name="absolute">true</variable>
            <comment>Resize width of a table column.

@param client		The name of the client.
@param idColumn	The id of the table column to be resized.
@param width		The new width - additional or absolute, dependent on the 'absolute' parameter.
                                            For additional width also negative values are possible to shrink the column size.
@param absolute	True, if the with value shall be the absolute new column width (default is 'true').

@author	QFS,mm
@since	1.08.4</comment>
            <BasicSequence id="_2F9">
              <variable name="currentWidth"/>
              <FetchGeometryStep client="$(client)" component="$(idColumn)"
                                 id="_2F7" local="true"
                                 widthvarname="currentWidth"/>
              <IfSequence id="_2FA"
                          test="&#34;$(absolute)&#34; == &#34;true&#34;">
                <ElseSequence id="_2FE">
                  <SetGlobalStep id="_2FF" local="true" varname="width">
                    <default>$[$(currentWidth) + $(width)]</default>
                  </SetGlobalStep>
                </ElseSequence>
              </IfSequence>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_MOVED"
                              id="_2F3" modifiers="0" x="$(currentWidth)"
                              y="1"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(idColumn)" event="MOUSE_PRESSED"
                              id="_2F4" modifiers="16" x="$(currentWidth)"
                              y="1"/>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_DRAGGED"
                              id="_2F5" modifiers="16" x="$(width)" y="1"/>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_RELEASED"
                              id="_2F6" modifiers="16" x="$(width)" y="1"/>
            </BasicSequence>
          </Procedure>
          <Procedure id="_4os" name="selectCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Select a given cell.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" id="_4ot" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_4ol" name="tabbedpane">
          <comment>Procedures to work with TabbedPanes.
(Swing component &lt;code&gt;javax.swing.JTabbedPane&lt;/code&gt; or any other TabFolder implementations)

@author QFS,mm
@since 2.1.0</comment>
          <Procedure id="_4om" name="closeTab">
            <variable name="id">idOfTab</variable>
            <variable name="wdiff">10</variable>
            <variable name="y">10</variable>
            <comment>Close a tab via clicking on the "X "button.
The procedure assumes that the "X" button is located 10 pixel away from the right corner. If this doesn't work for you, you can configure this via the parameter "wdiff".

@param id  ID of tab, which should be closed.
@param 	wdiff	X position of the "x" button seen from the right side.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author QFS,mm
@since 2.1.0</comment>
            <FetchGeometryStep client="$(client)" component="$(id)" id="_4on"
                               local="true" widthvarname="w"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_4oo" modifiers="16"
                            x="$[$(w)-$(wdiff)]" y="$(y)"/>
          </Procedure>
          <Procedure id="_1l9c" name="getIndexOfTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Return the index of a given tab in a JTabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to look for.

@return	The index of the tab.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_1l9d"
                            local="true" varname="index"/>
            <ReturnStep id="_1l9e" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2YNQ" name="getItemCount">
            <variable name="id">${id:aTabfolder}</variable>
            <comment>Return the number of items of a given tabbedpane.


@param id 		The component-ID of the tabbedpane.
@return itemCount

@author QFS
@since 5.3.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YNR"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                            id="_2YNe" local="true" varname="itemCount"/>
            <ReturnStep id="_2YNf" retval="$[$(itemCount)+1]"/>
          </Procedure>
          <Procedure id="_1l9f" name="getValueOfTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">&amp;</variable>
            <variable name="value"/>
            <comment>Return the text of a given tab in a JTabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The index to look for.

@return	The value of the tab.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(separator)$(value)" id="_1l9g"
                           local="true" varname="value"/>
            <ReturnStep id="_1l9h" retval="$(value)"/>
          </Procedure>
          <Procedure id="_6Pt" name="selectTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Select a tab in a given TabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane to select.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to select.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)"
                               component="$(id)$(separator)$(value)"
                               heightvarname="h" id="_1j+g" widthvarname="w"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(value)"
                            event="MOUSE_MPRC" id="_6Pu" modifiers="16"
                            x="$[$(w)/2]" y="$[$(h)/2]"/>
          </Procedure>
        </Package>
        <Package id="_15" name="text">
          <comment>Procedures to access text fields and text areas.
(Swing components &lt;code&gt;javax.swing.JTextField&lt;/code&gt; and &lt;code&gt;javax.swing.JTextArea&lt;/code&gt;)

@author	QFS,mm
@since	1.05.0</comment>
          <Procedure id="_6N" name="clearArea">
            <variable name="id">${id:aTextArea}</variable>
            <comment>Clear a multi-line text area.

@param	client	The name of the SUT client.
@param	id	The id of the text area.

@author	QFS,mm
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_3DV" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_16" name="clearField">
            <variable name="id">${id:aTextField}</variable>
            <comment>Clear a simple text field.

@param	client	The name of the SUT client.
@param	id	The id of the text field.

@author	QFS,mm
@since	1.05.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_3DU" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_6T9" name="getText">
            <variable name="id">${id:aTextField}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  The text of the textfield.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l8v"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l8w" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1l8V" name="setText">
            <variable name="id">${id:aTextField}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

If the text is empty, no action will take place.

@param	id	ID of the textfield.
@param 	text	Text to be set.
@param	append	If this value is set to true, the text will be appended to the current values.
@param	clear	If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents If this value is set to true, the text will be inserted replaying single events.
@param	newline	the separator sign for marking a linebreak within the text

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1l8W" test="rc.lookup(&#34;text&#34;)">
              <ServerScriptStep id="_1l8X">
                <code>global parts

text = rc.lookup("text")
newline = rc.lookup("newline")
parts = text.split(newline)
rc.setLocal("iterations", len(parts))
</code>
              </ServerScriptStep>
              <RepeatSequence count="$(iterations)" id="_1l8Y" var="i">
                <ServerScriptStep id="_1l8Z">
                  <code>global parts
rc.setLocal("text", parts[$(i)].replace('$$', '$$$$'))
</code>
                </ServerScriptStep>
                <IfSequence id="_1l8a" test="$(i) == 0">
                  <IfSequence id="_1l8b"
                              test="&#34;$(append)&#34; == &#34;true&#34;">
                    <IfSequence id="_1l8c"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_1l8d">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_1l8e">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_1l8f" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                    <ElseSequence id="_1l8g">
                      <IfSequence id="_1l8h"
                                  test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                        <TextInputStep clear="true" client="$(client)"
                                       component="$(id)" id="_1l8i">
                          <text>$(text)</text>
                        </TextInputStep>
                        <ElseSequence id="_1l8j">
                          <TextInputStep clear="true" client="$(client)"
                                         component="$(id)" id="_1l8k"
                                         single="false">
                            <text>$(text)</text>
                          </TextInputStep>
                        </ElseSequence>
                      </IfSequence>
                    </ElseSequence>
                  </IfSequence>
                  <ElseSequence id="_1l8l">
                    <IfSequence id="_1l8m"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_1l8n">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_1l8o">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_1l8p" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                  </ElseSequence>
                </IfSequence>
                <IfSequence id="_1l8q" test="$(i) &lt; ($(iterations) - 1)">
                  <KeyEventStep client="$(client)" component="$(id)"
                                event="KEY_PTR" id="_1l8r" keychar="13"
                                keycode="10" modifiers="0"/>
                </IfSequence>
              </RepeatSequence>
              <ElseSequence id="_1l8s">
                <IfSequence id="_1l8t"
                            test="&#34;$(clear)&#34; == &#34;true&#34;">
                  <TextInputStep clear="true" client="$(client)"
                                 component="$(id)" id="_1l8u" single="false">
                    <text></text>
                  </TextInputStep>
                </IfSequence>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1juc" name="setTextFromFile">
            <variable name="id">${id:aTextField}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param id 	The id of the text-field to set.
@param file	The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1juj" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1juk" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_w" name="tree">
          <comment>Procedures to access trees.
(Swing component &lt;code&gt;javax.swing.JTree&lt;/code&gt;)

@author	QFS,mm
@since	1.05.0</comment>
          <Package id="_1jvJ" name="checks">
            <comment>Procedures for checking a tree.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_2J2g" name="checkNumberOfChildNodes">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of child nodes of a given tree node according to a specified comparison mode.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 		Separator to use for the node syntax. Default is 				@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2J2h" local="true"
                             procedure="qfs.swing.tree.getChildNodeCount"
                             retvarname="nodeCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2J2i"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of child nodes of tree '$(id)$(nodeSeparator)$(node)'</variable>
                <variable name="got">$(nodeCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_1jvK" name="checkNumberOfRows">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of visible nodes under a given tree or tree node according to a specified comparison mode.
If no node is specified, you will get the visible nodes or all loaded nodes.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 		Separator to use for the node syntax. Default is 						@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1jvL" local="true"
                             procedure="qfs.swing.tree.getRowCount"
                             retvarname="rowCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1jwK"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of visible rows of tree '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_3bd" name="_expandNodesR">
            <variable name="treeId"/>
            <variable name="root"/>
            <variable name="callbackProc"/>
            <comment>Internal procedure.</comment>
            <SetGlobalStep id="_3e0" local="true" varname="node">
              <default>$(root)</default>
              <comment>Force variable expansion</comment>
            </SetGlobalStep>
            <TryStep id="_3dr">
              <ProcedureCall id="_3dq" procedure="qfs.swing.tree.expand">
                <variable name="node">$(treeId)$(node)</variable>
              </ProcedureCall>
              <IfSequence id="_3eh"
                          test="&#34;$(callbackProc)&#34; != &#34;&#34;">
                <ProcedureCall id="_3eP" procedure="$(callbackProc)">
                  <variable name="treeId">$(treeId)</variable>
                  <variable name="node">$(node)</variable>
                </ProcedureCall>
              </IfSequence>
              <CatchSequence exception="ComponentNotFoundException" id="_3ds"
                             maxerror="0">
                <ReturnStep id="_3dt"/>
              </CatchSequence>
            </TryStep>
            <RepeatSequence count="1000" id="_3en" var="i">
              <SetGlobalStep id="_3cL" local="true" varname="subnode">
                <default>$(node)/$(i)</default>
              </SetGlobalStep>
              <TryStep id="_3dv">
                <ComponentWaiter client="$(client)"
                                 component="$(treeId)$(subnode)" id="_3dw"
                                 timeout="0"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_3dy" maxerror="0">
                  <BreakStep id="_3dz"/>
                </CatchSequence>
              </TryStep>
              <ProcedureCall id="_3dx"
                             procedure="qfs.swing.tree._expandNodesR">
                <variable name="treeId">$(treeId)</variable>
                <variable name="root">$(subnode)</variable>
                <variable name="callbackProc">$(callbackProc)</variable>
              </ProcedureCall>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_3eO" name="callbackPrintNodeText">
            <variable name="treeId">${id:treeid}</variable>
            <variable name="node"/>
            <comment>Example for a callback procedure used by expandNodes.

@param	treeId  	The id of the tree.
@param	node  	The index of the node.

@author	QFS
@since	3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(treeId)"
                             id="_1oGW"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_3eQ"
                              name="Print node text">
              <code>tree = rc.getComponent(rc.lookup('treeId'))
node = tree.getLastSelectedPathComponent()
print node</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n8H" name="clickNodeWithDetails">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given node.
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the tree.
@param node 		The node, e.g. '/Root/Price' or '/0/0'.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n8J"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_x" name="collapse">
            <variable name="node">tree.item</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.

@author	QFS,mm
@since	1.05.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_y" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_z" keychar="65535" keycode="37"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_+" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n7z" name="collapseWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n7+" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_1n7-" keychar="65535"
                          keycode="37" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n80" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_6Vt" name="collapseNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_6Vu" modifiers="16"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_6Vv" keychar="65535" keycode="37"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_6Vw" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n81" name="collapseNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n82" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_1n83" keychar="65535" keycode="37"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n84" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1lXP" name="collapseNodes">
            <variable name="id">aTreeNode</variable>
            <comment>Collapse a tree node recursively.

@param	id  	The id of the tree node.

@author	QFS,mh
@since	3.4.11</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGX"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1lXT">
              <code>from javax.swing import JTree
from javax.swing.tree import TreePath

ID = rc.lookup('id')
if ID.find('&amp;/') &gt; 0:
    pass
elif ID.find('@/') &gt; 0:
    pass
elif ID.find('%/') &gt; 0:
    pass
else:
    raise UserException('Invalid id %s' %ID)

tree, itemIdx = rc.getComponent(ID)

def collapseAll(tree, path):
    lastNode = path.getLastPathComponent()
    for i in range(tree.getModel().getChildCount(lastNode)):
        child = tree.getModel().getChild(lastNode, i)
        pathToChild = path.pathByAddingChild(child)
        collapseAll(tree, pathToChild)
    tree.collapsePath(path)

collapseAll(tree, tree.getPathForRow(itemIdx))
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_-" name="expand">
            <variable name="node">tree.item</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.

@author	QFS,mm
@since	1.05.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_10" modifiers="16"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_11" keychar="65535"
                          keycode="39" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_12" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n85" name="expandWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n86" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_1n87" keychar="65535"
                          keycode="39" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n88" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_6Vx" name="expandNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.


@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_6Vy" modifiers="16"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_6Vz" keychar="65535" keycode="39"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_6V+" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n89" name="expandNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n8A" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_1n8B" keychar="65535" keycode="39"
                          modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n8C" modifiers="16"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_6bX" name="expandNodes">
            <variable name="id">aTreeNode</variable>
            <variable name="callbackProc"/>
            <comment>Expand a tree node recursively.

@param	id  	The id of the tree node.
@param	callbackProc  	The name of a procedure to be called for every visited node.

@author	QFS,mm
@since	3.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_6bY" modifiers="16"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_6XF">
              <code>
def setTreeAndIdx():
    ID = rc.lookup('id')
    if ID.find('&amp;/') &gt; 0:
        parts = ID.split('&amp;')
        rc.setLocal('tree', parts[0])
        rc.setLocal('idx', parts[1])
        return
    elif ID.find('@/') &gt; 0:
        treeID = ID.split('@')[0]
    elif ID.find('%/') &gt; 0:
        treeID = ID.split('%')[0]
    else:
        raise UserException('Invalid id %s' %ID)
    tree, itemIdx = rc.getComponent(ID)
    treepath = tree.getPathForRow(itemIdx)
    rc.logMessage("itemIdx: %d, path: %s" % (itemIdx, treepath))
    idx = []
    for i in range(treepath.getPathCount()):
        if i == 0:
            if tree.isRootVisible():
                idx.append('0')
        else:
            node = treepath.getPathComponent(i)
            pnode = treepath.getPathComponent(i - 1)
            idx.append(str(tree.getModel().getIndexOfChild(pnode, node)))
    rc.setLocal('tree', treeID)
    rc.setLocal('idx', '/' + '/'.join(idx))

setTreeAndIdx()
</code>
            </ClientScriptStep>
            <ProcedureCall id="_6XG" procedure="qfs.swing.tree._expandNodesR">
              <variable name="treeId">$(tree)</variable>
              <variable name="root">&amp;$(idx)</variable>
              <variable name="callbackProc">$(callbackProc)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n8D" name="expandNodesWithCoordinates">
            <variable name="id">aTreeNode</variable>
            <variable name="callbackProc"/>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node recursively.
You can specify the coordinates for clicking.

@param	id  	The id of the tree node.
@param	callbackProc  	The name of a procedure to be called for every visited node.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1n8E" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_1n8F">
              <code>
def setTreeAndIdx():
    ID = rc.lookup('id')
    if ID.find('&amp;/') &gt; 0:
        parts = ID.split('&amp;')
        rc.setLocal('tree', parts[0])
        rc.setLocal('idx', parts[1])
        return
    elif ID.find('@/') &gt; 0:
        treeID = ID.split('@')[0]
    elif ID.find('%/') &gt; 0:
        treeID = ID.split('%')[0]
    else:
        raise UserException('Invalid id %s' %ID)
    tree, itemIdx = rc.getComponent(ID)
    treepath = tree.getPathForRow(itemIdx)
    rc.logMessage("itemIdx: %d, path: %s" % (itemIdx, treepath))
    idx = []
    for i in range(treepath.getPathCount()):
        if i == 0:
            if tree.isRootVisible():
                idx.append('0')
        else:
            node = treepath.getPathComponent(i)
            pnode = treepath.getPathComponent(i - 1)
            idx.append(str(tree.getModel().getIndexOfChild(pnode, node)))
    rc.setLocal('tree', treeID)
    rc.setLocal('idx', '/' + '/'.join(idx))

setTreeAndIdx()
</code>
            </ClientScriptStep>
            <ProcedureCall id="_1n8G"
                           procedure="qfs.swing.tree._expandNodesR">
              <variable name="treeId">$(tree)</variable>
              <variable name="root">&amp;$(idx)</variable>
              <variable name="callbackProc">$(callbackProc)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_2J2b" name="getChildNodeCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of child nodes.

@param id 		The component-id of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the items of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 

@return nodeCount

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_2J2j"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_2J2k">
              <code>tree = None
item = None
nodeCount = 0
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if not rc.lookup("node") or not rc.lookup("nodeSeparator"):
    raise UserException("No value for 'node' parameter specified!")    

tree, item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))

if item != None:
    mdl = tree.getModel()
    path = tree.getPathForRow(item)
    if not onlyVisibleNodes:
        nodeCount = mdl.getChildCount(path.getLastPathComponent())
    elif tree.isExpanded(path):
        nodeCount = mdl.getChildCount(path.getLastPathComponent())        
else:
    raise UserException("No value for 'node' parameter specified!")
        
rc.setLocal("nodeCount", nodeCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2J2e" retval="$(nodeCount)"/>
          </Procedure>
          <Procedure id="_1jvQ" name="getIndexOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">@</variable>
            <variable name="linear">false</variable>
            <comment>Return the current index of a given node.

Sample usage:
Can be used to determine the numeric index of a node like '/Root/Price'.

@param id  		ID of the tree.
@param node 		The node. like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param linear		If true, return the linear index, ignoring the tree structure, otherwise return a hierarchical index like /0/1.
@return	index   The current index of the node, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <TryStep id="_1l8Q" name="Override option">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:awt}" id="_1l8U"
                                name="Set legacy option">
                <code>rc.setOption("LegacyFetchIndex", rc.getBool("linear"))</code>
              </ClientScriptStep>
              <FetchIndexStep client="$(client)"
                              component="$(id)$(nodeSeparator)$(node)"
                              id="_1jvR" local="true" varname="index"/>
              <ReturnStep id="_1jvS" retval="$(index)"/>
              <FinallySequence id="_1l8S" name="Reset option">
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:awt}" id="_1l8T"
                                  name="Unset legacy option">
                  <code>rc.unsetOption("LegacyFetchIndex")</code>
                </ClientScriptStep>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1jvN" name="getRowCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of visible nodes under a given tree or tree-node.
If no node is specified, you will get the visible nodes or all loaded nodes of the entire tree.

@param id 		The component-id of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the nodes of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 

@return rowCount

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_1oGY"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:awt}" id="_2J2P">
              <code>from de.qfs.lib.tree import TraversalCallback
from de.qfs.lib.tree import Traversal
from de.qfs.lib.tree import TreeUtil
from de.qfs.lib.gui import JTreePathAdapter
from javax.swing.tree import TreePath

class TreeItemTraversal(TraversalCallback):      
    def __init__(self, tree, followChildren):
        self.tree = tree
        self.followChildren = followChildren
        self.count = 0
        
    def getCount(self):
        return self.count
        
    def nodeEntered(self, traversal):
        path = traversal.getNode()
        self.count = self.count + 1
        return self.followChildren or self.tree.isExpanded(path)
        
    def nodeExited(self, traversal):
        pass
    
tree = None
item = None
rowCount = 0
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if rc.lookup("node") and rc.lookup("nodeSeparator"):
    tree, item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))
else:
    tree = rc.getComponent(rc.lookup("id"))

if item != None:
    mdl = tree.getModel()
    path = tree.getPathForRow(item)
    
    traversal = TreeItemTraversal(tree, not onlyVisibleNodes)
    TreeUtil.traverse(JTreePathAdapter (tree.getModel()), path, traversal)
    rowCount = traversal.getCount()
else:  
    if not onlyVisibleNodes:    
        traversal = TreeItemTraversal(tree, not onlyVisibleNodes)
        TreeUtil.traverse(JTreePathAdapter (tree.getModel()), TreePath(tree.getModel().getRoot()), traversal)
        rowCount = traversal.getCount()
    else:
        rowCount = tree.getRowCount()
        
rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1jvP" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1jvT" name="getValueOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">&amp;</variable>
            <comment>Return the text of a given node.

Sample usage:
Determine the text value for a node referenced by index like /0/1.

@param id  		ID of the tree.
@param node 		The node. It should be something like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is &amp; for index values, also available @ for text and % for regexp.

@return	name   The value of the node.
	
@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(nodeSeparator)$(node)" id="_1jvU"
                           local="true" varname="value"/>
            <ReturnStep id="_1jvV" retval="$(value)"/>
          </Procedure>
          <Procedure id="_4p6" name="selectNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Select a given node.

@param id  		ID of the tree.
@param node 		The node, e.g. '/Root/Price' or '/0/0'.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_4p7" modifiers="16"/>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2Fj" name="swt">
        <comment>Procedures for advanced manipulation of SWT components.

@author	QFS,mm
@since	2.0.3</comment>
        <Package id="_3Dh" name="cleanup">
          <comment>The procedures in this package are useful for generic cleanup after an exception is thrown. In some cases a menu or modal dialog may have been left open, causing future events for the SUT to be blocked.

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_3Di" name="closeAllDialogsAndModalShells">
            <variable name="maxDialogs">5</variable>
            <comment>Close all modal dialogs.
A modal dialog that is left open will cause events for the SUT to be blocked. Ensuring that modal dialogs are closed is a good operation to conduct in a setup/cleanup sequence.
Closing all instances of &lt;code&gt;org.eclipse.swt.widgets.Dialog&lt;/code&gt; and all modal instances of &lt;code&gt;org.eclipse.swt.widgets.Shell&lt;/code&gt;.


@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,mm
@since	2.1.0</comment>
            <RepeatSequence count="$(maxDialogs)" id="_3Dj">
              <comment>There may be more than one modal dialog. We can't use an endless loop though, in case
a dialog cannot be closed.</comment>
              <TryStep id="_4nc" name="Check for modal dialog">
                <ComponentWaiter client="$(client)"
                                 component="genericSWTDialog" id="_4p3"
                                 timeout="50"/>
                <SelectionEventStep client="$(client)"
                                    component="genericSWTDialog"
                                    detail="CANCEL" event="SELECTION"
                                    id="_4p4">
                  <comment>The SELECTION -4 is equivalent to closing the dialog through the
window manager. We can't press a generic OK button, since the results could
be disastrous. Cancelling a dialog should always have the least consequences.</comment>
                </SelectionEventStep>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_4p5" maxerror="0" name="Finished">
                  <TryStep id="_3Dk" name="Check for modal shells">
                    <ComponentWaiter client="$(client)"
                                     component="genericModalShell" id="_3Dl"
                                     timeout="50"/>
                    <WindowEventStep client="$(client)"
                                     component="genericModalShell"
                                     event="WINDOW_CLOSING" id="_4nh"/>
                    <CatchSequence exception="ComponentNotFoundException"
                                   id="_3Dn" maxerror="0" name="Finished">
                      <BreakStep id="_3Do"/>
                    </CatchSequence>
                    <CatchSequence exception="ModalDialogException" id="_6Pp"
                                   maxerror="0">
                      <comment>It could happen that an newly appearing message-box blocks closing the dialog. So in such cases close the message-box before.</comment>
                      <ComponentWaiter client="$(client)"
                                       component="genericModalShell"
                                       id="_1oGZ"
                                       timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                        <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
                      </ComponentWaiter>
                      <ClientScriptStep client="$(client)"
                                        engine="${default:guiengine:swt}"
                                        id="_6Q6">
                        <code>genericSWT = rc.getComponent("genericModalShell")
disp = genericSWT.getShell().getDisplay()
shells = disp.getShells()
shells[len(shells)-1].dispose()
</code>
                      </ClientScriptStep>
                    </CatchSequence>
                  </TryStep>
                </CatchSequence>
              </TryStep>
            </RepeatSequence>
          </Procedure>
          <Procedure id="_3D+" name="closeAllMenus">
            <comment>Close all menus unconditionally.
A menu left open (or even just selected) will cause events for the SUT to be blocked. This procedure is recommended for cleanup after an exception occurs.

@param	client	The name of the SUT client.

@author	QFS,mm
@since	2.1.0</comment>
            <TryStep id="_1j-W" name="Close popup menus">
              <ComponentWaiter client="$(client)"
                               component="genericSWTPopupMenu" id="_6Qq"
                               timeout="0"/>
              <SelectionEventStep client="$(client)"
                                  component="genericSWTPopupMenu"
                                  detail="close" event="SELECTION"
                                  id="_1j-Y"/>
              <CatchSequence exception="ComponentNotFoundException" id="_1j-X"
                             maxerror="0"/>
            </TryStep>
            <TryStep id="_1j-Z" name="Close pulldown menus">
              <ComponentWaiter client="$(client)"
                               component="genericSWTMenuBar" id="_1j-a"
                               timeout="0"/>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1j-d"
                                name="Determine if a menu is currently open">
                <code>bar = rc.getComponent("genericSWTMenuBar")
for item in bar.getItems():
    menu = item.getMenu()
    if menu and menu.isVisible():
        print "closing", menu
        rc.overrideElement("genericSWTMenuItem", item)
        break
else:
    raise ReturnException()</code>
              </ClientScriptStep>
              <SelectionEventStep client="$(client)"
                                  component="genericSWTMenuItem"
                                  detail="close" event="SELECTION"
                                  id="_1j-g"/>
              <CatchSequence exception="ComponentNotFoundException" id="_1j-c"
                             maxerror="0"/>
            </TryStep>
          </Procedure>
          <Procedure id="_3E0" name="implicitExceptionHandler">
            <variable name="maxDialogs">5</variable>
            <comment>This procedure encompasses the usage of other cleanup procedures in this package and is the recommended operation to perform after an exception occurs and is implicitly caught.

Calling this procedure should be the first step in the cleanup
sequence of any Test node with the "Implicitly catch exceptions" attribute set.

@param	client	The name of the SUT client.
@param	maxDialogs	Maximum number of modal dialogs that are tried to be closed. (Optional, default 5)

@author	QFS,mm
@since	2.1.0</comment>
            <ProcedureCall id="_3E1"
                           procedure="qfs.swt.cleanup.closeAllMenus"/>
            <ProcedureCall id="_3E2"
                           procedure="qfs.swt.cleanup.closeAllDialogsAndModalShells">
              <variable name="maxDialogs">$(maxDialogs)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_2Fk" name="checkbox">
          <comment>Procedures to set the state of checkboxes.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Button&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_2Fq" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.


@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_3DQ" procedure="qfs.swing.checkbox.deselect">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9c" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9r"
                           procedure="qfs.swing.checkbox.deselectWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1l9E" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1l9F">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1l9G"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1l9H" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1l9I"
                             maxerror="0">
                <ReturnStep id="_1l9J" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2Fl" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_3DP" procedure="qfs.swing.checkbox.select">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9h" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9s"
                           procedure="qfs.swing.checkbox.selectWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_2Fv" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_3DR" procedure="qfs.swing.checkbox.set">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9m" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9t"
                           procedure="qfs.swing.checkbox.setWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_4nf" name="ctabfolder">
          <comment>Procedures for SWT CTabFolder widgets.
(SWT component &lt;code&gt;org.eclipse.swt.custom.CTabFolder&lt;/code&gt;)

@author	QFS,mm
@since	2.0.3</comment>
          <Procedure id="_1kKA" name="checkTabIsDirty">
            <variable name="tabname"/>
            <variable name="separator">@</variable>
            <variable name="expectedDirty">true</variable>
            <variable name="throwExc">false</variable>
            <variable name="reportName"/>
            <comment>This procedure raises an error, if a given tab is not dirty.
This procedure checks for the standard dirty marker, i.e. a * at the beginning of the tab name.

@param	client	The name of the SUT client.
@param	tabname	The name of the tab to select.
@param	separator	@ for addressing the tab name by text,
		% for addressing the tab by regular expression.
		Note: &amp; is not supported by this procedure.
@param	expectedDirty  True, if marker is expected. False if marker is not expected.
@param 	throwExc	Whether the check should throw an exception on failure.
@param 	reportName	The Name for the check in the report.

@author	QFS,mm
@since	3.4.2</comment>
            <BasicSequence id="_1kKB"
                           name="Check whether given tab name contains a dirty marker, in this case a * at the beginning">
              <variable name="tabname">$(tabname)</variable>
              <SetGlobalStep id="_1lSF" local="true" varname="tabRegex">
                <default>true</default>
              </SetGlobalStep>
              <IfSequence id="_1kKD"
                          test="&#34;$(separator)&#34; == &#34;@&#34;">
                <SetGlobalStep id="_1lSJ" local="true" varname="dirtytabname">
                  <default>*$(tabname)</default>
                </SetGlobalStep>
                <ServerScriptStep id="_1lS6">
                  <code>import re
rc.setLocal("tabname", "\\*?" + re.escape(rc.lookup("tabname")))</code>
                </ServerScriptStep>
                <ElseSequence id="_1lSG">
                  <SetGlobalStep id="_1lSI" local="true"
                                 varname="dirtytabname">
                    <default>\*$(tabname)</default>
                  </SetGlobalStep>
                  <SetGlobalStep id="_1lSH" local="true" varname="tabname">
                    <default>\*?$(tabname)</default>
                  </SetGlobalStep>
                </ElseSequence>
              </IfSequence>
              <TryStep id="_1lRm" name="Old-style CTabFolder">
                <ComponentWaiter client="$(client)"
                                 component="genericShell.genericCTabFolder%$(tabname)"
                                 id="_1lRn" timeout="0">
                  <comment>Prevent default timeout</comment>
                </ComponentWaiter>
                <CheckBooleanStep checktype="visible" client="$(client)"
                                  component="genericShell.genericCTabFolder$(separator)$(dirtytabname)"
                                  id="_1kKC" name="$(reportName)"
                                  raise="$(throwExc)" state="$(expectedDirty)"
                                  timeout="0"/>
                <CatchSequence exception="TestException" id="_1lRp"
                               maxerror="0" name="New-style e4 CTabFolder">
                  <ComponentWaiter client="$(client)"
                                   component="genericShell.genericE4CTabFolder%$(tabname)"
                                   id="_1lRq" timeout="0">
                    <comment>Prevent default timeout</comment>
                  </ComponentWaiter>
                  <CheckBooleanStep checktype="visible" client="$(client)"
                                    component="genericShell.genericE4CTabFolder$(separator)$(dirtytabname)"
                                    id="_1lRs" name="$(reportName)"
                                    raise="$(throwExc)"
                                    state="$(expectedDirty)" timeout="0"/>
                </CatchSequence>
              </TryStep>
            </BasicSequence>
          </Procedure>
          <Procedure id="_4ng" name="closeTab">
            <variable name="tabname"/>
            <variable name="separator">@</variable>
            <comment>Close a tab in a generic CTabFolder that is identified only by the fact that it contains the desired tab. Even the target window is arbitrary.

@param	client	The name of the SUT client.
@param	tabname	The name of the tab to close.
@param	separator	@ for addressing the tab name by text,
		% for addressing the tab by regular expression.
		Note: &amp; is not supported by this procedure.

@author	QFS,mm
@since	2.0.3</comment>
            <IfSequence id="_1kJq"
                        test="&#34;$(separator)&#34; == &#34;%&#34;">
              <SetGlobalStep id="_1kJr" local="true" varname="tabRegex">
                <default>true</default>
              </SetGlobalStep>
              <ElseSequence id="_1kJs">
                <SetGlobalStep id="_1kJt" local="true" varname="tabRegex">
                  <default>false</default>
                </SetGlobalStep>
              </ElseSequence>
            </IfSequence>
            <TryStep id="_1lRe" name="Old-style CTabFolder">
              <ComponentWaiter client="$(client)"
                               component="genericShell.genericCTabFolder$(separator)$(tabname)"
                               id="_1lRf" timeout="0">
                <comment>Prevent default timeout</comment>
              </ComponentWaiter>
              <SelectionEventStep client="$(client)"
                                  component="genericShell.genericCTabFolder$(separator)$(tabname)"
                                  detail="close" event="SELECTION"
                                  id="_1lRk"/>
              <CatchSequence exception="TestException" id="_1lRh" maxerror="0"
                             name="New-style e4 CTabFolder">
                <ComponentWaiter client="$(client)"
                                 component="genericShell.genericE4CTabFolder$(separator)$(tabname)"
                                 id="_1lRi" timeout="0">
                  <comment>Prevent default timeout</comment>
                </ComponentWaiter>
                <SelectionEventStep client="$(client)"
                                    component="genericShell.genericE4CTabFolder$(separator)$(tabname)"
                                    detail="close" event="SELECTION"
                                    id="_1lRl"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lRz" name="openViewMenu">
            <variable name="tabname"/>
            <variable name="separator">@</variable>
            <comment>Open the View Menu for a generic CTabFolder that is identified only by the fact that it contains the desired tab. Even the target window is arbitrary.

@param	client	The name of the SUT client.
@param	tabname	The name of the tab to which the View Menu belongs.
@param	separator	@ for addressing the tab name by text,
		% for addressing the tab by regular expression.
		Note: &amp; is not supported by this procedure.


@author	QFS,gs
@since	3.4.7</comment>
            <IfSequence id="_1lS7"
                        test="&#34;$(separator)&#34; == &#34;%&#34;">
              <SetGlobalStep id="_1lS8" local="true" varname="tabRegex">
                <default>true</default>
              </SetGlobalStep>
              <ElseSequence id="_1lS9">
                <SetGlobalStep id="_1lSA" local="true" varname="tabRegex">
                  <default>false</default>
                </SetGlobalStep>
              </ElseSequence>
            </IfSequence>
            <TryStep id="_1lR+" name="Old-style CTabFolder">
              <ComponentWaiter client="$(client)"
                               component="genericShell.genericViewMenu"
                               id="_1lR-" timeout="0">
                <comment>Prevent default timeout</comment>
              </ComponentWaiter>
              <MouseEventStep clicks="1" client="$(client)"
                              component="genericShell.genericViewMenu"
                              event="MOUSE_MPRC" id="_J" modifiers="16"/>
              <CatchSequence exception="TestException" id="_1lS1" maxerror="0"
                             name="New-style e4 CTabFolder">
                <ComponentWaiter client="$(client)"
                                 component="genericShell.genericE4ViewMenu"
                                 id="_1lS4" timeout="0">
                  <comment>Prevent default timeout</comment>
                </ComponentWaiter>
                <MouseEventStep clicks="1" client="$(client)"
                                component="genericShell.genericE4ViewMenu"
                                event="MOUSE_MPRC" id="_1lS5" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_4nj" name="selectTab">
            <variable name="tabname"/>
            <variable name="separator">@</variable>
            <comment>Select a tab in a generic CTabFolder that is identified only by the fact that it contains the desired tab. Even the target window is arbitrary.

@param	client	The name of the SUT client.
@param	tabname	The name of the tab to select.
@param	separator	@ for addressing the tab name by text,
		% for addressing the tab by regular expression.
		Note: &amp; is not supported by this procedure.

@author	QFS,mm
@since	2.0.3</comment>
            <IfSequence id="_1lSB"
                        test="&#34;$(separator)&#34; == &#34;%&#34;">
              <SetGlobalStep id="_1lSC" local="true" varname="tabRegex">
                <default>true</default>
              </SetGlobalStep>
              <ElseSequence id="_1lSD">
                <SetGlobalStep id="_1lSE" local="true" varname="tabRegex">
                  <default>false</default>
                </SetGlobalStep>
              </ElseSequence>
            </IfSequence>
            <TryStep id="_1lRN" name="Old-style CTabFolder">
              <ComponentWaiter client="$(client)"
                               component="genericShell.genericCTabFolder$(separator)$(tabname)"
                               id="_1lRQ" timeout="0">
                <comment>Prevent default timeout</comment>
              </ComponentWaiter>
              <SelectionEventStep client="$(client)"
                                  component="genericShell.genericCTabFolder$(separator)$(tabname)"
                                  event="SELECTION" id="_4nk"/>
              <CatchSequence exception="TestException" id="_1lRO" maxerror="0"
                             name="New-style e4 CTabFolder">
                <ComponentWaiter client="$(client)"
                                 component="genericShell.genericE4CTabFolder$(separator)$(tabname)"
                                 id="_1lRR" timeout="0">
                  <comment>Prevent default timeout</comment>
                </ComponentWaiter>
                <SelectionEventStep client="$(client)"
                                    component="genericShell.genericE4CTabFolder$(separator)$(tabname)"
                                    event="SELECTION" id="_1lRP"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_4nz" name="colordialog">
          <comment>Procedures to handle Colordialogs.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.ColorDialog&lt;/code&gt;)

@author	QFS,mm
@since	3.0</comment>
          <Procedure id="_4n+" name="selectColor">
            <variable name="id">${id:aColorDialog}</variable>
            <variable name="color"/>
            <comment>Select a specified color of a ColorDialog.

The color should be in RGB values, e.g. #FF0000 for red.
If no color is specified, it will close the dialog without selection.

@param	client	The name of the SUT client.
@param 	id	ID of the ColorDialog.
@param	color	Color to be selected.

@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_4ob" test="rc.lookup(&#34;color&#34;)">
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="$(color)" event="SELECTION"
                                  id="_3AJ"/>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_6VU" name="combo">
          <comment>Procedures to handle comboboxes.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Combo&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_6YS" name="getItemCount">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the number of items of a given combobox.
It uses the method getItemCount() to get the number.

@param id 		The component-ID of the combobox.
@return itemCount

@author QFS,mm
@since 3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGb"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6YT">
              <code>cb = rc.getComponent(rc.lookup("id"))

itemCount = cb.getItemCount()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_6YU" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1lA3" name="getIndexOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the combo.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1lA4" local="true" varname="index"/>
            <ReturnStep id="_1lA5" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1l91" name="getValue">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the text of a given combo.

@param	id	ID of the combo.

@return  The text of the combo.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l92"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l93" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1lA6" name="getValueOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the combo.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1lA7"
                           local="true" varname="value"/>
            <ReturnStep id="_1lA8" retval="$(value)"/>
          </Procedure>
          <Procedure id="_6VV" name="setValue">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Select specified value of a given combobox using a selection event.

If the given value is empty, no action will take place.

You should use this procedure for any standard selections.

@param	client	The name of the SUT client.
@param 	id	ID of the Combo.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_6VW" test="rc.lookup(&#34;value&#34;)">
              <SelectionEventStep client="$(client)"
                                  component="$(id)$(separator)$(value)"
                                  event="SELECTION" id="_6VX"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_6VY" name="setValueViaSUTScript">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="value"/>
            <comment>Select specified value of a given combobox using a SUT script.
It used the API-method &lt;code&gt;select()&lt;/code&gt;.

If the given value is empty, no action will take place.

You should use this procedure only if setValue doesn't work for your use-case.


@param	client	The name of the SUT client.
@param 	id	ID of the Combo.
@param	value	Value, which should be selected.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_6VZ" test="rc.lookup(&#34;value&#34;)">
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGc"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6Va">
                <code>comboBox = rc.getComponent(rc.lookup("id"))
itemCount = comboBox.getItemCount()
for i in range (itemCount):
	oneItem = comboBox.getItem(i)
	if oneItem == rc.lookup("value"):
		comboBox.select(i)
		break

</code>
              </ClientScriptStep>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_4np" name="directorydialog">
          <comment>Procedures for accessing directory dialogs.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.DirectoryDialog&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_4nq" name="selectDirectory">
            <variable name="directory">aDirectory</variable>
            <comment>Select a directory in a &lt;code&gt;DirectoryDialog&lt;/code&gt; dialog.

The Directorydialog &lt;strong&gt;must&lt;/strong&gt; already be open (or at least be triggered to open).

@param	client	The name of the SUT client.
@param	directory	The directory to select (relative or absolute to the directorydialog's current directory).

@author	QFS,mm
@since	2.1.0</comment>
            <ServerScriptStep id="_4nr">
              <code>base = "."
try:
	base = rc.lookup("directory")[0:rc.lookup("directory").rindex(rc.lookup("system", "file.separator"))]
except:
	None

selected = rc.lookup("directory") # default value, unless the full path was specified
try:
	selected =  rc.lookup("directory")[rc.lookup("directory").rindex(rc.lookup("system", "file.separator")) +1 :]
except:
	None

rc.setLocal("base", base)
rc.setLocal("selected", selected)

</code>
            </ServerScriptStep>
            <FileSelection client="$(client)" directory="$(base)"
                           file="$(selected)" id="_4ns"/>
          </Procedure>
        </Package>
        <Package id="_4nl" name="filedialog">
          <comment>Procedures for accessing file dialogs.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.FileDialog&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_4nm" name="selectFile">
            <variable name="file">aFile</variable>
            <comment>Select a file in a &lt;code&gt;FileDialog&lt;/code&gt; dialog.

The filechooser dialog &lt;strong&gt;must&lt;/strong&gt; already be open (or at least be triggered to open).

@param	client	The name of the SUT client.
@param	file	The file to select (relative or absolute to the filechooser's current directory).

@author	QFS,mm
@since	2.1.0</comment>
            <ServerScriptStep id="_4nn">
              <code>dir = "."
try:
	dir = rc.lookup("file")[0:rc.lookup("file").rindex(rc.lookup("system", "file.separator"))]
except:
	None


file = rc.lookup("file") # default value, unless the full path was specified
try:
	file =  rc.lookup("file")[rc.lookup("file").rindex(rc.lookup("system", "file.separator")) +1 :]
except:
	None

rc.setLocal("directory", dir)
rc.setLocal("file", file)

</code>
            </ServerScriptStep>
            <FileSelection client="$(client)" directory="$(directory)"
                           file="$(file)" id="_4no"/>
          </Procedure>
        </Package>
        <Package id="_6Vc" name="general">
          <comment>Procedures which work for any SWT component.

@author	QFS,mm
@since 2.1.0
</comment>
          <Procedure id="_1mIb" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1mIc" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_1n8O" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1n8K" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1n8L" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_1n8M"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1j-y" name="deleteOverrideComponent">
            <comment>Delete the current association of PrioritySwtComponent.

@param	client		The name of the SUT client.

@author	QFS,mm
@since	3.3.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1j-z">
              <code>rc.overrideElement("PrioritySwtWidget", None)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n8P" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1n8Q" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n8R" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1n8S"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1lTD" name="doSelect">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="detail"/>
            <comment>Send a selection event to a given component. That's not a mouse-click.
Selection events are special events for menus or list selection.

@param	client	The name of the SUT client.
@param	id	The Id of the target-component.
@param	detail	The detail of the selection. Important for closing dialogs etc. For menu items leave it blank.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(id)"
                                detail="$(detail)" event="SELECTION"
                                id="_1lTE"/>
          </Procedure>
          <Procedure id="_6Vi" name="setLocation">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set the location of a given component.

It uses setLocation(x,y) to set the location.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x		The new x-coordinate of the location.
@param	y		The new y-coordinate of the location.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGd"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6Vj">
              <code>comp = rc.getComponent(rc.lookup("id"))

comp.setLocation($(x), $(y))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1j-s" name="setOverrideComponent">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Set a given component to the PrioritySwtWidget.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	3.3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGe"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1j-t">
              <code>comp = rc.getComponent(rc.lookup("id"))

rc.overrideElement("PrioritySwtWidget", comp)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6Vk" name="setSize">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="width"/>
            <variable name="height"/>
            <comment>Set the width and the height of a given component.

It uses setSize(width, height) to set the size.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	width		The new width of the component.
@param	height		The new height of the component.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGf"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6Vl">
              <code>comp = rc.getComponent(rc.lookup("id"))

comp.setSize($(width), $(height))</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n5r" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1n5s"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_1n5t" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_1n5u" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_4nd" name="instrument">
          <comment>Procedures for SWT instrumentation.

@author	QFS
@since	2.0.3</comment>
          <Procedure id="qfs.swt.instrument.setup" name="setup" uid="_1j+l">
            <variable name="sutdir"/>
            <variable name="plugin"/>
            <variable name="forceInstrumentation">false</variable>
            <comment>If necessary, instrument an Eclipse/RCP based or standalone SWT application for use with QF-Test. If the option Replay-&gt;Clients-&gt;Connect without SWT instrumentation is active and the SWT version is new enough, instumentation is not performed unless the parameter forceInstrumentation is set to true. Manual chapter 4 describes the effects of SWT instrumentation in detail.

@param	sutdir	The installation directory of the SUT.
@param	plugin	Optional: The specific plugin (the jar file, not the plugin folder) to instrument. Useful in case the directories are not layed out as expected.
@param	forceInstrumentation Whether to force instrumentation even if not required.

@author	QFS,kk,gs</comment>
            <ServerScriptStep id="_4Qs">
              <code>import instrumentswt

# The application directory as input
sutDir = rc.lookup("sutdir")
plugin = rc.lookup("plugin")
force = rc.getBool("forceInstrumentation")

instrumentswt.instrument(rc, sutDir, plugin, force=force)
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_4pk" name="list">
          <comment>Procedures for accessing lists.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.List&lt;/code&gt;)

@author	QFS,mm
@since 3.0</comment>
          <Package id="_1jvW" name="checks">
            <comment>Procedures for checking a list.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_1jvX" name="checkNumberOfItems">
              <variable name="id">${id:listid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of items of a given list according to a specified comparison mode.

It uses the method list.getItemCount() to get the number.

Sample usage:
You can check, that a list has exactly 6 items or that the table has less then 10 items.

@param	id 		The id of the list.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of items.
			&lt;, if the compareValue should be greater than the actual amount of items.
			&gt;, if the compareValue should be less than the actual amount of items.
			&lt;=, if the compareValue should be greater or equal than the actual amount of items.
			&gt;=, if the compareValue should be less or equal the actual amount of items.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1jvY" local="true"
                             procedure="qfs.swt.list.getItemCount"
                             retvarname="itemCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1jwL"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of items of list '$(id)'</variable>
                <variable name="got">$(itemCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1jwa" name="selection">
            <comment>Procedures to (de-)select certain items of a list.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_1jwb" name="deselectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Deselect all items. It uses &lt;code&gt;deselectAll&lt;/code&gt;.

@param 	id	ID of the list.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGg"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwc">
                <code>mylist = rc.getComponent(rc.lookup("id"))

mylist.deselectAll()


</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1jwd" name="deselectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Deselect a given item, specified by its index. It uses &lt;code&gt;deselect&lt;/code&gt;.

@param 	id	ID of the list.
@param 	item	The index of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGh"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwe">
                <code>mylist = rc.getComponent(rc.lookup("id"))

selItem = rc.lookup("item")
if selItem != None:
    mylist.deselect(int(selItem))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1jwf" name="deselectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Deselect a range of items, specified by their index. It uses &lt;code&gt;deselect&lt;/code&gt;.

@param 	id	ID of the list.
@param	startItem	The index of first item to be selected.
@param	endItem	The index of last item to be selected.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGi"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwg">
                <code>mylist = rc.getComponent(rc.lookup("id"))

startItem = rc.lookup("startItem")
endItem = rc.lookup("endItem")

items = mylist.getItemCount()

if endItem == None or endItem == '':
	endItem = items -1
else:
	endItem = int(endItem)

mylist.deselect(int(startItem), endItem)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1jwh" name="selectAllItems">
              <variable name="id">${id:listid}</variable>
              <comment>Select all items. It uses &lt;code&gt;selectAll&lt;/code&gt;.

@param 	id	ID of the list.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGj"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwi">
                <code>mylist = rc.getComponent(rc.lookup("id"))

items = mylist.selectAll()
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1jwj" name="selectItemRange">
              <variable name="id">${id:listid}</variable>
              <variable name="startItem">0</variable>
              <variable name="endItem"/>
              <comment>Select a range of items, specified by their index. It uses &lt;code&gt;select&lt;/code&gt;.

@param 	id	ID of the list.
@param	startItem	The index of first item to be selected.
@param	endItem	The index of last item to be selected.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGk"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwk">
                <code>mylist = rc.getComponent(rc.lookup("id"))

startItem = rc.lookup("startItem")
endItem = rc.lookup("endItem")

items = mylist.getItemCount()

if endItem == None or endItem == '':
	endItem = items -1
else:
	endItem = int(endItem)

mylist.select(int(startItem), endItem)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1jwp" name="selectItem">
              <variable name="id">${id:listid}</variable>
              <variable name="item"/>
              <comment>Select a given item, specified by its index. It uses &lt;code&gt;select&lt;/code&gt;.

@param 	id	ID of the list.
@param 	row	The index of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGl"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_1jwq">
                <code>mylist = rc.getComponent(rc.lookup("id"))

selItem = rc.lookup("item")
if selItem != None:
    mylist.select(int(selItem))</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1n8T" name="clickItemWithDetails">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given item by a mouse-click on it.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n8U"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1jva" name="getIndexOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1jvb" local="true" varname="index"/>
            <ReturnStep id="_1jvc" retval="$(index)"/>
          </Procedure>
          <Procedure id="_6Vm" name="getItemCount">
            <variable name="id">${id:listid}</variable>
            <comment>Return the number of items of a given list.
It uses the method list.getItemCount() to get the number.

@param id 		The component-ID of the list.
@return itemCount

@author QFS,mm
@since 3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGm"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6Vn">
              <code>list = rc.getComponent(rc.lookup("id"))

itemCount = list.getItemCount()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_6Vo" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1jvd" name="getValueOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1jve"
                           local="true" varname="value"/>
            <ReturnStep id="_1jvf" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1mIg" name="selectItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Select a given item by a mouse-click on it.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" id="_1mIh" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_2GQ" name="menu">
          <comment>Procedures to select menu items and checkbox menu items.
(SWT components &lt;code&gt;org.eclipse.swt.widgets.MenuItem&lt;/code&gt; from &lt;code&gt;org.eclipse.swt.widgets.Menu&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Procedure id="_2GR" name="selectItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item from a menu.

For example: for the File -&gt; Open action, the component ID of  "File" is the menu, and the ID for "Open" is the item.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of menu item.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(menu)"
                                event="SELECTION" id="_3B5"/>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3B8"/>
          </Procedure>
          <Procedure id="_2GV" name="selectSubItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu.

For example: for the View -&gt; Terminal -&gt; Show action, the component ID of "View" is the menu, the ID for "Terminal" is the item, and the ID for "Show" is the sub-item to select.

@param	client	The name of the SUT client.
@param	menu	The id of the menu.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(menu)"
                                event="SELECTION" id="_3B9"/>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3BA"/>
            <SelectionEventStep client="$(client)" component="$(subItem)"
                                event="SELECTION" id="_3BB"/>
          </Procedure>
          <Procedure id="_2Ga" name="setCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item.

For example: for the View -&gt; Show Details action, the component ID of "View" is the menu, and the ID for "Show Details" is the checkbox item to set (to true or false).

@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(menu)"
                                event="SELECTION" id="_3BC"/>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_2Gd" timeout="3000"/>
            <TryStep id="_2Ge" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_2Gf"
                                raise="true" timeout="0"/>
              <IfSequence id="_2Gg" test="$(checkItemValue)">
                <ProcedureCall id="_4oG"
                               procedure="qfs.swt.cleanup.closeAllMenus"/>
                <ElseSequence id="_2Gi">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_3BD"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_2Gk"
                             maxerror="0">
                <IfSequence id="_2Gl" test="$(checkItemValue)">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_3BE"/>
                  <ElseSequence id="_2Gn">
                    <ProcedureCall id="_1mIi"
                                   procedure="qfs.swt.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2Gp" name="setSubCheckItem">
            <variable name="menu">${id:aMenu}</variable>
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within within a submenu.

For example: for the View -&gt; Terminal -&gt; Wrap Lines action, the component ID of "View" is the menu,  the ID for "Terminal" is the item and the ID for "Wrap Lines" is the checkbox menu item to set (to true or false).


@param	client		The name of the SUT client.
@param	menu		The id of the menu.
@param	item		The id of the item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(menu)"
                                event="SELECTION" id="_3BF"/>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3BG"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_2Gt" timeout="3000"/>
            <TryStep id="_2Gu" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_2Gv"
                                raise="true" timeout="0"/>
              <IfSequence id="_2Gw" test="$(checkItemValue)">
                <ProcedureCall id="_4oH"
                               procedure="qfs.swt.cleanup.closeAllMenus"/>
                <ElseSequence id="_2Gy">
                  <SelectionEventStep client="$(client)"
                                      component="$(subCheckItem)"
                                      event="SELECTION" id="_3BL"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_2G+"
                             maxerror="0">
                <IfSequence id="_2G-" test="$(checkItemValue)">
                  <SelectionEventStep client="$(client)"
                                      component="$(subCheckItem)"
                                      event="SELECTION" id="_3BK"/>
                  <ElseSequence id="_2H1">
                    <ProcedureCall id="_1mIj"
                                   procedure="qfs.swt.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lSl" name="selectMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="item">${id:aMenuItem}</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select an item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "File" -&gt; "Close" you set menu to the component id "mFile" and item to "mClose" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Search text" you set menu to the component id "mFile.mSearch" and item to "mSearchText" (Of course you need to set your component id's).

@param	client	The name of the SUT client.
@param	menu	The path of the parent menus. The path is specified as list of component-ids.
@param	item	The id of menu item.
@param	menustringSeparator	The value, which separates the path of the parent menu.

@author	QFS,mm
@since	3.5

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1lSm" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.swt.general.doSelect", {"id" : m})</code>
            </ServerScriptStep>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_1lT0"/>
          </Procedure>
          <Procedure id="_1lSo" name="selectCheckMenuItemInHierarchy">
            <variable name="menu">aMenuHierarchy</variable>
            <variable name="checkItem">${id:aMenuItem}</variable>
            <variable name="checkItemValue">true</variable>
            <variable name="menustringSeparator">.</variable>
            <comment>Select a checkbox menu item from a menu.
This procedure is designed to work with any menu item. You can define the entire menu path in the parameter menu.
Samples:
If you want to select at "View" -&gt; "Show terminal" you set menu to the component id "mView" and item to "mShowTerminal" (Of course you need to set your component id's).
If you want to select at "Options" -&gt; "Search" -&gt; "Exclude digits" you set menu to the component id "mFile.mSearch" and item to "mExcludeDigits" (Of course you need to set your component id's).

@param	client		The name of the SUT client.
@param	menu		The path of the parent menus. The path is specified as list of component-ids.
@param	menustringSeparator	The value, which separates the path of the parent menu.
@param	checkItem		The id of the checkbox item.
@param	checkItemValue	The check item value to be set - 'true' to select the checkbox item (default), 'false' to deselect.

@author	QFS,mm
@since	3.5

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1lSp" name="Open the menu hierarchy">
              <code>menu = rc.lookup("menu")
mSep = rc.lookup("menustringSeparator")
if not mSep:
    mSep = "."

menus = menu.split(mSep)


for m in menus:
    if m:
        rc.callProcedure("qfs.swt.general.doSelect", {"id" : m})</code>
            </ServerScriptStep>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_1lT1" timeout="3000"/>
            <TryStep id="_1lT2" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_1lT3"
                                raise="true" timeout="0"/>
              <IfSequence id="_1lT4" test="$(checkItemValue)">
                <ProcedureCall id="_1lT5"
                               procedure="qfs.swt.cleanup.closeAllMenus"/>
                <ElseSequence id="_1lT6">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_1lT7"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_1lT8"
                             maxerror="0">
                <IfSequence id="_1lT9" test="$(checkItemValue)">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_1lTA"/>
                  <ElseSequence id="_1lTB">
                    <ProcedureCall id="_1mIk"
                                   procedure="qfs.swt.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_2H3" name="popupmenu">
          <comment>Procedures to select items and checkbox menu items from popup menus.

Note that for all procedures, the popup menu &lt;strong&gt;must&lt;/strong&gt; first be opened by the calling test-suite, as the popup menu is component-dependent.

See package "menu" for more details about menus and sub-menus.
(SWT components &lt;code&gt;org.eclipse.swt.widgets.MenuItem&lt;/code&gt;  from &lt;code&gt;org.eclipse.swt.widgets.Menu&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0
</comment>
          <Procedure id="_2H4" name="selectItem">
            <variable name="item">${id:anItem}</variable>
            <comment>Select an item in a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of menu item.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3BW"/>
          </Procedure>
          <Procedure id="_2H6" name="selectSubItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subItem">${id:aSubItem}</variable>
            <comment>Select an item within a submenu of a popup menu.

@param	client	The name of the SUT client.
@param	item	The id of the item to open the submenu.
@param	subItem	The id of item in submenu.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3BU"/>
            <SelectionEventStep client="$(client)" component="$(subItem)"
                                event="SELECTION" id="_3BV"/>
          </Procedure>
          <Procedure id="_2H9" name="setCheckItem">
            <variable name="checkItem">${id:aCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item in a popup menu.

@param	client		The name of the SUT client.
@param	checkItem		The id of the menu checkbox item.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(checkItem)"
                             id="_2HA" timeout="3000"/>
            <TryStep id="_2HB" name="Is CheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(checkItem)" id="_2HC"
                                raise="true" timeout="0"/>
              <IfSequence id="_2HD" test="$(checkItemValue)">
                <ProcedureCall id="_2HE"
                               procedure="qfs.swt.cleanup.closeAllMenus"/>
                <ElseSequence id="_2HF">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_3BY"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_2HH"
                             maxerror="0">
                <IfSequence id="_2HI" test="$(checkItemValue)">
                  <SelectionEventStep client="$(client)"
                                      component="$(checkItem)"
                                      event="SELECTION" id="_3BX"/>
                  <ElseSequence id="_2HK">
                    <ProcedureCall id="_4oF"
                                   procedure="qfs.swt.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2HM" name="setSubCheckItem">
            <variable name="item">${id:anItem}</variable>
            <variable name="subCheckItem">${id:aSubCheckItem}</variable>
            <variable name="checkItemValue">true</variable>
            <comment>Select a checkbox menu item within a submenu of a popup menu.

@param	client		The name of the SUT client.
@param	item		The id of item to open the submenu.
@param	subCheckItem		The id of the checkbox item in the submenu.
@param	checkItemValue	The checkbox item value to be set - "true" to select the checkbox item (default), "false" to deselect.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(item)" id="_2HN"
                             timeout="3000"/>
            <SelectionEventStep client="$(client)" component="$(item)"
                                event="SELECTION" id="_3Bb"/>
            <ComponentWaiter client="$(client)" component="$(subCheckItem)"
                             id="_2HP" timeout="3000"/>
            <TryStep id="_2HS" name="Is subCheckItem already selected">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(subCheckItem)" id="_2HT"
                                raise="true" timeout="0"/>
              <IfSequence id="_2HU" test="$(checkItemValue)">
                <ProcedureCall id="_2HV"
                               procedure="qfs.swt.cleanup.closeAllMenus"/>
                <ElseSequence id="_2HW">
                  <SelectionEventStep client="$(client)"
                                      component="$(subCheckItem)"
                                      event="SELECTION" id="_3Ba"/>
                </ElseSequence>
              </IfSequence>
              <CatchSequence exception="CheckFailedException" id="_2HY"
                             maxerror="0">
                <IfSequence id="_2HZ" test="$(checkItemValue)">
                  <SelectionEventStep client="$(client)"
                                      component="$(subCheckItem)"
                                      event="SELECTION" id="_3BZ"/>
                  <ElseSequence id="_2Hb">
                    <ProcedureCall id="_4oE"
                                   procedure="qfs.swt.cleanup.closeAllMenus"/>
                  </ElseSequence>
                </IfSequence>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1lAa" name="radiobutton">
          <comment>Procedures to set the state of buttons with the style SWT.RADIO.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Button&lt;/code&gt;)

@author	QFS,mm
@since	3.5.0</comment>
          <Procedure id="_1lAb" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1lAc">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1lAd"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1lAe" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1lAf"
                             maxerror="0">
                <ReturnStep id="_1lAg" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1mIl" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.

@param	id	The id of the radio button.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1mIm">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1mIn"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1mIo"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1mIp" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n8V" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n8W">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1n8X"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1n8Y"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1n8Z" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_6Q-" name="sash">
          <comment>Procedures to work with sash components.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Sash&lt;/code&gt;)

@author	QFS,mm
@since	2.1.1</comment>
          <Procedure id="_6R0" name="moveSash">
            <variable name="id">${id:sashId}</variable>
            <variable name="distance">aDistance</variable>
            <comment>Move a sash by a given distance.

@param id 		The component-ID of the sash.
@param distance	The number of pixels to move the sash.

@author	QFS,mm
@since	2.1.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGn"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6R1">
              <code>sash = rc.getComponent(rc.lookup("id"))
from org.eclipse.swt import SWT
rc.setLocal("horiz", (sash.getStyle() &amp; SWT.HORIZONTAL) != 0)
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MOVED" id="_6R2" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_PRESSED" id="_6R3" modifiers="16"/>
            <IfSequence id="_6R4" test="$(horiz)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_DRAGGED" id="_6R5" modifiers="16"
                              y="$[1+$(distance)]"/>
              <ElseSequence id="_6R6">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_DRAGGED"
                                id="_6R7" modifiers="16"
                                x="$[1+$(distance)]"/>
              </ElseSequence>
            </IfSequence>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_RELEASED" id="_6R8" modifiers="16"/>
          </Procedure>
          <Procedure id="_6R9" name="moveSashTo">
            <variable name="id">${id:sashId}</variable>
            <variable name="target">aTarget</variable>
            <comment>Move a sash to a given position.

@param id 		The component-ID of the sash.
@param target		The target position for the sash.

@author	QFS,mm
@since	2.1.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGo"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6RA">
              <code>sash = rc.getComponent(rc.lookup("id"))
from org.eclipse.swt import SWT
horiz = (sash.getStyle() &amp; SWT.HORIZONTAL) != 0
rc.setLocal("horiz", horiz)
</code>
            </ClientScriptStep>
            <FetchGeometryStep client="$(client)" component="$(id)" id="_6RI"
                               local="true" windowrelative="false"
                               xvarname="px" yvarname="py"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MOVED" id="_6RB" modifiers="0"/>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_PRESSED" id="_6RC" modifiers="16"/>
            <IfSequence id="_6RD" test="$(horiz)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_DRAGGED" id="_6RE" modifiers="16"
                              y="$[$(target) + 1 - $(py)]"/>
              <ElseSequence id="_6RF">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_DRAGGED"
                                id="_6RG" modifiers="16"
                                x="$[$(target) + 1 - $(px)]"/>
              </ElseSequence>
            </IfSequence>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_RELEASED" id="_6RH" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_1kKO" name="scrollbar">
          <comment>Procedures to work with scrollbar components.

@author	QFS
@since	3.0</comment>
          <Procedure id="_1kKP" name="scrollLeft">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component to the left by simulating a hard mouse click on the left arrow button of its horizontal scrollbar.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l7-" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l80">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getHorizontalBar().isVisible()
    arrowsize = com.getHorizontalBar().getSize().y
    rc.setLocal("arrowSize", arrowsize)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No horizontal scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l81" modifiers="16"
                            x="$[$(x) + $(arrowSize) / 2]"
                            y="$[$(y) + $(h) - $(arrowSize) / 2]"/>
          </Procedure>
          <Procedure id="_1l82" name="scrollRight">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component to the right by simulating a hard mouse click on the right arrow button of its horizontal scrollbar.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l83" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l84">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getHorizontalBar().isVisible()
    arrowsize = com.getHorizontalBar().getSize().y
    rc.setLocal("arrowSize", arrowsize)
    rc.setLocal("arrowOffset", arrowsize + 3)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No horizontal scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l85" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowOffset) - $(arrowSize) / 2]"
                            y="$[$(y) + $(h) - $(arrowSize) / 2]"/>
          </Procedure>
          <Procedure id="_1l86" name="scrollUp">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component upwards by simulating a hard mouse click on the up arrow button of its vertical scrollbar.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l87" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l88">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getVerticalBar().isVisible()
    arrowsize = com.getVerticalBar().getSize().x
    rc.setLocal("arrowSize", arrowsize)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No vertical scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l89" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowSize) / 2]"
                            y="$[$(y) + $(arrowSize) / 2]"/>
          </Procedure>
          <Procedure id="_1l8A" name="scrollDown">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component downwards by simulating a hard mouse click on the down arrow button of its vertical scrollbar.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l8B" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l8C">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getVerticalBar().isVisible()
    arrowsize = com.getVerticalBar().getSize().x
    rc.setLocal("arrowSize", arrowsize)
    rc.setLocal("arrowOffset", arrowsize + 3)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No vertical scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l8D" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowSize) / 2]"
                            y="$[$(y) + $(h) - $(arrowOffset) - $(arrowSize) / 2]"/>
          </Procedure>
          <Procedure id="_1l8E" name="pageLeft">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component one page to the left by simulating a hard mouse click to the left of the scrollbar's thumb.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l7z" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l7+">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getHorizontalBar().isVisible()
    arrowsize = com.getHorizontalBar().getSize().y
    rc.setLocal("arrowSize", arrowsize)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No horizontal scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l8F" modifiers="16"
                            x="$[$(x) + $(arrowSize) + 3]"
                            y="$[$(y) + $(h) - $(arrowSize) / 2]"/>
          </Procedure>
          <Procedure id="_1l7r" name="pageRight">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component one page to the right by simulating a hard mouse click to the right of the scrollbar's thumb.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l7s" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6bv">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getHorizontalBar().isVisible()
    arrowsize = com.getHorizontalBar().getSize().y
    rc.setLocal("arrowSize", arrowsize)
    rc.setLocal("arrowOffset", arrowsize + 3)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No horizontal scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l7t" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowOffset) - $(arrowSize) - 1]"
                            y="$[$(y) + $(h) - $(arrowSize)/2]"/>
          </Procedure>
          <Procedure id="_1l8G" name="pageUp">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component one page upwards by simulating a hard mouse click above the scrollbar's thumb.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l7x" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l7y">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getVerticalBar().isVisible()
    arrowsize = com.getVerticalBar().getSize().x
    rc.setLocal("arrowSize", arrowsize)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No vertical scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l8H" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowSize)/2]"
                            y="$[$(y) + $(arrowSize) + 3]"/>
          </Procedure>
          <Procedure id="_1l8I" name="pageDown">
            <variable name="id">${id:id of scrollable component}</variable>
            <comment>Scroll a component one page downwards by simulating a hard mouse click below the scrollbar's thumb.

@param	id	The id of the component to scroll.

@throws	UserException	If no horizontal scrollbar is visible.

@author 	QFS,kk
@since	3.0

@ignoreanalyzerefcid</comment>
            <FetchGeometryStep client="$(client)" component="$(id)"
                               heightvarname="h" id="_1l7v" local="true"
                               widthvarname="w" windowrelative="false"
                               xvarname="x" yvarname="y"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1l7w">
              <code>com = rc.getComponent(rc.lookup("id"))
ok = 0
try:
    ok = com.getVerticalBar().isVisible()
    arrowsize = com.getVerticalBar().getSize().x
    rc.setLocal("arrowSize", arrowsize)
    rc.setLocal("arrowOffset", arrowsize + 3)
    rc.overrideElement("PrioritySwtWidget", com.getParent())
except:
    pass
if not ok:
    raise UserException("No vertical scrollbar available for " + rc.lookup("id"))
</code>
            </ClientScriptStep>
            <MouseEventStep clicks="1" client="$(client)"
                            component="PrioritySwtWidget" event="MOUSE_MPRC"
                            hardevent="true" id="_1l8J" modifiers="16"
                            x="$[$(x) + $(w) - $(arrowSize)/2]"
                            y="$[$(y) + $(h) - $(arrowOffset) - $(arrowSize) - 1]"/>
          </Procedure>
        </Package>
        <Package id="_3EO" name="table">
          <comment>Procedures to access tables.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Table&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Package id="_1nOH" name="checkbox">
            <comment>Procedures to set the checked state of tableitems.
These procedures become necessary, because checkboxes in tables cannot be treated like normal checkboxes.

@author	QFS,fs
@since	3.5</comment>
            <Procedure id="_1nOu" name="set">
              <variable name="check">true</variable>
              <variable name="id">aTableCellId</variable>
              <comment>Set checked state of a tableitem to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the tableitem, including the table-id and the addressing of the cell.
@param	check	The check value to be set (either true or false).

@author	QFS,fs
@since	3.5</comment>
              <IfSequence id="_1nOv" test="$(check)">
                <ProcedureCall id="_1nOz"
                               procedure="qfs.swt.table.checkbox.select">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
                <ElseSequence id="_1nOx">
                  <ProcedureCall id="_1nO+"
                                 procedure="qfs.swt.table.checkbox.deselect">
                    <variable name="id">$(id)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
            </Procedure>
            <Procedure id="_1nOI" name="deselect">
              <variable name="id">aTableCellId</variable>
              <comment>Unset the checked state of a tableitem in a table. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the tableitem, including the table-id and the addressing of the cell.

@author	QFS,fs
@since	3.5</comment>
              <TryStep id="_1nOq">
                <CheckBooleanStep checktype="checked" client="$(client)"
                                  component="$(id)" id="_1nOr" raise="true"
                                  state="false" timeout="0"/>
                <CatchSequence exception="CheckFailedException" id="_1nOs"
                               maxerror="0">
                  <ClientScriptStep client="$(client)"
                                    engine="${default:guiengine:swt}"
                                    id="_1nOt">
                    <code>table, item = rc.getComponent(rc.lookup("id"))
row = item[1]
tableItem = table.getItem(row)
tableItem.setChecked(False)
</code>
                  </ClientScriptStep>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1nOS" name="select">
              <variable name="id">aTableCellId</variable>
              <comment>Set the checked state of a tableitem in a table. If the checkbox is already checked, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the tableitem, including the table-id and the addressing of the cell.


@author	QFS,fs
@since	3.5</comment>
              <TryStep id="_1nOT">
                <CheckBooleanStep checktype="checked" client="$(client)"
                                  component="$(id)" id="_H" raise="true"
                                  timeout="0"/>
                <CatchSequence exception="CheckFailedException" id="_1nOV"
                               maxerror="0">
                  <ClientScriptStep client="$(client)"
                                    engine="${default:guiengine:swt}"
                                    id="_1nOm">
                    <code>table, item = rc.getComponent(rc.lookup("id"))
row = item[1]
tableItem = table.getItem(row)
tableItem.setChecked(True)
</code>
                  </ClientScriptStep>
                </CatchSequence>
              </TryStep>
            </Procedure>
          </Package>
          <Package id="_1jvi" name="checks">
            <comment>Procedures for checking a table.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_1jvj" name="checkNumberOfRows">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of rows of a given table according to a specified comparison mode.
It uses the method Table.getItemCount() to get the number.

Sample usage:
You can check, that a table has exactly 6 rows or that the table has less then 10 rows.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1jvk" local="true"
                             procedure="qfs.swt.table.getRowCount"
                             retvarname="rowCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1jwH"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_6QS" name="selection">
            <comment>Procedures to (de-)select certain rows of a table.

@author QFS,mm
@since 2.1.0</comment>
            <Procedure id="_6QT" name="deselectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Deselect all rows. It uses &lt;code&gt;deselectAll()&lt;/code&gt;.

@param 	id	ID of the table.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGq"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6QU">
                <code>table = rc.getComponent(rc.lookup("id"))

table.deselectAll()

</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QV" name="deselectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Deselect a given row, specified by its index. It uses &lt;code&gt;deselect()&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGr"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6QW">
                <code>table = rc.getComponent(rc.lookup("id"))

selRow = rc.lookup("row")
if selRow != None:
	table.deselect(int(selRow))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QX" name="deselectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Deselect a range of rows, specified by their index. It uses &lt;code&gt;deselect()&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGs"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6QY">
                <code>table = rc.getComponent(rc.lookup("id"))

startRow = rc.lookup("startRow")
endRow = rc.lookup("endRow")

rows = table.getItemCount()

if endRow == None or endRow == '':
	endRow = rows -1
else:
	endRow = int(endRow)

table.deselect(int(startRow), endRow)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6QZ" name="selectAllRows">
              <variable name="id">${id:tableid}</variable>
              <comment>Select all rows. It uses &lt;code&gt;selectAll()&lt;/code&gt;.

@param 	id	ID of the table.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGt"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6Qa">
                <code>table = rc.getComponent(rc.lookup("id"))

table.selectAll()</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6Qb" name="selectRow">
              <variable name="id">${id:tableid}</variable>
              <variable name="row"/>
              <comment>Select a given row, specified by its index. It uses &lt;code&gt;select()&lt;/code&gt;.

@param 	id	ID of the table.
@param 	row	The index of the row.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGu"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6Qc">
                <code>table = rc.getComponent(rc.lookup("id"))

selRow = rc.lookup("row")
if selRow != None:
	table.select(int(selRow))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6Qd" name="selectRowRange">
              <variable name="id">${id:tableid}</variable>
              <variable name="startRow">0</variable>
              <variable name="endRow"/>
              <comment>Select a range of rows, specified by their index. It uses &lt;code&gt;select()&lt;/code&gt;.

@param 	id	ID of the table.
@param	startRow	The index of first row to be selected.
@param	endRow	The index of last row to be selected.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oGv"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:swt}" id="_6Qe">
                <code>table = rc.getComponent(rc.lookup("id"))

startRow = rc.lookup("startRow")
endRow = rc.lookup("endRow")

rows = table.getItemCount()

if endRow == None or endRow == '':
	endRow = rows -1
else:
	endRow = int(endRow)

table.select(int(startRow), endRow)</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1n8a" name="clickCellWithDetails">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given cell.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n8b"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_4oI" name="getColumnCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of columns of a given table.
It uses the method getColumnCount() do get the number.

@param id 		The component-ID of the table.
@return columnCount

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGw"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_4oJ">
              <code>table = rc.getComponent(rc.lookup("id"))

columnCount = table.getColumnCount()

rc.setLocal("columnCount", columnCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_4oK" retval="$(columnCount)"/>
          </Procedure>
          <Procedure id="_1jvm" name="getIndexOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">@</variable>
            <comment>Return the current index of a given column.

Sample usage:
Can be used to determine the numeric index of a column like 'Price'.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the column, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)"
                            id="_1jvn" local="true" varname="index"/>
            <ReturnStep id="_1jvo" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1jvp" name="getNameOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">&amp;</variable>
            <comment>Return the header text of a given column.

Sample usage:
Determine the title of the second column.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   The name of the column.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)"
                           id="_1jvq" local="true" varname="name"/>
            <ReturnStep id="_1jvr" retval="$(name)"/>
          </Procedure>
          <Procedure id="_2Fw" name="getRowCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of rows of a given table.
It uses the method Table.getItemCount() to get the number.

@param id 		The component-ID of the table.
@return rowCount

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oGx"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_2Fx">
              <code>table = rc.getComponent(rc.lookup("id"))

rowCount = table.getItemCount()

rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2Fy" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1jvs" name="getRowIndexOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Return the row number of a given cell.

Sample usage:
Can be used to determine in which row a dedicated cell is located.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the row, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            id="_1jvt" local="true" varname="index"/>
            <ReturnStep id="_1jvu" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1jvv" name="getValueOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">&amp;</variable>
            <comment>Return the text of a given cell.

Sample usage:
Can be used to determine the text of the cell in the first column and first row.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value   The current value of the row, which has been read by the 'Fetch text' node of QF-Test.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                           id="_1jvw" local="true" varname="value"/>
            <ReturnStep id="_1jvx" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1mIq" name="selectCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Select a given cell.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" id="_1mIr" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_6Qo" name="tabfolder">
          <comment>Procedures for SWT TabFolder widgets.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.TabFolder&lt;/code&gt;)

@author	QFS,mm
@since	2.2.0</comment>
          <Procedure id="_6Qt" name="closeTab">
            <variable name="id">${id:aTabfolder}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Close a tab via sending a "close" selection event.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabfolder to select.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to select.

@author	QFS,mm
@since	2.2.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)"
                                component="$(id)$(separator)$(value)"
                                detail="close" event="SELECTION" id="_6Qz"/>
          </Procedure>
          <Procedure id="_1l9Q" name="getIndexOfTab">
            <variable name="id">${id:aTabfolder}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Return the index of a given tab.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabfolder.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to look for.

@return	The index of the tab.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_1l9R"
                            local="true" varname="index"/>
            <ReturnStep id="_1l9S" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2YNI" name="getItemCount">
            <variable name="id">${id:aTabfolder}</variable>
            <comment>Return the number of items of a given tabfolder.


@param id 		The component-ID of the tabfolder.
@return itemCount

@author QFS
@since 5.3.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YNJ"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_2YNK">
              <code>tabfolder = rc.getComponent(rc.lookup("id"))

itemCount = tabfolder.getItemCount()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2YNL" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1l9T" name="getValueOfTab">
            <variable name="id">${id:aTabfolder}</variable>
            <variable name="separator">&amp;</variable>
            <variable name="value"/>
            <comment>Return the text of a given tab.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabfolder.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The index to look for.

@return	The value of the tab.

@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(separator)$(value)" id="_1l9U"
                           local="true" varname="value"/>
            <ReturnStep id="_1l9V" retval="$(value)"/>
          </Procedure>
          <Procedure id="_6Qw" name="selectTab">
            <variable name="id">${id:aTabfolder}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Select a tab in a given Tabfolder.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabfolder to select.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to select.

@author	QFS,mm
@since	2.2.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)"
                                component="$(id)$(separator)$(value)"
                                event="SELECTION" id="_6Qy"/>
          </Procedure>
        </Package>
        <Package id="_2Ho" name="text">
          <comment>Procedures to access text fields and text areas. It should work with any SWT components representing textfields or textareas, e.g. &lt;code&gt;org.eclipse.swt.custom.StyledText&lt;/code&gt; or &lt;code&gt;org.eclipse.swt.widgets.Text&lt;/code&gt;.

@author QFS,mm
@since 2.1.0</comment>
          <Procedure id="_2Hw" name="clearArea">
            <variable name="id">${id:aTextArea}</variable>
            <comment>Clear a multi-line text area.

@param	client	The name of the SUT client.
@param	id	The id of the text area.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_3DT" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2Hp" name="clearField">
            <variable name="id">${id:aTextfield}</variable>
            <comment>Clear a simple text field.

@param	client	The name of the SUT client.
@param	id	The id of the text field.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_3DS" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_1l8x" name="getText">
            <variable name="id">${id:aTextfield}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  The text of the textfield.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l8y"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l8z" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_4o9" name="setText">
            <variable name="id">${id:aTextfield}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

If the text is empty, no action will take place.

@param	id	ID of the textfield.
@param 	text	text to be set.
@param	append	if this value is set to true, the text will be appended to the current values.
@param	clear	If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents If this value is set to true, the text will be inserted replaying single events.
@param	newline	the separator sign for marking a linebreak within the text

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_4oT" test="rc.lookup(&#34;text&#34;)">
              <ServerScriptStep id="_6Tr">
                <code>from java.lang import String

global parts

parts = []

text = rc.lookup("text")
newline = rc.lookup("newline")

stringText = String(text)
parts = stringText.split(newline)

rc.setLocal("iterations", len(parts))
</code>
              </ServerScriptStep>
              <RepeatSequence count="$(iterations)" id="_6UD" var="i">
                <ServerScriptStep id="_1jx7">
                  <code>global parts
rc.setLocal("text", parts[$(i)].replace('$$', '$$$$'))
</code>
                </ServerScriptStep>
                <IfSequence id="_6U0" test="$(i) == 0">
                  <IfSequence id="_6U4"
                              test="&#34;$(append)&#34; == &#34;true&#34;">
                    <IfSequence id="_6UY"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_6UZ">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_6Ua">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_6Ub" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                    <ElseSequence id="_6U6">
                      <IfSequence id="_6Uc"
                                  test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                        <TextInputStep clear="true" client="$(client)"
                                       component="$(id)" id="_6Ud">
                          <text>$(text)</text>
                        </TextInputStep>
                        <ElseSequence id="_6Ue">
                          <TextInputStep clear="true" client="$(client)"
                                         component="$(id)" id="_6Uf"
                                         single="false">
                            <text>$(text)</text>
                          </TextInputStep>
                        </ElseSequence>
                      </IfSequence>
                    </ElseSequence>
                  </IfSequence>
                  <ElseSequence id="_6UW">
                    <IfSequence id="_6Uk"
                                test="&#34;$(replaySingleEvents)&#34; == &#34;true&#34;">
                      <TextInputStep client="$(client)" component="$(id)"
                                     id="_6Ul">
                        <text>$(text)</text>
                      </TextInputStep>
                      <ElseSequence id="_6Um">
                        <TextInputStep client="$(client)" component="$(id)"
                                       id="_6Un" single="false">
                          <text>$(text)</text>
                        </TextInputStep>
                      </ElseSequence>
                    </IfSequence>
                  </ElseSequence>
                </IfSequence>
                <IfSequence id="_6Tt" test="$(i) &lt; ($(iterations) - 1)">
                  <KeyEventStep client="$(client)" component="$(id)"
                                event="KEY_PTR" id="_6T-" keychar="13"
                                keycode="10" modifiers="0"/>
                </IfSequence>
              </RepeatSequence>
              <ElseSequence id="_6V8">
                <IfSequence id="_6V9"
                            test="&#34;$(clear)&#34; == &#34;true&#34;">
                  <TextInputStep clear="true" client="$(client)"
                                 component="$(id)" id="_6VC" single="false">
                    <text></text>
                  </TextInputStep>
                </IfSequence>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1juo" name="setTextFromFile">
            <variable name="id">${id:aTextfield}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param id 	The id of the text-field to set.
@param file	The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1jup" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1juq" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_2I3" name="tree">
          <comment>Procedures to access trees.
(SWT component &lt;code&gt;org.eclipse.swt.widgets.Tree&lt;/code&gt;)

@author	QFS,mm
@since	2.1.0</comment>
          <Package id="_1jvy" name="checks">
            <comment>Procedures for checking a tree.

@author QFS,mm
@since 3.1.1</comment>
            <Procedure id="_2J2x" name="checkNumberOfChildNodes">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of child nodes of a given tree node according to a specified comparison mode.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 		Separator to use for the node syntax. Default is 				@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2J2y" local="true"
                             procedure="qfs.swt.tree.getChildNodeCount"
                             retvarname="nodeCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2J2z"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of child nodes of tree '$(id)$(nodeSeparator)$(node)'</variable>
                <variable name="got">$(nodeCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_1jvz" name="checkNumberOfRows">
              <variable name="id">${id:treeId}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="countOnlyVisibleNodes">True</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of visible nodes under a given tree or tree node according to a specified comparison mode.
If no node is specified, you will get the visible nodes or all loaded nodes.

Sample usage:
You can check, that a tree has exactly 6 visible rows or that the tree has less then 10 visible rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave  empty, if you want to count rows of whole tree.
@param 	nodeSeparator 	Separator to use for the node syntax. Default is 										@ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1jv+" local="true"
                             procedure="qfs.swt.tree.getRowCount"
                             retvarname="rowCount">
                <variable name="countOnlyVisibleNodes">$(countOnlyVisibleNodes)</variable>
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1jwM"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of visible rows of tree '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1lRV" name="multicolumn">
            <comment>Special procedures for multi-column trees.

@author QFS,kk
@since 3.5.0</comment>
            <Procedure id="_1lRX" name="getRowIndexByCellText">
              <variable name="treeId"/>
              <variable name="column"/>
              <variable name="columnSeparator">@</variable>
              <variable name="text"/>
              <variable name="regexp">false</variable>
              <comment>Return the index of the first row containing a given cell text in a given column of an SWT multi-column tree.

@param treeId 	     The id of the swt multi-column tree.
@param column    The column header text.
@param columnSeparator The separator to use for the node syntax.
                             Default is @ for text values, also  available &amp; for index and % for regexp.
@param text	     The cell text to look for.
@param regexp     If true the text parameter is meant as regexp. Default is false.
@return	     The row index. -1 in case no fitting cell is found.

@author QFS,kk
@since 3.5.0</comment>
              <ProcedureCall id="_1lRY" local="true"
                             procedure="qfs.swt.tree.getRowCount"
                             retvarname="rows">
                <variable name="id">$(treeId)</variable>
                <variable name="node"/>
                <variable name="nodeSeparator"/>
                <variable name="countOnlyVisibleNodes">True</variable>
              </ProcedureCall>
              <RepeatSequence count="$(rows)" id="_2J4t"
                              name="Search cell in rows" var="row">
                <CheckStringStep client="$(client)"
                                 component="$(treeId)$(columnSeparator)$(column)&amp;$(row)"
                                 errorlevel="0" id="_1lRa" local="true"
                                 regexp="$(regexp)" resvarname="found"
                                 timeout="0">
                  <text>$(text)</text>
                </CheckStringStep>
                <IfSequence id="_1lRb" test="$(found)">
                  <ReturnStep id="_1lRc" retval="$(row)"/>
                </IfSequence>
              </RepeatSequence>
              <ReturnStep id="_1lRd" retval="-1">
                <comment>Not found, return -1.</comment>
              </ReturnStep>
            </Procedure>
          </Package>
          <Procedure id="_6Wb" name="callbackPrintNodeText">
            <variable name="treeId">${id:treeId}</variable>
            <variable name="node"/>
            <comment>Example for a callback procedure used by expandNodes.

@param	treeId  	The id of the tree.
@param	node  	The index of the node.

@author	QFS
@since	3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(treeId)$(node)"
                             id="_1oGy"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6Wc"
                              name="Print node text">
              <code>c = rc.getComponent("$(treeId)$(node)")[1]
print c.getText()
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n8z" name="clickNodeWithDetails">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given node.
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the tree.
@param node 		The node, e.g. '/Root/Price' or '/0/0'.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n8+"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2J2s" name="getChildNodeCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of child nodes.

@param id 		The component-id of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the items of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 

@return nodeCount

@author QFS,mm
@since 4.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_2J2t"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_2J2w">
              <code>tree = None
item = None
nodeCount = 0
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if not rc.lookup("node") or not rc.lookup("nodeSeparator"):
    raise UserException("No value for 'node' parameter specified!") 

tree, item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))


#in case of multi-trees, go for treeitem in provided array
checkItem = item
try:
    checkItem = item[1]
except:
    pass
                
if not onlyVisibleNodes:
    nodeCount = checkItem.getItemCount()
elif checkItem.getExpanded():
    nodeCount = checkItem.getItemCount()   

rc.setLocal("nodeCount", nodeCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2J2v" retval="$(nodeCount)"/>
          </Procedure>
          <Procedure id="_1jw0" name="getIndexOfNode">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">@</variable>
            <comment>Return the hierarchical index of a given node.

Sample usage:
Can be used to determine the numeric index of a node like '/Root/Price'.

@param id  		ID of the tree.
@param node 		The node. like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the node, which has been read by the 'Fetch Index' node of QF-Test. This will be something like /0/1.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(nodeSeparator)$(node)"
                            id="_1jw1" local="true" varname="index"/>
            <ReturnStep id="_1jw2" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1jw3" name="getRowCount">
            <variable name="id">${id:treeId}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <variable name="countOnlyVisibleNodes">True</variable>
            <comment>Return the number of visible nodes under a given tree or tree-node.
If no node is specified, you will get the visible nodes or all loaded nodes of the entire tree.

@param id 		The component-id of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the nodes of the root node.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param  	countOnlyVisibleNodes  	If true, only visible children will be taken into account. Otherwise also invisible children. If the node itself is invisible QF-Test tries to expand that node before performing the count operation. 

@return rowCount

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)"
                             component="$(id)$(nodeSeparator)$(node)"
                             id="_2J2Q"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1oH+">
              <code>def getNumberOfChildren(node, checkVisibility):
    isExpanded = True 
       
    #in case of multi-tree items check array
    checkNode = node
    try:
        checkNode = node[1]
    except:
        pass   
    
    try:
        isExpanded = checkNode.getExpanded()
    except:
        pass
            
    if checkVisibility or isExpanded:
        cs = checkNode.getItems()
        count = 0
        if cs:
            count = len(cs)     
        child_count = 0    
        for c in cs:
            child = c
            try:
                child = c[1]
            except:
                pass
            if checkVisibility or child.getExpanded():                   
                child_count = child_count + getNumberOfChildren(child, checkVisibility)                           
        return count + child_count
    else:
        return 0   
        
tree = None
item = None
rowCount = 0
onlyVisibleNodes = rc.getBool("countOnlyVisibleNodes")

if rc.lookup("node") and rc.lookup("nodeSeparator"):
    tree, item = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))
else:
    tree = rc.getComponent(rc.lookup("id"))

if item:
    if not onlyVisibleNodes:
        rowCount = getNumberOfChildren(item, True) + 1   
    else:
        rowCount = getNumberOfChildren(item, False) + 1
else:
    item = tree
    try:
        item = tree[0]
    except:
        pass
    if not onlyVisibleNodes:
        rowCount = getNumberOfChildren(item, True)    
    else:
        rowCount = getNumberOfChildren(item, False)    

rc.setLocal("rowCount", rowCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_1jw5" retval="$(rowCount)"/>
          </Procedure>
          <Procedure id="_1jw6" name="getValueOfNode">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">&amp;</variable>
            <comment>Return the text of a given node.

Sample usage:
Determine the text value for a node referenced by index like /0/1.

@param id  		ID of the tree.
@param node 		The node. It should be something like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	The value of the node.

@author QFS,mm
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(nodeSeparator)$(node)" id="_1jw7"
                           local="true" varname="value"/>
            <ReturnStep id="_1jw8" retval="$(value)"/>
          </Procedure>
          <Procedure id="_4ov" name="collapse">
            <variable name="node">tree.item</variable>
            <comment>Collapse a tree node.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.

@author	QFS,mm
@since	2.1.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_4ox">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc
import array

treeId = rc.lookup("node")

if treeId != None:
	tree, item = rc.getComponent(treeId)
        if item and isinstance(item, (array.array)):
            item = item[1]
            
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	if item != None:
                event = Event()
                event.item = item;
                tree.sendEvent (SWT.Collapse, event);
		item.setExpanded(false)
else:
	raise UserException("Cannot find tree-id!")

</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n8c" name="collapseWithCoordinates">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node and collapses the node programatically.
You can specify the coordinates for selecting the node.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n8g" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1n8h">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc

treeId = rc.lookup("node")

idx = Misc.unquotedIndexOf(treeId, "#", 0)
if idx != -1:
		treeId = treeId[idx+1:]

idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)
while (idx != -1):
	treeId = treeId[0:idx]
	idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)

if treeId != None:
	tree = rc.getComponent(treeId)
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	selectedItem = tree.getSelection()[0]
	if selectedItem != None:
                event = Event()
                event.item = selectedItem;
                tree.sendEvent (SWT.Collapse, event);
		selectedItem.setExpanded(false)
else:
	raise UserException("Cannot find tree-id!")

</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_4oy" name="expand">
            <variable name="node">tree.item</variable>
            <comment>Expand a tree node.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.

@author	QFS,mm
@since	2.1.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_4o+">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc
import array

treeId = rc.lookup("node")

if treeId != None:
	tree, item = rc.getComponent(treeId)

        if item and isinstance(item, (array.array)):
            item = item[1]
            
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	if item != None:
                event = Event()
                event.item = item;
                tree.sendEvent (SWT.Expand, event);
		item.setExpanded(true)
else:
	raise UserException("Cannot find tree-id!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_2JZx" name="expandCompleteTree">
            <variable name="id">${id:treeId}</variable>
            <variable name="level">-1</variable>
            <variable name="expand">true</variable>
            <comment>Collapse a tree node.

@param	client	The name of the SUT client.
@param	id	The id of the tree to collapse.
@param	level	If positive, expand tree nodes only to that depth/level.
@param	expand	If false, collapse tree items instead of expanding.

@author	QFS,ys
@since	4.3

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${qftest:engine.$(id)}" id="_2JZy">
              <code>from org.eclipse.swt import SWT

tree = rc.getComponent(rc.lookup("id"))
lvl = rc.getInt("level")
expandBool = rc.getBool("expand")
Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

def expand(tree, item, expandBool):
    event = Event()
    event.item = item
    if expandBool:
        tree.sendEvent(SWT.Expand, event)
        item.setExpanded(True)
    else:
        tree.sendEvent(SWT.Collapse, event)
        item.setExpanded(False)

def expandRecursive(tree, subElement, expandBool, lvl):
    if lvl != -1:
        lvl -= 1
        if lvl == 0:
            return
    expand(tree, subElement, expandBool)
    for item in subElement.getItems():
        expandRecursive(tree, item, expandBool, lvl)

tree.setRedraw(False)
items = tree.getItems()
for item in items:
    expandRecursive(tree, item, expandBool, lvl)
tree.setRedraw(True)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n8i" name="expandWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node and expands the node programatically.
You can specify the coordinates for selecting the node.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_1n8m" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1n8n">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc

treeId = rc.lookup("node")

idx = Misc.unquotedIndexOf(treeId, "#", 0)
if idx != -1:
		treeId = treeId[idx+1:]

idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)
while (idx != -1):
	treeId = treeId[0:idx]
	idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)

if treeId != None:
	tree = rc.getComponent(treeId)
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	selectedItem = tree.getSelection()[0]
	if selectedItem != None:
                event = Event()
                event.item = selectedItem;
                tree.sendEvent (SWT.Expand, event);
		selectedItem.setExpanded(true)
else:
	raise UserException("Cannot find tree-id!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6V-" name="collapseNode">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Collapse a tree node.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1oHQ" procedure="qfs.swt.tree.collapse">
              <variable name="node">$(id)$(separator)$(node)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n8u" name="collapseNodeWithCoordinates">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node and collapses the node programatically.
You can specify the coordinates for selecting the node.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n8x" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1n8y">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc

treeId = rc.lookup("id")

idx = Misc.unquotedIndexOf(treeId, "#", 0)
if idx != -1:
		treeId = treeId[idx+1:]

idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)
while (idx != -1):
	treeId = treeId[0:idx]
	idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)

if treeId != None:
	tree = rc.getComponent(treeId)
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	selectedItem = tree.getSelection()[0]
	if selectedItem != None:
                event = Event()
                event.item = selectedItem;
                tree.sendEvent (SWT.Collapse, event);
		selectedItem.setExpanded(false)
else:
	raise UserException("Cannot find tree-id!")

</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6W2" name="expandNode">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Expand a tree node.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1oHR" procedure="qfs.swt.tree.expand">
              <variable name="node">$(id)$(separator)$(node)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n8o" name="expandNodeWithCoordinates">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node and expands the node programatically.
You can specify the coordinates for selecting the node.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1n8s" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1n8t">
              <code>from org.eclipse.swt import SWT
from de.qfs.lib.util import Misc

treeId = rc.lookup("id")

idx = Misc.unquotedIndexOf(treeId, "#", 0)
if idx != -1:
		treeId = treeId[idx+1:]

idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)
while (idx != -1):
	treeId = treeId[0:idx]
	idx = Misc.unquotedIndexOf(treeId, "@&amp;%", 0)

if treeId != None:
	tree = rc.getComponent(treeId)
        Event = tree.__class__.getClassLoader().loadClass("org.eclipse.swt.widgets.Event")

	selectedItem = tree.getSelection()[0]
	if selectedItem != None:
                event = Event()
                event.item = selectedItem;
                tree.sendEvent (SWT.Expand, event);
		selectedItem.setExpanded(true)
else:
	raise UserException("Cannot find tree-id!")</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6Pl" name="selectNode">
            <variable name="id">${id:treeId}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Select a given node.

@param id  		The id of the tree.
@param node 		The node.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_1mIv" modifiers="16"/>
          </Procedure>
          <Procedure id="_6Wd" name="expandNodes">
            <variable name="id"/>
            <variable name="callbackProc"/>
            <comment>Expand a tree node recursively.

@param	id  	The id of the tree node.
@param	callbackProc  	The name of a procedure to be called for every visited node.

@author	QFS
@since	3.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1mIw" modifiers="16"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_6Wf">
              <code>ID = rc.lookup('id')
item = rc.getComponent(ID)[1]
idx = []
while item:
    parent = item.getParentItem()
    if parent:
        idx.append(str(parent.indexOf(item)))
    else:
        idx.append(str(item.getParent().indexOf(item)))
        break
    item = parent

idx.reverse()
rc.setLocal('idx', '/' + '/'.join(idx))
if ID.find('&amp;/') &gt; 0:
    rc.setLocal('tree', ID.split('&amp;')[0])
elif ID.find('@/') &gt; 0:
    rc.setLocal('tree', ID.split('@')[0])
elif ID.find('%/') &gt; 0:
    rc.setLocal('tree', ID.split('%')[0])
else:
    raise UserException('Invalid id %s' %ID)
    </code>
            </ClientScriptStep>
            <ProcedureCall id="_6Wg" procedure="qfs.swt.tree._expandNodesR">
              <variable name="treeId">$(tree)</variable>
              <variable name="root">&amp;$(idx)</variable>
              <variable name="callbackProc">$(callbackProc)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n8-" name="expandNodesWithCoordinates">
            <variable name="id"/>
            <variable name="callbackProc"/>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node recursively.
You can specify the coordinates for clicking.

@param	id  	The id of the tree node.
@param	callbackProc  	The name of a procedure to be called for every visited node.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1n93" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:swt}" id="_1n94">
              <code>ID = rc.lookup('id')
item = rc.getComponent(ID)[1]
idx = []
while item:
    parent = item.getParentItem()
    if parent:
        idx.append(str(parent.indexOf(item)))
    else:
        idx.append(str(item.getParent().indexOf(item)))
        break
    item = parent

idx.reverse()
rc.setLocal('idx', '/' + '/'.join(idx))
if ID.find('&amp;/') &gt; 0:
    rc.setLocal('tree', ID.split('&amp;')[0])
elif ID.find('@/') &gt; 0:
    rc.setLocal('tree', ID.split('@')[0])
elif ID.find('%/') &gt; 0:
    rc.setLocal('tree', ID.split('%')[0])
else:
    raise UserException('Invalid id %s' %ID)
    </code>
            </ClientScriptStep>
            <ProcedureCall id="_1n95" procedure="qfs.swt.tree._expandNodesR">
              <variable name="treeId">$(tree)</variable>
              <variable name="root">&amp;$(idx)</variable>
              <variable name="callbackProc">$(callbackProc)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_6Wh" name="_expandNodesR">
            <variable name="treeId"/>
            <variable name="root"/>
            <variable name="callbackProc"/>
            <comment>Internal procedure.</comment>
            <SetGlobalStep id="_6Wi" local="true" varname="node">
              <default>$(root)</default>
              <comment>Force variable expansion</comment>
            </SetGlobalStep>
            <TryStep id="_6bO">
              <ProcedureCall id="_6bP" procedure="qfs.swt.tree.expand">
                <variable name="node">$(treeId)$(node)</variable>
              </ProcedureCall>
              <IfSequence id="_6Wl"
                          test="&#34;$(callbackProc)&#34; != &#34;&#34;">
                <ProcedureCall id="_6bQ" procedure="$(callbackProc)">
                  <variable name="treeId">$(treeId)</variable>
                  <variable name="node">$(node)</variable>
                </ProcedureCall>
              </IfSequence>
              <CatchSequence exception="ComponentNotFoundException" id="_6bR"
                             maxerror="0">
                <ReturnStep id="_6Wo"/>
              </CatchSequence>
            </TryStep>
            <RepeatSequence count="1000" id="_6a+" var="i">
              <SetGlobalStep id="_6Wq" local="true" varname="subnode">
                <default>$(node)/$(i)</default>
              </SetGlobalStep>
              <TryStep id="_6bS">
                <ComponentWaiter client="$(client)"
                                 component="$(treeId)$(subnode)" id="_6bT"
                                 timeout="0"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_6bU" maxerror="0">
                  <BreakStep id="_6bV"/>
                </CatchSequence>
              </TryStep>
              <ProcedureCall id="_6bW" procedure="qfs.swt.tree._expandNodesR">
                <variable name="treeId">$(treeId)</variable>
                <variable name="root">$(subnode)</variable>
                <variable name="callbackProc">$(callbackProc)</variable>
              </ProcedureCall>
            </RepeatSequence>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2Fd" name="utils">
        <comment>Miscellaneous utility procedures.

@author	QFS,mm
@since	2.1.0</comment>
        <Package id="_1kGv" name="clipboard">
          <comment>Accessing the clipboard from procedures.

@author QFS,mm
@since 3.4.0</comment>
          <Procedure id="qfs.utils.clipboard.getTextFromClipboard"
                     name="getTextFromClipboard" uid="_1kHJ">
            <comment>Return the current text on the system clipboard.

@return  The current text on the clipboard.

@author QFS,mm
@since 3.4.0</comment>
            <ServerScriptStep id="_1kGx" interpreter="groovy"
                              name="get text from clipboard">
              <code>import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.Toolkit;
import java.io.*;

String text = "";
Transferable t = Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null);

try {
  if (t != null &amp;&amp; t.isDataFlavorSupported(DataFlavor.stringFlavor)) {
    text = (String)t.getTransferData(DataFlavor.stringFlavor);
 }
} catch (UnsupportedFlavorException e) {
} catch (IOException e) {
}
rc.setLocal("text", text)</code>
            </ServerScriptStep>
            <ReturnStep id="_1kGy" retval="$(text)"/>
          </Procedure>
          <Procedure id="qfs.utils.clipboard.setTextAtClipboard"
                     name="setTextAtClipboard" uid="_1nO-">
            <variable name="text">The text to set.</variable>
            <comment>Set a text on the system clipboard.

@author QFS,mh
@since 3.5.91</comment>
            <ServerScriptStep id="_1nP0" interpreter="groovy">
              <code>import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.Toolkit;
import java.io.IOException;

String text = rc.lookup("text");

try {
    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(text), null);
} catch (UnsupportedFlavorException e) {
} catch (IOException e) {
}
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1jw+" name="email">
          <comment>Procedures for sending E-Mails.

Note: SSL is currently not supported.

@author	QFS,mm
@since	3.1.2</comment>
          <Package id="_1jxA" name="pop3">
            <comment>Procedures for interacting with a POP3 server.

Note: SSL is currently not supported.

@author	QFS
@since	3.1.3</comment>
            <Procedure id="qfs.utils.email.pop3.deleteMessages"
                       name="deleteMessages" uid="_1kHM">
              <variable name="host"/>
              <variable name="port"/>
              <variable name="username"/>
              <variable name="password"/>
              <comment>Delete all messages from a pop3 account.

@param	host	Hostname of the pop3 server.
@param	port	Optional port of the pop3 server, leave empty to use the standard port.
@param	username	Username for the pop3 account.
@param	password	Password for the pop3 account.
</comment>
              <ServerScriptStep id="_1jxC">
                <code>from poplib import POP3

host = rc.lookup("host")
port = rc.lookup("port")
user = rc.lookup("username")
pwd = rc.lookup("password")

try:
    if port:
        pop = POP3(host, int(port))
    else:
        pop = POP3(host)
    rc.logMessage("Connected to server\nWelcome: %s" % pop.getwelcome())
except Exception, ex:
    rc.logError("Could not connect to pop3 server %s:%s\nError: %s" % (host, port, ex))
    raise ReturnException()

ok = false
try:
    try:
        pop.user(user)
        pop.pass_(pwd)
        rc.logMessage("Logged in to server")
    except Exception, ex:
        rc.logError("Could not log in to pop3 server as %s\nError: %s" % (user, ex))
        raise ReturnException()

    try:
        count, size = pop.stat()
        rc.logMessage("Mailbox contains %d message(s)" % count)
        if count &gt; 0:
            for i in range(count):
                pop.dele(i + 1)
                rc.logMessage("Message %d deleted" % (i + 1))
        pop.quit()
        rc.logMessage("Session terminated cleanly")
        ok = true
    except Exception, ex:
        rc.logError("Error while interacting with pop3 server: %s" % ex)
        raise ReturnException()
finally:
    if not ok:
        try:
            pop.quit()
        except:
            pass
</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="qfs.utils.email.pop3.fetchMessage"
                       name="fetchMessage" uid="_1kHN">
              <variable name="host"/>
              <variable name="port"/>
              <variable name="username"/>
              <variable name="password"/>
              <variable name="number">1</variable>
              <variable name="delete">true</variable>
              <variable name="timeout">0</variable>
              <comment>Fetch a message from a pop3 account.

@param	host	Hostname of the pop3 server.
@param	port	Optional port of the pop3 server, leave empty to use the standard port.
@param	username	Username for the pop3 account.
@param	password	Password for the pop3 account.
@param	number	Optional number of the message to get, default 1.
@param	delete	Whether to delete the message, default true.
@param	timeout	Approximate maximum time in ms to wait for the message to appear.
</comment>
              <ServerScriptStep id="_1jxG">
                <code>timeout = rc.getInt("timeout")
if timeout &lt;= 0:
    rc.setLocal("count", 1)
else:
    rc.setLocal("count", int(timeout / 1000) + 1)</code>
              </ServerScriptStep>
              <RepeatSequence count="$(count)" id="_1jxF" name="Retries">
                <ServerScriptStep id="_1jxE">
                  <code>from poplib import POP3

host = rc.lookup("host")
port = rc.lookup("port")
user = rc.lookup("username")
pwd = rc.lookup("password")
num = rc.getInt("number")
delete = rc.getBool("delete")
try:
    if port:
        pop = POP3(host, int(port))
    else:
        pop = POP3(host)
    rc.logMessage("Connected to server\nWelcome: %s" % pop.getwelcome())
except Exception, ex:
    rc.logError("Could not connect to pop3 server %s:%s\nError: %s" % (host, port, ex))
    raise BreakException()

try:
    pop.user(user)
    pop.pass_(pwd)
    rc.logMessage("Logged in to server")
except Exception, ex:
    rc.logError("Could not log in to pop3 server as %s\nError: %s" % (user, ex))
    raise BreakException()

ok = False
try:
    try:
        count, size = pop.stat()
        rc.logMessage("Mailbox contains %d message(s)" % count)
        if count &gt;= num:
            ret = pop.retr(num)
            rc.logMessage("Retrieved message %d" % num)
            if delete:
                pop.dele(num)
                rc.logMessage("Message %d deleted" % num)
            pop.quit()
            rc.logMessage("Session terminated cleanly")
            ok = True
            raise ReturnException ("\n".join(ret[1]))
        else:
            rc.logMessage("No message %d available" % num)
    except Exception, ex:
        rc.logError("Error while interacting with pop3 server: %s" % ex)
        raise BreakException()
finally:
    if not ok:
        try:
            pop.quit()
        except:
            pass

</code>
                </ServerScriptStep>
                <BasicSequence id="_1jxJ" name="Delay ~1s" postdelay="750"/>
                <ElseSequence id="_1jxH">
                  <ServerScriptStep id="_1jxI">
                    <code>rc.logError("No message avaiable.")</code>
                  </ServerScriptStep>
                </ElseSequence>
              </RepeatSequence>
            </Procedure>
          </Package>
          <Procedure id="qfs.utils.email.sendEmail" name="sendEmail"
                     uid="_2JAc">
            <variable name="from"/>
            <variable name="to"/>
            <variable name="subject"/>
            <variable name="text"/>
            <variable name="asHtml">false</variable>
            <variable name="smtpHost">localhost:25</variable>
            <variable name="smtpUser"/>
            <variable name="smtpPassword"/>
            <variable name="fileToAttach"/>
            <variable name="readFileAsText">false</variable>
            <variable name="supressErrors">true</variable>
            <comment>This procedure uses the smtplib module from Jython, to send emails via SMTP(s) server. 
This procedure performs a login of a given user to a given SMTP server before sending the e-mail.
The attachment type is guessed based on file extension.

Logs detailed Error/Warning messages.

Note: To and From fields work only with ASCII characters, see https://docs.python.org/2.7/library/email.header.html

@param from	  		The address of the sender.
@param to			A comma-separated list of recipients.
@param subject 		The subject of the e-mail.
@param text	  		The text of the e-mail.
@param asHtml 		The Body of the email. Plain text or HTML.			
@param smtpHost  		SMTP server for sending e-mails. HOSTNAME:PORT
@param smtpUser  		Username for login to the  SMTP server.
@param smtpPassword  		Password for  login to the  SMTP server.

@param fileToAttach		File to attach. Use full path.
@param readFileAsText		force file to be read as text file

@param suppressErrors		Log Warnings instead of errors in run-log


@author QFS,pv
@since 4.1
</comment>
            <ServerScriptStep id="_2JkU">
              <code>from __future__ import with_statement
import os.path
import smtplib
import sys

from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from smtplib import SMTPAuthenticationError
from smtplib import SMTPException


import mimetypes

filecontent = ''

def trust_all_certificates(f):
    from javax.net.ssl import TrustManager, X509TrustManager
    from jarray import array
    from javax.net.ssl import SSLContext
    class TrustAllX509TrustManager(X509TrustManager):
        '''Define a custom TrustManager which will blindly accept all certificates'''
        def checkClientTrusted(self, chain, auth):
            pass
        def checkServerTrusted(self, chain, auth):
            pass
        def getAcceptedIssuers(self):
            return None
    # Create a static reference to an SSLContext which will use
    # our custom TrustManager
    trust_managers = array([TrustAllX509TrustManager()], TrustManager)
    TRUST_ALL_CONTEXT = SSLContext.getInstance("SSL")
    TRUST_ALL_CONTEXT.init(None, trust_managers, None)
    # Keep a static reference to the JVM's default SSLContext for restoring
    # at a later time
    DEFAULT_CONTEXT = SSLContext.getDefault()

    def wrapped(*args, **kwargs):
        SSLContext.setDefault(TRUST_ALL_CONTEXT)
        try:
            res = f(*args, **kwargs)
            return res
        finally:
            SSLContext.setDefault(DEFAULT_CONTEXT)
    return wrapped

def guess_types(path):
        ctype = ''
        encoding = ''
        if rc.getBool('readFileAsText') or path.endswith(('qrl','txt')):
            ctype = 'text/plain'
            encoding = 'utf-8'
        elif path.endswith('qzp'): 
            ctype = 'application/zip'
            encoding = 'binary'
        elif path.endswith('qrz'): 
            ctype = 'application/gzip'
            encoding = 'binary'
        else:
            ctype, encoding = mimetypes.guess_type(path)
        
        if ctype is None or encoding is None:
            ctype = 'application/octet-stream'   
             
        return ctype, encoding
           
def attachFile(path):
    try:
        # Guess the content type based on the file's extension.     
        ctype, encoding = guess_types(os.path.basename(path))

        maintype, subtype = ctype.split('/', 1)
                      
        if maintype == 'text':
            with open(path, 'rU') as fp:
                filecontent=''
                for line in fp.readlines():
                    filecontent += line;
                attachment = MIMEText(filecontent)
                name = os.path.basename(path)
                attachment.add_header('Content-Disposition', 'attachment', filename=name)
                return attachment
        else:
             with open(path) as fp:
                filecontent = fp.read()
                attachment = MIMEApplication(filecontent, subtype)
                name = os.path.basename(path)
                attachment.add_header('Content-Disposition', 'attachment', filename=name)
                return attachment
                
    except IOError, ioex:
        print ioex
        em = "errno: "+str(ioex.errno)+"\nerr message: "+os.strerror(ioex.errno)+" filename="+ioex.filename
        logging(em)
        
	return false


def logging(message):
    logWarnings = rc.getBool("supressErrors")
    if logWarnings:
        rc.logWarning(message, nowrap=False)
    else:
        rc.logError(message, nowrap=False)

@trust_all_certificates
def sendEmail():
    try:
        try:
            s = smtplib.SMTP_SSL(smtpHost)
        except:
            s = smtplib.SMTP(smtpHost)

        if smtpUser != '': #only perform login, if user is specified
            print "trying to authenticate to SMTP server ..."
            s.login(smtpUser, smtpPassword)
            print "successfully authorized"
            
        messageAsString = msg.as_string()
        print "sending email ..."
        s.sendmail(fromMail, addresses, messageAsString)
        s.quit()
        print "email sent successfully."
    except SMTPAuthenticationError,SMTPException:
        em = "Authentication failed. Check connection and credential details for %s."% smtpHost
        print em
        logging(em)
        return
    except:
        em = 'Cannot connect to server. Check hostname and port. Use hostnames instead of IP address'
        print em
        logging(em)
        raise


smtpHost = rc.lookup("smtpHost")
smtpUser = rc.lookup("smtpUser")
smtpPassword = str(rc.lookup("smtpPassword"))
asHtml = rc.getBool("asHtml")
fromMail = rc.lookup("from")
subject = rc.lookup("subject")
addstr = rc.lookup("to")
addarray = addstr.split(",")
addresses = []
for a in addarray:
    addresses.append(a.strip())

pathstr = rc.lookup("fileToAttach")
patharray = []
if len(pathstr)&gt;0:
    patharray = pathstr.split(",")
paths = []
for p in patharray:
    paths.append(os.path.normpath(p.strip()))


msg = MIMEMultipart()
msg['From'] = fromMail
msg['Subject'] = subject
msg['To'] = ",".join(addresses)

if asHtml:
    msg.attach(MIMEText(rc.lookup("text"), "html"))
else:
    msg.attach(MIMEText(rc.lookup("text"), "plain"))

if len(paths):
    for path in paths:
	af = attachFile(path)
	if(af):
            msg.attach(af)

sendEmail()
</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="qfs.utils.email.sendEmail_SMTPHost"
                     name="sendEmail_SMTPHost" uid="_1kHL">
            <variable name="from"/>
            <variable name="to"/>
            <variable name="subject"/>
            <variable name="text"/>
            <variable name="asHtml">false</variable>
            <variable name="smtpHost">localhost</variable>
            <variable name="smtpUser"/>
            <variable name="smtpPassword"/>
            <comment>Send an e-mail.
This procedure uses the smtplib module from Jython, which requires a SMTP server for sending e-mails.
This procedure performs a login of a given user to a given SMTP server before sending the e-mail.

It is possible that you have to copy that script and use it as template for your own script, because your mail-server requires a different authentication.

@param from	  The address of the sender.
@param to          A comma-separated list of recipients.
@param subject The subject of the e-mail.
@param text	  The text of the e-mail.
@param asHtml The Content-Type of the text is text/html.
@param smtpHost  SMTP server for sending e-mails.
@param smtpUser  User for the SMTP server.
@param smtpPassword  Password for the SMTP server.

@throws  Exception If something went wrong

@author QFS,fs
@since 3.1.2
@deprecated	Use qfs.utils.email.sendEmail because it provides the same functionallity.</comment>
            <ServerScriptStep id="_1jx6">
              <code>import smtplib
from email.MIMEText import MIMEText

smtpHost = rc.lookup("smtpHost")
smtpUser = rc.lookup("smtpUser")
smtpPassword = rc.lookup("smtpPassword")
asHtml = rc.getBool("asHtml")

addstr = rc.lookup("to")
addarray= addstr.split(",")

addresses = []
for a in addarray:
    addresses.append(a.strip())

if asHtml:
    msg = MIMEText(rc.lookup("text"),"html")
else:
    msg = MIMEText(rc.lookup("text"),"plain")
    
msg['From'] = rc.lookup("from")
msg['Subject'] = rc.lookup("subject")
msg['To'] = ",".join(addresses)

# Send the message via SMTP server, but don't include the
# envelope header.
s = smtplib.SMTP(smtpHost)

if smtpUser != '': #only perform login, if user is specified
    s.login(smtpUser, smtpPassword)

s.sendmail(rc.lookup("from"), addresses, msg.as_string())
s.quit()</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1kH2" name="files">
          <comment>Contain procedures to work with files.

@author QFS,mm
@since 3.4.0
</comment>
          <Procedure id="qfs.utils.files.checkFileForExistingRow"
                     name="checkFileForExistingLine" uid="_1kHS">
            <variable name="fileName">aFile</variable>
            <variable name="value">aValue</variable>
            <variable name="valueRegex">true</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <comment>Check, whether a given file contain a specific value in a line.
If valueRegex is set to true, it checks for a regular expression.
If valueRegex is set to false the text has in a row has to match exactly.

@param fileName The filename to check.
@param value  	The value for checking.
@param valueRegex  True, if the value is a regex, otherwise false.
@param errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws UserException, if file doesn't exist.
@author QFS,mm
@since 3.4.0</comment>
            <ServerScriptStep id="_1kH4" interpreter="groovy"
                              name="Check file">
              <code>import java.io.File
import de.qfs.apps.qftest.shared.exceptions.UserException

boolean regex = rc.getBool("valueRegex")
File theFile = new File(rc.lookup("fileName"))
if (!theFile.exists()) {
    throw new UserException("'" + rc.lookup("fileName") +"' doesn't exist.")
}

def theValue = rc.lookup("value")
def theFoundValue = theFile.readLines().find { line -&gt;
    if(regex) {
        matcher = line =~ /.*${theValue}.*/
        if(matcher.matches()) {
            return line
        }
    } else {
        if (theValue.equals(line)) {
            return line
        }
    }
}

level = rc.ERROR

if ("EXCEPTION".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.EXCEPTION
}
else if ("WARNING".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.WARNING
}
else if ("MESSAGE".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.OK
}

appearInReport = rc.getBool("appearInReport")

rc.check((theFoundValue != null), "Row '" + rc.lookup("value") + "' in '" + rc.lookup("fileName") + "'.", level, appearInReport)
    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="qfs.utils.files.checkFileForContent"
                     name="checkFileForContent" uid="_1kHT">
            <variable name="fileName">aFile</variable>
            <variable name="value">aValue</variable>
            <variable name="errorLevel">ERROR</variable>
            <variable name="appearInReport">1</variable>
            <comment>Check, whether a given file contain a specific value.  The value has to be a regular expression.
It checks the whole text of the file for the value, so you can also specify text containing line breaks, if required.

@param fileName The filename to check.
@param value  	The value for checking.
@param errorLevel   	The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws UserException, if file doesn't exist.
@author QFS,mm
@since 3.4.0</comment>
            <ServerScriptStep id="_1kH8" interpreter="groovy"
                              name="Check file">
              <code>import java.io.File
import de.qfs.apps.qftest.shared.exceptions.UserException

File theFile = new File(rc.lookup("fileName"))
if (!theFile.exists()) {
    throw new UserException("'" + rc.lookup("fileName") +"' doesn't exist.")
}

def theValue = rc.lookup("value")
def matcher = theFile.text =~ /(?s).*${theValue}.*/

level = rc.ERROR

if ("EXCEPTION".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.EXCEPTION
}
else if ("WARNING".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.WARNING
}
else if ("MESSAGE".equals(rc.lookup("errorLevel").toUpperCase())) {
    level = rc.OK
}

appearInReport = rc.getBool("appearInReport")

rc.check(matcher.matches(), "Check if file '" + rc.lookup("fileName") + "' contains '" + rc.lookup("value") + "'.", level, appearInReport)
    </code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1lQx" name="compareFiles">
            <variable name="file1">aFile</variable>
            <variable name="file2">aFileForCompare</variable>
            <comment>Compare the given files and returns true if equal, otherwise false.
It uses the Jython module filecmp for the comparison.
It doesn't return the diff of the files in case of differences.

@param	file1	The name and path of the first file to compare.
@param	file2	The name and path of the second file to compare with.
@throws	UserException	If at least one of both file to be compared does not exist.
@return	true	If both files are equal.
	false	If both files are not equal.

@author	QFS,mks
@since	3.5.0</comment>
            <ProcedureCall id="_1lR1" local="true"
                           procedure="qfs.shellutils.exists"
                           retvarname="bFileExists">
              <variable name="file">$(file1)</variable>
            </ProcedureCall>
            <IfSequence id="_1lR2"
                        name="first file to compare is not existing"
                        test="not $(bFileExists)">
              <ThrowStep id="_1lR3"
                         throwmessage="File '$(file1)' does not exist!"/>
            </IfSequence>
            <ProcedureCall id="_1lR4" local="true"
                           procedure="qfs.shellutils.exists"
                           retvarname="bFileExists">
              <variable name="file">$(file2)</variable>
            </ProcedureCall>
            <IfSequence id="_1lR5"
                        name="second file to compare is not existing"
                        test="not $(bFileExists)">
              <ThrowStep id="_1lR6"
                         throwmessage="File '$(file2)' does not exist!"/>
            </IfSequence>
            <ServerScriptStep id="_1lQy" name="do file compare">
              <code># Compare the given files
import filecmp

compResult = filecmp.cmp(rc.lookup("file1"), rc.lookup("file2"))

rc.setLocal("compResult", compResult)</code>
            </ServerScriptStep>
            <ReturnStep id="_1lQz" retval="$(compResult)"/>
          </Procedure>
          <Procedure id="_1lrJ" name="readExcelFile">
            <variable name="fileName"/>
            <variable name="sheet">0</variable>
            <variable name="dateFormat">MM/dd/yy</variable>
            <variable name="resultGroupName">resultGroup</variable>
            <comment>Read a worksheet of an Excel file.

@param fileName	The name of the file to read.
@param sheet		The name or the index of the worksheet.
@param dateFormat	A format string for the Java SimpleDateFormat.
@param resultGroupName	If this name is specified, the result is stored in a property group which an be accessed via ${resultGroupName:cellReference}, for example ${resultGroup:A2}

@author QFS,rl
@since 3.5.0
</comment>
            <ServerScriptStep id="_Cou">
              <code>from org.apache.poi.hssf.usermodel import HSSFWorkbook
from org.apache.poi.xssf.usermodel import XSSFWorkbook
from org.apache.poi.ss.usermodel import Cell, Row, DateUtil, DataFormatter
from org.apache.poi.ss.util import CellReference
from java.io import FileInputStream, FileNotFoundException
from java.text import SimpleDateFormat
from de.qfs.apps.qftest.step import ExcelDataBinder

def getWorkbook(filename):
    wb = None
    try:
        fis = FileInputStream(filename)
    except FileNotFoundException:
        raise UserException("File %s not found" %filename)
    if filename.lower().endswith(".xlsx") or filename.lower().endswith(".xlsm"):
        try:
            wb = XSSFWorkbook(fis)
        except:
            pass
    if not wb:
        wb = HSSFWorkbook(fis)
    fis.close()
    return wb

def getSheet(wb, sheet):
    res = None
    try:
        idx = int(sheet)
        res = wb.getSheetAt(idx)
    except:
        res = wb.getSheet(sheet)
    return res

def getColumnNumber(sheet):
    f = sheet.getFirstRowNum()
    l = sheet.getLastRowNum()
    nCol = 0
    for r in range(f, l + 1):
        row = sheet.getRow(r)
        if row:
            nCol = max(row.getLastCellNum(), nCol)
    return nCol

# Retrieve a cell's value by POI methods
def getCellValue0(cell, evaluator, dateFormat, dataFormatter):
    res = ""
    ty = cell.getCellType()
    if ty == Cell.CELL_TYPE_FORMULA:
        try:
            value = evaluator.evaluate(cell)
            ty = value.getCellType()
            if ty == Cell.CELL_TYPE_NUMERIC:
                if DateUtil.isCellDateFormatted(cell):
                    date = cell.getDateCellValue()
                    res = dateFormat.format(date)
                else:
                    res = value.getNumberValue()
                    res = dataFormatter.createFormat(cell).format(res)
            elif ty == Cell.CELL_TYPE_STRING:
                res = cell.getStringCellValue()
        except:
            pass
    elif ty == Cell.CELL_TYPE_NUMERIC:
        if DateUtil.isCellDateFormatted(cell):
            d = cell.getDateCellValue()
            res = dateFormat.format(d)
        else:
            #res = cell.getNumericCellValue()  # as double
            res = dataFormatter.formatCellValue(cell)
    if not res:
        res = cell.toString()
    return res

def getCellValue(wb, cell, evaluator, dateFormat, dataFormatter):
    res = ""
    ty = cell.getCellType()
    if ty == Cell.CELL_TYPE_FORMULA \
    or ty == Cell.CELL_TYPE_NUMERIC:
        try:
            res = edb.getFormulaPOIValue(
                wb, cell, dataFormatter, dateFormat.toPattern())
        except:
            pass
    if not res:
        res = cell.toString()
    return res

def isEmpty(seq):
    empty = True
    for d in seq:
        if d:
            empty = False
            break
    return empty

wb = getWorkbook(rc.lookup("fileName"))
theSheet = rc.lookup("sheet")
if not theSheet:
    raise UserException("No value for sheet specified!")

sheet = getSheet(wb, theSheet)
if not sheet:
    raise UserException("No sheet found!")

group = rc.lookup("resultGroupName")
if not group:
    raise UserException("No value for resultGroupName specified!")
    
global resultRows
resultRows = []

if group:
    rc.clearProperties(group)
df = rc.lookup("dateFormat")
if not df:
    df = "MM/dd/yy"
dateFormat = SimpleDateFormat(df)
dataFormatter = DataFormatter()
evaluator = wb.getCreationHelper().createFormulaEvaluator()
edb = ExcelDataBinder()
nCol = getColumnNumber(sheet)
last = sheet.getLastRowNum()
for r in range(sheet.getFirstRowNum(), last + 1):
    row = sheet.getRow(r)
    rowdata = []
    for c in range(nCol):
        cell = None
        if row:
            cell = row.getCell(c, Row.RETURN_BLANK_AS_NULL)
        if cell:
            data = getCellValue(wb, cell, evaluator, dateFormat, dataFormatter)
            #data = getCellValue0(cell, evaluator, dateFormat, dataFormatter)
        else:
            data = ""
        rowdata.append(data)
        if group:
            cellRef = CellReference(r, c)
            ref = cellRef.formatAsString()
            rc.setProperty(group, ref, data)
    if r == last and isEmpty(rowdata):
        # getLastRowNum() may or may not include a trailing empty row
        continue
    resultRows.append(rowdata)
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_6cC" name="random">
          <comment>Procedures for generating random string.

@author	QFS,mm
@since	3.0</comment>
          <Procedure id="qfs.utils.random.getEntriesOfArea"
                     name="getEntriesOfArea" uid="_1kHO">
            <variable name="length">2</variable>
            <variable name="area">abcdefghijklmnopqrstuvwxyz</variable>
            <comment>Return a random string created of parts of a specified area. The length of the string can also be specified as parameter.

@param area	  The area, which contains the choices.
@param length  The length of the random string.

@return   string  The random string.

@author	QFS,mm
@since	3.0

</comment>
            <ServerScriptStep id="_6cE">
              <code>import random

area = rc.lookup("area")

string = ""

for i in range(int(rc.lookup("length"))):
    string = string + random.choice(area)

rc.setLocal("string", string) </code>
            </ServerScriptStep>
            <ReturnStep id="_6cF" retval="$(string)"/>
          </Procedure>
          <Procedure id="qfs.utils.random.getNumber" name="getNumber"
                     uid="_1kHP">
            <variable name="length">2</variable>
            <comment>Return a random number.

@param length  The length of the random string.

@return   number  The random number.

@author	QFS,mm
@since	3.0

</comment>
            <ProcedureCall id="_6cH" local="true"
                           procedure="qfs.utils.random.getEntriesOfArea"
                           retvarname="number">
              <variable name="area">0123456789</variable>
              <variable name="length">$(length)</variable>
            </ProcedureCall>
            <ReturnStep id="_6c9" retval="$(number)"/>
          </Procedure>
          <Procedure id="qfs.utils.random.getString" name="getString"
                     uid="_1kHQ">
            <variable name="length">2</variable>
            <comment>Return a random string containing small letters.

@param length  The length of the random string.

@return   string  The random string.

@author	QFS,mm
@since	3.0</comment>
            <ProcedureCall id="_6cG" local="true"
                           procedure="qfs.utils.random.getEntriesOfArea"
                           retvarname="string">
              <variable name="area">abcdefghijklmnopqrstuvwxyz</variable>
              <variable name="length">$(length)</variable>
            </ProcedureCall>
            <ReturnStep id="_6cB" retval="$(string)"/>
          </Procedure>
          <Procedure id="qfs.utils.random.getNumberFromRange"
                     name="getNumberFromRange" uid="_1kHR">
            <variable name="lowest">0</variable>
            <variable name="highest">3</variable>
            <comment>Return a random number between two given numbers.

If you call it with lowest 0 and highest 3. The procedure could return 0, 1 or 2.

@param lowest  The lowest number for the random choice. It could be returned.
@param highest  The highest number for the random choice. It won't be included.

@return   random  The random number.

@author	QFS,mm
@since	3.4.0</comment>
            <ServerScriptStep id="_1kHC">
              <code>import random

low = rc.getNum("lowest")
high = rc.getNum("highest")

choice = random.choice(range(low, high))

rc.setLocal("number", choice) </code>
            </ServerScriptStep>
            <ReturnStep id="_1kHB" retval="$(number)"/>
          </Procedure>
        </Package>
        <Package id="_1nWj" name="ssh">
          <comment>Procedures for executing commands on a remote server via ssh.

@author	QFS,ys
@since	4.0</comment>
          <Package id="_1nWp" name="session">
            <Procedure id="_1nWq" name="open">
              <variable name="sessionName">defaultSession</variable>
              <variable name="server"/>
              <variable name="port">22</variable>
              <variable name="user"/>
              <variable name="password"/>
              <variable name="keyfile"/>
              <variable name="checkKnownHosts">True</variable>
              <variable name="knownHostsFile"/>
              <variable name="connectionTimeout">5000</variable>
              <variable name="command">bash -i</variable>
              <variable name="encoding">UTF-8</variable>
              <comment>Connect to a remote server by ssh and keep the session open for further use.

@param sessionName	The name of the global Jython variable in which the session is stored.
@param server	The remote server to connect to.
@param port		The port to use for ssh login (optional, default 22).
@param user		The username to use.
@param password	The password to use (optional).
@param keyfile	The name of the file containing the key for public key authentication. Used only if no password is specified (optional, default is &lt;user_home&gt;/.ssh/id_rsa).
@param checkKnownHost	Whether to check the fingerprint of the remote server. For security reasons this should be enabled.
@param knownHostFile	A file containing the fingerprint for the remote server (optional, default is &lt;user_home&gt;/.ssh/known_hosts).
@param connectionTimeout	Time in ms to wait for a connection. -1 to wait forever (optional, default is 5000).
@param encoding	The encoding for the stdout and stderr stream (optional, default is UTF-8).

@throws Exception If something goes wrong with the ssh connection.

@author QFS, gs
@since 4.0
</comment>
              <ServerScriptStep id="_1nWs">
                <code>import ssh
reload(ssh)

# get execution/call/remote data
user = rc.lookup("user")
server = rc.lookup("server")
port = rc.getInt("port")
password = rc.lookup("password")
keyfile = rc.lookup("keyfile")
command = rc.lookup("command")
checkKnownHosts = rc.getBool("checkKnownHosts")
knownHostsFile = rc.lookup("knownHostsFile")
connectionTimeout = rc.getInt("connectionTimeout")
encoding = rc.lookup("encoding")

session = ssh.Session(user, server, port, password, keyfile,
                      checkKnownHosts, knownHostsFile, connectionTimeout, command,
                      None, "-", True)
if encoding:
    session.setEncoding(encoding)
global $(sessionName)
$(sessionName) = session

rc.logMessage("Session: %s" % session)

try:
    session.open()
    rc.logMessage("session connected")

except:
    import traceback
    rc.logError(traceback.format_exc())
    raise
</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="_1nWv" name="send">
              <variable name="sessionName">defaultSession</variable>
              <variable name="input"/>
              <variable name="expect"/>
              <variable name="timeout">1000</variable>
              <comment>Send a command via an established ssh connection and wait for resulting output.

@param sessionName	The name of the global Jython variable in which the session is stored.
@param input	The text to send.
@param addNewline	Whether to automatically terminate the command with a newline character if necessary (optional, default true).
@param expect	A regular expression for the output to expect from the program.
@param timeout	The maximum time to wait for the output.

@return	The partial output from the program from the start or the last point of execution of this procedure to the end of the string that we were waiting for.

@throws Exception If something goes wrong with the ssh connection or program execution.

@author QFS, gs
@since 4.0
</comment>
              <ServerScriptStep id="_1nWw">
                <code>import ssh
reload(ssh)

global $(sessionName)
session = $(sessionName)
rc.logMessage("Session: %s" % session)

input = rc.lookup("input")
addNewline = rc.getBool("default", "addNewline:True")
expect = rc.lookup("expect")
timeout = rc.getInt("timeout")

session.send(input, addNewline)
if expect:
    ret = session.expect(expect, timeout)
    rc.logMessage("Result: %s" % ret)
    raise ReturnException (ret)
</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="_1nWt" name="close">
              <variable name="sessionName">defaultSession</variable>
              <variable name="resultGroupName"/>
              <comment>Close an established ssh connection.

@param sessionName	The name of the global Jython variable in which the session is stored.
@param resultGroupName	If this name is specified the combined stdout and stderr and the exit code of the executed command are stored in a property group and may be accessed with ${resultGroup:'stdout'} (for the stdout and stderr of the program) and ${resultGroup:'exitCode'} (for the exit code of the program).

@throws Exception If something goes wrong with the ssh connection.

@author QFS, gs
@since 4.0
</comment>
              <ServerScriptStep id="_1nWu">
                <code>import ssh
reload(ssh)

resultGroup = rc.lookup("resultGroupName")

global $(sessionName)
session = $(sessionName)

rc.logMessage("Session: %s" % session)

try:
    session.close()
    rc.logMessage("session connected")

except:
    import traceback
    rc.logError(traceback.format_exc())
    raise

# save execution data
cmdout = session.getStdout()
rc.logMessage("stdout: %s" % cmdout)
if resultGroup:
    rc.setProperty(resultGroup, "stdout", cmdout)
    rc.setProperty(resultGroup, "stderr", "")
    rc.setProperty(resultGroup, "code", str(session.getExitCode()))
</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_3LE" name="executeCommand">
            <variable name="server"/>
            <variable name="port">22</variable>
            <variable name="user"/>
            <variable name="password"/>
            <variable name="keyfile"/>
            <variable name="checkKnownHosts">True</variable>
            <variable name="knownHostsFile"/>
            <variable name="connectionTimeout">5000</variable>
            <variable name="command"/>
            <variable name="stdin"/>
            <variable name="stdinFile"/>
            <variable name="programTimeout">5000</variable>
            <variable name="mixOut">False</variable>
            <variable name="encoding">UTF-8</variable>
            <variable name="resultGroupName"/>
            <comment>Connect to a remote server by ssh and execute a command.

@param server	The remote server to connect to.
@param port		The port to use for ssh login (optional, default 22).
@param user		The username to use.
@param password	The password to use (optional).
@param keyfile	The name of the file containing the key for public key authentication. Used only if no password is specified (optional, default is &lt;user_home&gt;/.ssh/id_rsa).
@param checkKnownHosts	Whether to check the fingerprint of the remote server. For security reasons this should be enabled.
@param knownHostFile	A file containing the fingerprint for the remote server (optional, default is &lt;user_home&gt;/.ssh/known_hosts).
@param connectionTimeout	Time in ms to wait for a connection. -1 to wait forever (optional, default is 5000).
@param command	The command to execute on the remote server.
@param stdin		Text to be based to the stdin of the executing program. Ignored if stdinFile is specified.
@param stdinFile	The path to a local file or nothing. If a file is specified, the content of this file is passed to the stdin of the executing program.
@param mixOut	If true, stdout and stderr of the executing program are captured together in the stdout stream with stderr remaining empty (optional, default False).
@param programTimeout	Time in ms to wait for the command to execute. -1 to wait forever (optional, default is 5000).
@param encoding	The encoding for the stdout and stderr stream (optional, default is UTF-8).
@param resultGroupName	If this name is specified the stdout, stderr and exit code of the executed command are stored in a property group and may be accessed with ${resultGroup:'stdout'} (for the stdout of the program), ${resultGroup:'stderr'} (for the stderr of the program) and ${resultGroup:'exitCode'} (for the exit code of the program).

@throws Exception If something goes wrong with the ssh connection or program execution.

@author QFS, ys, gs
@since 4.0</comment>
            <ServerScriptStep id="_1nWk">
              <code>import ssh
reload(ssh)

# get execution/call/remote data
user = rc.lookup("user")
server = rc.lookup("server")
port = rc.getInt("port")
password = rc.lookup("password")
keyfile = rc.lookup("keyfile")
checkKnownHosts = rc.getBool("checkKnownHosts")
knownHostsFile = rc.lookup("knownHostsFile")
connectionTimeout = rc.getInt("connectionTimeout")
command = rc.lookup("command")
input = rc.lookup("stdin")
inputFile = rc.lookup("stdinFile")
mixOut = rc.getBool("mixOut")
programTimeout = rc.getInt("programTimeout")
resultGroup = rc.lookup("resultGroupName")
encoding = rc.lookup("encoding")

session = ssh.Session(user, server, port, password, keyfile,
                      checkKnownHosts, knownHostsFile, connectionTimeout, command,
                      input, inputFile)
if encoding:
    session.setEncoding(encoding)
rc.logMessage("Session: %s" % session)

try:
    try:
        session.open()
        rc.logMessage("session connected")
        session.wait(programTimeout)
        exitCode = session.getExitCode()
        rc.logMessage("exitCode: %s" % exitCode)

    except:
        import traceback
        rc.logError(traceback.format_exc())
        raise
finally:
    # close/disconnect the connection
    session.close()

# save execution data
cmdout = session.getStdout()
rc.logMessage("stdout: %s" % cmdout)
cmderr = session.getStderr()
rc.logMessage("stderr: %s" % cmderr)
if resultGroup:
    rc.setProperty(resultGroup, "stdout", cmdout)
    rc.setProperty(resultGroup, "stderr", cmderr)
    rc.setProperty(resultGroup, "exitCode", str(exitCode))
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1jx9" name="testrun">
          <comment>Procedures for handling the test execution.

@author QFS,mm
@since 3.1.3</comment>
          <Package id="_1jyd" name="skip">
            <comment>Procedures for skipping test-steps.

@author QFS,mm
@since 3.1.3</comment>
            <Procedure id="qfs.utils.testrun.skip.skipTestCase"
                       name="skipTestCase" uid="_1kHd">
              <comment>Skip the execution of the current test-case.

@author QFS,mm
@since 3.1.3</comment>
              <ServerScriptStep id="_1jyf">
                <code>rc.skipTestCase()</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="qfs.utils.testrun.skip.skipTestSet"
                       name="skipTestSet" uid="_1kHe">
              <comment>Skip the execution of the current test-set.

@author QFS,mm
@since 3.1.3</comment>
              <ServerScriptStep id="_1jxL">
                <code>rc.skipTestSet()</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
          <Package id="_1jyg" name="stop">
            <comment>Procedures for stopping test-steps.

@author QFS,mm
@since 3.1.3</comment>
            <Procedure id="qfs.utils.testrun.stop.stopTestCase"
                       name="stopTestCase" uid="_1kHf">
              <variable name="expectedToFail">false</variable>
              <comment>Stop the execution of the current test-case

@param expectedToFail  	Whether test-case was expected to fail.

@author QFS,mm
@since 3.1.3</comment>
              <ServerScriptStep id="_1jyi">
                <code>rc.stopTestCase($(expectedToFail))</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="qfs.utils.testrun.stop.stopTestRun"
                       name="stopTestRun" uid="_1kHg">
              <comment>Stop the complete test-run.

@author QFS,mm
@since 3.1.3
</comment>
              <ServerScriptStep id="_1jyk">
                <code>rc.stopTest()</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="qfs.utils.testrun.stop.stopTestSet"
                       name="stopTestSet" uid="_1kHh">
              <comment>Stop the execution of the current test-set.

@author QFS,mm
@since 3.1.3</comment>
              <ServerScriptStep id="_1jym">
                <code>rc.stopTestSet()</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
        </Package>
        <Package id="_1j-m" name="variables">
          <comment>Procedures for working with variables.

@author QFS,mm
@since 3.3.0</comment>
          <Procedure id="_1j-k" name="deleteAllGlobalVariables">
            <comment>Delete all global QF-Test variables.

@author QFS,mm
@since 3.3.0</comment>
            <ServerScriptStep id="_1j-l" name="clear global variables">
              <code>rc.clearGlobals()</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1lRt" name="deleteGlobalVariablesExcept">
            <variable name="dontDelete"/>
            <comment>Delete all global QF-Test variables.
You can define some exceptions for variable names, which shouldn't be deleted.

@param  dontDelete	A comma-separated list of variable names which shouldn't be deleted.
If dontDelete is set to: client,number
The variables client and number won't become deleted.

@author QFS,mm
@since 3.5.0</comment>
            <ServerScriptStep id="_1lRu"
                              name="clear global variables with taking care about specified exceptions">
              <code>dontDelete = rc.lookup("dontDelete")

if dontDelete == None or len(dontDelete) == 0:
    #nothing specified - so delete all
    rc.clearGlobals()
else :
    theVars = dontDelete.split(",")

    if theVars == None or len(theVars) == 0:
        #nothing specified - so delete all
        rc.clearGlobals()
    else:
        allGlobals = rc.getGlobals().clone()
        for oneGlobal in allGlobals:
            if not oneGlobal in theVars:
                rc.setGlobal(oneGlobal, None)</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1l8M" name="deletePropertyGroup">
            <variable name="groupName">nameOfGroup</variable>
            <comment>Delete a given global property group.
You can also use this to delete a custom resource bundle set, which have been read by the Load-Resource bundle node.

@param  groupName	The name of the group.

@author QFS,mm
@since 3.5.0</comment>
            <ServerScriptStep id="_1l8N" name="clear property group">
              <code>rc.clearProperties(rc.lookup("groupName"))</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1j-n" name="deleteOneGlobalVariable">
            <variable name="variableName">nameOfVariable</variable>
            <comment>Delete a given global QF-Test variable.

@param  variableName	The name of the variable.

@author QFS,mm
@since 3.3.0</comment>
            <ServerScriptStep id="_1j-o"
                              name="clear a specific global variable">
              <code>rc.setGlobal(rc.lookup("variableName"), None)</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1l8K" name="deleteOnePropertyVariable">
            <variable name="groupName">nameOfGroup</variable>
            <variable name="variableName">nameOfVariable</variable>
            <comment>Delete a given variable of a property group.

@param  groupName	The name of the group.
@param  variableName	The name of the variable.

@author QFS,mm
@since 3.5.0</comment>
            <ServerScriptStep id="_1l8L" name="clear property group">
              <code>rc.setProperty(rc.lookup("groupName"), rc.lookup("variableName"), None)</code>
            </ServerScriptStep>
          </Procedure>
          <Procedure id="_1l8O" name="listAllMembersOfPropertyGroup">
            <variable name="groupName">nameOfGroup</variable>
            <comment>Print a list of all members of a given property group to the terminal.

@param  groupName	The name of the group.

@author QFS,mm
@since 3.5.0</comment>
            <ServerScriptStep id="_1l8P" name="clear property group">
              <code>props = rc.getProperties(rc.lookup("groupName"))

if props != None:
    print "Members for group '" + rc.lookup("groupName") + "':"
    for p in props.keys():
        print "\tProperty: '" + p + "' with value: '" + props.get(p) + "'"
else:
    print "No members for group '" + rc.lookup("groupName") + "'."</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_1juI" name="xml">
          <comment>Procedures for working with XML files.

@author QFS,mm
@since 3.1.1</comment>
          <Procedure id="qfs.utils.xml.compareXMLFiles" name="compareXMLFiles"
                     uid="_1oUp">
            <variable name="originalFile">aFile</variable>
            <variable name="compareFile">aFile</variable>
            <variable name="noCheck">[]</variable>
            <variable name="sort">false</variable>
            <variable name="stripWhitespace">false</variable>
            <variable name="xmlNamespace">none</variable>
            <variable name="stopAtFirstDiff">false</variable>
            <variable name="compareComments">false</variable>
            <variable name="technology">auto</variable>
            <comment>Compare two XML files for full identity.

If differences are found, an error is logged for each different tag.

The 'noCheck' parameter can be used to exclude tags and attributes from the comparison, for example random values like timestamps. 'noCheck' also ignores tags, that only appear in one xml file, so optional tags can be specified there as well.

Examples for noCheck:
noCheck: date ... ignores all 'date' tags.
noCheck: date@value ... ignores all 'date' tags with the attribute 'value'.
noCheck: date@value=11122015 ... ignores all 'date' tags with the attribute 'value' and corresponding value '11122015'.
noCheck: date@value=%.*2015  ... ignores all 'date' tags where the regular expression '.*2015' matches to the value of the attribute 'value'.

@param originalFile	The original file for comparison.
@param compareFile	The file for comparing.
@param noCheck	A comma separated list of tags and attributes, which are excluded for checking, to ignore attributes specifiy tag@attr, or tag@attr=value or tag@attr=%regex-for-value.
@param stripWhitespace	Whether to strip leading and trailing whitespaces from text nodes before comparing.
@param xmlNamespace	Whether to process xml namespace definitions. Legal values are 'ignore' (remove all namespaces) or 'normalize' (normalize the namespaces). For all other values, xml namespace definitions are not preprocessed and possible namespaces are interpreted literally.
@param technology	The technology to use in order to compare the two xml files. Currently either 'sax', 'minidom', or 'auto' can be specified here. While 'sax' is the faster one, 'minidom' supports the additional 'sort=true' parameter. 'auto' means to take the technology which can probably best handle the given situation.

Minidom exclusive
@param sort		Sort the xml trees from both files before checking for identity.

SAX exclusive
@param stopAtFirstDiff 	If enabled, only the first difference will be logged in the protocol. The files won't be compared any further which could lead to better runtime, especially while comparing large files. If no difference is found, the parameter will not affect the comparison.
@param compareComments 	Whether the content of comments should be compared. If the parameter is disabled it will only be checked if both files include a comment tag at the same position.

@throws UserException, if one of the given files don't exist.

@author QFS,mm,ys
@since 3.1.1</comment>
            <IfSequence id="_1oUq"
                        test="rc.lookup(&#34;originalFile&#34;) == &#34;aFile&#34;">
              <ThrowStep id="_1oUr"
                         throwmessage="Parameter 'originalFile' hasn't been set!"/>
            </IfSequence>
            <IfSequence id="_1oUX"
                        test="rc.lookup(&#34;compareFile&#34;) == &#34;aFile&#34;">
              <ThrowStep id="_1oUs"
                         throwmessage="Parameter 'compareFile' hasn't been set!"/>
            </IfSequence>
            <IfSequence id="_2YQn" name="Use Minidom"
                        test="&#34;$(technology)&#34; == &#34;minidom&#34; or ((&#34;$(technology)&#34; == &#34;auto&#34; or &#34;$(technology)&#34; == &#34;&#34;) and rc.getBool(&#34;sort&#34;))">
              <ServerScriptStep id="_2YRh" name="compare files using minidom">
                <code>import xml.dom.minidom
from xml.dom.minidom import Node
from de.qfs.lib.util import Misc
from java.util.regex import Matcher, Pattern

#compare the attributes of the tag
def compareAttributes(original, compare):
    origAttributes = original.attributes
    compareAttributes = compare.attributes

    #number of attributes the same
    if len(origAttributes) != len(compareAttributes):
        rc.logError("Attributes of the original node '" + original.tagName + "' are not the same like '" + compare.tagName + "'")
        return -1

    #no attributes -&gt; ok
    if len(origAttributes) &lt;= 0:
        return 1

    #attribute names the same?
    for oAttr in origAttributes.keys():
        hk = compareAttributes.has_key(oAttr)
        if not hk:
            rc.logError("Attribute '" + oAttr + "' of the original node '" + original.tagName + "' cannot be found in compare node.")
            return -1

    #compare attribute values
    for oAttr in origAttributes.keys():
        oValue = origAttributes[oAttr]
        cValue = compareAttributes[oAttr]

        if oValue.nodeValue != cValue.nodeValue:
            rc.logError("Attribute '" + oAttr + "' of the original node '" + original.tagName + "' has value '" + oValue.nodeValue + "', but the compare one has value '" + cValue.nodeValue + "'")
            return -1

    return 1

#direct call of nodeValue
def getNodeValueOfTextNode(node, doStrip=False):
    if node.nodeType == Node.TEXT_NODE:
        nodeValue = node.nodeValue
        if doStrip and nodeValue:
            return nodeValue.strip()
        else:
            return nodeValue
    return ""
    
#read the text from a XML node.
def getElementText(node, doStrip=False):
    try:
        if node.nodeType == Node.TEXT_NODE:
            return getNodeValueOfTextNode(node, doStrip)
        else:
            return None
    except:
        return None

#compares original and compare DOM tree
def checkNode(original, compare):
    #original.normalize()
    #compare.normalize()
    #Normalizing is not necessary anymore since QF-Test 3.5M1.
    #It has been done by Jython already.
    for i in range(len(original.childNodes)):
        #compare nodes
        error = 0
        #correct amount of child nodes?
        if len(original.childNodes[i].childNodes) != len(compare.childNodes[i].childNodes):
            rc.logError("The original node of tag '" + original.childNodes[i].tagName + "' has '" + str(len(original.childNodes[i].childNodes)) + "' child nodes and the node in the comparison file has '" + str(len(compare.childNodes[i].childNodes)) + "' child nodes!")            #compare values
            rc.logMessage("original childNodes: %s" % str(original.childNodes[i].childNodes))
            rc.logMessage("comparison childNodes: %s" % str(compare.childNodes[i].childNodes))
            error = 1

        if error == 0:
            try:
                #are tags the same
                if original.childNodes[i].tagName != compare.childNodes[i].tagName:
                    rc.logError("Could not find tag '" + original.childNodes[i].tagName + "' in compare file at position " + str(i) + ". Found '" + compare.childNodes[i].tagName + "' instead!")
                    error = 1
            except:
                pass

        #compare text
        if error == 0 and original.childNodes[i] != None and compare.childNodes[i] != None:
                if getElementText(original.childNodes[i]) == getElementText(compare.childNodes[i]):
                   checkNode(original.childNodes[i], compare.childNodes[i])
                else:
                    try:
                       rc.logError("Not equal elements original file: '" + original.childNodes[i].parentNode.tagName + "'='" + getElementText(original.childNodes[i]) + "' and in new file '" + compare.childNodes[i].parentNode.tagName + "' ='" + getElementText(compare.childNodes[i]) + "'")
                    except:
                        pass

        #compare attributes
        if error == 0:
            try:
                returnValue = compareAttributes(original.childNodes[i], compare.childNodes[i])
                if returnValue != 1:
                    error = 1
            except:
                pass

todrop = {}
for noCheck in rc.lookup("noCheck").split(","):
    todrop[noCheck.strip()] = True


def prune(node):
    """remove unwanted attributes and subnodes"""
    num = len(node.childNodes)

    for i in range(num):
        child = node.childNodes[num - i - 1]
        try:
            #flag whether node should be deleted
            toDelete = False
            
            #node in noCheck array?
            if todrop.has_key(child.tagName):
                toDelete = True
            else:
                #check for tag@att=value pairs for ignoring
                childAttrs = child.attributes
                for tk in todrop.keys():
                    #regex
                    if tk.find("=%") != -1:
                        parts = tk.split("@")
                        if len(parts) == 2:
                            attParts = parts[1].split("=%")
                            if childAttrs.has_key(attParts[0]):
                                #use java pattern as jython re also matches only the beginning of strings
                                if Pattern.compile(attParts[1]).matcher(childAttrs.get(attParts[0]).nodeValue).matches():                    
                                    toDelete = True
                                    break                                        
                    #standard text
                    elif tk.find("=") != -1:
                        parts = tk.split("@")
                        if len(parts) == 2:
                            attParts = parts[1].split("=")
                            if childAttrs.has_key(attParts[0]):
                                if attParts[1] == childAttrs.get(attParts[0]).nodeValue:
                                    toDelete = True
                                    break                                        
                                        
            if toDelete:
                #remove the node from structure because of noCheck list specified
                delNode = node.childNodes[num - i - 1]
                parent =  delNode.parentNode
                
                #also remove linebreak node if existing
                delLinebreakNode = None
                try:
                    delLinebreakNode = node.childNodes[num - i]
                except:
                    pass   

                if parent:
                    if node.nodeType == Node.ELEMENT_NODE:
                        parent.removeChild(delNode)
                        if delLinebreakNode and delLinebreakNode.nodeType == Node.TEXT_NODE:
                            if Misc.lineSepToLineFeed(getElementText(delLinebreakNode, false)) == "\n":
                                parent.removeChild(delLinebreakNode)
                del delNode
                del delLinebreakNode
                
        except AttributeError:
            # no tagName
            pass
            
    #clean from attributes, if ignore tag@attr is specified
    if node.attributes:
        for att in node.attributes.keys():
            # print "Att:", att
            try:
                if todrop.has_key(node.tagName + '@' + att):
                    del node.attributes[att]
            except AttributeError:
                # no tagName
                pass

    for child in node.childNodes:
        prune(child) 

error = 0
origFile = rc.lookup("originalFile")
origHandle = open(origFile)
origDom = None
try:
    origDom = xml.dom.minidom.parse(origHandle)
except:
    rc.logError("Original file '" + rc.lookup("originalFile") + "' has a non valid XML structure!")
    error = 1
origHandle.close()

compFile = rc.lookup("compareFile")
compHandle = open(compFile)
compDom = None
try:
    compDom = xml.dom.minidom.parse(compHandle)
except:
    rc.logError("Comparison file '" + rc.lookup("compareFile") + "' has a non valid XML structure!")
    error = 1
compHandle.close()

if compDom != None and origDom != None:
    prune(origDom)
    #hdl = open(origFile + "2", "w")
    #hdl.write(origDom.saveXML(None))
    #hdl.close()
    prune(compDom)
    #hdl = open(compFile + "2", "w")
    #hdl.write(compDom.saveXML(None))
    #hdl.close()

    # check whether to remove indent whitespaces (not tested)
    if rc.getBool("stripWhitespace"):
        def stripWhitespace(node):
            for child in node.childNodes:
                if child.nodeType == Node.ELEMENT_NODE:
                    stripWhitespace(child)
                elif child.nodeType == Node.TEXT_NODE:
                    if child.nodeValue:
                        child.nodeValue = child.nodeValue.strip()
        stripWhitespace(origDom)
        stripWhitespace(compDom)
    
    # check whether to "normalize"/ignore the xml namespace
    def removeNamespaceAttrs(node):
        # remove namespace from current node
        try:
            deleteAttr = []
            for attr in node.attributes.values():
                if attr.nodeName == "xmlns" or attr.nodeName.startswith("xmlns:"):
                    deleteAttr.append(attr)
            for attr in deleteAttr:
                node.removeAttribute(attr.nodeName)
        except: # no attrs.
            pass
        # check next nodes
        for child in node.childNodes:
            removeNamespaceAttrs(child)
    if rc.lookup("xmlNamespace") == "ignore":
        # remove all namespaces from the xml
        def stripNamespaces(node):
            # remove current nodes namespace
            try:
                if node.tagName.find(":"):
                    node.tagName = node.tagName.split(":")[-1]
            except: # wrong node type
                pass
            # do the same for all subchildren
            for child in node.childNodes:
                stripNamespaces(child)
        stripNamespaces(origDom)
        stripNamespaces(compDom)
        removeNamespaceAttrs(origDom)
        removeNamespaceAttrs(compDom)
    elif rc.lookup("xmlNamespace") == "normalize":
        # normalize all namespaces
        def normalizeNamespaces(node, seenNamespaces={}):
            # save the current nodes namespace
            try:
                for attr in node.attributes.values():
                    if attr.nodeName.startswith("xmlns:"):
                        seenNamespaces.update({attr.nodeName[6:]:attr.nodeValue})
            except: # no attributes
                pass
            # normalize current nodes namespace
            try:
                if node.tagName.find(":"):
                    try:
                        splits = node.tagName.split(":")
                        node.tagName = seenNamespaces[splits[0]] + ":" + ":".join(splits[1:])
                    except: # no namespace
                        pass
            except: # wrong node type
                pass
            # do the same for all subchildren
            for child in node.childNodes:
                normalizeNamespaces(child)
        normalizeNamespaces(origDom)
        normalizeNamespaces(compDom)
        removeNamespaceAttrs(origDom)
        removeNamespaceAttrs(compDom)
    
    # check whether to sort both files before checking trees?
    if rc.getBool("sort"):
        def nodeComparingFunction(node1, node2):
            # sort by xml representation
            return 1 if node1.toxml() &gt; node2.toxml() else \
                    (-1 if node1.toxml() &lt; node2.toxml() else 0)
        
        # a function to sort the whole xml tree
        def sortXmlNode(node):
            # get the number of childrens
            # if this node has no child nodes, it is already sorted, and we have nothing to do.
            if not node.hasChildNodes: return node
            # ok, definatelly at least one subnode, sort subnodes first
            for n in node.childNodes:
                sortXmlNode(n)
            # the nasty thing about minidom is, that it has no default sort, and that one should not change node.childNodes 
            # save all children
            children = [ child for child in node.childNodes ]
            # now remove all children
            for child in node.childNodes: node.removeChild(child)
            # now sort all children
            children = sorted(children, cmp=nodeComparingFunction)
            # and (re)append children (in sorted order)
            for child in children: node.appendChild(child)
            # return sorted (sub)tree
            return node
        
        # sort both file trees
        origDom, compDom = sortXmlNode(origDom), sortXmlNode(compDom)
    
    # just normalize ...
    origDom.normalize()
    compDom.normalize()
    # and compare
    checkNode(origDom, compDom)
else:
    if error == 0:
        rc.logError("An unexpected error occurred during reading XML files!")</code>
              </ServerScriptStep>
              <ElseifSequence id="_2Ydk" name="Use Sax"
                              test="&#34;$(technology)&#34; == &#34;sax&#34; or &#34;$(technology)&#34; == &#34;auto&#34; or &#34;$(technology)&#34; == &#34;&#34;">
                <ServerScriptStep id="_2Ydl" name="compare files using sax">
                  <code>import threading, Queue, time, xml.sax
from java.util.regex import Matcher, Pattern
import java.util.concurrent as concurrentLinkedQueue
from java.util import TreeSet, Comparator
from itertools import izip as izip
from os.path import exists

#The thread for parsing a XML Document
class SaxThread(threading.Thread):

    def __init__(self, fileName, handler, errorQueue):
        threading.Thread.__init__(self)
        self.fileName = fileName
        self.handler = handler
        self.errorQueue = errorQueue
             
    def run(self):
        #add XMLHandler and ErrorHandler to the parser and start Parsing the Document        
        parser = xml.sax.make_parser()    
        parser.setErrorHandler(XMLErrorHandler(self.fileName, self.errorQueue))
        parser.setContentHandler(self.handler)
        try:
            parser.parse(rc.lookup(self.fileName))
        #FinishParsing Exception is only thrown if endProgram is set to True, so an Error thats Handeld by Error Handler occured
        except FinishParsing:
            pass
        except Exception as error:
            print ("Error: " ,error)
            self.errorQueue.put(error)

#Objekt including the content of Nodes
class ContentObject:

    def __init__(self, *args):
        self.type = args[0]
        if len(args) &gt; 1:
            self.startLineNum = args[1]
            self.endLineNum = args[2]
            self.level = args[3]
            self.childNodes = args[4]
            self.nodeName = args[5]
            if len(args) == 7:
                self.content = args[6]
                self.attrName = EMPTY
            elif len(args) == 8:
                self.attrName = args[6]
                self.content = args[7]
            else:
                self.content = EMPTY
                self.attrName = EMPTY
    
    def concatenateContent(self):
        return self.nodeName + " " + self.attrName + " " + self.content
    
    def concatenateAll(self):
        return str(self.level) + " " + str(self.childNodes) + " " + self.nodeName + " " + self.attrName + " " + self.content
    
    def conctenateWithoutContent(self):
        return str(self.level) + " " + str(self.childNodes) + " " + self.nodeName + " " + self.attrName
    
    def getLineNum(self):
        if self.endLineNum == self.startLineNum:
            return str(self.endLineNum)
        else:
            return str(self.startLineNum)+ "-" + str(self.endLineNum)

class ContentTreeSet:

    def __init__(self):
        self.startNode = TreeSet(COMPARATOR)
        self.content = TreeSet(COMPARATOR)
        self.childNodes = None
        self.endNode = None
     
    def addChildNodes(self, childNode):
        try:
            if self.childNodes is None:
                self.childNodes = TreeSet(COMPARATOR)
            self.childNodes.add(childNode)
        except Exception as error:
            print ("Error: " ,error)
            
class ContentComparator(Comparator):
    #Compare the elements of both trees to sort them
    def compare(self, origObj, compObj):
        #Check the result, because if elements are the same, they won't be sorted into the result
        comp = self.compareObjects(origObj, compObj)
        if comp == 0:
            return 1
        return comp
    
    #Compare Methode for content Objects
    def compareContent(self, origObj, compObj):
        if origObj.nodeName &gt; compObj.nodeName:
            return 1
        if origObj.nodeName &lt; compObj.nodeName:
            return -1
        elif origObj.attrName &gt; compObj.attrName:
            return 1
        elif origObj.attrName &lt; compObj.attrName:
            return -1
        elif origObj.content &gt; compObj.content:
            return 1
        elif origObj.content &lt; compObj.content:
            return -1
        return 0
    
    #Helper Method for compare
    def compareObjects(self, origObj, compObj):
        if isinstance(origObj, ContentObject) and isinstance(compObj, ContentObject):
            if (origObj.type != "start" and compObj.type == "start"):
                return 1
            return self.compareContent(origObj, compObj)
        elif isinstance(origObj, ContentTreeSet) and isinstance(compObj, ContentTreeSet):
            for orig,comp in izip(origObj.startNode,compObj.startNode):
                res = self.compareObjects(orig, comp)
                if res != 0:
                    return res
            if origObj.startNode.size() &gt; compObj.startNode.size():
                return -1
            elif origObj.startNode.size() &lt; compObj.startNode.size():
                return 1
            #Compare the content if startNode ist equal
            for orig,comp in izip(origObj.content,compObj.content):
                res = self.compareObjects(orig, comp)
                if res != 0:
                    return res
            if origObj.content.size() &gt; compObj.content.size():
                return -1
            elif origObj.content.size() &lt; compObj.content.size():
                return 1
            #Compare the childNodes if startNode and content ist equal
            if not origObj.childNodes is None and not compObj.childNodes is None:
                for orig,comp in izip(origObj.childNodes,compObj.childNodes):
                    res = self.compareObjects(orig, comp)
                    if res != 0:
                        return res
                if origObj.childNodes.size() &gt; compObj.childNodes.size():
                    return -1
                elif origObj.childNodes.size() &lt; compObj.childNodes.size():
                    return 1
            return 0
        return 0

#Thread that compares the both Queues filled by the SaxThread
class CompareThread(threading.Thread):

    def __init__(self, stopAtFirstDiff, originalFileQueue, compareFileQueue, errorQueue):
        threading.Thread.__init__(self)
        self.stopAtFirstDiff = stopAtFirstDiff
        self.originalFileQueue = originalFileQueue
        self.compareFileQueue = compareFileQueue
        self.errorQueue = errorQueue
    
    def errorMessages(self, origItem, compItem):
        if origItem.type != compItem.type and not state.endProgram:
            self.errorQueue.put("Not equal Nodes '" + origItem.nodeName + "' in original file line '" + origItem.getLineNum() + "' and '" + compItem.nodeName + "' in new file line '" + compItem.nodeName * "'")
        elif (origItem.type == "start" and compItem.type == "start" and origItem.nodeName != compItem.nodeName and not state.endProgram):
            self.errorQueue.put("Could not find tag '" + origItem.nodeName + "' in line '"+ origItem.getLineNum() + "' of compare file at position '" + str(origItem.childNodes) +"'. Found '" + compItem.nodeName + "' in line '" + compItem.getLineNum() + "' instead!")
        elif (origItem.type == "end" or compItem.type == "end") and not state.endProgram:
            self.errorQueue.put("Not equal Nodes '" + origItem.nodeName + "' in original file line '" + origItem.getLineNum() + "' and '" + compItem.nodeName + "' in new file line '" + compItem.getLineNum() + "'.")
        elif ((origItem.type == "cont" or origItem.type == "comm") and (compItem.type == "cont" or compItem.type == "comm")) and not state.endProgram:
            self.errorQueue.put("Not equal elements in line '"+ origItem.getLineNum() +"' of original file: '" + origItem.nodeName + "'='" + origItem.content + "' and in line '" + compItem.getLineNum() +"' of new file '" + compItem.nodeName + "'='" + compItem.content + "'")
        elif (origItem.nodeName == compItem.nodeName and origItem.attrName == compItem.attrName and not state.endProgram):
            self.errorQueue.put("Attribute '" + origItem.attrName + "' of the original node '" + origItem.nodeName + "' in line '" + origItem.getLineNum() +"' has value '" + origItem.content + "', but the compare one in line '"+ compItem.getLineNum()+"' has value '" + compItem.content + "'")
        elif (origItem.nodeName == compItem.nodeName and origItem.attrName != compItem.attrName and not state.endProgram):
            self.errorQueue.put("Attribute '" + origItem.attrName + "' of the original node '" + origItem.nodeName + "' in line '"+ origItem.getLineNum()+"' cannot be found in compare node.")
        elif not state.endProgram:
            self.errorQueue.put("Not equal elements in line '"+origItem.getLineNum()+"' of original file: '" + origItem.nodeName + "'='" + origItem.content + "' and in line '" + compItem.getLineNum()+"' of new file '" + compItem.nodeName + "'='" + compItem.content + "'")

    def poll(self, treeStack):
        nextElement = treeStack[-1]
        if (isinstance(nextElement, ContentTreeSet)):
            if not nextElement.startNode.isEmpty():
                treeStack.append(nextElement.startNode.pollFirst())
            elif not nextElement.childNodes is None:
                treeStack.append(nextElement.childNodes.pollFirst())
                if nextElement.childNodes.size() == 0:
                    nextElement.childNodes = None
            elif not nextElement.content.isEmpty():
                treeStack.append(nextElement.content.pollFirst())
            elif not nextElement.endNode is None:
                treeStack.append(nextElement.endNode)
                nextElement.endNode = None
            else:
                treeStack.pop()
            return self.poll(treeStack)
        elif (isinstance(nextElement, ContentObject)):
            treeStack.pop()
            return nextElement
        else:
            return None

    #removes items from one queue
    def removeQueueItems(self, queue, wantedLevel):
        while True and not state.endProgram:
            try:
                if sort:
                    if queue[0].endNode is None:
                        stopComparing = True
                        return item
                item = None
                while item is None:
                    if sort:
                        item = self.poll(queue)
                    else:
                        item = queue.poll()
                if not sort:
                    if item.type == "stop":
                        stopComparing = True
                        return item
                if item.level == wantedLevel and item.type == "end" and not state.endProgram:
                    return item               
            except Exception as err:
                stopComparing = True
                return ContentObject("stop")
                
    def run(self):
        stopComparing = False
        if sort:
            self.originalFileQueue = [self.originalFileQueue.pop()]
            self.compareFileQueue = [self.compareFileQueue.pop()]
        while not stopComparing and not state.endProgram:
            try:
                if sort:
                    if self.originalFileQueue[0].endNode is None or self.compareFileQueue[0].endNode is ContentObject:
                        raise FinishParsing
                origItem = None
                compItem = None
                while origItem is None or compItem is None:
                    #get both Elements from the Queue, if nothing is found after 100 seconds, an Exception is thrown
                    if origItem is None:
                        if sort:
                            origItem = self.poll(self.originalFileQueue)
                        else:
                            origItem = self.originalFileQueue.poll()
                        origItemSave = origItem
                    if compItem is None:
                        if sort:
                            compItem = self.poll(self.compareFileQueue)
                        else:
                            compItem = self.compareFileQueue.poll()
                        compItemSave = compItem    
                if not sort:
                    if origItem.type == "stop" or compItem.type == "stop":
                        raise FinishParsing
            except Exception as err:
                #If endProgram is not empty then the parser was stopped manually and the comparing has to be stopped.
                #If not then something went wrong, all Threads have to be terminated and an Exception has to be thrown
                if sort:
                    if (state.endProgram or self.originalFileQueue[0].endNode is None or self.compareFileQueue[0].endNode is None):
                        stopComparing = True
                elif not sort:
                    if (state.endProgram or origItem.type == "stop" or compItem.type == "stop"):
                        stopComparing = True
                elif not state.endProgram:
                    state.endProgram = True
                    self.errorQueue.put("Couldn't find new content for 100 seconds")
                    endAllThreads()
                    break  
            #if content is not the same, look what kind of difference it is and log corresponding error,
            if ((sort and origItem.concatenateContent() != compItem.concatenateContent()) or (not sort and origItem.concatenateAll() != compItem.concatenateAll())) and not state.endProgram and not stopComparing:
                if (((origItem.type == "end" and compItem.type == "end") and (compItem.level &lt; origItem.level or compItem.childNodes &lt; origItem.childNodes))
                    or (origItem.type != "end" and compItem.type == "end" or compItem.level &gt; origItem.level)): 
                    #remove all queue items until the end node is reached 
                    level = (origItem.level if compItem.type != "end" else compItem.level)
                    origItem = self.removeQueueItems(self.originalFileQueue, level)
                    if compItem.type != "end": compItem = self.removeQueueItems(self.compareFileQueue, level)
                elif (((origItem.type == "end" and compItem.type == "end") and (compItem.level &gt;= origItem.level or compItem.childNodes &gt;= origItem.childNodes)) 
                    or (compItem.type != "end" and origItem.type == "end" or compItem.level &lt; origItem.level)):   
                    level = (compItem.level if origItem.type != "end" else origItem.level)
                    compItem = self.removeQueueItems(self.compareFileQueue, level)
                    if origItem.type != "end":  origItem = self.removeQueueItems(self.originalFileQueue, level)
                else: 
                    level = (compItem.level if origItem.type != "end" else origItem.level)
                    if (sort and origItem.concatenateContent() != compItem.concatenateContent()) or (not sort and origItem.conctenateWithoutContent() != compItem.conctenateWithoutContent()): level = level-1
                    compItem = self.removeQueueItems(self.compareFileQueue, level)
                    if origItem.type != "end":  origItem = self.removeQueueItems(self.originalFileQueue, level)
                if (not compItem is None and not origItem is None) and (compItem.childNodes != origItem.childNodes):
                    self.errorQueue.put("The original node of tag '" + origItem.nodeName + "' in line '" + origItem.getLineNum() + "' has '" + str(origItem.childNodes) + "' child nodes and the node in the comparison file in line '" + compItem.getLineNum() + "' has '" + str(compItem.childNodes) + "' child nodes!")
                elif (not compItem is None and not origItem is None) and ((not sort and origItem.concatenateAll() != compItem.concatenateAll() and (origItemSave.level != compItemSave.level or origItemSave.childNodes != compItemSave.childNodes))):
                    self.errorQueue.put("The child Notes of original node of tag '" + origItem.nodeName + "' in line '" + origItem.getLineNum()+ "' have a different order than the node in the comparison file in line '" + compItem.getLineNum() + "'")
                else:
                    self.errorMessages(origItemSave, compItemSave)     
                if (self.stopAtFirstDiff and not state.endProgram) or origItem is None or compItem is None:
                    state.endProgram = True
                    return

#The Class that implements the parser and builds the content that will be compared        
class XMLHandler(xml.sax.ContentHandler):
 
    def __init__(self, current_content):
        self.locator = None
        self.lineNumberSE = []
        self.inNoCheckNode = ""
        self.current_content = current_content
        self.currentNode = []
        self.seenNamespaces = {}
        self.stillInNoCheck = False
        self.childsPerLevel = {0:0,1:0}
        self.contentCounter = 1
        self.levelCounter = 0
        self.contentSave = ""
           
    #setDocumentLocator is called at the very beginning of the Document and initiates the locator
    def setDocumentLocator(self, locator):
        self.locator = locator
            
    #startElement is called at the beginning of every Node
    #If endProgram is True then throw an Exception to stop parsing
    def startElement(self, name, attrs):
        if state.endProgram: raise FinishParsing
        #If contentSave is not empty then add it to the result Queue 
        if self.contentSave != "": self.addContent()     
        #change name if xmlNamespace has value ignore or normalize
        name = self.normalizeName(name)
        #Add current node counter to content, for ignoring child attributes when an error occures during compare
        self.contentCounter = 1
        self.currentNode.append(name) 
        self.levelCounter = self.levelCounter + 1
        saveContent = concurrentLinkedQueue.ConcurrentLinkedQueue()
        #Add current Line Number
        actLineNumber = self.locator.getLineNumber() 
        self.lineNumberSE.append(actLineNumber)
        self.stillInNoCheck = False               
        if todrop.has_key(name):
            self.inNoCheckNode = name
        elif self.inNoCheckNode == "":
            if stripWhitespace: 
                saveContent.add(ContentObject(STARTTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name.strip("\n\t ")))
            else:
                saveContent.add(ContentObject(STARTTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name))
        #If the node isn't in todrop then everything has to be compared
        if attrs.getLength() != 0 and self.inNoCheckNode == "":
            for attr, attrName in zip(attrs, attrs.getNames()):
                if attr != None and attrs != None and attrName != "xmlns" and not attrName.startswith("xmlns:"):
                    if stripWhitespace: 
                        saveContent.add(ContentObject(ATTRTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name.strip("\n\t "), attrName, attr))
                    else:
                        saveContent.add(ContentObject(ATTRTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name, attrName, attr))
                elif attrName.startswith("xmlns:") and xmlNamespace == "normalize":
                    self.seenNamespaces.update({attrName[6:]:attr})
        #If the node is in todrop it is possible that only some attributes/values have to be compared
        elif attrs.getLength() != 0 and todrop.get(name) != None:
            self.inNoCheckNode = ""
            if stripWhitespace: 
                saveContent.add(ContentObject(STARTTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name.strip("\n\t ")))
            else:
                saveContent.add(ContentObject(STARTTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name))
            for (attr, attrName) in zip(attrs, attrs.getNames()):
                if noCheck(name, attrs, attrName) == 0 and attrs.getValue(attrName) != "" and attrs != None and attrName != "xmlns" and not attrName.startswith("xmlns:"):                                       
                    if stripWhitespace: 
                        saveContent.add(ContentObject(ATTRTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name.strip("\n\t "), attrName, attrs.getValue(attrName)))
                    else:
                        saveContent.add(ContentObject(ATTRTYPE, actLineNumber, actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter-1), name, attrName, attrs.getValue(attrName)))
                #if noCheck is -1 then todrop value contains = or %= and the complete node has to be removed
                elif noCheck(name, attrs, attrName) == -1 and attrs.getValue(attrName) != "" and attrs != None and attrName != "xmlns" and not attrName.startswith("xmlns:"):   
                    saveContent = concurrentLinkedQueue.ConcurrentLinkedQueue()  
                    self.inNoCheckNode = name
                    break;
        #if inNoCheckNode is not empty then the Node is ignored and the child count of parent node will not be increased
        if self.inNoCheckNode == "" and self.levelCounter != 1:
            #for correct counting the child notes  
            for key, value in self.childsPerLevel.items():
                if key == self.levelCounter:
                    self.childsPerLevel.update({key: 0})
                elif key == self.levelCounter-1:
                    self.childsPerLevel.update({key: value + 1})
            if not self.levelCounter in self.childsPerLevel.keys():
                self.childsPerLevel.update({self.levelCounter: 0})
            if sort:
                subList = ContentTreeSet()
                self.current_content.append(subList)
        if not saveContent.isEmpty():
            for item in saveContent:
                if not sort:
                    self.current_content.add(item)
                else:
                    self.current_content[-1].startNode.add(item)
        saveContent = None
        
    #Characters is called if there is Text outside of an attribute.
    def characters(self, content):
        if state.endProgram: raise FinishParsing
        #if ignored node is finished then the \n has to be ignored 
        if self.contentCounter &lt; 2 and self.stillInNoCheck == False and not (stripWhitespace and content.strip("\n\t ") == ""):
            for key, value in self.childsPerLevel.items():
                if key == self.levelCounter:
                    self.childsPerLevel.update({key: value + 1})
        #Save the current content in an extra String, because if the content is very long the parser will call this method multiple times, but its not defined 
        #after what content length it will make the break
        if not (self.stillInNoCheck or todrop.has_key(self.currentNode[-1]) or self.inNoCheckNode != "") and content != "":
            if ((stripWhitespace and content.strip("\n\t ") != "") or not stripWhitespace) and self.contentSave == "" and self.contentCounter != -1: 
                    self.lineNumberSE.append(self.locator.getLineNumber())
            elif ((stripWhitespace and content.strip("\n\t ") != "") or not stripWhitespace) and self.contentSave != "": 
                    self.lineNumberSE.pop()
                    self.lineNumberSE.append(self.locator.getLineNumber())               
            if stripWhitespace and content.strip("\n\t ") != "": 
                self.contentSave += content.strip("\n\t ")
            elif stripWhitespace == False:
                self.contentSave += content
        #set contentCounter to 2 because if characters is called multiple times it will again be countet as a child
        self.contentCounter = 2
    
    #Method if comment appears. if compareComments is set to true then the text of the comment s also compared. If not it is only compared weather there is a comment or not
    def comment(self, comment):
        if state.endProgram: raise FinishParsing
        #if inNoCheck is empty set stillInContent to false, because if theres a comment it has to be count as a child 
        if self.inNoCheckNode == "": self.stillInNoCheck = False
        if self.contentSave != "": self.addContent()     
        if self.stillInNoCheck == False:
            for key, value in self.childsPerLevel.items():
                if key == self.levelCounter:
                    self.childsPerLevel.update({key: value + 1})
        actLineNumber = self.locator.getLineNumber()
        if rc.getBool("compareComments"):
            if not (self.stillInNoCheck or todrop.has_key(self.currentNode[-1]) or self.inNoCheckNode != "") and comment != "":
                if not sort:
                    if stripWhitespace and comment.strip("\n\t ") != "": 
                        self.current_content.add(ContentObject("comm", self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1].strip("\n\t "), comment.strip("\n\t ")))
                    elif stripWhitespace == False:
                        self.current_content.add(ContentObject("comm", self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1], comment))
                else:
                    if stripWhitespace and comment.strip("\n\t ") != "": 
                        self.current_content[self.levelCounter-1].content.add(ContentObject("comm", self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1].strip("\n\t "), comment.strip("\n\t ")))
                    elif stripWhitespace == False:
                        self.current_content[self.levelCounter-1].content.add(ContentObject("comm", self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1], comment))
        self.contentCounter = -1
        self.lineNumberSE.append(self.locator.getLineNumber())
       
    #Method called at the End of a node.
    def endElement(self, name):
        if state.endProgram: raise FinishParsing
        if self.contentSave != "": self.addContent()     
        actLineNumber = self.locator.getLineNumber() 
        name = self.normalizeName(name)
        #If the end node is in todrop then empty the Variable. For correct ignoring content, stillInNoCheck is set to True.
        if self.inNoCheckNode != "" and todrop.has_key(name):
            self.inNoCheckNode = ""
            self.stillInNoCheck = True
        elif self.inNoCheckNode == "":
            if not sort:
                if stripWhitespace: 
                    self.current_content.add(ContentObject(ENDTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), name.strip("\n\t ")))
                else:
                    self.current_content.add(ContentObject(ENDTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), name))
            else:
                if stripWhitespace: 
                    self.current_content[-1].endNode = ContentObject(ENDTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), name.strip("\n\t "))
                else:
                    self.current_content[-1].endNode = ContentObject(ENDTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), name)
            for key, value in self.childsPerLevel.items():
                if key &gt; self.levelCounter:
                    self.childsPerLevel.pop(key)
            if self.levelCounter &gt; 1 and sort:
                self.current_content[-2].addChildNodes(self.current_content.pop())
        self.currentNode.pop()
        self.lineNumberSE.pop()
        self.levelCounter = self.levelCounter - 1
        self.contentCounter = 1
         
    #Method only called at the very End of the Document. Add "None" to the Query so the Compare Thread nows the Document is finished. 
    def endDocument(self):
        if state.endProgram: raise FinishParsing
        if not sort:
            self.current_content.add(ContentObject("stop",0,0,0,0,"stop"))

    #look wether name has namespace and xmlNamespace has a valid value     
    def normalizeName(self, name):
        if xmlNamespace == "ignore" and name.find(":") != -1:
            name = name.split(":")[-1]
        elif xmlNamespace == "normalize" and name.find(":") != -1 and self.seenNamespaces:
            splits = name.split(":")
            name = self.seenNamespaces[splits[0]] + ":" + ":".join(splits[1:])
        return name
    
    #Add Content to the result Queue
    def addContent(self):
        actLineNumber = self.lineNumberSE.pop()
        #if self.lineNumberSE[-1] != actLineNumber:
        #    actLineNumber = self.lineNumberSE[-1] + "-" + actLineNumber
        if not sort:
            if stripWhitespace and self.contentSave.strip("\n\t ") != "": 
                self.current_content.add(ContentObject(CONTTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1].strip("\n\t "), self.contentSave))
            elif stripWhitespace == False:
                self.current_content.add(ContentObject(CONTTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1], self.contentSave))
        else:
            if stripWhitespace and self.contentSave.strip("\n\t ") != "": 
                self.current_content[self.levelCounter-1].content.add(ContentObject(CONTTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1].strip("\n\t "), self.contentSave))
            elif stripWhitespace == False:
                self.current_content[self.levelCounter-1].content.add(ContentObject(CONTTYPE,self.lineNumberSE[-1],actLineNumber, self.levelCounter, self.childsPerLevel.get(self.levelCounter), self.currentNode[-1], self.contentSave))
        self.contentSave = ""

        
#If an Error occures, that would stop the parser, then end all other Threads and throw an Exception
class XMLErrorHandler(xml.sax.ErrorHandler):
    
    def __init__(self, fileName, errorQueue):
        self.errorQueue = errorQueue
        self.fileName = fileName

    def error(self, exception):
        state.endProgram = True
        self.errorQueue.put(exception.getMessage)
        endAllThreads()

    def fatalError(self, exception):
        state.endProgram = True
        if isinstance(exception, xml.sax.SAXParseException):
            self.errorQueue.put("Error in " + exception.getSystemId() + " in line " + str(exception.getLineNumber()) + ":\n" + exception.getMessage())
        else:
            self.errorQueue.put(exception.getLineNumber())
        endAllThreads()

    def warning(self, exception):
        self.errorQueue.put(str(exception))

#Exception that is thrown if endProgram is set to true before finish parsing    
class FinishParsing(Exception):
    pass

class StateOfProgram:

    def __init__(self, endProgram):
        self.endProgram = endProgram

#If toignore contains a vlaue of a node    
def noCheck(name, attrs, node):
    for i in todrop.items():
        if i[0] == name and i[1] != None:
            if isinstance(i[1], unicode):
                res = evaluateNoCheck(i[1], attrs, node)
                if res != 0:
                    return res
            elif isinstance(i[1], list):
                for j in i[1]:
                    res = evaluateNoCheck(j, attrs, node)
                    if res != 0:
                        return res
    return 0

#If noCheck Attribute has special values to be ignored, go through toIgnore to look if the actual attribute is the one to be ignored
#0 if item is not found, 1 if item is specofied without value, -1 if item is specified with value (contains = or =%)
def evaluateNoCheck(item, attrs, node):
    if node == item:
        return 1
    elif item.find("=%") != -1:
        parts = item.split("=%")
        if parts[0] == node and Pattern.compile(parts[1]).matcher(attrs.getValue(node)).matches():
            return -1
    elif item.find("=") != -1:
        parts = item.split("=")
        if parts[0] == node and parts[1] == attrs.getValue(node):
            return -1
    return 0

#Iterate throug all Threads and wait for them to end
def endAllThreads():
    for t in allThreads:
        try:
            if t != threading.currentThread():
                t.join()
        except Exception as err:
            errorQueue.put(err)
            
#Analyze the given Attributes that wont be checked
todrop = {}
for i in rc.lookup("noCheck").split(","):
    if todrop.has_key(i):
        if todrop.get(i) != None:
            todrop.update({i : None})
    elif i.find("@") != -1 and todrop.has_key(i.split("@")[0]):
        name = i.split("@")
        if todrop.get(name[0]) != None:
            todrop.update({name[0] : [todrop.get(name[0]), name[1]]}) 
    elif i.find("@") != -1:
        for j in i.split("@"):
            todrop[i] = j.strip()
        todrop[i[0:i.find("@")]] = todrop.pop(i)
    else:
        todrop.setdefault(i)
          
#define Variables
xmlNamespace = rc.lookup("xmlNamespace")
stripWhitespace = rc.getBool("stripWhitespace")
sort = rc.getBool("sort")
stopAtFirstDiff = rc.getBool("stopAtFirstDiff")
state = StateOfProgram(False)
errorQueue = Queue.Queue()

#initialize constants
STARTTYPE = "start"
ATTRTYPE = "attr"
CONTTYPE = "cont"
ENDTYPE = "end"
EMPTY = ""

if exists(rc.lookup("originalFile")) and exists(rc.lookup("compareFile")):
    if sort:
        COMPARATOR = ContentComparator()
        
        originalFileQueue = [ContentTreeSet()]
        compareFileQueue = [ContentTreeSet()]

        #create both parsing threads
        originalFileThread = SaxThread("originalFile", XMLHandler(originalFileQueue), errorQueue)
        compareFileThread = SaxThread("compareFile", XMLHandler(compareFileQueue), errorQueue)
        #ceate a third thread to compare both parsers
        compareThread = CompareThread(stopAtFirstDiff, originalFileQueue, compareFileQueue, errorQueue)
        #for better handling, save Threads in Array
        allThreads = [originalFileThread, compareFileThread]
        for thread in allThreads:
            thread.start()
        endAllThreads()
        compareThread.start()
        compareThread.join()
    else:
        originalFileQueue = concurrentLinkedQueue.ConcurrentLinkedQueue()
        compareFileQueue = concurrentLinkedQueue.ConcurrentLinkedQueue()
    
        #create both parsing threads
        originalFileThread = SaxThread("originalFile", XMLHandler(originalFileQueue), errorQueue)
        compareFileThread = SaxThread("compareFile", XMLHandler(compareFileQueue), errorQueue)
        #ceate a third thread to compare both parsers
        compareThread = CompareThread(stopAtFirstDiff, originalFileQueue, compareFileQueue, errorQueue)
        #for better handling, save Threads in Array
        allThreads = [originalFileThread, compareFileThread, compareThread]
        for thread in allThreads:
            thread.start()
        endAllThreads()
elif not exists(rc.lookup("originalFile")):
    raise IOError("No such file or directory: u'" + rc.lookup("originalFile")+"'")
elif not exists(rc.lookup("compareFile")):
    raise IOError("No such file or directory: u'" + rc.lookup("compareFile")+"'")
    
#log all errors that occured during the compare
while not errorQueue.empty():
    rc.logError(errorQueue.get())</code>
                </ServerScriptStep>
              </ElseifSequence>
              <ElseSequence id="_2YdI">
                <ThrowStep id="_2Ydm"
                           throwmessage="Invalid parameter technology with value &#34;$(technology)&#34;"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1lVM" name="loadPropertiesFromXML">
            <variable name="file"/>
            <variable name="group"/>
            <variable name="includeAttributes">True</variable>
            <comment>Load properties from an XML file. Property names are created from the node hierarchy and separated by a '.' or '.@' respectively (in case of an attribute), for example:

  ${group:root.first.second}=Text of this node
  ${group:root.first.@id}=Value of the id attribute

@param	file	    The name of the XML file.
@param	group	    The name of the properties group.
@param	includeAttributes Whether to define attributes as variables too.

@author	QFS
@since	3.5, rl
</comment>
            <ServerScriptStep id="_1lVN">
              <code>from xml.dom.minidom import parse

def setProperties(node, group):
    node.normalize()
    qualifier = ""
    if node.nodeType == node.ELEMENT_NODE:
        parent = node.parentNode
        while parent and parent != node.ownerDocument:
            qualifier = parent.nodeName + "." + qualifier
            parent = parent.parentNode
        if $(includeAttributes):
            attribs = node.attributes
            for i in range(attribs.length):
                attr = attribs.item(i)
                name = qualifier + node.nodeName + ".@" + attr.nodeName
                rc.setProperty(group, name, attr.nodeValue)
    if node.nodeType == node.ELEMENT_NODE \
    and node.firstChild \
    and node.firstChild.nodeType == node.TEXT_NODE \
    and node.firstChild == node.lastChild:
        name = qualifier + node.nodeName
        rc.setProperty(group, name, node.firstChild.nodeValue)
    for c in node.childNodes:
        setProperties(c, group)

filename = rc.lookup("file")
group = rc.lookup("group")
if not group:
    raise UserException("The group must not be empty")
doc = parse(filename)
rc.clearProperties(group) # QF-Test 3.5
#props = rc.getProperties(group)
#if props:
#    props.clear()
setProperties(doc.documentElement, group)
doc.unlink()
</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Procedure id="_2K1S" name="click">
          <variable name="id">SCREEN</variable>
          <variable name="x">-</variable>
          <variable name="y">-</variable>
          <variable name="mouseModifier">16</variable>
          <variable name="nrTimes">1</variable>
          <variable name="keyModifier">0</variable>
          <comment>Perform a mouse click somwhere on the screen or onto a given component.

@param id          The QF-Test component ID of the source to click on or SCREEN.
@param x            The x coordinate of the click. Use "-" to replay a click on the center of the source.
@param y            The y coordinate of the click. Use "-" to replay a click on the center of the source.
@param mouseModifier     The mouse modifier: 16 - left click, 4 - right click
@param nrTimes           The number of times that the click gets executed (set to 2 in order to replay a double click)
@param keyModifier    Whether to press a modifier key during the operation: 1 - SHIFT, 2 - CTRL, 3 - SHIFT+CTRL, 4 - CMD, 8 - ALT

@author	QFS,ys
@since	4.7.0
</comment>
          <ProcedureCall id="_2K1U" local="true"
                         procedure=".getBoundsOnScreen" retvarname="bounds">
            <variable name="client">$(client)</variable>
            <variable name="id">$(id)</variable>
          </ProcedureCall>
          <ServerScriptStep id="_2K1W" name="click">
            <code>from java.awt.event import InputEvent, KeyEvent
from java.awt import Robot
import time

def parse(s, wh):
    s = s.strip()
    if s == "-": return wh / 2
    return float(s)

x, y, w, h = [float(x) for x in rc.lookup("bounds").split(",")]
x += parse(rc.lookup("x"), w)
y += parse(rc.lookup("y"), h)
keyModifier = rc.getInt("keyModifier")
mouseModifier = rc.getInt("mouseModifier")
nrTimes = rc.getInt("nrTimes")

pressShift = keyModifier &amp; InputEvent.SHIFT_MASK
pressCtrl = keyModifier &amp; InputEvent.CTRL_MASK
pressAlt = keyModifier &amp; InputEvent.ALT_MASK
pressCmd = keyModifier &amp; InputEvent.META_MASK
shiftPressed = False
ctrlPressed = False
altPressed = False
cmdPressed = False

r = Robot()
r.setAutoDelay(50)

x, y = int(x), int(y)
if ${qftest:windows}:
    # move to coordinate 0,0 first. See &lt;https://stackoverflow.com/questions/48799393/robot-mousemove-not-moving-to-specified-location-properly&gt; for why.
    r.mouseMove(0, 0)
r.mouseMove(x, y)

try:
    if pressShift:
        shiftPressed = True
        r.keyPress(KeyEvent.VK_SHIFT)
    if pressCtrl:
        ctrlPressed = True
        r.keyPress(KeyEvent.VK_CONTROL)
    if pressAlt:
        altPressed = True
        r.keyPress(KeyEvent.VK_ALT)
    if pressCmd:
        cmdPressed = True
        r.keyPress(KeyEvent.VK_META)

    if not ${qftest:windows} and (shiftPressed or ctrlPressed):
        time.sleep(0.5)

    for i in range(nrTimes):
        r.mousePress(mouseModifier)
        r.mouseRelease(mouseModifier)

    if not ${qftest:windows} and (shiftPressed or ctrlPressed):
        time.sleep(0.5)

finally:
    try:
        if shiftPressed: r.keyRelease(KeyEvent.VK_SHIFT)
    finally: pass
    try:
        if ctrlPressed: r.keyRelease(KeyEvent.VK_CONTROL)
    finally: pass
    try:
        if altPressed: r.keyRelease(KeyEvent.VK_ALT)
    finally: pass
    try:
        if cmdPressed: r.keyRelease(KeyEvent.VK_META)
    finally: pass</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.utils.createThreadDump" name="createThreadDump"
                   uid="_1kHa">
          <comment>Trigger a full thread dump in the SUT if possible.

@param client	The name of the SUT client.

@author	QFS
@since	3.4</comment>
          <ServerScriptStep id="_9++">
            <code>from de.qfs.apps.qftest import ScriptAccess
ScriptAccess.triggerThreadDump(rc.context, rc.lookup("client"))</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1oNA" name="dragAndDrop">
          <variable name="source"/>
          <variable name="target"/>
          <variable name="fromX"/>
          <variable name="fromY"/>
          <variable name="toX"/>
          <variable name="toY"/>
          <variable name="fromClient"/>
          <variable name="toClient"/>
          <variable name="modifier"/>
          <variable name="eventDelay">50</variable>
          <comment>Drag the source component or item onto the target and drop it.

@param source   The QF-Test component ID of the source or SCREEN
@param target    The QF-Test component ID of the target or SCREEN
@param fromX    An X-offset when starting to drag the source
@param fromY    A Y-offset when starting to drag the source
@param toX    An X-offset when dropping on the target
@param toY    A Y-offset when dropping on the target
@param fromClient    The name of the source's client
@param toClient        The name of the target's client
@param modifier    Whether to press a modifier key during the operation: 17 - SHIFT, 18 - CTRL, 19 - SHIFT+CTRL
@param eventDelay The amount of milliseconds to wait between each inserted event. High values ensure that the SUT has the time to respond to every event generated while low values will speedup the replay. Default is 50.

@author	QFS,rl
@since	4.0.5
</comment>
          <ServerScriptStep id="_1oUQ" name="set parameters">
            <code>if not rc.lookup("fromClient") and rc.lookup("source") != "SCREEN":
    rc.setLocal("fromClient", rc.lookup("client"))
if not rc.lookup("toClient") and rc.lookup("target") != "SCREEN":
    rc.setLocal("toClient", rc.lookup("client"))
if not rc.lookup("modifier"):
    rc.setLocal("modifier", "16")
</code>
          </ServerScriptStep>
          <ProcedureCall id="_1oNd" local="true"
                         procedure=".getBoundsOnScreen" retvarname="from">
            <variable name="id">$(source)</variable>
            <variable name="client">$(fromClient)</variable>
          </ProcedureCall>
          <ProcedureCall id="_1oNe" local="true"
                         procedure=".getBoundsOnScreen" retvarname="to">
            <variable name="id">$(target)</variable>
            <variable name="client">$(toClient)</variable>
          </ProcedureCall>
          <ServerScriptStep id="_1oNG" name="drag and drop">
            <code>from java.awt.event import InputEvent, KeyEvent
from java.awt import Robot
import time, math

def interpolateMove(r, x0, y0, x1, y1, step):
    dx, dy = x1 - x0, y1 - y0
    steps = int(math.floor(math.sqrt(dx * dx + dy * dy) / step))
    for i in range(1, steps):
        x = x0 + dx * i / steps
        y = y0 + dy * i / steps
        r.mouseMove(x, y)
    r.mouseMove(x1, y1)


parts = rc.lookup("from").split(",")
x0, y0, w0, h0 = int(parts[0]), int(parts[1]), int(parts[2]), int(parts[3])
parts = rc.lookup("to").split(",")
x1, y1, w1, h1 = int(parts[0]), int(parts[1]), int(parts[2]), int(parts[3])

if not rc.lookup("fromX"):
    rc.setLocal("fromX", w0 / 2)
if not rc.lookup("fromY"):
    rc.setLocal("fromY", h0 / 2)
if not rc.lookup("toX"):
    rc.setLocal("toX", w1 / 2)
if not rc.lookup("toY"):
    rc.setLocal("toY", h1 / 2)

modifier = rc.getInt("modifier")

r = Robot()
r.setAutoDelay(rc.getInt("eventDelay"))
x = x0 + rc.getNum("fromX")
y = y0 + rc.getNum("fromY")
r.mouseMove(x, y)
if not ${qftest:windows}:
    r.mousePress(InputEvent.BUTTON1_MASK)
    r.mouseRelease(InputEvent.BUTTON1_MASK)
    time.sleep(1)
interpolateMove(r, x + 5, y + 5, x, y, 1)
r.mousePress(InputEvent.BUTTON1_MASK)
if modifier &amp; InputEvent.SHIFT_MASK:
    r.keyPress(KeyEvent.VK_SHIFT)
if modifier &amp; InputEvent.CTRL_MASK:
    r.keyPress(KeyEvent.VK_CONTROL)
interpolateMove(r, x, y, x + 5, y + 5, 1)
xs, ys = x + 5, y + 5
x = x1 + rc.getNum("toX")
y = y1 + rc.getNum("toY")
interpolateMove(r, xs, ys, x + 5, y + 5, 10)
interpolateMove(r, x + 5, y + 5, x, y, 1)
time.sleep(0.5)
r.mouseRelease(InputEvent.BUTTON1_MASK)
time.sleep(1)
if modifier &amp; InputEvent.SHIFT_MASK:
    r.keyRelease(KeyEvent.VK_SHIFT)
if modifier &amp; InputEvent.CTRL_MASK:
    r.keyRelease(KeyEvent.VK_CONTROL)
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1oHq" name="dumpComponents">
          <variable name="id">${id:someId}</variable>
          <variable name="visibleOnly">false</variable>
          <variable name="interestingOnly">false</variable>
          <variable name="filter"/>
          <variable name="dontcompactify">true</variable>
          <comment>Dump an entire component hierarchy into the run-log.

@param	id	The id of the component from which to start dumping.
@param	visibleOnly Whether to include only visible components, i.e. ignore all components that are not currently showing.
@param	interestingOnly Whether to include only "interesting" components, i.e. ignore all components that QF-Test would not record with the default option settings.
@param	filter	Optional comma-separated list of classes. If defined, dump only components of these classes or not of these classes, if filter is negated by preprending ^.
@param	dontcompactify Whether to prevent the resulting log entry from compactification.

@author	QFS,gs
@since	4.0.5

@ignoreanalyzerefcid</comment>
          <ClientScriptStep client="$(client)" engine="${default:engine:}"
                            id="_353">
            <code>import array, types
com = rc.getComponent(rc.lookup("id"))

if type(com) in [types.TupleType, array.array]:
    # An item that doesn't resolve to a component, use the parent instead
    com = com[0]

h = rc.engine.getHelper()
visibleOnly = rc.getBool("visibleOnly")
interestingOnly = rc.getBool("interestingOnly")
filter = rc.lookup("default", "filter:")
incl = True
if filter:
    if filter.startswith("^"):
        incl = False
        filter = filter[1:].split(",")
    else:
        filter = filter.split(",")


def dump(com, lines, depth=0, h=h):
    vis = h.isVisible(com)
    ign = (interestingOnly and not h.isInterestingParent(com)) or \
           visibleOnly and not vis
    flt = filter and not \
        ((incl and h.isMatchingClass(com, filter)) or \
         (not incl and not h.isMatchingClass(com, filter)))
    if not (ign or flt):
        try:
            pos = h.getLocation(com)
            pos = "%d,%d" % (pos.x, pos.y)
        except:
            pos = "-,-"
        try:
            size = h.getSize(com)
            try:
                size = "%dx%d" % (size.width, size.height)
            except:
                # Conflicting getSize methods in WidgetHelper
                size = "%dx%d" % (size.x, size.y)
        except:
            size = "-x-"
        try:
            spos = h.getLocationOnScreen(com)
            sloc = " s[%d,%d]" % (spos.x, spos.y)
        except:
            sloc=""
        cls = ",".join(h.getClassNames(com))
        vs = "" if vis else " [hidden]"
        lines.append("%s p[%s,%s]%s%s\n%s%s\n%s[%s]" % ("+"*depth, pos, size, sloc, vs, " "*depth, com, " "*depth, cls))
    for c in rc.engine.getHelper().getAdapter().getChildren(com):
        dump(c, lines, depth + 1)

lines = []
dump(com, lines)
rc.logMessage("\n".join(lines), dontcompactify=rc.getBool("dontcompactify"))

</code>
          </ClientScriptStep>
        </Procedure>
        <Procedure id="qfs.utils.dumpHeap" name="dumpHeap" uid="_1kHb">
          <variable name="sut">true</variable>
          <variable name="file"/>
          <variable name="deleteFirst">true</variable>
          <comment>Dump the heap of the Java VM.

@param	sut	True to dump the SUT heap for $(client), false for the QF-Test heap.
@param	client	The name of the SUT client in case sut is true.
@param	file	The name of the file to dump the heap to.
@param	deleteFirst	Whether to delete the file first. Otherwise an existing file will not be overwritten.
@param          guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.


@author	QFS
@since	3.4</comment>
          <IfSequence id="_1k0Q" test="$(deleteFirst)">
            <ProcedureCall id="_1k0R" procedure="qfs.shellutils.deleteFile">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
          </IfSequence>
          <TryStep id="_1k0N">
            <IfSequence id="_1k0J" test="$(sut)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_31-">
                <code>from javax.management import MBeanServer
from java.lang.management import ManagementFactory
from com.sun.management import HotSpotDiagnosticMXBean

server = ManagementFactory.getPlatformMBeanServer()
bean = ManagementFactory.newPlatformMXBeanProxy(server, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean)
filename = rc.lookup("file")
rc.logMessage("Dumping heap for client %s to %s" % (rc.lookup("client"), filename))
bean.dumpHeap(filename, True)
</code>
              </ClientScriptStep>
              <ElseSequence id="_1k0L">
                <ServerScriptStep id="_1k0P">
                  <code>from javax.management import MBeanServer
from java.lang.management import ManagementFactory
from com.sun.management import HotSpotDiagnosticMXBean

server = ManagementFactory.getPlatformMBeanServer()
bean = ManagementFactory.newPlatformMXBeanProxy(server, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean)
filename = rc.lookup("file")
rc.logMessage("Dumping heap for QF-Test to %s" % filename)
bean.dumpHeap(filename, True)
</code>
                </ServerScriptStep>
              </ElseSequence>
            </IfSequence>
            <CatchSequence exception="TestException" id="_1k0O" maxerror="2"/>
          </TryStep>
        </Procedure>
        <Procedure id="_1oNJ" name="getBoundsOnScreen">
          <variable name="id"/>
          <variable name="client">$(client)</variable>
          <comment>Get the screen location and the size of a component or sub-item.

@param id    The QF-Test component ID of the component
@param client  The client of the component

@author	QFS,rl
@since	4.0.5
</comment>
          <IfSequence id="_1oNa" test="&#34;$(id)&#34; == &#34;SCREEN&#34;">
            <ServerScriptStep id="_1oUT" name="screen size">
              <code>from java.awt import GraphicsEnvironment

ge = GraphicsEnvironment.getLocalGraphicsEnvironment()
screen = ge.getDefaultScreenDevice()
c = screen.getDefaultConfiguration()
bnds = c.getBounds()
rc.setLocal("x", bnds.x)
rc.setLocal("y", bnds.y)
rc.setLocal("w", bnds.width)
rc.setLocal("h", bnds.height)
</code>
            </ServerScriptStep>
            <ReturnStep id="_1oNb" retval="$(x),$(y),$(w),$(h)"/>
          </IfSequence>
          <ClientScriptStep client="$(client)" engine="${qftest:engine.$(id)}"
                            id="_1oNZ" name="get the component's geometry">
            <code>import array, types, collections

def getLocationOnScreen(com):
    iloc = [0, 0]
    size = [0, 0]
    item = None
    if isinstance(com, collections.Iterable):
        if qf.isInstance(com[0], "javax.swing.JTree"):
            com = (com[0], com[0].getPathForRow(com[1]))
        elif qf.isInstance(com[0], "javax.swing.JTable"):
            com = (com[0], array.array(b'i', [com[1][1], com[1][0]]))
        com, item = com
    h = rc.engine.helperFor(com)
    # Bring the window into the foreground because a
    # hard event is about to be played back
    h.raiseWindow(com)
    if item != None:
        iloc = h.getItemLocationInParent(com, item)
        size = h.getItemSize(com, item)
    else:
        geo = h.getSize(com)
        size = [geo.width, geo.height]
    loc = h.getLocationOnScreen(com)
    loc.x += iloc[0]
    loc.y += iloc[1]
    return [loc.x, loc.y, size[0], size[1]]

com = rc.getComponent(rc.lookup("id"))
rc.logMessage("com: %s" % com)
loc = getLocationOnScreen(com)

rc.setLocal("x", loc[0])
rc.setLocal("y", loc[1])
rc.setLocal("w", loc[2])
rc.setLocal("h", loc[3])
</code>
          </ClientScriptStep>
          <ReturnStep id="_1oNc" retval="$(x),$(y),$(w),$(h)"/>
        </Procedure>
        <Procedure id="qfs.utils.getDate" name="getDate" uid="_1kHU">
          <variable name="format">dd.MM.yyyy</variable>
          <variable name="offset"/>
          <variable name="locale"/>
          <comment>Return a date, default is the current date in current locale.

Formatting rules:
If a format and a locale are specified the date will be formatted using both values.
If only a format is specified the date will be formatted only with that format.
If only a locale is specified the date will be formatted according to the locale-format.

@param	format	The format of the date, default is the current locale.
		You can specify this via the SimpleDateFormat in Java, e.g. MM/dd/yyyy.
		dd means two digits for the day.
		MM means two digits for month.
		yyyy means four digits for year.		
@param 	offset	The number of days in future/past.
		For yesterday's date specify -1.
		For tomorrow's date specify 1.
@param 	locale	The locale of the date, e.g. de, us, it, es, fr, zh, ko, ru, pt, ar 
		or specific locales as en_gb, de_ch etc.

@return	date	The date in specified format.

Further samples:
MMM stands for the name of the month, e.g. 'Feb'.
E stands for the day of the week, e.g. 'Mon'.
w stands for week in the year.
Further samples can be found at SimpleDateFormat documentation at Java's documentation.

@author	QFS,mm
@since	2.1.0</comment>
          <ServerScriptStep id="_18">
            <code>from java.lang import System
from java.util import Date, Locale
from java.text import SimpleDateFormat
from java.text import DateFormat

now = System.currentTimeMillis()
day = 24 * 3600 * 1000

dateFormat = DateFormat.getDateInstance()
locale = rc.lookup("locale")
format = rc.lookup("format")
if format and locale:
    parts = locale.split("_")
    theLocale = None
    if len(parts) == 1: 
        theLocale = Locale(locale)
    else:
        theLocale = Locale(parts[0], parts[1])
    dateFormat = SimpleDateFormat(format, theLocale)
elif format:
    dateFormat = SimpleDateFormat(format)
elif locale:
    parts = locale.split("_")
    if len(parts) == 1:
        dateFormat = SimpleDateFormat.getDateInstance(DateFormat.LONG, Locale(locale)) 
    else:
        dateFormat = SimpleDateFormat.getDateInstance(DateFormat.LONG, Locale(parts[0], parts[1])) 
    
if (rc.lookup("offset")):
	now = now + (long(rc.lookup("offset")) * day)

rc.setLocal("date", dateFormat.format(Date(now)))
</code>
          </ServerScriptStep>
          <ReturnStep id="_2Fh" retval="$(date)"/>
        </Procedure>
        <Procedure id="qfs.utils.getTime" name="getTime" uid="_1kHV">
          <variable name="format">HH:mm:ss</variable>
          <variable name="offset"/>
          <variable name="timezone"/>
          <variable name="locale"/>
          <comment>Return the time in the current format.
Default is now, timestamps in the past or in future can be specified via the offset parameter.

Formatting rules:
If a format and a locale are specified the time will be formatted using both values.
If only a format is specified the time will be formatted only with that format.
If only a locale is specified the time will be formatted according to the locale-format.

@param	format	The format of the date, default  HH:mm:ss.
		hh means two digits for the hour.
		mm means two digits for minutes.
		ss means two digits for seconds.
@param	offset	The seconds in future/past.
		For one minute ago specify -60.
		For one minute in future specify +60.
@param	timezone	The timezone to get the time from.
		If left empty, the local time will be taken.
		If an invalid timezone is specified 
		the timezone will be set to GMT.
		Examples see below.

@param 	locale	The locale of the date, e.g. de, us, it, es, fr, zh, ko, ru, pt, ar 
		or specific locales as en_gb, de_ch etc.

Further samples:
S stands for current millisecond.
K stands for hour in am/pm (0-11)
k stands for hour in day (1-24)
a stands for the am/pm marker
z stands for the time zone abbreviation
(zzzz) stands for the time zone name
Further samples can be found at SimpleDateFormat documentation at Java's documentation.

Samples for timezone: 
GMT (Greenwich mean time),
CET (Central european time),
IST (India Standard Time),
GMT-08:00 
GMT+2:00.

@return 	The time in specified format.

@author	QFS,mm, Denis Gauthier
@since	2.1.0, 3.1.4</comment>
          <ServerScriptStep id="_1j+c">
            <code>from java.lang import System
from java.util import Date, TimeZone, Locale
from java.text import SimpleDateFormat
from java.text import DateFormat

now = System.currentTimeMillis()

dateFormat = SimpleDateFormat("hh:mm:ss")
locale = rc.lookup("locale")
format = rc.lookup("format")

if format and locale:
    parts = locale.split("_")
    theLocale = None
    if len(parts) == 1: 
        theLocale = Locale(locale)
    else:
        theLocale = Locale(parts[0], parts[1])
    dateFormat = SimpleDateFormat(format, theLocale)
elif format:
    dateFormat = SimpleDateFormat(format)
elif locale:
    parts = locale.split("_")
    if len(parts) == 1:
        dateFormat = SimpleDateFormat.getTimeInstance(DateFormat.LONG, Locale(locale)) 
    else:
        dateFormat = SimpleDateFormat.getTimeInstance(DateFormat.LONG, Locale(parts[0], parts[1])) 
    
if (rc.lookup("offset")):
	now = now + (long(rc.lookup("offset")) * 1000)

if (rc.lookup("timezone")):
	dateFormat.setTimeZone(TimeZone.getTimeZone(rc.lookup("timezone")))

rc.setLocal("time", dateFormat.format(Date(now)))
</code>
          </ServerScriptStep>
          <ReturnStep id="_1j+d" retval="$(time)"/>
        </Procedure>
        <Procedure id="qfs.utils.getTimestamp" name="getTimestamp"
                   uid="_1kHW">
          <comment>Return a timestamp, which represents the current time in milliseconds.

@return 	The timestamp in milliseconds.

@author	QFS,mm
@since	3.3.0</comment>
          <ServerScriptStep id="_1k01">
            <code>from java.lang import System
from java.util import Date, TimeZone
from java.text import SimpleDateFormat

now = System.currentTimeMillis()

rc.setLocal("timestamp", now)
</code>
          </ServerScriptStep>
          <ReturnStep id="_1k02" retval="$(timestamp)"/>
        </Procedure>
        <Procedure id="qfs.utils.killAllClients" name="killAllClients"
                   uid="_1kHX">
          <variable name="timeout">5000</variable>
          <comment>Kill all running clients.

@param timeout The timeout for waiting for process termination after killing a client.

@throws  ClientNotTerminatedException if a client has not been killed.

@author QFS,mm
@since 3.1.1</comment>
          <ServerScriptStep id="_6dG"
                            name="look for all running clients and kill them">
            <code>clients = rc.lookup("qftest", "clients")

for c in clients.split('\n'):
    rc.callProcedure("qfs.utils.killClient", {"client" : c})</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="qfs.utils.killClient" name="killClient" uid="_1kHY">
          <variable name="client"/>
          <variable name="timeout">5000</variable>
          <comment>Kill a client.

@param client	The connection.
@param timeout The timeout for waiting for process termination after killing.

@throws  ClientNotTerminatedException if a client has not been killed.

@author QFS,mm
@since 3.1.1</comment>
          <TryStep id="_6d5" name="client already stopped?">
            <ProcessWaiter client="$(client)" id="_6d4" timeout="0"/>
            <CatchSequence exception="ClientNotTerminatedException" id="_6dH"
                           maxerror="0"
                           name="client not stopped -&gt; stop it">
              <ClientStopper client="$(client)" id="_6d2"/>
              <ProcessWaiter client="$(client)" id="_6d3"
                             timeout="$(timeout)"/>
            </CatchSequence>
            <CatchSequence exception="NoSuchClientException" id="_6d6"
                           maxerror="0"
                           name="client doesn't exist -&gt; ignore"/>
          </TryStep>
        </Procedure>
        <Procedure id="_1jw9" name="logAllMethodsOfAGivenComponent">
          <variable name="id">aComponentId</variable>
          <comment>Log all available methods of a given component.
This script can be used to look for dedicated methods of objects.
NOTE: If you use custom classloaders, the procedure could fail.

@param	id	The id of the component.
@param          guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.


@author	QFS,mm
@since	3.1.1</comment>
          <ComponentWaiter client="$(client)" component="$(id)" id="_1oG+"
                           timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
            <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
          </ComponentWaiter>
          <ClientScriptStep client="$(client)" engine="${default:guiengine:}"
                            id="_1jwB">
            <code>obj = rc.getComponent(rc.lookup("id"))

ms = obj.getClass().getMethods()

for m in ms:
    rc.logMessage(str(m))</code>
          </ClientScriptStep>
        </Procedure>
        <Procedure id="qfs.utils.logMemory" name="logMemory" uid="_1kHZ">
          <variable name="sut">true</variable>
          <variable name="warningLimit"/>
          <variable name="warningDelay">5</variable>
          <variable name="errorLimit"/>
          <variable name="errorDelay">10</variable>
          <comment>Log current memory use.

@param	sut	True to log SUT memory for $(client), false for qftest memory.
@param	client	The name of the SUT client in case sut is true.
@param	warningLimit	Optional value in MB. If exceeded, log a warning instead of a plain message.
@param	warningDelay	If warningLimit is exceeded, wait the given delay in seconds, then try again and log a warning only if the limit is still exceeded.
@param	errorLimit	Optional value in MB. If exceeded, log an error instead of a warning or a plain message.
@param	errorDelay	If errorLimit is exceeded, wait the given delay in seconds, then try again and log an error only if the limit is still exceeded.
@param          guiengine	The name of the GUI-engine to run the SUTscript, e.g. awt, swt, web. Can be empty, if you work with one engine at the same time.
@return	The memory used in MB.

@author	QFS
@since	2.1.0</comment>
          <IfSequence id="_1et" test="$(sut)">
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:}" id="_6Y5">
              <code>import time
from java.lang import Runtime, System

# run at most twice
for i in range(2):
    System.gc()
    System.runFinalization()
    System.gc()
    total = Runtime.getRuntime().totalMemory()
    free = Runtime.getRuntime().freeMemory()
    used = (total - free) / 1024.0 / 1024.0
    if rc.lookup("errorLimit"):
        limit = float(rc.lookup("errorLimit"))
        if used &gt; limit:
            if i == 0:
                try:
                    waitsec = rc.getNum("errorDelay")
                    if waitsec &gt; 0:
                        rc.logMessage("Used memory for SUT client %s: %.1f MB - exceeds errorLimit %.1f MB - delaying %s seconds" % (rc.lookup("client"), used, limit, waitsec))
                        time.sleep(waitsec)
                        continue
                except:
                    import traceback
                    rc.logError(traceback.format_exc())
            rc.logError("Used memory for SUT client %s: %.1f MB - exceeds %.1f MB" % (rc.lookup("client"), used, limit))
            raise ReturnException(str(used))
    if rc.lookup("warningLimit"):
        limit = float(rc.lookup("warningLimit"))
        if used &gt; limit:
            if i == 0:
                try:
                    waitsec = rc.getNum("warningDelay")
                    if waitsec &gt; 0:
                        rc.logMessage("Used memory for SUT client %s: %.1f MB - exceeds warningLimit %.1f MB - delaying %s seconds" % (rc.lookup("client"), used, limit, waitsec))
                        time.sleep(waitsec)
                        continue
                except:
                    import traceback
                    rc.logError(traceback.format_exc())
            rc.logWarning("Used memory for SUT client %s: %.1f MB - exceeds %.1f MB" % (rc.lookup("client"), used, limit))
            raise ReturnException(str(used))
    rc.logMessage("Used memory for SUT client %s: %.1f MB" % (rc.lookup("client"), used), dontcompactify=1)
    raise ReturnException(str(used))
</code>
              <comment>@async</comment>
            </ClientScriptStep>
            <ElseSequence id="_1ev">
              <ServerScriptStep id="_6Y4">
                <code>import time
from java.lang import Runtime, System

# run at most twice
for i in range(2):
    System.gc()
    System.runFinalization()
    System.gc()
    total = Runtime.getRuntime().totalMemory()
    free = Runtime.getRuntime().freeMemory()
    used = (total - free) / 1024.0 / 1024.0
    if rc.lookup("errorLimit"):
        limit = float(rc.lookup("errorLimit"))
        if used &gt; limit:
            if i == 0:
                try:
                    waitsec = rc.getNum("errorDelay")
                    if waitsec &gt; 0:
                        rc.logMessage("Used memory for QF-Test: %.1f MB - exceeds errorLimit %.1f MB - delaying %s seconds" % (used, limit, waitsec))
                        time.sleep(waitsec)
                        continue
                except:
                    import traceback
                    rc.logError(traceback.format_exc())
            rc.logError("Used memory for QF-Test: %.1f MB - exceeds %.1f MB" % (used, limit))
            raise ReturnException(str(used))
    if rc.lookup("warningLimit"):
        limit = float(rc.lookup("warningLimit"))
        if used &gt; limit:
            if i == 0:
                try:
                    waitsec = rc.getNum("warningDelay")
                    if waitsec &gt; 0:
                        rc.logMessage("Used memory for QF-Test: %.1f MB - exceeds warningLimit %.1f MB - delaying %s seconds" % (used, limit, waitsec))
                        time.sleep(waitsec)
                        continue
                except:
                    import traceback
                    rc.logError(traceback.format_exc())
            rc.logWarning("Used memory for QF-Test: %.1f MB - exceeds %.1f MB" % (used, limit))
            raise ReturnException(str(used))
    rc.logMessage("Used memory for QF-Test: %.1f MB" % used, dontcompactify=1)
    raise ReturnException(str(used))
</code>
              </ServerScriptStep>
            </ElseSequence>
          </IfSequence>
        </Procedure>
        <Procedure id="qfs.utils.logNativeMemory" name="logNativeMemory"
                   uid="_1lYG">
          <variable name="processID"/>
          <variable name="warningLimit"/>
          <variable name="errorLimit"/>
          <variable name="processTree">False</variable>
          <comment>Log current memory usage of the native process(es) of a client.

@param	client	Optional name of the SUT client. Its processID is used unless processID is explicitly specified.
@param	processID	Can be explicitly specified if known, otherwise the client parameter is used to determine the process.
@param	warningLimit	Optional value in MB. If exceeded, log a warning instead of a plain message.
@param	errorLimit	Optional value in MB. If exceeded, log an error instead of a warning or a plain message.
@param	processTree	If set to True the amount of the process itself and all its child processes will get logged.
@return	The memory used in MB.

@author	QFS, mh
@since	3.4.11</comment>
          <ServerScriptStep id="_1lYH" name="getProcessID">
            <code>processID = rc.lookup("processID")
processTree = rc.getBool("processTree")
mem = 0

if processID:
    pid = int(processID)
    from de.qfs.apps.qftest.shared.system import Native
    if processTree:
        pid = Native.instance().getProcessTreeList(pid)
        mem = Native.instance().getMemoryUsageOfProcessTree(pid)
    else:
        mem = Native.instance().getMemoryUsage(pid)

else:
    if processTree:
        pid = rc.context.getProcessTreeList("$(client)")
        mem = rc.context.getMemoryUsageOfProcessTree("$(client)")
    else:
        pid = rc.context.getProcessID("$(client)")
        mem = rc.context.getMemoryUsage("$(client)")

if mem &lt; 0:
    raise UserException("Error while getting amount of memory.")

used = mem / 1024.0
if rc.lookup("errorLimit"):
    limit = float(rc.lookup("errorLimit"))
    if used &gt; limit:
        rc.logError("Used memory for client %s with process ID %s: %.1f MB - exceeds %.1f MB" % (rc.lookup("client"), pid, used, limit))
        raise ReturnException(str(used))
if rc.lookup("warningLimit"):
    limit = float(rc.lookup("warningLimit"))
    if used &gt; limit:
        rc.logWarning("Used memory for client %s with process ID %s: %.1f MB - exceeds %.1f MB" % (rc.lookup("client"), pid, used, limit))
        raise ReturnException(str(used))
rc.logMessage("Used memory for client %s with process ID %s: %.1f MB" % (rc.lookup("client"), pid, used), dontcompactify=1)

raise ReturnException(str(used))
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_6Pr" name="printMessage">
          <variable name="message">aMessage</variable>
          <comment>Print a given message to STDOUT.

@param	message	The message to be printed.

@author QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_6Ps">
            <code>print rc.lookup("message")</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_3EK" name="printVariable">
          <variable name="variableName">nameOfVariable</variable>
          <comment>Print the content of a variable.

@param	variableName	The name of the variable.

@author QFS,mm
@since 2.1.0</comment>
          <ServerScriptStep id="_3EL">
            <code>print rc.lookup("variableName"), ":", rc.lookup(rc.lookup("variableName"))</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1juh" name="readTextFromFile">
          <variable name="file">aFile</variable>
          <variable name="fileencoding"/>
          <comment>Read the content of a given file.

@param file	The path to the file.
@param fileencoding The file encoding to use. If this parameter is empty, the default file encoding will be used.

@return	The contents of the file.

@throws UserException, if files doesn't exist.

@author QFS,mm
@since 3.1.1</comment>
          <ProcedureCall id="_1lRC" local="true"
                         procedure="qfs.shellutils.exists"
                         retvarname="fExists">
            <variable name="file">$(file)</variable>
          </ProcedureCall>
          <IfSequence id="_1lRG" test="not $(fExists)">
            <ThrowStep id="_1lRH"
                       throwmessage="File '$(file)' doesn't exist!"/>
          </IfSequence>
          <ServerScriptStep id="_1jui">
            <code>import codecs
fh, encoding = None, rc.lookup("fileencoding")
if encoding == None or encoding.strip() == "":
    fh = open(rc.lookup("file"), "r")
else:
    fh = codecs.open(rc.lookup("file"), "r", encoding)
try:
    text = fh.read()
finally:
    fh.close()
raise ReturnException(text)
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1lAy" name="sendEmail">
          <variable name="from"/>
          <variable name="to"/>
          <variable name="subject"/>
          <variable name="text"/>
          <comment>@deprecated Use qfs.utils.email.sendEmail or qfs.utils.email.sendEmail_SMTPHost instead.

@author QFS,mm
@since 2.9.1</comment>
          <ServerScriptStep id="_1lAz">
            <code>import smtplib
from email.MIMEText import MIMEText

addstr = rc.lookup("to")
addarray= addstr.split(",")

addresses = []
for a in addarray:
    addresses.append(a.strip())

msg = MIMEText(rc.lookup("text"))
msg['From'] = rc.lookup("from")
msg['Subject'] = rc.lookup("subject")
msg['To'] = ",".join(addresses)

# Send the message via SMTP server, but don't include the
# envelope header.
try:
    s = smtplib.SMTP()
    s.connect()
    s.sendmail(rc.lookup("from"), addresses, msg.as_string())
    s.close()
    rc.setLocal("return", 1)

except:
    rc.setLocal("return", -1)
</code>
          </ServerScriptStep>
          <ReturnStep id="_1lA+" retval="$(return)"/>
        </Procedure>
        <Procedure id="_2KK5" name="waitForClientOutput">
          <variable name="expectedOutput"/>
          <variable name="isRegex">false</variable>
          <variable name="timeout">60000</variable>
          <variable name="polling">200</variable>
          <variable name="dologerror">false</variable>
          <comment>Wait until a client prints something to the terminal.

If no output can be determined, throw an exception or log an error depending on the parameters.

@param	client	      The client for which the output should be inspected.
@param	expectedOutput     The output to wait for.
@param	isRegex	      True to have the output matched as regular expression.
@param	timeout	      The maximal waiting time (in ms).
@param	polling	      The interval in milliseconds in which to poll for new components.
@param	dologerror	      Log an error instead of throwing an exception.

@throws	Exception	If dologerror==false and the terminal output was not found once timeout exceeded.

@author	QFS,pb
@since 5.2
</comment>
          <IfSequence id="_2KK6" name="Check for clients parameter"
                      test="&#34;$(client)&#34; == &#34;&#34;">
            <ThrowStep id="_2KK7" throwmessage="No client specified!"/>
          </IfSequence>
          <ServerScriptStep id="_2KK8" interpreter="groovy"
                            name="initialize time">
            <code>rc.setLocal("waitTillThisTime", System.currentTimeMillis() + rc.getNum("timeout"))</code>
          </ServerScriptStep>
          <WhileSequence id="_2KK9" test="True">
            <ServerScriptStep id="_2KKA" interpreter="groovy"
                              name="Check for expected output">
              <code>import de.qfs.apps.qftest.shared.exceptions.ReturnException
import de.qfs.apps.qftest.shared.exceptions.MissingPropertyException

try {
    def output = rc.lookup("qftest", "client.output.${rc.lookup('client')}", expand=false)
    def expected = rc.lookup('expectedOutput')
    rc.setLocal('clientFound',true)
    
    if (rc.getBool('isRegex')) {
        def matcher = output =~ /${expected}/
        if (matcher) {
            throw new ReturnException()
        }
    } else {
        if (output.contains(expected)) {
            throw new ReturnException()
        }
    }
} catch (MissingPropertyException ex) {
    rc.setLocal('clientFound',false)
}</code>
            </ServerScriptStep>
            <ServerScriptStep id="_2KKB" interpreter="groovy"
                              name="Check whether timeout exceeded">
              <code>import de.qfs.apps.qftest.shared.exceptions.BreakException
def currentTime = System.currentTimeMillis()
def waitTillThisTime = rc.getNum("waitTillThisTime")
if (currentTime &gt; waitTillThisTime) {
    throw new BreakException()
}</code>
            </ServerScriptStep>
            <ProcedureCall id="_2KKC" procedure="qfs.utils.sleep">
              <variable name="sleeptime">$(polling)</variable>
            </ProcedureCall>
          </WhileSequence>
          <ServerScriptStep id="_2KKD" interpreter="groovy"
                            name="Check for expected output once again">
            <code>import de.qfs.apps.qftest.shared.exceptions.ReturnException
import de.qfs.apps.qftest.shared.exceptions.MissingPropertyException

try {
    def output = rc.lookup("qftest", "client.output.${rc.lookup('client')}", expand=false)
    def expected = rc.lookup('expectedOutput')
    rc.setLocal('clientFound',true)
    
    if (rc.getBool('isRegex')) {
        def matcher = output =~ /${expected}/
        if (matcher) {
            throw new ReturnException()
        }
    } else {
        if (output.contains(expected)) {
            throw new ReturnException()
        }
    }
} catch (MissingPropertyException ex) {
    rc.setLocal('clientFound',false)
}</code>
          </ServerScriptStep>
          <ServerScriptStep id="_2KKE" interpreter="groovy"
                            name="Handle timeout case">
            <code>import de.qfs.apps.qftest.shared.exceptions.UserException
def expected = rc.lookup('expectedOutput')
def client = rc.lookup('client')
def timeout = rc.lookup('timeout')

def clientFound = rc.getBool('clientFound')

def error = clientFound ? "Output '${expected}' not found in client '${client}' within ${timeout} milliseconds."
                        : "No output for client '${client}' found within ${timeout} milliseconds."
                        
if (rc.getBool('dologerror')) {
    rc.logError(error)
} else {
    throw new UserException(error)
}</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2KKP" name="sendKey">
          <variable name="key"/>
          <variable name="qualifier"/>
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Send the given key along with the qualifier to the component which currently has the input focus.

@param key The key to be send along with the qualifier key. Valid input: a single letter of the latin alphabet, a digit or values for special keys like ENTER, DELETE, TAB, ESCAPE or F1 to F24.
@param qualifier The qualifiers to send along with the key. Valid inputs: SHIFT, CONTROL/CTRL, ALT (= OPTION), META (= WINDOWS/COMMAND), combinations of these, or the empty string for no qualifier
@param title	(optional) The title of the window to bring to front before pressing the shortcut.
@param titleRegexp  (optional) true, if the given title is a regular expression, otherwise false.

@author QFS,pb
@since 5.2</comment>
          <IfSequence id="_2KKM" name="Optionally bring window to foreground"
                      test="&#34;$(title)&#34; != &#34;&#34;">
            <ProcedureCall id="_2KKL"
                           postdelay="${default:delayAfterRaise:500}"
                           procedure="qfs.utils.setWindowToForeground">
              <variable name="title">$(title)</variable>
              <variable name="titleRegexp">$(titleRegexp)</variable>
            </ProcedureCall>
          </IfSequence>
          <ServerScriptStep id="_2KKF" interpreter="groovy"
                            name="Send key plus qualifier">
            <code>import de.qfs.apps.qftest.shared.system.Native
import java.awt.event.KeyEvent
import java.awt.Event

def keyName = rc.lookup("key")

int keyCode = 0;
char key = 0;
try {
    keyCode = KeyEvent["VK_" + keyName.toUpperCase()]
} catch (e) {
    key = keyName[0] // Fallback, use first char of "key" as character
}

def qualiName = rc.lookup("qualifier")
def qualies = qualiName.toUpperCase().split("[^A-Z]+").collect{
  switch(it) {
  case "CONTROL": return "CTRL"
  case "OPTION": return "ALT"
  case "CMD": case "COMMAND": return "META"
  case "WIN": case "WINDOWS": return "META"
  default: return it
  }
}

int modifiers = 0
qualies.each{
     if (it != "") {
        try {
            int modifier = Event[it + "_MASK"]
            modifiers = modifiers | modifier
        } catch (e) {
            throw new UserException("Invalid qualifier! Expected: SHIFT, CONTROL, CTRL, ALT, OPTION, META, COMMAND, CMD, or the empty string for no qualifier. Got: ${qualiName}")
        }
    }
}

Native.instance().charInput(key,keyCode,modifiers)</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2KKQ" name="sendText">
          <variable name="text"/>
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Send the given text to the component which currently has the input focus.

@param text The text to be send.
@param title	(optional) The title of the window to bring to front before sending the text.
@param titleRegexp  (optional) true, if the given title is a regular expression, otherwise false.

@author QFS,pb
@since 5.2</comment>
          <IfSequence id="_2KKN" name="Optionally bring window to foreground"
                      test="&#34;$(title)&#34; != &#34;&#34;">
            <ProcedureCall id="_2KKO"
                           postdelay="${default:delayAfterRaise:500}"
                           procedure="qfs.utils.setWindowToForeground">
              <variable name="title">$(title)</variable>
              <variable name="titleRegexp">$(titleRegexp)</variable>
            </ProcedureCall>
          </IfSequence>
          <ServerScriptStep id="_2KKR" interpreter="groovy"
                            name="Send the text with native key events">
            <code>import de.qfs.apps.qftest.shared.system.Native

def textToInput = rc.lookup("text")

Native.instance().textInput(textToInput)</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2KKH" name="setWindowToForeground">
          <variable name="title"/>
          <variable name="titleRegexp">true</variable>
          <comment>Brings the specified window to the foreground.

@param title	The title of the window to bring to front before pressing the shortcut.
@param titleRegexp  true, if the given title is a regular expression, otherwise false.

@author QFS,pb
@since 5.2</comment>
          <ServerScriptStep id="_2KKI" interpreter="groovy"
                            name="Bring window to foreground">
            <code>import de.qfs.lib.util.Misc
import java.util.regex.Pattern

def title = rc.lookup("title")
def titleRegexp = rc.getBool("titleRegexp")

if (! title) {
    throw new UserException("Cannot find a window without title.")
}

def autoX = null;
if (Misc.OS_IS_WINDOWS) {
     autoX = de.qfs.Autowin.instance()
} else if (Misc.OS_IS_LINUX) {
     autoX = de.qfs.Autolin.instance()
} else {
     autoX = de.qfs.Automac.instance()
}

def window = autoX.findWindow(title,titleRegexp)
if (window) {
    autoX.setForeground(window)
} else {
    throw new ComponentNotFoundException("Cannot find an open window '${title}'.")
}
</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_2JDX" name="waitForOneOfNComponents">
          <variable name="comids"/>
          <variable name="disappear">false</variable>
          <variable name="hidden">false</variable>
          <variable name="timeout">60000</variable>
          <variable name="polling">200</variable>
          <variable name="dologerror">false</variable>
          <variable name="comidsSeparator">,</variable>
          <comment>Wait until one of N components is available.
If no component can be determined within a given timeout it will throw an exception or log an error depending on the parameters.

@param	comids	      Comma-separated list of component ids to wait for.
@param	disappear	      If this parameter is set to true, the procedure will wait until at least one of the given component disappeared.
@param	hidden	      Whether to accept hidden components.
@param	timeout	      The maximal waiting timeout (in ms).
@param	polling	      The interval in milliseconds in which to poll for new components.
@param	dologerror	      Log an error instead of throwing an exception.
@param	comidsSeparator   The value, which separates the component ids. , is default.

@returns	The id of the component that was found.

@throws	ComponentNotFoundException	If dologerror==false, disappear==false and non of the components was found once timeout exceeded.
@throws	ComponentFoundException		If dologerror==false, disappear==true and all components can still be found once timeout exceeded.

@author	QFS,ys
@since 4.2.1</comment>
          <IfSequence id="_2JDe" name="Check for coms parameter"
                      test="(&#34;${default:comids:X}&#34; == &#34;X&#34; and &#34;${default:comids:Y}&#34; == &#34;Y&#34;) or not rc.lookup(&#34;comids&#34;)">
            <ThrowStep id="_2JDd" throwmessage="No component id specified!"/>
          </IfSequence>
          <ServerScriptStep id="_2JDY" name="initialize time">
            <code>from java.lang import System
rc.setLocal("waitTillThisTime", str(System.currentTimeMillis() + rc.getNum("timeout")))</code>
          </ServerScriptStep>
          <WhileSequence id="_2JDa" test="True">
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:}" id="_2JDb"
                              name="Try to access one of n components">
              <code>disappear = rc.getBool("disappear")
sep = rc.lookup("comidsSeparator")
for comId in rc.lookup("comids", expand=False).split(sep):
    comId = comId.strip()
    try:
        com = rc.getComponent(comId, hidden=rc.getBool("hidden"))
        if not disappear:
            raise BreakException() # stop loop, give previous components a chance
    except ComponentNotFoundException, e:
        if disappear:
            raise BreakException() # stop loop, give previous components a chance</code>
            </ClientScriptStep>
            <ServerScriptStep id="_2JDc"
                              name="Check whether timeout exceeded">
              <code># check timeout
from java.lang import System
currentTime = System.currentTimeMillis()
waitTillThisTime = rc.getNum("waitTillThisTime")
if currentTime &gt; waitTillThisTime:
    raise BreakException()</code>
            </ServerScriptStep>
            <ProcedureCall id="_2JDf" procedure="qfs.utils.sleep">
              <variable name="sleeptime">$(polling)</variable>
            </ProcedureCall>
          </WhileSequence>
          <ClientScriptStep client="$(client)" engine="${default:guiengine:}"
                            id="_2JDZ" name="Check for component once again">
            <code>disappear = rc.getBool("disappear")
sep = rc.lookup("comidsSeparator")
for comId in rc.lookup("comids", expand=False).split(sep):
    try:
        com = rc.getComponent(comId, hidden=rc.getBool("hidden"))
        if not disappear:
            raise ReturnException(comId)
    except ComponentNotFoundException, e:
        if disappear:
            raise ReturnException(comId)
error = rc.getBool("dologerror")
if not disappear:
    if error:
        rc.logError("None of the given components were found!")
    else:
        raise ComponentNotFoundException("None of the given components were found!")
else:
    if error:
        rc.logError("None of the given components disappeared!")
    else:
        raise ComponentFoundException()</code>
          </ClientScriptStep>
        </Procedure>
        <Procedure id="_4oi" name="writeMessageIntoFile">
          <variable name="message">aMessage</variable>
          <variable name="file">aFile</variable>
          <variable name="addLinebreak">false</variable>
          <comment>Write a given message into a given file.
NOTE: Special characters like \n or \t won't be expanded and will be treated as normal characters.

@param message The message, which should be written.
@param file  The file, where the message has to be written into.
@param addLinebreak  If this is set to true, a linebreak `\n` will be appended to the text. On Windows '\r\n will be added.

@throws UserException, if no proper values for file and message have been set.

@author        QFS,mm
@since 2.1.0</comment>
          <IfSequence id="_1lQ+"
                      test="rc.lookup(&#34;file&#34;) == &#34;aFile&#34; or not rc.lookup(&#34;file&#34;) ">
            <ThrowStep id="_1lQ-"
                       throwmessage="Parameter 'file' hasn't been set!"/>
          </IfSequence>
          <IfSequence id="_1lR0"
                      test="rc.lookup(&#34;message&#34;) == &#34;aMessage&#34;">
            <ThrowStep id="_1lRI"
                       throwmessage="Parameter 'message' hasn't been set!"/>
          </IfSequence>
          <ServerScriptStep id="_4oj" interpreter="groovy">
            <code>file = rc.lookup("file")
if(file != "aFile") {
    pw = null
    try {
        pw = new FileWriter (file, true)
	pw.write(rc.lookup("message"))
	if (rc.getBool("addLinebreak")) {
            if (rc.lookup("qftest", "windows") == "true") {
	        pw.write("\r")
            }
	    pw.write("\n")
	}
    } finally {
        if (pw != null) {
	    pw.close()
        }
    }
}

</code>
          </ServerScriptStep>
        </Procedure>
        <Procedure id="_1jwx" name="sleep">
          <variable name="sleeptime">100</variable>
          <comment>Sleep a given time.

@param  sleeptime    The time to sleep in milliseconds.

@author QFS,mm
@since 3.5.0</comment>
          <IfSequence id="_1lA-" test="rc.lookup(&#34;sleeptime&#34;)">
            <BasicSequence id="_1lB0" name="do sleep"
                           postdelay="$(sleeptime)"/>
          </IfSequence>
        </Procedure>
      </Package>
      <Package id="_4o-" name="web">
        <comment>Web utility procedures.

@author	QFS
@since	2.9.0</comment>
        <Package id="_1j+u" name="ajax">
          <comment>AJAX procedures.

@author	QFS
@since	3.3.0</comment>
          <Procedure id="_2J4w" name="dumpCustomWebResolverProperties">
            <comment>Dump properties of an installed CustomWebResolver.

@author	QFS,fs
@since	4.0.9</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_2JAZ"
                              interpreter="groovy">
              <code>import de.qfs.apps.qftest.client.resolvers.web.generic.GenericResolverHelper

try {
    //synchronize with java store because of lazy detection
    customWebResolver = GenericResolverHelper.getInstance().getCustomWebResolver();
    
    if(customWebResolver) {
        rc.logMessage(customWebResolver.getBasicResolver().dumpResolverProperties());
        println customWebResolver.getBasicResolver().dumpResolverProperties();
    } else {
        rc.logMessage("No CustomWebResolver found or installed");
        println "No CustomWebResolver found or installed";
    }
} catch(ex){
    rc.logMessage("Problem during dummp of resolver.");
    println ex;
}</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1j+v" name="installToolkitResolver">
            <variable name="toolkit">anAjaxToolkit</variable>
            <variable name="resolver_version"/>
            <variable name="auto_extjs_version"/>
            <variable name="auto_extgwt_version"/>
            <variable name="auto_gwt_version"/>
            <variable name="auto_icefaces_version"/>
            <variable name="auto_jqueryui_version"/>
            <variable name="auto_kendoui_version"/>
            <variable name="auto_primefaces_version"/>
            <variable name="auto_qooxdoo_version"/>
            <variable name="auto_rap_version"/>
            <variable name="auto_rap2_version"/>
            <variable name="auto_richfaces_version"/>
            <variable name="auto_vaadin_version"/>
            <variable name="auto_zk_version"/>
            <comment>Install a special resolver for given AJAX toolkit to improve recorded  component types and hierarchy and therefore achieves improved component recognition.

@param toolkit	The AJAX toolkit. Currently supported are autodetect, extjs, extgwt, gwt, icefaces, jeasyui, jqueryui, primefaces, qooxdoo, rap, richfaces, vaadin and zk.
@param resolver_version	The resolver version, e.g. 1 or 1.0 or 1.1.1. The latest possible version with the given restriction will be used, e.g. if 1.0 is given, than the latest 1.0.x will apply. If empty, latest available version will be used. Delete or also leave empty when auto detection is used.
@param nofallback	Optional parameter for toolkits with different resolver versions. If nofallback is true, QF-Test will not try to determine the best version but use the version specified.
@param auto_extjs_version	The resolver version for extjs to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_extgwt_version	The resolver version for extgwt to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_gwt_version	The resolver version for gwt to be used by the autodetector. Typically automatically set by the Quickstart Wizard.	
@param auto_icefaces_version The resolver version for icefaces to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_jqueryui_version The resolver version for jquery to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_kendoui_version The resolver version for kendoui to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_primefaces_version The resolver version for primefaces to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_qooxdoo_version The resolver version for qooxdoo to be used by the autodetector. Typically automatically set by the Quickstart Wizard. 	
@param auto_rap_version	The resolver version for rap &lt; 2.0 to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_rap2_version	The resolver version for rap &gt;= 2.0 to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_richfaces_version The resolver version for richfaces to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@param auto_vaadin_version The resolver version for vaadin to be used by the autodetector. Typically automatically set by the Quickstart Wizard.	
@param auto_zk_version The resolver version for zk to be used by the autodetector. Typically automatically set by the Quickstart Wizard.
@deprecated Use qfs.web.ajax.installCustomWebResolver instead.

@author	QFS,kk
@since	3.3.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_5vQ"
                              name="Install resolver for given ajax toolkit">
              <code>try:
    from resolvers.web import $(toolkit)
except:
    rc.logError("No resolver found for toolkit $(toolkit).")
    raise ReturnException

version = rc.lookup("resolver_version")

if "$(toolkit)" != "autodetect":
    if version and version != "":
        if "$(toolkit)" == "extjs" and rc.getBool("default", "nofallback:false"):
            $(toolkit).install(rc, version, nofallback=true)
        else:
            $(toolkit).install(rc, version)
    else:
        $(toolkit).install(rc)
else:
    auto_extjs_version      = rc.lookup("auto_extjs_version")
    auto_extgwt_version	    = rc.lookup("auto_extgwt_version")
    auto_gwt_version        = rc.lookup("auto_gwt_version")
    auto_icefaces_version   = rc.lookup("auto_icefaces_version")
    auto_jqueryui_version   = rc.lookup("auto_jqueryui_version")
    auto_kendoui_version    = rc.lookup("auto_kendoui_version")
    auto_primefaces_version = rc.lookup("auto_primefaces_version")
    auto_qooxdoo_version    = rc.lookup("auto_qooxdoo_version")
    auto_rap_version        = rc.lookup("auto_rap_version")
    auto_rap2_version        = rc.lookup("auto_rap2_version")
    auto_richfaces_version  = rc.lookup("auto_richfaces_version")
    auto_vaadin_version     = rc.lookup("auto_vaadin_version")
    auto_zk_version	    = rc.lookup("auto_zk_version")


    auto_versions = { \
                     "extjs"     :auto_extjs_version \
                     ,"extgwt"    :auto_extgwt_version \
                     ,"gwt"       :auto_gwt_version \
                     ,"icefaces"  :auto_icefaces_version \
                     ,"jqueryui"  :auto_jqueryui_version \
                     ,"kendoui"   :auto_kendoui_version \
                     ,"primefaces":auto_primefaces_version \
                     ,"qooxdoo"   :auto_qooxdoo_version \
                     ,"rap"       :auto_rap_version \
                     ,"rap2"       :auto_rap2_version \
                     ,"richfaces" :auto_richfaces_version \
                     ,"vaadin"    :auto_vaadin_version \
                     ,"zk"        :auto_zk_version \
                     }

    autodetect.install(rc, None, auto_versions)
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1lST" name="uninstallToolkitResolver">
            <variable name="toolkit">anAjaxToolkit</variable>
            <comment>Uninstall a special resolver for given AJAX toolkit.

@param toolkit	The AJAX toolkit. Currently supported are autodetect, extjs, extgwt, gwt, icefaces, jeasyui,jqueryui, primefaces, qooxdoo, rap, richfaces, vaadin and zk.
@deprecated Use qfs.web.ajax.uninstallCustomWebResolver instead.

@author	QFS,mm
@since	3.5.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1lSU"
                              name="Uninstall resolver for given ajax toolkit">
              <code>try:
    from resolvers.web import $(toolkit)
except:
    rc.logError("No resolver found for toolkit $(toolkit).")
    raise ReturnException

$(toolkit).uninstall(rc)    </code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1mID" name="installCustomWebResolver">
            <variable name="resolver">custom</variable>
            <variable name="version"/>
            <variable name="genericClasses"/>
            <variable name="attributesToGenericClasses"/>
            <variable name="tagsToGenericClasses"/>
            <variable name="ignoreTags"/>
            <variable name="ignoreByAttributes"/>
            <variable name="autoIdPatterns"/>
            <variable name="customIdAttributes"/>
            <variable name="interestingByAttributes"/>
            <variable name="attributesToQftFeature"/>
            <variable name="documentJS"/>
            <comment>Install a generic CustomWebResolver for an Ajax framework.

NOTE: It is recommended to use the Quickstart Wizard from the Extras menu to create a setup sequence for web applications which then contains a call to this procedure with appropriate parameter values.               

Component recognition is mostly based on determining QF-Test generic class names from CSS classes or other attributes.

Lists below are to be specified as comma separated lists. Regular expressions can be specified by prefixing '%'.

Please find a list of any parameters ordered by their priority.
Under normal circumstances you should only use parameters from the sections "REQUIRED PARAMETERS" and "PARAMETERS PRIORITY 1".
Any other parameters should be used very carefully.

You can find further information about Generic classes of QF-Test in the manual in chapter "Generic classes".
You can also find a chapter how to apply this procedure to your web-page, please see chapter "Customizing QF-Test for your AJAX toolkit".

Samples of parameter settings:
============================================================

Sample 1:
=================
Name		Value
resolver		custom
version		
genericClasses		css-button=Button,css-label=Label

... maps the css classes "css-button" to the generic QF-Test class "Button" and maps the css class "css-label" to the generic class "Label".

Sample 2:
=================
Name		Value
resolver		gwt
version		
genericClasses		gwtButton=Button,tc=TableCell@::parent=TableRow
attributesToGenericClasses	id=%.*list=List
customIdAttributes	qfs-id,qfs-tableid@::ancestor=Table

... extends the GWT resolver and maps every component with css-class 'gwtButton' to QF-Test generic class Button.
Then it maps every component with the css-class 'tc' to TableCell but only if its direct parent has the QF-Test class TableRow.
Every node having an 'id' attribute matching the regular expression .*list (so everything which ends with list) will be mapped to a QF-Test generic class List.
Every node having the attribute 'qfs-id' will get this attribute as 'id' from a QF-Test perspective (used as QF-Test name and for id extra feature of component recognition).
Every node having the attribute 'qfs-tableid' will get this attribute as 'id' from a QF-Test perspective, but only if one of the ancestor nodes has the generic class name Table (so only inside Tables).

Special syntaxes:
============================================================
Using regular expressions works with leading %, e.g. %css.*=Button

Using @:: operators (Can be used in all priority 1 parameters):
css-button=Button@::ancestor=Table		Map button only if one ancestor has the class Table. Script: node.getAncestorOfClass("Table")
css-button=Button@::parent=Table		Map button only if direct parent has the class Table. Script: node.getParent()
css-button=Button@::interestingparent=Table	Map button only if the QF-Test parent has the class Table. Script: node.getInterestingParent().

Using exact tag matching (Can be used in all priority 1 parameters):
row=TableRow=SPAN			Map css class 'row' to a QF-Test TableRow only if the tag itself is a SPAN.
row=TableRow=SPAN@::parent=Table		Map css class 'row' to a QF-Test TableRow only if the tag itself is a SPAN and if it has a direct of the QF-Test class Table.

myid=%.*=INPUT			Can be used for any attribute mappings as well. Here every value of the attribute 'myid' matches, but only if the node itself has the tag INPUT.

Using @:: operators with levels (Can be used in all priority 1 parameters):
Those parameters rely on the component structure recorded by QF-Test or the generated DomNode, so they could fail if the web-page or your resovler gets changed.
You should consider to use the normal @::ancestor operator in that case or map a dedicated parent to a specific parent class which can use with @::parent or @::ancestor again.
css-button=Button@::ancestor&lt;3&gt;=Table		Map button only if an ancestor within the three parent levels has the class Table.  Script: node.getAncestorOfClass("Table", 3)
css-button=Button@::parent&lt;3&gt;=Table		Map button only if parent at 3rd level has the class Table. Script: node.getNthParent(3). 
css-button=Button@::interestingparent&lt;3&gt;=Table	Map button only if the 3rd level of QF-Test parent has the class Table. Script: node.getInterestingParent(3).


PARAMETERS:
============================================================

******************************** REQUIRED PARAMETERS *********************************************
@param	resolver		The resolver to extend. Either 'custom' or the concrete name, e.g. 'zk' or 'vaadin'.
@param	version		Leave it blank for the latest versions. The resolver version, e.g. 1 or 1.0 or 1.1.1. The latest possible version with the given restriction will be used,
			e.g. if 1.0 is given, than the latest 1.0.x will apply. 
			If empty, latest available version will be used. Delete or also leave empty when auto detection is used.


*********************************************** PARAMETERS PRIORITY 1 *********************************************** 
Those parameters will make use for most applications.

@param	genericClasses		CSS classes that map to a generic class name, e.g. ui-button=Button,ui-table=Table. (uses node.getAttribute("class")). 
			Can be overridden by attributesToGenericClasses.
@param	attributesToGenericClasses	List of attributes, which should be mapped to generic classes, e.g. id=table=Table,name=%.*combo.*=ComboBox.
			Assignments from here can override genericClasses values.
@param 	tagsToGenericClasses	List of tags which should be mapped to generic classes, e.g. LI=ListItem.
@param	ignoreTags		Class names or tags for which to ignore nodes when creating the parent hierarchy of a node, e.g. DIV,TBODY. 
			In this example only DIV and TBODY nodes that are not mapped
			to some other class will be ignored.
@param	ignoreByAttributes	List of attributes which should be ignored, e.g. id=container,id=header.
@param 	autoIdPatterns		List of patterns, which mark an automated generated ID from your framework. If the "id" attribute matches this criteria, 
			it will be ignored, e.g. myAutoId,%auto.*
@param 	customIdAttributes	List of attribute-names which can act as ids for component, e.g. myid,qft-id will use the attributes myid and qft-id in case 
			they are set for ID-resolution.
@param 	interestingByAttributes	List of attributes which should be interesting and not ignored, e.g. id=container,id=header.
@param 	attributesToQftFeature	List of attributes which will be used for QF-Test feature recognition of components.
@param 	documentJS		Javascript code which should be injected to the web-page. Can be used to inject custom Javascript functions.

***********************************************  PARAMETERS PRIORITY 2 *********************************************** 
Those parameters will just make sense for a few applications. Please just use them only if you have discussed them with the QFS support team.

@param 	attributesToQftName	List of attributes, which will  be used for QF-Test name recognition of components.
@param 	nonTrivialClasses	List of CSS classes of objects, which shouldn't be ignored by QF-Test. 
			Trivial nodes are I, FONT, BOLD etc. if you want to keep them, you need to activate them here specifying a proper CSS class.
@param 	redirectClasses	Specify the redirect behavior of events to those nodes, 
			e.g. Button=False no redirection
			Button=True redirect in any case
			Button=maybe redirect only if there is no other redirection inside that Button
			Button=Label=false ... Don't redirect to button objects within labels.
@param 	allBrowsersSemihardClasses	List of classes to activate semi-hard events for those classes, e.g. Button for all browsers.
			Alternative might be setting the global Options.OPT_WEB_SEMI_HARD_EVENTS option to true, which works for all components.
@param 	chromeSemihardClasses	List of classes to activate semi-hard events for those classes, e.g. Button for Chrome.
			Alternative might be setting the global Options.OPT_WEB_SEMI_HARD_EVENTS option to true, which works for all components.
@param 	ieSemihardClasses	List of classes to activate semi-hard events for those classes, e.g. Button for IE.
			Alternative might be setting the global Options.OPT_WEB_SEMI_HARD_EVENTS option to true, which works for all components.
@param 	mozSemihardClasses	List of classes to activate semi-hard events for those classes, e.g. Button for Firefox.
			Alternative might be setting the global Options.OPT_WEB_SEMI_HARD_EVENTS option to true, which works for all components.
@param 	edgeSemihardClasses	List of classes to activate semi-hard events for those classes, e.g. Button for Edge.
			Alternative might be setting the global Options.OPT_WEB_SEMI_HARD_EVENTS option to true, which works for all components.
@param 	allBrowsersHardClasses	List of classes to activate hard events for those classes, e.g. Button for all browsers.
			Alternative might be activating "Replay as hard event" for mouse-click nodes.
@param 	chromeHardClasses	List of classes to activate hard events for those classes, e.g. Button for Chrome.
			Alternative might be activating "Replay as hard event" for mouse-click nodes.
@param 	ieHardClasses		List of classes to activate hard events for those classes, e.g. Button for IE.
			Alternative might be activating "Replay as hard event" for mouse-click nodes.
@param 	mozHardClasses	List of classes to activate hard events for those classes, e.g. Button for Firefox.
			Alternative might be activating "Replay as hard event" for mouse-click nodes.
@param 	edgeHardClasses	List of classes to activate hard events for those classes, e.g. Button for Edge.
			Alternative might be activating "Replay as hard event" for mouse-click nodes.
@param 	ignoreStructureClasses	List of classes to record the component without any structure (index and count) information.
@param 	ignoreStructureIndexClasses	List of classes to record the component without structure index information.
@param 	ignoreStructureCountClasses	List of classes to record the component without any structure count information.
@param 	ignoreGeometryClasses	List of classes to record the component without any geometry (height, width, x and y) information.
@param 	ignoreLocationClasses	List of classes to record the component without any geometry location (x and y) information.
@param 	ignoreSizeClasses	List of classes to record the component without any geometry size (height, width) information.
@param 	keepStructureClasses	List of classes to record the component with structure information (index and count). Useful to override default settings.
@param 	keepStructureIndexClasses	List of classes to record the component with structure index. Useful to override default settings.
@param 	keepStructureCountClasses	List of classes to record the component with structure count. Useful to override default settings.
@param 	keepGeometryClasses	List of classes to record the component with geometry information (height, width, x and y). Useful to override default settings.
@param 	keepLocationClasses	List of classes to record the component with geometry location (x and y). Useful to override default settings.
@param 	keepSizeClasses	List of classes to record the component with geometry size (height, width). Useful to override default settings.
@param 	menuItemClasses	List of classes which act as MenuItems.
@param 	busyPaneBreakerClasses	List of classes which shouldn't be blocked by BusyPane objects.
@param	ignoreTextClasses	List of classes which shouldn't be taken into account if a text is retrieved from a node.

***********************************************  PARAMETERS PRIORITY 3 *********************************************** 
Those parameters are pure experts parameters, which should only be use in rare use-cases. If you use them, you should have discussed them with the QFS support team.

@param 	volatileClasses			List of classes which have an not stabile way of recording all mouse-events to the same node. 
				Need to be set if mouse-events are recorded in four nodes instead of one Mouse-click event.
@param 	abstractCoordinatesClasses		List of classes which don't get mouse co-ordinates recorded for mouse-click events. Recording only.
@param 	ieCorrectMouseClasses		List of classes to fix some recorded co-ordinates for IE.
@param 	mozCorrectMouseClasses		List of classes to fix some recorded co-ordinates for Firefox.
@param 	chromeCorrectMouseClasses		List of classes to fix some recorded co-ordinates for Chrome.
@param 	abstractedCoordinatesRedirectClasses	List of classes which gets a dedicated target, if no mouse-events are specified. Replay only.
				E.g. CheckBox=INPUT:CHECKBOX redirect any click without co-ordinates at Checkbox to underlying INPUT:CHECKBOX.
@param 	keepMovedClasses		List of classes to keep MOUSE_MOVED events.
@param 	missingReleaseClasses		List of classes for components, where the release events are missing during recording. Recording only.
@param 	cursorPositionAsItemClasses		List of classes for components, which shouldn't record the sub-items for content.
@param	ignoreTextSameGenericClassnameClasses	List of classes which shouldn't be taken into account if nodes of those classes have the same nodes as nested content.

***********************************************  PARAMETERS PRIORITY 4 *********************************************** 
Those parameters impact the way how the internal mechanism works. There is no relation to classes or tags. They just influence internal behavior.

@param 	logMode			Default true, everything is written into the DiagnosticLog. If false nothing will be written to DiagnosticLog.
@param 	textRedirect			If true, then text-events and checks will be recorded on redirected TextField and TextArea nodes. (Default)  
				If false, every text-event and text-check will be redirected to the real INPUT:TEXT or TEXTAREA nodes.
@param 	timeout			Timeout in ms which will be waited after every node change.
@param	insertClassesFront		If true, new class mappings will be put to the beginning of the classes list. 
				If false (default) no mappings will be added to the end of the classes list.
@param	excludeHiddenTableItems		If true (default) hidden table items will be taken into account. Otherwise they will be ignored.
@param 	excludeHiddenListItems		If true hidden list items will be taken into account. If false (default) they will be ignored.
@param 	unregisterDefaultTableResolver	If true the default table recognition will be disabled. Very dangerous to disable.
@param 	unregisterDefaultGenericClassNameResolver 	If true the default generic class name recognition will be disabled. Very dangerous to disable.

***********************************************  DEPRECATED PARAMETERS *********************************************** 
Those parameters have been used in QF-Test 4.0. You should replace those parameters with genericClasses, ignoreByAttributes, attributestoGenericClasses etc.

@param	goodCssClasses	CSS classes that make a good class name. They will become a Class for QF-Test component.
@param	ignoreCssClasses	CSS classes that should be ignored. Those css classes won't be used for Qf-Test classes coming from goodCSSClasses.
@param	badCssClasses		CSS classes that should not get a class name. Nodes having this css class somewhere won't get any QF-Test class name.
@param	remapClasses		List of from:to pairs to remap one class to another class, e.g. table-row-odd:table-row
@param	preferredCssClasses	CSS classes that should be preferred, if multiple CSS classes are defined.
@throws	UserException		If no resolver was found or installed.

@author	QFS,fs
@since	3.5.3
</comment>
            <ServerScriptStep id="_2J2O" interpreter="groovy">
              <code>procParam = rc.context.getVariableStack().getProcedureCallBindings();
</code>
            </ServerScriptStep>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_2J2M"
                              interpreter="groovy">
              <code>import de.qfs.apps.qftest.client.resolvers.web.generic.GenericResolverHelper
import de.qfs.apps.qftest.shared.exceptions.UserException

def params = rc.fromServer("procParam");
// install resolver
def res = GenericResolverHelper.getInstance().getInstalledCustomWebResolver(params);
if (res == null) {
    throw new UserException("No CustomWebResolver found or installed. For parameter\nresolver: " + rc.lookup("resolver") + "\nversion: " + rc.lookup("version"));
}
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1mIF" name="uninstallCustomWebResolver">
            <comment>Uninstall a previously installed generic CustomWebResolver.

@author	QFS,fs
@since	3.5.3
</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1mIG"
                              interpreter="groovy">
              <code>import de.qfs.apps.qftest.client.resolvers.web.generic.GenericResolverHelper

try {
    //synchronize with java store because of lazy detection
    customWebResolver = GenericResolverHelper.getInstance().getCustomWebResolver();
    
    customWebResolver.uninstall();
    rc.logMessage("Uninstalled " + customWebResolver.getClass().getSimpleName().split("_")[0] + " " + customWebResolver.getVersion(), dontcompactify:true)
    println "Uninstalled "  + customWebResolver.getClass().getSimpleName().split("_")[0] + " " + customWebResolver.getVersion();
    customWebResolver = null;
    //synchronize with java store because of lazy detection
    GenericResolverHelper.getInstance().setCustomWebResolver(null);
} catch(ex) {
    println "Uninstall failed, maybe no CustomWebResolver was installed";
}
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1oD+" name="updateCustomWebResolverProperties">
            <variable name="excludeHiddenItem"/>
            <variable name="eventSync"/>
            <variable name="treeResolver"/>
            <variable name="treetableResolver"/>
            <comment>Updates properties of an installed generic CustomWebResolver.

@param	excludeHiddenItem	Flag to check for all or only visible elements in list of table items.
			e.g. 
			List=false,Accordion=false,Table=true

@param	eventSync		EventSynchronizer
			e.g.
			duration=10000,sleepTime=99,initialSleepTime=10 

			sleepTime -&gt; Sleep time, if page is busy.
			initialSleepTime -&gt; Initial sleep time before calling the first check.
			duration -&gt; Duration time how long it should be checked.

@param	treeResolver		Tree and TreeTable resolver
			e.g.
			nodeTolerance=10,
			postExpansionDelay=100,
			customExpanderClickPositon=x5ydefault,
			autoExpansionClick=semihard,
			treeTextNodeRetrieval=default,
			treeCalculationMode=treeCalculatedHierarchy,

			nodeTolerance -&gt; Tolerance for depth comparison of nodes.
				Normally all nodes should be on the same x level, 
				but in some cases a selected node could be moved by one or two pixels.
				In this case that value can be set to be more flexible.
			postExpansionDelay -&gt; Sleep time for waiting after tree node expanding.
			customExpanderClickPositon -&gt; Custom Expander x and y click position.
				Key word default clicks in the middle.
			autoExpansionClick -&gt; The mode of the tree node auto expand click event. (hard,semihard)
			treeTextNodeRetrieval -&gt; Mode for text node retrieval.
				Uses as default the text node with the longest text.
				Key word default uses always the first text node. (default,treeLongestText)
			treeCalculationMode -&gt; Mode for calculating TreeNode elements.
				Key word treeCalculatedHierarchy counts the parent elements of the hierarchical structure.
				(treeCalculatedLocation,treeCalculatedHierarchy)

@param	treetableResolver	TreeTable resolver
			e.g.
			treetableCustomColumn=1,

			treetableCustomColumn -&gt; Custom column index to use for the TreeTable.
				Uses as default the first column with the index 0.

@author	QFS,fs
@since	4</comment>
            <ServerScriptStep id="_1oCP" interpreter="groovy">
              <code>// save procedure parameters global
procParam = rc.context.getVariableStack().getProcedureCallBindings()
</code>
            </ServerScriptStep>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1oD-"
                              interpreter="groovy">
              <code>import de.qfs.apps.qftest.client.resolvers.web.generic.GenericResolverHelper

params = rc.fromServer("procParam");

try {
    //synchronize with java store because of lazy detection
    customWebResolver = GenericResolverHelper.getInstance().getCustomWebResolver();
    //updating parameters
    if (customWebResolver != null &amp;&amp; params != null) {
        e = params.propertyNames();
        while (e.hasMoreElements()) {
            key = (String) e.nextElement();
            value = params.getProperty(key)
            if (key != null &amp;&amp; value != null) {
                customWebResolver.getBasicResolver().updateResolverProperties(key,value);
            }
        }
        println "Updated resolver properties for "  + customWebResolver.getClass().getSimpleName().split("_")[0] + " " + customWebResolver.getVersion();
        rc.logMessage("Updated resolver properties for " + customWebResolver.getClass().getSimpleName().split("_")[0] + " " + customWebResolver.getVersion(), dontcompactify:true);
    }
} catch(e) {
    println "Updated resolver properties failed, maybe no CustomWebResolver was installed";
}

</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Package id="_6Wn" name="browser">
          <comment>Browser procedures.

@author	QFS
@since	2.9.0</comment>
          <Package id="_2KKS" name="external">
            <comment>This package contains methods to interrupt a browser-open call from a java application.

@author	QFS
@since	5.2.0</comment>
            <Package id="_2KKT" name="observers">
              <Procedure id="_8" name="catchBrowserOpen">
                <comment>Registers a notification observer which intercepts external browser opening and stores the corresponding url.

@param	client	      The client in which the observer is registered.

@author QFS,pb
@since 5.2</comment>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:}" id="_O"
                                  interpreter="groovy"
                                  name="Intercept direct browser open calls">
                  <code>notifications.addObserver("_qf_interceptBrowserOpen", { data -&gt;
    try {
        data.open = false // Avoid real browser opening
        _qf_global_url = data.url // store opend url
    } catch (e) {
        qf.println("Exception while opening browser: ${e}")
    }
},"user.browser.open")</code>
                </ClientScriptStep>
              </Procedure>
              <Procedure id="_2KKU" name="uncatchBrowserOpen">
                <comment>Unregisters the a notification observer previously registered with catchBrowserOpen

@param	client	      The client in which the observer is unregistered.

@author QFS,pb
@since 5.2</comment>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:}" id="_2KKV"
                                  interpreter="groovy"
                                  name="Stop intercepting direct browser open calls">
                  <code>notifications.removeObserver("_qf_interceptBrowserOpen")</code>
                </ClientScriptStep>
              </Procedure>
              <Procedure id="_2JEl" name="catchProcessOpen">
                <comment>Registers a notification observer which intercepts external process launches. If the process arguments contain a web link, the process call is treated as browser open call.

@param	client	      The client in which the observer is registered.

@author QFS,pb
@since 5.2</comment>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:}" id="_2JEm"
                                  interpreter="groovy"
                                  name="Intercept process calls">
                  <code>notifications.addObserver("_qf_interceptBrowserOpenViaProcess", { data -&gt;
    try {
        for(def arg: data.command) {
            def matcher = arg =~ /"?((:?http|https|file):\/\/[^"]+)/
            if (matcher) {
                // we can hand over the complete data, since the keys of "browser.open" and "process.start" are disjunct
                data.url = matcher.group(1)
                notifications.post("user.browser.open",data)
                if (data.containsKey("open") &amp;&amp; ! data['open']) {
                    data.exitcode=0 // prevents the browser start
                }
            }
        }
    } catch (e) {
        qf.println("Exception while process start: ${e}")
    }
},"user.process.start")</code>
                </ClientScriptStep>
              </Procedure>
              <Procedure id="_2JEn" name="uncatchProcessOpen">
                <comment>Unregisters the a notification observer previously registered with catchProcessOpen

@param	client	      The client in which the observer is unregistered.

@author QFS,pb
@since 5.2</comment>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:}" id="_2JEo"
                                  interpreter="groovy"
                                  name="Stop intercepting process calls">
                  <code>notifications.removeObserver("_qf_interceptBrowserOpenViaProcess")</code>
                </ClientScriptStep>
              </Procedure>
            </Package>
            <Procedure id="_2KKW" name="prepareForBrowserOpen">
              <variable name="interceptProcessCalls">true</variable>
              <comment>Call this procedure before triggering an action that opens an external browser and before calling "waitForBrowser".

This procedure installs an notification observer, which prevents an external browser from opening and stores the url instead.

@param	client	      	The client for which browser calls should be intercepted.
@param	interceptProcessCalls	If "true" all external processes opened by the SUT are checked and treated as a browser call, 
			as soon as their arguments contain a URL starting with http://, https:// or file://

@author QFS,pb
@since 5.2</comment>
              <IfSequence id="_2KKX" name="Check for client parameter"
                          test="&#34;$(client)&#34; == &#34;&#34;">
                <ThrowStep id="_2KKY" throwmessage="No client specified!"/>
              </IfSequence>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_2KKZ"
                                interpreter="groovy"
                                name="Reset the url catch variable">
                <code>_qf_global_url = null</code>
              </ClientScriptStep>
              <ProcedureCall id="_2KKa"
                             procedure=".observers.catchBrowserOpen">
                <variable name="client">$(client)</variable>
              </ProcedureCall>
              <IfSequence id="_2KKl" test="$(interceptProcessCalls)">
                <ProcedureCall id="_2JEp"
                               procedure=".observers.catchProcessOpen">
                  <variable name="client">$(client)</variable>
                </ProcedureCall>
              </IfSequence>
            </Procedure>
            <Procedure id="_2KKb" name="waitForBrowserOpen">
              <variable name="checkUrl"/>
              <variable name="isRegex">false</variable>
              <variable name="callProcedure"/>
              <variable name="timeout">60000</variable>
              <variable name="polling">200</variable>
              <variable name="dologerror"/>
              <comment>Checks, if after "prepareForBrowserOpen" a call for opening an external browser has been intercepted and checks the intercepted url and/or starts a defined procedure. Returns the url of the browser open call.

@param	client	      The client for which browser calls were intercepted.
@param	checkUrl	      The expected url which should have been opened (option)
@param	isRegex	      If "true", checkUrl will be interpreted as regular expression.
@param	callProcedure	      If set, the given procedure is called with "url" as argument.
@param	timeout	      The maximal waiting timeout (in ms).
@param	polling	      The interval in milliseconds in which to poll for the interception.
@param	dologerror	      Log an error instead of throwing an exception.

@throws	Exception	If dologerror==false and no call was intercepted once timeout exceeded.

@author	QFS,pb
@since 5.2</comment>
              <IfSequence id="_2KKc" name="Check for client parameter"
                          test="&#34;$(client)&#34; == &#34;&#34;">
                <ThrowStep id="_2KKG" throwmessage="No client specified!"/>
              </IfSequence>
              <ServerScriptStep id="_2KKd" interpreter="groovy"
                                name="initialize time">
                <code>rc.setLocal("waitTillThisTime", System.currentTimeMillis() + rc.getNum("timeout"))</code>
              </ServerScriptStep>
              <WhileSequence id="_2KKe" name="Wait for the browser open call"
                             test="True">
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:}" id="_2KKJ"
                                  interpreter="groovy"
                                  name="Check for opened browser">
                  <code>import de.qfs.apps.qftest.shared.exceptions.BreakException


def browserOpened = false
try {
    if (_qf_global_url != null) {
        browserOpened = true
    }
} catch (e) {
    // _qf_global_url not set
}

if (browserOpened) {
    throw new BreakException()
}</code>
                </ClientScriptStep>
                <ServerScriptStep id="_2KKK" interpreter="groovy"
                                  name="Check whether timeout exceeded">
                  <code>import de.qfs.apps.qftest.shared.exceptions.BreakException
def currentTime = System.currentTimeMillis()
def waitTillThisTime = rc.getNum("waitTillThisTime")
if (currentTime &gt; waitTillThisTime) {
    throw new BreakException()
}</code>
                </ServerScriptStep>
                <ProcedureCall id="_2KKf" procedure="qfs.utils.sleep">
                  <variable name="sleeptime">$(polling)</variable>
                </ProcedureCall>
              </WhileSequence>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_2KKg"
                                interpreter="groovy"
                                name="Handle timeout case">
                <code>import de.qfs.apps.qftest.shared.exceptions.UserException
import de.qfs.apps.qftest.shared.exceptions.ReturnException

def browserOpened = false
try {
    if (_qf_global_url != null) {
        browserOpened = true
    }
} catch (e) {
    // _qf_global_url not set
}

if (! browserOpened) {
    def client = rc.lookup('client')
    def timeout = rc.lookup('timeout')
    
    def error = "No opened browser registered in client '${client}' within ${timeout} milliseconds."
                            
    if (rc.getBool('dologerror')) {
        rc.logError(error)
        throw new ReturnException(null)
    } else {
        throw new UserException(error)
    }
}</code>
              </ClientScriptStep>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:}" id="_2JEY"
                                interpreter="groovy" name="Read called URL">
                <code>assert _qf_global_url != null : "Case _qf_global_url == null handled in script before"

rc.setLocal("calledUrl",_qf_global_url)
_qf_global_url = null

</code>
              </ClientScriptStep>
              <IfSequence id="_2JEZ" name="Should the url be checked?"
                          test="&#34;$(checkUrl)&#34; != &#34;&#34;">
                <ServerScriptStep id="_2JEa" interpreter="groovy"
                                  name="Check URL">
                  <code>def calledUrl = rc.lookup("calledUrl")
def checkUrl = rc.lookup("checkUrl")

if (rc.getBool("isRegex")) {
    def matcher = calledUrl =~ /${checkUrl}/
    rc.check(!!matcher, "Called browser opened with URL ${calledUrl}, which should match ${checkUrl}.")
} else {
    rc.checkEqual(calledUrl, checkUrl, "Browser should be opened with URL ${checkUrl}.")
}</code>
                </ServerScriptStep>
              </IfSequence>
              <IfSequence id="_2JEc" name="Should a procedure be called?"
                          test="&#34;$(callProcedure)&#34; != &#34;&#34;">
                <ProcedureCall id="_2JEd" procedure="$(callProcedure)">
                  <variable name="url">$(calledUrl)</variable>
                  <comment>All other parameters of "waitForBrowserOpen" are also handed over to the called procedure</comment>
                </ProcedureCall>
              </IfSequence>
              <ReturnStep id="_2JEe" retval="$(calledUrl)"/>
            </Procedure>
            <Procedure id="_2KKh" name="stopInterceptingBrowserOpen">
              <comment>Call this procedure to restore the normal behavior before a call to "prepareForBrowserOpen"

@param	client	      The client for which browser calls have been intercepted.

@author QFS,pb
@since 5.2</comment>
              <IfSequence id="_2KKi" name="Check for client parameter"
                          test="&#34;$(client)&#34; == &#34;&#34;">
                <ThrowStep id="_2KKj" throwmessage="No client specified!"/>
              </IfSequence>
              <ProcedureCall id="_2KKk"
                             procedure=".observers.uncatchBrowserOpen">
                <variable name="client">$(client)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2JEq"
                             procedure=".observers.uncatchProcessOpen">
                <variable name="client">$(client)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_6XU" name="dom">
            <comment>Procedures for handling DOM access.

@author	QFS,tm
@since	2.9.1
</comment>
            <Procedure id="_6XV" name="selectAllCheckboxes">
              <variable name="parent"/>
              <variable name="select">true</variable>
              <comment>Check or uncheck all (enabled) Checkboxes which are situated in the DOM-Tree beneath the given Parent.
In most of the cases the parent should be set to the form-Element which contains the checkboxes.

@deprecated Use qfs.web.checkbox.setAll instead.

@param	parent	The parent Element.
@param	select	If set to false, all Checkboxes are unchecked.

@author	QFS,tm
@since	2.9.1</comment>
              <ProcedureCall id="_1jwt" procedure="qfs.web.checkbox.setAll">
                <variable name="check">$(select)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_6Xz" name="dialogs">
            <comment>Procedures for handling Error-Dialogs opened within the Browser.

@author	QFS,tm
@since	2.9.1
</comment>
            <Procedure id="_1lVC" name="closeCertificateWarning">
              <variable name="timeout">30000</variable>
              <variable name="title">.*ertificate.*|Sicherheitshinweis|Security.*</variable>
              <variable name="button">.*Ja|.*Yes|.*Ok|.*OK</variable>
              <comment>Uses the Java AWT Robot/Autowin Methods to automatically close an open Certificate Warning Dialog.

@deprecated Is handled by the browser engine internally.
@param  browser - The browser.
@param  button- The title of the button to click.
@param  timeout with default 30000 - The timeout to wait for the dialog.
@param  title with default .*ertificate.*|Sicherheitshinweis|Security.* - The title of the dialog.

@author	QFS,tm
@since	2.9.1</comment>
              <IfSequence id="_1lVD" test="${qftest:windows}">
                <ServerScriptStep id="_1lVE" interpreter="groovy"
                                  name="Wait for dialog and click">
                  <code>import de.qfs.apps.qftest.shared.exceptions.UserException
import de.qfs.Autowin

def autowin = Autowin.instance()
def win = autowin.waitForWindow(rc.getInt("timeout"), rc.lookup("title"), true)
if (! win) {
    throw new UserException ("Certificate dialog did not appear.")
}
win.setForeground()

def button = autowin.findChildWindow(win, rc.lookup("button"), true)
if (! button) {
    throw new UserException ("Button on Certificate dialog not found.")
}

autowin.doClick(button, 5, 5)</code>
                </ServerScriptStep>
                <ElseSequence id="_1lVF">
                  <ServerScriptStep id="_1lVG" interpreter="groovy">
                    <code>import java.awt.Robot
def r = new Robot()
r.keyPress(10)
r.keyRelease(10)</code>
                  </ServerScriptStep>
                </ElseSequence>
              </IfSequence>
            </Procedure>
            <Procedure id="_6X+" name="closeJavascriptWarning">
              <comment>Uses the Java AWT Robot Methods to automatically close an open Javascript Warning Dialog.

@deprecated Is handled by the browser engine internally.
@author	QFS,tm
@since	2.9.1
</comment>
              <ServerScriptStep id="_2JEM" interpreter="groovy">
                <code>import java.awt.Robot
def r = new Robot()
r.keyPress(10)
r.keyRelease(10)</code>
              </ServerScriptStep>
            </Procedure>
            <Procedure id="_1j+U" name="upload">
              <variable name="filename"/>
              <variable name="title">(?i)Datei.*auswhlen|Datei hochladen|.*upload.*</variable>
              <variable name="button">(?i).*ffnen|.*open</variable>
              <comment>Handle the native Windows Upload dialog (especially for Internet Explorer 8).

@deprecated 	Please use qfs.web.input.fileUpload instead.
@param	filename	The name of the file to be uploaded.
@param	title	A regexp for the title of the dialog.
@param	button	A regexp for the text on the open button.

@author	QFS
@since	3.2</comment>
              <IfSequence id="_1j+V" test="${qftest:windows}">
                <ServerScriptStep id="_1j+W" interpreter="groovy">
                  <code>import de.qfs.apps.qftest.shared.exceptions.UserException
import de.qfs.Autowin

def autowin = Autowin.instance()

def fileName = rc.lookup("filename")
def dialogTitleRe = rc.lookup("title")
def btnTitleRe = rc.lookup("button")

def wnd = autowin.waitForWindow(5000, dialogTitleRe, true)
if (! wnd) {
    throw new UserException("The dialog did not appear.")
}
wnd.setForeground()

def edits = autowin.findChildWindows(wnd, clazz:"Edit")
if (edits.isEmpty()) {
    throw new UserException("Edit window not found.")
}
autowin.setWindowText(edits[0], fileName)
Thread.sleep(1000)

def btns = autowin.findChildWindows(wnd, btnTitleRe, true, "Button")
if (btns.isEmpty()) {
    rc.logWarning(sprintf("Button '%s' not found", btnTitleRe))
    btns = autowin.findChildWindows(wnd, null, false, "Button")
    if (btns.isEmpty()) {
        throw new UserException("Button not found.")
    }
}
def btn = btns[0]
autowin.doClick(btn, 10, 5)
</code>
                </ServerScriptStep>
                <ElseSequence id="_1j+X">
                  <ServerScriptStep id="_1j+C" interpreter="groovy">
                    <code>rc.logWarning("Procedure 'upload' is supported on Windows only")</code>
                  </ServerScriptStep>
                </ElseSequence>
              </IfSequence>
            </Procedure>
          </Package>
          <Package id="_2JAh" name="download">
            <comment>Procedures to handle downloads in QF-Test.

@author	QFS,mm
@since	4.1.0</comment>
            <Procedure id="_2JAi" name="setDownloadProperty">
              <variable name="downloadproperty">1</variable>
              <comment>Set the QF-Test download property.

@param	downloadproperty	0 is default, 
			1 could fix most problems
			2 in rare use-cases.

@author 	QFS, mm
@since 	4.1.0</comment>
              <ClientScriptStep client="$(client)" engine="web" id="_2JAj"
                                interpreter="groovy">
                <code>System.setProperty("de.qfs.meex2.ie.download_direct", rc.lookup("downloadproperty")) </code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Package id="_6Wt" name="general">
            <comment>General browser procedures.

@author	QFS
@since	2.9.0</comment>
            <Procedure id="_1lYI" name="startAsNewProcess">
              <variable name="executable"/>
              <variable name="browsertype">no</variable>
              <variable name="args"/>
              <variable name="url">anUrl</variable>
              <variable name="profileTemplateDir"/>
              <variable name="waitForClientTimeout">120000</variable>
              <variable name="threadDelay">10000</variable>
              <variable name="syncStart">true</variable>
              <variable name="dialogTimeout">-1</variable>
              <comment>Ensures the given browser executable is started as a new process.
This is especially important when testing an applet in the browser.
Otherwise the applet is not properly recognized by QF-Test.

For Internet Explorer this a new process is ensured by a respective command line option.
Firefox and Chrome need to be started with a separate profile in order to not block. Those profiles get created within the .qftest directory below the users home directory. For firefox options are set by creating a user.js in the profile directory to avoid blocking dialogs like checking for default browser, checking for updates etc.
Safari neither offers a command line option nor supports profiles. Therefore in case there are already running instances those will be terminated. In interactive mode a dialog asks for
permission to do so, in batch mode it's simply done.

@param	client    	The client.
@param	executable	The browser executable. Possibly the full path is necessary.
@param	browsertype	The browser type that needs special handling:
		'firefox' for Firefox,
		'chrome' for Google Chrome,
		'safari' for Apple Safari,
		'ie' for Internet Explorer auto detection with respective handling,
 		'ie6' for Internet Explorer 6, (IE7 don't require special handling),
		'ie8' for Internet Explorer 8,
		'ie9' for Internet Explorer 9 or higher,
		'no' for no special handling.
@param	args	Optional browser arguments.
		For Google chrome the following args may become helpful to avoid blocking after update or on new available java plugins: --always-authorize-plugins  --allow-outdated-plugins
@param	url	The URL of (typically) the applet.
@param 	waitForClientTimeout 	Time in ms to wait for the client to connect. Default is 120000.
@param 	profileTemplateDir	Firefox only: Directory containing firefox profile data to be used. The template directory is copied to a temporary location before being used. If not specified an empty profile is used, which is also the default.
@param	threadDelay 	When executing applet tests on multiple threads, a delay can be necessary between the single browser starts to avoid java plugin connection get's confused.
@param	syncStart	Synchronize multiple threads after browser start.
@param 	dialogTimeout	Timeout value in ms for the dialog in interactive mode. When timeout is reached, test continues with terminating the processes. -1 means infinite waiting time.
@author	QFS,kk
@since	3.4</comment>
              <TryStep id="_1lXX"
                       name="First check for Client already connected">
                <ClientWaiter client="$(client)" id="_1lXW" timeout="0"/>
                <ThrowStep id="_1lYJ"
                           throwmessage="Client $(client) already running.">
                  <comment> </comment>
                </ThrowStep>
                <CatchSequence exception="ClientNotConnectedException"
                               id="_1lXY" maxerror="0"/>
              </TryStep>
              <BasicSequence id="_1lYK" name="Start browser as a new process">
                <variable name="browserRunning">false</variable>
                <BasicSequence id="_1lYL" name="IE variants">
                  <IfSequence id="_1lYM" test="${qftest:windows} ">
                    <IfSequence id="_1lYs" name="IE category auto detection"
                                test="&#34;$(browsertype)&#34; == &#34;ie&#34;">
                      <ProcessClientStarter client="reg" executable="cmd"
                                            id="_1lar">
                        <parameter>/c</parameter>
                        <parameter>reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer" /v version | findstr "version" </parameter>
                      </ProcessClientStarter>
                      <ProcessWaiter check="0" client="reg" id="_1lYv"
                                     timeout="5000"/>
                      <ServerScriptStep id="_1lYw" interpreter="groovy"
                                        name="Get ie version and assign to category">
                        <code>import de.qfs.apps.qftest.shared.exceptions.UserException

def regstr = rc.getStr("qftest", "client.output.reg", expand=false)
def fullversion = regstr.split()[2]
def version = fullversion.split('\\.')[0]
try {
    if ((version as Integer) &gt; 8) {
    version = "8"
    }
} catch (NumberFormatException ex) {
    throw new UserException("Could not determine version of Internet Explorer")
}
rc.setLocal("browsertype", "ie" + version)</code>
                      </ServerScriptStep>
                    </IfSequence>
                    <IfSequence id="_1lYS" name="IE6 needs -new arg"
                                test="&#34;$(browsertype)&#34; == &#34;ie6&#34;">
                      <SetGlobalStep id="_1lYp" local="true" varname="args">
                        <default>-new $(args)</default>
                      </SetGlobalStep>
                    </IfSequence>
                    <IfSequence id="_1lYa" name="IE7 -new arg (is default)"
                                test="&#34;$(browsertype)&#34; == &#34;ie7&#34;">
                      <SetGlobalStep id="_1lYq" local="true" varname="args">
                        <default>-new $(args)</default>
                      </SetGlobalStep>
                    </IfSequence>
                    <IfSequence id="_1lYn"
                                name="IE8 and higher need -noframemerging arg"
                                test="&#34;$(browsertype)&#34; == &#34;ie8&#34;">
                      <SetGlobalStep id="_1lYr" local="true" varname="args">
                        <default>-noframemerging $(args)</default>
                      </SetGlobalStep>
                    </IfSequence>
                  </IfSequence>
                </BasicSequence>
                <IfSequence id="_1lXO" name="Firefox"
                            test="&#34;$(browsertype)&#34; == &#34;firefox&#34;">
                  <SetGlobalStep id="_1lXS" local="true" varname="profile">
                    <default>${system:user.home}/.qftest/$(client)_${qftest:thread}_mozProfile</default>
                  </SetGlobalStep>
                  <RepeatSequence count="5" id="_1lpB"
                                  name="Try to remove profile directory">
                    <ProcedureCall id="_1lpC" local="true"
                                   procedure="qfs.shellutils.exists"
                                   retvarname="profDirExists">
                      <variable name="file">$(profile)</variable>
                    </ProcedureCall>
                    <IfSequence id="_1lpD" test="$(profDirExists)">
                      <TryStep id="_1lr7">
                        <ProcedureCall id="_1lr8"
                                       procedure="qfs.shellutils.removeDirectory">
                          <variable name="directory">$(profile)</variable>
                        </ProcedureCall>
                        <CatchSequence exception="TestException" id="_1lr9"
                                       maxerror="1"/>
                      </TryStep>
                      <ElseSequence id="_1lrA">
                        <BreakStep id="_1lrB"/>
                      </ElseSequence>
                    </IfSequence>
                    <BasicSequence id="_1lrC" name="sleep" postdelay="300"/>
                  </RepeatSequence>
                  <IfSequence id="_1mG6"
                              test="&#34;$(profileTemplateDir)&#34; != &#34;&#34;">
                    <ProcedureCall id="_1mG7"
                                   procedure="qfs.shellutils.exists"
                                   retvarname="exists">
                      <variable name="file">$(profileTemplateDir)</variable>
                    </ProcedureCall>
                    <IfSequence id="_1mGA" test="$(exists)">
                      <ProcedureCall id="_1mG8"
                                     procedure="qfs.shellutils.copy">
                        <variable name="source">$(profileTemplateDir)</variable>
                        <variable name="target">$(profile)</variable>
                      </ProcedureCall>
                      <ElseSequence id="_1mGB">
                        <ThrowStep id="_1mGC"
                                   throwmessage="Profile template directory $(profileTemplateDir) doen't exist.">
                          <comment> </comment>
                        </ThrowStep>
                      </ElseSequence>
                    </IfSequence>
                    <ElseSequence id="_1mG9"
                                  name="Create an empty profile directory">
                      <ProcedureCall id="_1mH4"
                                     procedure="qfs.shellutils.mkdir">
                        <variable name="directory">$(profile)</variable>
                      </ProcedureCall>
                    </ElseSequence>
                  </IfSequence>
                  <ServerScriptStep id="_1lau" interpreter="groovy"
                                    name="Set Options to avoid updates check and default browser dialog.">
                    <code>// create a file nameed user.js in the profile directory containing the respective config entries
// to avoid updates checks and default browser dialogs.

def ffOptions = """#Options to avoid checking for updates and asking for default browser
user_pref("browser.shell.checkDefaultBrowser", false);
user_pref("app.update.enabled", false);
user_pref("app.update.service.enabled", false);
user_pref("browser.search.update", false);
user_pref("extensions.update.enabled", false);
user_pref("plugin.state.java", 2);
"""
def profDir = rc.lookup("profile")
new File(profDir + "/user.js").text = ffOptions
</code>
                  </ServerScriptStep>
                  <SetGlobalStep id="_1lYz" local="true" varname="args">
                    <default>-no-remote -profile "$(profile)" $(args)</default>
                  </SetGlobalStep>
                </IfSequence>
                <IfSequence id="_1lY+" name="Chrome"
                            test="&#34;$(browsertype)&#34; == &#34;chrome&#34;">
                  <SetGlobalStep id="_1lY-" local="true" varname="profile">
                    <default>${system:user.home}/.qftest/$(client)_${qftest:thread}_chromeProfile</default>
                  </SetGlobalStep>
                  <RepeatSequence count="5" id="_1lrD"
                                  name="Try to remove profile directory">
                    <ProcedureCall id="_1lYx" local="true"
                                   procedure="qfs.shellutils.exists"
                                   retvarname="profDirExists">
                      <variable name="file">$(profile)</variable>
                    </ProcedureCall>
                    <IfSequence id="_1lYy" test="$(profDirExists)">
                      <TryStep id="_1lrE">
                        <ProcedureCall id="_1lXa"
                                       procedure="qfs.shellutils.removeDirectory">
                          <variable name="directory">$(profile)</variable>
                        </ProcedureCall>
                        <CatchSequence exception="TestException" id="_1lrF"
                                       maxerror="1"/>
                      </TryStep>
                      <ElseSequence id="_1lrG">
                        <BreakStep id="_1lrH"/>
                      </ElseSequence>
                    </IfSequence>
                    <BasicSequence id="_1lrI" name="sleep" postdelay="300"/>
                  </RepeatSequence>
                  <ProcedureCall id="_1lYQ" procedure="qfs.shellutils.mkdir">
                    <variable name="directory">$(profile)</variable>
                  </ProcedureCall>
                  <SetGlobalStep id="_1lYR" local="true" varname="args">
                    <default>--no-first-run --user-data-dir="$(profile)" $(args)</default>
                  </SetGlobalStep>
                </IfSequence>
                <IfSequence id="_1lXe" name="Safari"
                            test="&#34;$(browsertype)&#34; == &#34;Safari&#34;">
                  <IfSequence id="_1lak"
                              name="Only Safari on Windows needs to be terminated"
                              test="${qftest:windows}">
                    <BasicSequence id="_1lZ0"
                                   name="Check for running browser processes">
                      <IfSequence id="_1lZ1"
                                  name="Terminate browser only if it is the first thread"
                                  test="${qftest:thread} &lt; 1">
                        <BasicSequence id="_1lZ2"
                                       name="Check for running browser processes">
                          <ShellClientStarter client="qfps"
                                              command="${qftest:dir.version}\bin\qfps.exe -list | findstr &#34;$(browsertype)&#34;"
                                              id="_1lZ3"/>
                          <ProcessWaiter check="0" client="qfps" id="_1lZ4"
                                         local="true" raise="false"
                                         resvarname="browserRunning"
                                         timeout="30000"/>
                        </BasicSequence>
                        <BasicSequence id="_1lZ5"
                                       name="Possibly show dialog for interactive mode">
                          <IfSequence id="_1lZ6"
                                      test="$(browserRunning) and not ${qftest:batch}">
                            <variable name="dialogres"/>
                            <variable name="title"/>
                            <variable name="message"/>
                            <IfSequence id="_1lZ7"
                                        test="&#34;${system:user.language}&#34; == &#34;de&#34;">
                              <SetGlobalStep id="_1lZ8" local="true"
                                             varname="title">
                                <default>Laufende $(browsertype) Prozesse beenden?</default>
                              </SetGlobalStep>
                              <SetGlobalStep id="_1lZ9" local="true"
                                             varname="message">
                                <default>Es gibt laufende $(browsertype) Prozesse, die beendet werden mssen.
Ansonsten kann QF-Test sich nicht mit dem zu testenden Applet verbinden.

JA wird laufenden $(browsertype) Prozesse nun beenden und einen neuen starten.
NEIN wird diese Prozedur ohne weitere Aktion abbrechen.</default>
                              </SetGlobalStep>
                              <ElseSequence id="_1lZA">
                                <SetGlobalStep id="_1lZB" local="true"
                                               varname="title">
                                  <default>Terminate running $(browsertype) processes?</default>
                                </SetGlobalStep>
                                <SetGlobalStep id="_1lZC" local="true"
                                               varname="message">
                                  <default>There are running $(browsertype) processes that need to be terminated.
Otherwise QF-Test will not be able to connect to the applet to be tested.

YES will terminate the running $(browsertype) processes and start a new one.
NO will abort this procedure without further action.</default>
                                </SetGlobalStep>
                              </ElseSequence>
                            </IfSequence>
                            <ProcedureCall id="_1lZD" local="true"
                                           procedure="qfs.dialogs.showYes_No_Dialog"
                                           retvarname="dialogres">
                              <variable name="title">$(title)</variable>
                              <variable name="msg">$(message)</variable>
                              <variable name="timeout">$(dialogTimeout)</variable>
                              <variable name="alwaysOnTop">True</variable>
                              <variable name="wraplength">160</variable>
                            </ProcedureCall>
                            <IfSequence id="_1lZE"
                                        test="&#34;$(dialogres)&#34; == &#34;1&#34;">
                              <ThrowStep id="_1lZF"
                                         throwmessage="Browser start aborted."/>
                            </IfSequence>
                          </IfSequence>
                        </BasicSequence>
                        <BasicSequence id="_1lZG"
                                       name="Possibly terminate running browser">
                          <IfSequence id="_1lZH" test="$(browserRunning)">
                            <ShellClientStarter client="qfps"
                                                command="qfps -killtree -name $(browsertype).exe"
                                                id="_1lZJ"/>
                            <ProcessWaiter client="qfps" id="_1lZK"
                                           local="true" timeout="30000"/>
                          </IfSequence>
                        </BasicSequence>
                      </IfSequence>
                    </BasicSequence>
                  </IfSequence>
                </IfSequence>
                <IfSequence id="_1lal"
                            name="Possibly sync threads and add thread specific delay"
                            test="${qftest:threads} &gt; 1">
                  <ServerScriptStep id="_1lam" interpreter="groovy">
                    <code>rc.syncThreads("Startup Thread Sync", timeout : 120000)</code>
                  </ServerScriptStep>
                  <BasicSequence id="_1lXg"
                                 name="Add a delay on multiple threads"
                                 postdelay="$[${qftest:thread}*$(threadDelay)]"/>
                </IfSequence>
                <BasicSequence id="_1lZR" name="Start a new browser process">
                  <IfSequence id="_1lYi" test="${qftest:windows}">
                    <ProcessClientStarter client="$(client)" executable="cmd"
                                          id="_1lat">
                      <parameter>/c</parameter>
                      <parameter>"$(executable)" $(args) $(url)</parameter>
                    </ProcessClientStarter>
                    <ElseifSequence id="_1lai"
                                    test="&#34;${system:os.name}&#34; == &#34;Mac OS X&#34;">
                      <ShellClientStarter client="$(client)"
                                          command="open -n -a $(executable) --args $(args) $(url)"
                                          id="_1laj"/>
                    </ElseifSequence>
                    <ElseSequence id="_1lYj">
                      <ShellClientStarter client="$(client)"
                                          command="$(executable) $(args) $(url)"
                                          id="_1lYk"/>
                    </ElseSequence>
                  </IfSequence>
                </BasicSequence>
                <IfSequence id="_1lXi" name="Possibly sync threads"
                            test="${qftest:threads} &gt; 1 and $(syncStart)">
                  <ServerScriptStep id="_1lXh" interpreter="groovy">
                    <code>rc.syncThreads("Startup Thread Sync", timeout : 120000)</code>
                  </ServerScriptStep>
                </IfSequence>
                <ClientWaiter client="$(client)" id="_1mHm"
                              timeout="$(waitForClientTimeout)"/>
              </BasicSequence>
            </Procedure>
            <Procedure id="_6Wr" name="checkForRunningBrowserEngine">
              <variable name="mozprofile"/>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Check for the browser and if is not running than start it.

@param client    	The client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param mozprofile	The directory to store the profile data (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <TryStep id="_6Ws">
                <ClientWaiter client="$(client)" id="_6WF" timeout="0"/>
                <CatchSequence exception="ClientNotConnectedException"
                               id="_6WG" maxerror="0">
                  <IfSequence id="_2JAo"
                              test="${default:startBrowserIfNotRunning:False}">
                    <IfSequence id="_1kJX" test="'$(mozprofile)'!=''">
                      <BrowserClientStarter browser="$(browser)"
                                            client="$(client)"
                                            executable="${qftest:java}"
                                            id="_6WH"
                                            mozhome="${default:mozhome:}"
                                            openwindow="false"
                                            url="about:nowindow">
                        <parameter>-Dqftest.web.profilepath=$(mozprofile)</parameter>
                      </BrowserClientStarter>
                      <ElseSequence id="_1kJY">
                        <BrowserClientStarter browser="$(browser)"
                                              client="$(client)"
                                              executable="${qftest:java}"
                                              id="_1kJZ"
                                              mozhome="${default:mozhome:}"
                                              openwindow="false"
                                              url="about:nowindow"/>
                      </ElseSequence>
                    </IfSequence>
                    <ClientWaiter client="$(client)" id="_6WI"/>
                  </IfSequence>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_6aC" name="isIE6">
              <comment>Checks if running Browser-Engine has embedded Internet Explorer 6.

If true it sets the global variable "isIE6" to true.

@param client    	The client.

@author	QFS,tm
@since	2.9.1
</comment>
              <ComponentWaiter client="$(client)" component="genericDocument"
                               id="_6bN"/>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6bH"
                                interpreter="groovy">
                <code>def doc = rc.getComponent('genericDocument')
def browsertype = doc.getBrowser().getInfo().getBrowserType()
rc.setGlobal("isIE6",false)
if (browsertype == 'ie') {
    def version = doc.getBrowser().getInfo().getBrowserVersion()
    if (! version) {
        if (version[0]=='6') {
            rc.setGlobal("isIE6",true)
        }
    } else {
        rc.logError("Could not determine Version of Internet Explorer")
    }
}</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6Y7" name="openNewWindow">
              <variable name="url"/>
              <variable name="windowname"/>
              <variable name="x">50</variable>
              <variable name="y">50</variable>
              <variable name="width">900</variable>
              <variable name="height">700</variable>
              <comment>Open a new window in an already running browser.

@param          client              The client.
@param          browser          The type of Browser (ie, mozilla).
@param          url                  The URL to open in the new window.
@param          windowname  The name of the new window. (optional)
@param          x                     X-Coordinate for the browser window. (optional)
@param          y                     Y-Coordinate for the browser window. (optional)
@param          width              Width for the browser window. (optional)
@param          height             Height for the browser window. (optional)

@author	QFS,tm
@since	2.9.1</comment>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6Y6"
                                interpreter="groovy">
                <code>def x = rc.getInt("x")
def y = rc.getInt("y")
def width = rc.getInt("width")
def height = rc.getInt("height")

System.getProperties().put("qftest.web.browser.geometry",
                           "${width}x${height}+${x}+${y}")
rc.engine.openBrowserWindow(rc.lookup("browser"), rc.lookup("url"), rc.lookup("windowname"))
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6Y9" name="showUrl">
              <variable name="url"/>
              <comment>Show a different URL in an open browser window.

@param client  The client.
@param url	The URL to show.

@author	QFS,tm
@since	2.9.1</comment>
              <ComponentWaiter client="$(client)" component="genericDocument"
                               id="_6bM"/>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6Y8"
                                interpreter="groovy">
                <code>def com = rc.getComponent("genericDocument")
def url = rc.lookup("url")
rc.engine.getPlayer().notifyLoadURL(url)
com.getBrowser().loadURL(url)
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_2JDg" name="openMobileEmulation">
              <variable name="url"/>
              <variable name="windowname"/>
              <variable name="deviceName">iPhone 8</variable>
              <variable name="orientation">vertical</variable>
              <variable name="insets"/>
              <variable name="x">50</variable>
              <variable name="y">50</variable>
              <variable name="width"/>
              <variable name="height"/>
              <variable name="userAgent"/>
              <variable name="pixelRatio"/>
              <comment>Opens a new browser window which emulates a mobile browser. If the web engine is not started yet, or is using Chrome or headless Chrome and a WebDriver connection, the mobile emulation mode of Chrome is used. Otherwise, the selected browser is started with the mobile userAgent and screen size set to mimic a mobile browser. If already a browser window was opened in the web engine, the web engine is closed, first.

Valid parameters for "deviceName" are:
"iPhone 4", "iPhone 5/SE", "iPhone 5", "iPhone SE", "iPhone 6/7/8", "iPhone 6", "iPhone 7", "iPhone 8", "iPhone 6/7/8 Plus", "iPhone 6 Plus", "iPhone 7 Plus", "iPhone 8 Plus", "iPhone X", "iPhone XR", "iPhone Xs Max", "iPhone Xs", "iPhone 11", "iPhone 11 Pro", "iPhone 11 Pro Max", "iPhone 12", "iPhone 12 Pro", "iPhone 12 Pro Max", "iPhone 12 mini", "BlackBerry Z30", "Nexus 4", "Nexus 5", "Nexus 5X", "Nexus 6", "Nexus 6P", "Pixel 2", "Pixel 2 XL", "Pixel 3", "Pixel 3 XL", "Pixel 4", "Pixel 4 XL", "LG Optimus L70", "Nokia N9", "Nokia Lumia 520", "Microsoft Lumia 550", "Microsoft Lumia 950", "Galaxy S III", "Galaxy S5", "Galaxy S7", "Galaxy S8", "Galaxy S8+", "Galaxy S9", "Galaxy S9+", "Galaxy Note 9", "Samsung Galaxy S10", "Samsung Galaxy S10+", "Samsung Galaxy S10e", "Samsung Galaxy A20", "Samsung Galaxy Note 10", "Samsung Galaxy Note 10+", "Palm PVG100", "JioPhone 2", "Kindle Fire HDX", "iPad Mini", "iPad", "iPad (10.2&#8220;)", "iPad Air", "iPad Air (10.5&#8220;)", "iPad Air (10.9&#8220;)", "iPad Pro", "iPad Pro (10.5&#8220;)", "iPad Pro (12.9&#8220;)", "Blackberry PlayBook", "Nexus 10", "Nexus 7", "Red Hydrogen One", "Galaxy Note 3", "Galaxy Note II", "Galaxy Tab S3", "Samsung Galaxy Tab S4", "Galaxy Note 8", "Laptop with touch", "Laptop with HiDPI screen", "Laptop with MDPI screen", "Moto G4", "Custom"

@param          client              The client name.
@param          url                  The URL to open in the mobile emulation.
@param          windowname  The name of the new window. (optional)
@param          deviceName    A valid device name to use for extracting the mobile device parameters
@param          orientation      If "deviceName" is used, options are "vertical" and "horizontal". (optional)
@param          insets              If "deviceName" is used, can be set to "True" to reduce the visible area by the default browser insets of the device, or to the title of a device specific presentation mode (e.g. "keyboard") to select the insets of this mode, or to an int array like "10,10,10,10". "False" or empty represent the full-screen browser. (optional)
@param          x                     X-Coordinate for the browser window. (optional)
@param          y                     Y-Coordinate for the browser window. (optional)
@param          width              Width of the emulated device. (optional, if deviceName is not set)
@param          height             Height of the emulated device. (optional, if deviceName is not set)
@param          userAgent       The user agent to use. (optional, if deviceName is not set)
@param          pixelRatio       The pixelRatio to emulate. (optional, if deviceName is not set)

@author	QFS,pb
@since	4.2.1</comment>
              <ServerScriptStep id="_2JDk" interpreter="groovy"
                                name="Select and correct parameters">
                <code>import de.qfs.apps.qftest.shared.exceptions.UserException
import de.qfs.apps.qftest.extras.MobileDeviceInfo

def deviceName = rc.lookup("deviceName")
if (deviceName &amp;&amp; ! deviceName.equalsIgnoreCase("Custom")) {
    def deviceInfo = MobileDeviceInfo.getDevices().get(deviceName)

    if (! deviceInfo) {
        throw new UserException(sprintf("The device '%s' could not be emulated. Please provide the device parameter explicetly.", deviceName))
                    }
    deviceInfo.setOrientation(rc.lookup("default","orientation:vertical"))
    deviceInfo.setInsetsTitle(rc.lookup("default","insets:"))

    rc.setLocal("width", deviceInfo.getWidth())
    rc.setLocal("height", deviceInfo.getHeight())
    rc.setLocal("pixelRatio", deviceInfo.getPixelRatio())
    rc.setLocal("userAgent", deviceInfo.getUserAgent())
}

if (! rc.lookup("default","client:")) {
    rc.setLocal("client","emulatedDevice")
}
        
if (! rc.lookup("default","url:")) {
    rc.setLocal("url","about:blank")
}
</code>
                <comment>Emulated Devices data is based on:

https://codesearch.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/emulated_devices/module.json - DevTools License - Copyright 2014 The Chromium Authors. All rights reserved: https://codesearch.chromium.org/chromium/src/third_party/blink/renderer/devtools/LICENSE</comment>
              </ServerScriptStep>
              <BasicSequence id="_2JDi" name="Start web engine">
                <ClientWaiter client="$(client)"
                              engine="${default:guiengine:web}" id="_2JDj"
                              local="true" raise="false"
                              resvarname="isWebEngineRunning" timeout="1"/>
                <IfSequence id="_2JEF" test="$(isWebEngineRunning)">
                  <ClientScriptStep client="$(client)"
                                    engine="${default:guiengine:web}"
                                    id="_2JEJ" interpreter="groovy"
                                    name="Test for opened browser windows">
                    <code>def browsers = rc.engine.getBrowsers()

rc.setLocal("browserWindowsOpened", browsers.length &gt; 0)</code>
                  </ClientScriptStep>
                  <IfSequence id="_2JEK" test="$(browserWindowsOpened)">
                    <ClientStopper client="$(client)" id="_1ojt"/>
                    <ProcessWaiter client="$(client)" id="_1oju"/>
                    <SetGlobalStep id="_2JEI" local="true"
                                   varname="isWebEngineRunning">
                      <default>False</default>
                    </SetGlobalStep>
                  </IfSequence>
                </IfSequence>
                <IfSequence id="_2JDr" test="not $(isWebEngineRunning)">
                  <BrowserClientStarter browser="chrome" client="$(client)"
                                        connectionmode="${default:webmode:Prefer WebDriver}"
                                        executable="${qftest:java}" id="_2JDs"
                                        mozhome="${default:browserdir:}"
                                        openwindow="false"/>
                  <ClientWaiter client="$(client)"
                                engine="${default:guiengine:web}" id="_2JDv"/>
                </IfSequence>
              </BasicSequence>
              <TestStep id="_2YMu">
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_2JDt"
                                  interpreter="groovy"
                                  name="Detect web engine properties">
                  <code>def isQfdriverMode = ("qfdriver" == rc.engine.getConnectionMode())
rc.setLocal("isQfdriverMode", isQfdriverMode)

def defaultBrowser = rc.engine.getDefaultBrowser()
rc.setLocal("browser",defaultBrowser)
rc.setLocal("isChrome", defaultBrowser in ["chrome", "headless-chrome"])

def width = rc.getInt("width")
def height = rc.getInt("height")
rc.setLocal("heightOfWindow", isQfdriverMode ? height + 102 : height) // default decoration height
rc.setLocal("widthOfWindow", isQfdriverMode ? width + 17: width) // default decoration width</code>
                </ClientScriptStep>
              </TestStep>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_2JDh"
                                interpreter="groovy"
                                name="Set Emulation Data">
                <code>import de.qfs.lib.json.JsonObject
import de.qfs.apps.qftest.shared.extensions.SystemProperties

def userAgent = rc.lookup("userAgent")

def emulationData = new JsonObject()
emulationData.add("userAgent",userAgent)
def deviceMetrics = new JsonObject()
emulationData.add("deviceMetrics",deviceMetrics)
deviceMetrics.add("height",rc.getInt("height"))
deviceMetrics.add("width",rc.getInt("width"))
deviceMetrics.add("pixelRatio",rc.getNum("pixelRatio"))

def props = System.getProperties()
props.put(SystemProperties.QFTEST_WEB_MOBILE_EMULATION,emulationData.toString())

rc.engine.preferences().setStrPref(rc.lookup("browser"),"general.useragent.override",userAgent) // For Firefox
props.put(SystemProperties.QFTEST_WEB_CHROME_ARGS,sprintf("\"--user-agent=%s\" %s", userAgent,props.get(SystemProperties.QFTEST_WEB_CHROME_ARGS,""))) // For Chrome</code>
              </ClientScriptStep>
              <TryStep id="_2JD-">
                <IfSequence id="_2JE2"
                            test="&#34;$(browser)&#34; == &#34;safari&#34;">
                  <ProcessClientStarter client="setSafariUserAgent"
                                        directory="/usr/bin"
                                        executable="/usr/bin/defaults"
                                        id="_2JEA">
                    <parameter>write</parameter>
                    <parameter>com.apple.Safari</parameter>
                    <parameter>CustomUserAgent</parameter>
                    <parameter>'$(userAgent)'</parameter>
                  </ProcessClientStarter>
                  <ProcessWaiter client="setSafariUserAgent" id="_2JE5"/>
                </IfSequence>
                <TestStep id="_2YMv">
                  <BrowserClientStarter browser="${default:browser:chrome}"
                                        client="$(client)"
                                        executable="${qftest:java}"
                                        height="$(heightOfWindow)" id="_2JDx"
                                        openwindow="true" url="$(url)"
                                        width="$(widthOfWindow)"
                                        windowname="$(windowname)" x="$(x)"
                                        y="$(y)"/>
                </TestStep>
                <DocumentWaiter client="$(client)" component="genericDocument"
                                id="_2JDw" timeout="60000"
                                windowname="$(windowname)"/>
                <IfSequence id="_2JEC" test="$(isQfdriverMode)">
                  <ClientScriptStep client="$(client)"
                                    engine="${default:guiengine:web}"
                                    id="_2JED" interpreter="groovy"
                                    name="Correct Viewport">
                    <code>def node = rc.getComponent("genericDocument")

def inner = node.getRootElement().getLocationOnScreen()
def outer = node.getBrowserSize()

rc.setLocal("viewportWidth",outer[2]-inner[2]+rc.getInt("width"))
rc.setLocal("viewportHeight",outer[3]-inner[3]+rc.getInt("height"))</code>
                  </ClientScriptStep>
                  <ComponentEventStep client="$(client)"
                                      component="genericDocument"
                                      event="COMPONENT_RESIZED" id="_2JEE"
                                      param1="$(viewportWidth)"
                                      param2="$(viewportHeight)"/>
                </IfSequence>
                <FinallySequence id="_2JE1">
                  <IfSequence id="_2JE6"
                              test="&#34;$(browser)&#34; == &#34;safari&#34;">
                    <ProcessClientStarter client="setSafariUserAgent"
                                          directory="/usr/bin"
                                          executable="/usr/bin/defaults"
                                          id="_2JEB">
                      <parameter>delete</parameter>
                      <parameter>com.apple.Safari</parameter>
                      <parameter>CustomUserAgent</parameter>
                    </ProcessClientStarter>
                    <ProcessWaiter client="setSafariUserAgent" id="_2JE8"/>
                  </IfSequence>
                </FinallySequence>
              </TryStep>
            </Procedure>
            <Procedure id="_2YdL" name="getBestBrowser">
              <variable name="browserDir"/>
              <variable name="connectionMode"/>
              <variable name="throwException">true</variable>
              <comment>Tries to detect the best browser type for the current system and returns its browser name.

@param browserDir	Directory where to find the browser in (optional).
@param connectionMode	Connection mode for the browser (optional).
@param throwException	If true, a TestException is thrown if no browser could be found.

@author QFS,pb
@since 6.0.0</comment>
              <ServerScriptStep id="_2Ydf" interpreter="groovy">
                <code>import de.qfs.apps.qftest.shared.web.best.BestBrowserInfo
import de.qfs.apps.qftest.shared.web.ConnectionMode

def browserDir = rc.lookup("browserDir")
def connectionMode = rc.lookup("connectionMode")

final BestBrowserInfo info = new BestBrowserInfo()

if (browserDir) {
    info.setBrowserDir(browserDir)
}

if (connectionMode) {
    connectionMode = connectionMode.toLowerCase().replaceAll("(?s)\\W+", "").replaceAll("-", "")
    info.setPreferredConnectionMode(ConnectionMode.fromName(connectionMode))
}

info.findExecutable()

if (! info.foundBest()) {
    if (rc.getBool("throwException")) {
        throw new TestException ("No best browser found", "noBestBrowser")
    }
    throw new ReturnException("")
}
throw new ReturnException(info.getSimpleBrowserName())</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
          <Package id="_6WP" name="mozilla">
            <comment>Mozilla utility procedures.

@author	QFS
@since	2.9.0</comment>
            <Procedure id="_1oC9" name="cleanupProfileDir">
              <variable name="mozprofile"/>
              <comment>Performs several cleanup actions on the given mozProfile directory. If no directory is given the default directory (user.home)/.qftest/mozProfile is used.

@param    mozprofile     The Mozilla profile directory.

@author	QFS,tm
@since	4.0.0</comment>
              <ServerScriptStep id="_1oCA" interpreter="groovy"
                                name="cleanupPlaces">
                <code>// helper functions

// removes all occurrences of mozillas places files in the given directory
def cleanupPlaces(profileFolder) {
    def dir = new File(profileFolder);
    def p = ~/places.*sqlite.*/
    if (dir.isDirectory()) {
        rc.logMessage("---- cleaning up places files");
        dir.eachFileMatch (p) { file -&gt;
            if (file.delete()) {
                rc.logMessage( "----- successfully deleted: " + file.getName());
            } else {
                rc.logWarning( "----- failed to delete: " + file.getName());
            }
        }
        rc.logMessage("---- finished cleaning up places files");
    } else {
        rc.logMessage("---- directory doesn't exist yet. Nothing to clean up.");
    }
}

profiledir = rc.lookup("mozprofile");
//if no mozprofile is defined the default location is used
if (profiledir.isEmpty()){
    profiledir = rc.lookup("system","user.home");
}
profiledir += "/.qftest/mozProfile";
rc.logMessage("--- prepare for cleanup of profile folder (" + profiledir + ")");

try {
   cleanupPlaces(profiledir);
} catch (e) {
    rc.logWarning("Cleanup failed: \n" + e);
}
rc.logMessage("--- profile cleanup finished");</code>
              </ServerScriptStep>
            </Procedure>
          </Package>
          <Package id="_6Wj" name="settings">
            <comment>The procedures in this package are useful for customizing browser settings.

@author QFS
@since 2.9.0</comment>
            <Procedure id="_5B1" name="deleteCookies">
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Delete cookies.

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHn" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6Ww"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_5B2"
                                interpreter="groovy">
                <code>rc.engine.preferences().deleteAllCookies(rc.lookup("browser"))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_5B5" name="disableCookies">
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Disable cookies in the browser.

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHm" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6Wv"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_5B6"
                                interpreter="groovy">
                <code>rc.engine.preferences().setCookiesBehavior(rc.lookup("browser"),false)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_5B0" name="doStartupSettings">
              <variable name="emptyCache">true</variable>
              <variable name="enableCookies">true</variable>
              <variable name="deleteCookies">true</variable>
              <variable name="locale"/>
              <variable name="enableProxy">false</variable>
              <variable name="proxyAddress"/>
              <variable name="proxyPort"/>
              <variable name="enableProxyBypass">false</variable>
              <variable name="proxyBypass"/>
              <variable name="proxyAutoconfigurl"/>
              <variable name="proxyType"/>
              <variable name="compatibilitymode">no</variable>
              <variable name="mozprofile"/>
              <variable name="consoleOutputValue">0</variable>
              <variable name="userAgentValue"/>
              <variable name="directDownloadsDir"/>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Do startup settings for the  browser. This procedure is used by the Quickstart Wizard.

@param	client		The name of the SUT client.
@param	browser		The browser.
@param	mozhome		The Mozilla installation directory (optional).
@param	mozprofile		The folder to store the profile-data(optional).
@param	compatibiltymode	Set the compatibility mode for Internet Explorer (either "ie7", "ie8", "ie8doc", "ie9", "ie9doc", "ie10", "ie10doc", "ie11" or "ie11doc"). With modes ending with doc, webpages containing standard-based !DOCTYPE directives are displayed in the original browser mode. With modes not ending with doc, all webpages are displayed just in this mode regardless of the !DOCTYPE directive.
@param	emptyCache		true, to enable caching.
@param	enableCookies		true, to allow cookies.
@param	deleteCookies		true, to delete stored cookies.
@param	locale		The locale to be used.
@param	enableProxy		true to enable proxy settings
@param	proxyAddress		Optional address for a proxy server.
@param	proxyPort		Optional port for a proxy server.
@param	enableProxyBypass	true to overwrite system proxy bypass settings when proxy is enabled. 
@param 	proxyBypass		Optional list of URLs to exclude from Proxy. Use ',' as separator.
@param 	proxyAutoconfigurl  	URL to get the proxy configuration from.
@param 	proxyType   		Type of proxy (is empty by default; set regardless of activate). If empty, the proxy type is determined by address and autoconfigurl parameters. For details, see comments on setProxy procedure
@param	consoleOutputValue	0, to forward no logs from browser console to QF-Test terminal; 1, to forward logs; 2, to forward logs with timestamp; 3, to forward logs with log level; 4, to forward logs with timestamp and log level; 5, to forward logs with timestamp, log level and multiline description (option 5 is available for CDP-Driver only); parameter is optional, default value is 0. 
@param	userAgentValue	The user agent to be used (not empty value, to override user agent).
@param	directDownloadsDir	Add a path here if you want to have files directly downloaded to this directory and avoid download dialogs. If the parameter left empty, you will need to choose download path via dialog as usual. (The parameter is evaluated in CDP-Driver mode only.)
@param 	startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHh" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <IfSequence id="_1oC7" test="'$(mozprofile)'==''">
                <ProcedureCall id="_1oC8"
                               procedure="qfs.web.browser.mozilla.cleanupProfileDir">
                  <variable name="mozprofile">$(mozprofile)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_1k0C"
                          test="&#34;$(compatibilitymode)&#34;!=&#34;no&#34;">
                <ProcedureCall id="_1k0D"
                               procedure="qfs.web.browser.settings.enableCompatibilityMode">
                  <variable name="compatibilitymode">$(compatibilitymode)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_6W-" test="$(emptyCache)">
                <ProcedureCall id="_6WJ"
                               procedure="qfs.web.browser.settings.emptyCache">
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_6X0" test="$(enableCookies)">
                <ProcedureCall id="_6X1"
                               procedure="qfs.web.browser.settings.enableCookies">
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
                <ElseSequence id="_6X2">
                  <ProcedureCall id="_6X3"
                                 procedure="qfs.web.browser.settings.disableCookies">
                    <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                  </ProcedureCall>
                </ElseSequence>
              </IfSequence>
              <IfSequence id="_6X4" test="$(deleteCookies)">
                <ProcedureCall id="_6X5"
                               procedure="qfs.web.browser.settings.deleteCookies">
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_6X6" test="&#34;$(locale)&#34; != &#34;&#34;">
                <ProcedureCall id="_6X7"
                               procedure="qfs.web.browser.settings.setLocale">
                  <variable name="locale">$(locale)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_2YN3"
                          test="&#34;$(consoleOutputValue)&#34; != &#34;0&#34;">
                <ProcedureCall id="_2YN4"
                               procedure="qfs.web.browser.settings.setTerminalLogs">
                  <variable name="consoleOutputValue">$(consoleOutputValue)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <IfSequence id="_2YND"
                          test="&#34;$(userAgentValue)&#34; != &#34;&#34;">
                <ProcedureCall id="_2YNE"
                               procedure="qfs.web.browser.settings.setUserAgent">
                  <variable name="userAgentValue">$(userAgentValue)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <ServerScriptStep id="_2Yd-" interpreter="groovy">
                <code>def directDownloadsDir = rc.lookup("directDownloadsDir")
def isDirectDownload = false
if (directDownloadsDir != null &amp;&amp; directDownloadsDir != "") {
    isDirectDownload = true
}
rc.setLocal("isDirectDownload", isDirectDownload)
</code>
              </ServerScriptStep>
              <IfSequence id="_2YNr"
                          test="&#34;$(isDirectDownload)&#34; == &#34;true&#34;">
                <ProcedureCall id="_2YNs"
                               procedure="qfs.web.browser.settings.setDirectDownload">
                  <variable name="downloadsDir">$(directDownloadsDir)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </IfSequence>
              <BasicSequence id="_2JKE" name="proxySettings">
                <BasicSequence id="_2JLK"
                               name="Backward compatibility checks">
                  <IfSequence id="_2JAm"
                              name="Probably use old &#34;type&#34; parameter"
                              test="rc.lookup(&#34;default&#34;, &#34;proxyType:&#34;)==''">
                    <SetGlobalStep id="_2JAn" local="true"
                                   varname="proxyType">
                      <default>${default:type:}</default>
                    </SetGlobalStep>
                  </IfSequence>
                  <IfSequence id="_2J4v"
                              name="Probably use old &#34;autoconfigurl&#34; parameter"
                              test="rc.lookup(&#34;default&#34;, &#34;proxyAutoconfigurl:&#34;)==''">
                    <SetGlobalStep id="_2J4u" local="true"
                                   varname="proxyAutoconfigurl">
                      <default>${default:autoconfigurl:}</default>
                    </SetGlobalStep>
                  </IfSequence>
                </BasicSequence>
                <SetGlobalStep id="_2JKD" local="true"
                               varname="activateProxy">
                  <default>$[1 if rc.getBool("enableProxy") else 0]</default>
                </SetGlobalStep>
                <ProcedureCall id="_1n5-"
                               procedure="qfs.web.browser.settings.setProxy">
                  <variable name="activate">$(activateProxy)</variable>
                  <variable name="address">$(proxyAddress)</variable>
                  <variable name="port">$(proxyPort)</variable>
                  <variable name="enableProxyBypass">$(enableProxyBypass)</variable>
                  <variable name="bypass">$(proxyBypass)</variable>
                  <variable name="autoconfigurl">$(proxyAutoconfigurl)</variable>
                  <variable name="type">$(proxyType)</variable>
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
              </BasicSequence>
            </Procedure>
            <Procedure id="_6Wy" name="emptyCache">
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Empty the browser cache.

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHi" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6Wz"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6W+"
                                interpreter="groovy">
                <code>rc.engine.preferences().deleteCache(rc.lookup("browser"))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_5B3" name="enableCookies">
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Enable cookies in the browser.

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHl" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6Wu"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_5B4"
                                interpreter="groovy">
                <code>rc.engine.preferences().setCookiesBehavior(rc.lookup("browser"),true)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1k0E" name="enableCompatibilityMode">
              <variable name="compatibilitymode">ie7</variable>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Sets the compatibilitymode in Internet Explorer.
(This procedure is only working at browser startup)

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param compatibilitymode     The compatibility mode (either "ie7", "ie8", "ie8doc", "ie9", "ie9doc", "ie10", "ie10doc", "ie11" or "ie11doc"). With modes ending with doc, webpages containing standard-based !DOCTYPE directives are displayed in the original browser mode. With modes not ending with doc, all webpages are displayed just in this mode regardless of the !DOCTYPE directive.
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 3.3.0</comment>
              <ProcedureCall id="_1oHj" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <IfSequence id="_1k0F" test="'$(browser)'=='ie'">
                <ProcedureCall id="_1k0G"
                               procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                  <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
                </ProcedureCall>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_1kGh"
                                  interpreter="groovy">
                  <code>import de.qfs.apps.qftest.shared.exceptions.UserException

def mode = rc.lookup("compatibilitymode")

def getEMode(mode) {
    switch (mode) {
        case "ie7":     return 7000
        case "ie8":     return 8888
        case "ie8doc":  return 8000
        case "ie9":     return 9999
        case "ie9doc":  return 9000
        case "ie10":    return 10001
        case "ie10doc": return 10000
        case "ie11":    return 11001
        case "ie11doc": return 11000
    }
    throw new UserException("invalid compatibility mode. Use either ie7, ie8, ie8doc, ie9, ie9doc, ie10, ie10doc, ie11c or ie11doc.")
}

rc.engine.preferences().setIntPref(rc.lookup("browser"),"general.ie_emulationmode",getEMode(mode))</code>
                  <comment>see http://msdn.microsoft.com/en-us/library/ee330730%28v=VS.85%29.aspx for more information on browser emulation constants</comment>
                </ClientScriptStep>
              </IfSequence>
            </Procedure>
            <Procedure id="_1k0S" name="enableMutationListeners">
              <variable name="documentId"/>
              <variable name="enable">true</variable>
              <variable name="forceRescanOnEnable">true</variable>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Enable/Disable MutationListeners in the QF-Test browser engine for a specific document or globally for all documents.

@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param	documentId     If empty or not present, enable/disable works globally for all document. Otherwise for the documentId given
@param	enable	enable/disable MutationListener
@param	forceRescanOnEnable force a DOM rescan after enabling the Mutation Listener
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 3.4.0.</comment>
              <ProcedureCall id="_1oHk" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_1k0T"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ServerScriptStep id="_1oHF" interpreter="groovy">
                <code>def docId = rc.lookup("documentId")
if (docId.isEmpty()) {
    docId = "genericDocument"
}
rc.setLocal("doc", docId)</code>
              </ServerScriptStep>
              <ComponentWaiter client="$(client)" component="$(doc)"
                               id="_1oHG"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_G"
                                interpreter="groovy">
                <code>def alldocs = false
def docId = rc.lookup("documentId")
def enable = rc.getBool("enable")
def rescan = rc.getBool("forceRescanOnEnable")
def document = null
if (! docId.isEmpty()) {
    document = rc.getComponent(docId)
    rc.logMessage(sprintf("MutationListeners set to: %d rescan: %d for documentId: %s",enable,rescan,docId))
} else {
    document = rc.getComponent('genericDocument')
    alldocs = true
    rc.logMessage(sprintf("MutationListeners set to: %d rescan: %d for all documents",enable,rescan))
}
document.enableMutationListener(alldocs, enable, rescan )</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_2Ydg" name="setDirectDownload">
              <variable name="downloadsDir"/>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Whether show download dialog at download (empty downloadsDir) or to download a file directly in provided directory. The procedure is evaluated in CDP-Driver mode only.

@param downloadsDir		The path to save downloaded file (no direct download if empty)
@param client			The name of the SUT client.
@param browser 		The browser.
@param mozhome		The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS
@since 5.3.0</comment>
              <ProcedureCall id="_2YNo" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_2YNp"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2Ydz"
                             procedure="._helpers._checkCdpDriverMode"/>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_2YNq"
                                interpreter="groovy">
                <code>rc.engine.preferences().setDirectDownload(rc.lookup("browser"), rc.lookup("downloadsDir"))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6Wk" name="setLocale">
              <variable name="locale"/>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Set preferred language for in the displaying web pages in the browser.


@param client		The name of the SUT client.
@param browser 	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param locale		The locale, i.e. en for english, en-us for english/United States.
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 2.9.0</comment>
              <ProcedureCall id="_1oHo" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6Wx"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6Wm"
                                interpreter="groovy">
                <code>rc.engine.preferences().setStrPref(rc.lookup("browser"),"general.useragent.locale",rc.lookup('locale'))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_6cL" name="setProxy">
              <variable name="address"/>
              <variable name="port"/>
              <variable name="enableProxyBypass">false</variable>
              <variable name="bypass"/>
              <variable name="activate">1</variable>
              <variable name="autoconfigurl"/>
              <variable name="type"/>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Set a proxy server for the browser.

@param client		The name of the SUT client.
@param browser	The browser.
@param mozhome	The Mozilla installation directory (optional).
@param address	The address of the proxy server (only set if activate=1).
@param port		The port of the proxy server (only set if activate=1).
@param enableProxyBypass   true to overwrite system proxy bypass settings, false to ignore the parameter.
@param bypass 	List of URLs to exclude from proxy. Use ',' as separator.  (only set if activate=1 and enableProxyBypass=true)
@param activate       	1 to activate the parameters address, port, bypass and autoconfigurl, 0 to use a direct connection (no proxy).
@param autoconfigurl  	URL to get the proxy configuration from.
@param type   	Type of proxy (is empty by default; set regardless of activate value). If empty, the type is determined by address and autoconfigurl parameters.
		Optional values to override the default behavior:
		proxy off (use direct connection) = 0 ;
		proxy on = 1;
		use autoconfig proxy url = 2;
		auto detect proxy = 4;
		use system proxy settings = 5;
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS,tm
@since 3.0.1</comment>
              <ProcedureCall id="_1oHp" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_6cM"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_6cN"
                                interpreter="groovy">
                <code>def browser = rc.lookup("browser")
def autoconfurl = rc.getStr("autoconfigurl")
def address = rc.getStr("address")
def overridetype = rc.lookup("type")
def enableBypass = rc.lookup("enableProxyBypass")
def bypass = rc.lookup("bypass")
def proxytype = 0
def preferences = rc.engine.preferences()
if (rc.getInt("activate")) {
   if (! address.isEmpty()) {
      proxytype = 1
      preferences.setIntPref(browser,"network.proxy.http_port", rc.getInt("port"))
      preferences.setStrPref(browser,"network.proxy.http",address)
      if (rc.getBool("enableProxyBypass")) {
         preferences.setStrPref(browser,"network.proxy.no_proxies_on",bypass)
     }
   } else if(! autoconfurl.isEmpty()) {
      proxytype = 2
      if (autoconfurl.indexOf("://") == -1) {
         autoconfurl = "http://" + autoconfurl
      }
      preferences.setStrPref(browser,"network.proxy.autoconfig_url",autoconfurl)
  }
}
if (! overridetype.isEmpty()) {
    proxytype = Integer.parseInt(overridetype)
}
preferences.setIntPref(browser,"network.proxy.type", proxytype)</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_2YM-" name="setTerminalLogs">
              <variable name="consoleOutputValue">0</variable>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Whether to pass on browser console logs to QF-Test terminal

@param consoleOutputValue		0, to forward no logs from browser console to QF-Test terminal; 1, to forward logs; 2, to forward logs with timestamp, 3, to forward logs with log level; 4, to forward logs with timestamp and log level; 5, to forward logs with timestamp, log level and multiline description (option 5 is available for CDP-Driver only).
@param client			The name of the SUT client.
@param browser 		The browser.
@param mozhome		The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS
@since 5.3.0</comment>
              <ProcedureCall id="_2YN0" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_2YN1"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_2YN2"
                                interpreter="groovy">
                <code>System.setProperty("qftest.web.console_output", rc.lookup("consoleOutputValue"))</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_2YN9" name="setUserAgent">
              <variable name="userAgentValue">New User Agent</variable>
              <variable name="startBrowserIfNotRunning">false</variable>
              <comment>Set user agent for the browser.

@param userAgentValue		The new value for user agent.
@param client			The name of the SUT client.
@param browser 		The browser.
@param mozhome		The Mozilla installation directory (optional).
@param startBrowserIfNotRunning	If true, the browser will be started, default is false not to start the browser. (optional).

@author QFS
@since 5.3.0</comment>
              <ProcedureCall id="_2YNA" local="true"
                             procedure="._helpers._checkBrowserValid"
                             retvarname="browser"/>
              <ProcedureCall id="_2YNB"
                             procedure="qfs.web.browser.general.checkForRunningBrowserEngine">
                <variable name="startBrowserIfNotRunning">$(startBrowserIfNotRunning)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_2YNC"
                                interpreter="groovy">
                <code>rc.engine.preferences().setUserAgent(rc.lookup("browser"), rc.lookup("userAgentValue"))</code>
              </ClientScriptStep>
            </Procedure>
            <Package id="_1oHf" name="_helpers">
              <Procedure id="_1oHg" name="_checkBrowserValid">
                <comment>Test whether the browser parameter is valid, i.e. one of 'ie', 'mozilla' or 'chrome. Otherwise throw an exception.

@param	browser	The browser to check.

@return	The valid browser, possibly mapped to a primary name in case of an alias like firefox/mozilla.</comment>
                <ServerScriptStep id="_1oHe" interpreter="groovy"
                                  name="Check browser">
                  <code>import de.qfs.apps.qftest.shared.exceptions.TestException
import de.qfs.apps.qftest.shared.exceptions.ReturnException

def browser = rc.lookup("browser")
// Map aliases
if (browser == "firefox") browser = "mozilla"
if (browser == "headless") browser = "headless-chrome"
// Check validity
if (! (browser in ["ie", "mozilla", "chrome", "safari", "opera", "edge", "msedge", "classicedge", "electron", "headless-firefox", "headless-chrome", "headless-edge"])) {
    throw new TestException("Illegal browser: " + browser)
}
throw new ReturnException(browser)</code>
                </ServerScriptStep>
              </Procedure>
              <Procedure id="_2Ydr" name="_checkCdpDriverMode">
                <comment>Tests whether CDP-Driver mode is used. Otherwise logs a Warning in runlog.</comment>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_2Yd+"
                                  interpreter="groovy"
                                  name="Check CDP-Driver Mode">
                  <code>def connectionMode = rc.engine.getConnectionMode()
def isCdpMode = connectionMode.contains("cdp")
def message = "Connection mode expected to be CDP-Driver in this procedure, but is " + connectionMode + "."
if (!isCdpMode) {
    rc.logWarning(message, false)
}</code>
                </ClientScriptStep>
              </Procedure>
            </Package>
          </Package>
        </Package>
        <Package id="_6a5" name="checkbox">
          <comment>Procedures to set the state of checkboxes.
(Web component &lt;code&gt;INPUT:CHECKBOX&lt;/code&gt;)

@author	QFS
@since	3.0</comment>
          <Procedure id="_6a8" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS,tm
@since	3.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_6a9" procedure="qfs.swing.checkbox.deselect">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9u" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9v"
                           procedure="qfs.swing.checkbox.deselectWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1l9K" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1l9L">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1l9M"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1l9N" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1l9O"
                             maxerror="0">
                <ReturnStep id="_1l9P" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_6a6" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.


@author	QFS,tm
@since	3.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_6a7" procedure="qfs.swing.checkbox.select">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9w" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9x"
                           procedure="qfs.swing.checkbox.selectWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_6aA" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).


@author	QFS,tm
@since	3.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_6aB" procedure="qfs.swing.checkbox.set">
              <variable name="id">$(id)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1n9y" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1n9z"
                           procedure="qfs.swing.checkbox.setWithCoordinates">
              <variable name="id">$(id)</variable>
              <variable name="x">$(x)</variable>
              <variable name="y">$(y)</variable>
            </ProcedureCall>
          </Procedure>
          <Procedure id="_1jww" name="setAll">
            <variable name="parent">${id:aParentComponent}</variable>
            <variable name="check">true</variable>
            <comment>Set all (enabled) checkboxes inside a given parent.
In most of the cases the parent should be set to the form-Element which contains the checkboxes.

@param	parent	The parent element.
@param	check	The check value to be set (either true or false).

@author	QFS,kk
@since	3.1.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(parent)"
                             id="_1oG-"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1jwv"
                              interpreter="groovy">
              <code>def form = rc.getComponent(rc.lookup('parent'))
def inputs = form.getElementsByTagName("input")
def index = 0
while (index &lt; inputs.length) {
    child = inputs[index]
    if ('checkbox'.equals(child.getAttribute('type'))) {
        if (! '1'.equals(child.getAttribute('disabled'))) {
            child.setAttribute("checked",rc.lookup('check'))
        }
    }
    index += 1
}</code>
            </ClientScriptStep>
          </Procedure>
        </Package>
        <Package id="_6X8" name="checks">
          <comment>Procedures for handling different web checks.

@author	QFS,tm
@since	2.9.1
</comment>
          <Package id="_76q" name="style">
            <comment>Procedures for handling different element style checks.

@author QFS,tm
@since 3.5.
</comment>
            <Package id="_76o" name="color">
              <comment>Procedures for handling different element style checks concerning color attributes.

@author QFS,tm
@since   3.5.</comment>
              <Procedure id="_76i" name="checkColor">
                <variable name="id">${id:aComponentId}</variable>
                <variable name="value"/>
                <comment>Checks the value that indicates the color of the text of the component.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The color to check for.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
                <ProcedureCall id="_76j"
                               procedure="qfs.web.checks.style.checkStyleAttribute">
                  <variable name="attribute">color</variable>
                  <variable name="id">$(id)</variable>
                  <variable name="value">$(value)</variable>
                </ProcedureCall>
              </Procedure>
              <Procedure id="_76m" name="checkBackgroundColor">
                <variable name="id">${id:aComponentId}</variable>
                <variable name="value"/>
                <comment>Checks the value that indicates the color behind the content of the component.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The background color to check for.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
                <IfSequence id="_776" test="'$(browser)'.startswith('ie')">
                  <ProcedureCall id="_76n"
                                 procedure="qfs.web.checks.style.checkStyleAttribute">
                    <variable name="attribute">backgroundColor</variable>
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                  </ProcedureCall>
                  <ElseSequence id="_778">
                    <ProcedureCall id="_77A"
                                   procedure="qfs.web.checks.style.checkStyleAttribute">
                      <variable name="attribute">background-color</variable>
                      <variable name="id">$(id)</variable>
                      <variable name="value">$(value)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </Procedure>
            </Package>
            <Package id="_76p" name="font">
              <comment>Procedures for handling different element style checks concerning font attributes.

@author QFS,tm
@since   3.5.</comment>
              <Procedure id="_76Z" name="checkFontName">
                <variable name="id">${id:aComponentId}</variable>
                <variable name="value"/>
                <comment>Checks the name of the font used for text in the component.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The Font-Family to check for.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
                <IfSequence id="_76s" test="'$(browser)'.startswith('ie')">
                  <ProcedureCall id="_76a"
                                 procedure="qfs.web.checks.style.checkStyleAttribute">
                    <variable name="attribute">fontFamily</variable>
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                  </ProcedureCall>
                  <ElseSequence id="_76t">
                    <IfSequence id="_1oHV"
                                test="'$(browser)'.startswith('firefox')">
                      <ServerScriptStep id="_775" interpreter="groovy"
                                        name="strip whitespaces">
                        <code>def value = rc.lookup('value')
value = value.replace(', ',',')
value = value.replace(' ,',',')
rc.setLocal('value',value)</code>
                      </ServerScriptStep>
                    </IfSequence>
                    <ProcedureCall id="_76r"
                                   procedure="qfs.web.checks.style.checkStyleAttribute">
                      <variable name="attribute">font-family</variable>
                      <variable name="id">$(id)</variable>
                      <variable name="value">$(value)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </Procedure>
              <Procedure id="_76d" name="checkFontSize">
                <variable name="id">${id:aComponentId}</variable>
                <variable name="value"/>
                <comment>Checks the value that indicates the font size used for text in the component

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The font size to check for.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
                <IfSequence id="_76u" test="'$(browser)'.startswith('ie')">
                  <ProcedureCall id="_76e"
                                 procedure="qfs.web.checks.style.checkStyleAttribute">
                    <variable name="attribute">fontSize</variable>
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                  </ProcedureCall>
                  <ElseSequence id="_76w">
                    <ProcedureCall id="_76y"
                                   procedure="qfs.web.checks.style.checkStyleAttribute">
                      <variable name="attribute">font-size</variable>
                      <variable name="id">$(id)</variable>
                      <variable name="value">$(value)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </Procedure>
              <Procedure id="_76f" name="checkFontStyle">
                <variable name="id">${id:aComponentId}</variable>
                <variable name="value"/>
                <comment>Checks the value that indicates the font style used for text in the component (italic, normal or oblique)

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The font style to check for. (italic, normal or oblique)

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
                <IfSequence id="_76z" test="'$(browser)'.startswith('ie')">
                  <ProcedureCall id="_771"
                                 procedure="qfs.web.checks.style.checkStyleAttribute">
                    <variable name="attribute">fontStyle</variable>
                    <variable name="id">$(id)</variable>
                    <variable name="value">$(value)</variable>
                  </ProcedureCall>
                  <ElseSequence id="_76-">
                    <ProcedureCall id="_76g"
                                   procedure="qfs.web.checks.style.checkStyleAttribute">
                      <variable name="attribute">font-style</variable>
                      <variable name="id">$(id)</variable>
                      <variable name="value">$(value)</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </Procedure>
            </Package>
            <Procedure id="_76Q" name="checkStyleAttribute">
              <variable name="id">${id:aComponentId}</variable>
              <variable name="attribute"/>
              <variable name="value"/>
              <comment>Checks a specific style attribute for the given component.

It writes an error into the run-log, if the check fails.

@param          browser          The type of Browser (ie, mozilla).
@param	id	The id of the component.
@param	attribute	The attribute which should be checked.
@param	value	The attribute value to check for.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_76S"
                             procedure="qfs.web.checks.style.getStyleAttributeThroughJS"
                             retvarname="cssValue">
                <variable name="id">$(id)</variable>
                <variable name="attribute">$(attribute)</variable>
              </ProcedureCall>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_76R"
                                interpreter="groovy">
                <code>def cssValue = rc.lookup('cssValue')
//RGB conversion
//(mozilla based browsers return color attributes as rgb)
def m  = (cssValue =~ /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/)
if (m) {
    cssValue = sprintf('#%02x%02x%02x',m.group(1) as Integer,m.group(2) as Integer,m.group(3) as Integer)
    // "#0088aa" -&gt; "#08a"
    if (cssValue.length() == 7 &amp;&amp; cssValue[1] == cssValue[2] &amp;&amp; cssValue[3] == cssValue[4] &amp;&amp; cssValue[5] == cssValue[6] ) {
        cssValue = sprintf('#%s%s%s',cssValue[1],cssValue[3],cssValue[5])
    }
}
cssValue = cssValue.replace("\"","'")
rc.checkEqual(cssValue, rc.lookup('value'), "Checking style attribute")</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_76N" name="getStyleAttributeThroughJS">
              <variable name="id">${id:aComponentId}</variable>
              <variable name="attribute"/>
              <comment>Returns the value of a specific style attribute of the given component.

@param          browser          The type of Browser (ie, mozilla).
@param	id	The id of the component.
@param	attribute	The style attribute to check for.

@return 	The value of the style attribute. Returns "undefined" if the style attribute not exists.

@author QFS,tm
@since 3.5.

@ignoreanalyzerefcid</comment>
              <BasicSequence id="_76V">
                <variable name="result"/>
                <ComponentWaiter client="$(client)" component="$(id)"
                                 id="_1oH0"
                                 timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                  <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
                </ComponentWaiter>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_1lYF"
                                  interpreter="groovy">
                  <code>//expand the given component
def node = rc.getComponent(rc.lookup('id'))
// expand the given style attribute
def styleProperty = rc.lookup('attribute')

//convert stype properties like text-decoration to single worded
//properties because Internet Explorer below 9 doesn't support
//multi-worded properties
if (rc.lookup("browser") == "ie") {
    def strings = styleProperty.split("-")
    if (strings.length &gt; 1) {
        def second = strings[1].capitalize()
        styleProperty = strings[0] + second
    }
}

// "_qf_node" in evalJS always references the node on which evalJS is called

//The javascript code to execute in the browser engine.
def jscode = sprintf("""
function getStyle()
{
    if (_qf_node.currentStyle)
    {//Internet Explorer properties
       var result = _qf_node.currentStyle['%s'];
       while (result == "inherit")
        {//because IE has no computedStyle attribute
            if (_qf_node.nodeName == "HTML")
            {
                break;
            }
            var parent = _qf_node.parentNode;
            if (parent.currentStyle)
            {
                _qf_node = parent;
                result = _qf_node.currentStyle['%s'];
            }
        }
    }
    else if (window.getComputedStyle)
    {//Mozilla properties
        var result = document.defaultView.getComputedStyle(_qf_node,null).getPropertyValue('%s');
    }
    return result;
}
document._qf_error = ""
try { getStyle();}catch (e){ document._qf_error = e;}
""", styleProperty,styleProperty,styleProperty)
//evaluating the javascript code inside the browser engine
def result = node.evalJS(jscode)
//setting return value for the procedure
if (result) {
  rc.setLocal("result", result)
} else {
  rc.setLocal("result", "undefined")
}

def error = node.evalJS("""function returnError(e){
return e.toString();}
returnError(document._qf_error);""")
if (error) {
    rc.logError("javascript error occured: "+error)
}
</code>
                </ClientScriptStep>
                <ReturnStep id="_76U" retval="$(result)"/>
              </BasicSequence>
            </Procedure>
          </Package>
          <Procedure id="_6X9" name="checkTitle">
            <variable name="title"/>
            <variable name="reportName"/>
            <comment>Checks the title of the BrowserWindow.

It writes an error into the run-log, if the check fails.

@param title	  	Title, which should be checked.
@param reportName	the Name for the check in the report.

@author QFS,tm
@since 2.9.1</comment>
            <CheckStringStep checktype="title" client="$(client)"
                             component="genericDocument" id="_6XA"
                             name="$(reportName)" timeout="100">
              <text>$(title)</text>
            </CheckStringStep>
          </Procedure>
          <Procedure id="_6XB" name="checkAttribute">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="attribute"/>
            <variable name="value"/>
            <variable name="appearInReport">1</variable>
            <comment>Checks an attribute of a component.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	attribute	The attribute to check.
@param	value	The expected value.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@author	QFS,tm
@since	2.9.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oH1"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_6XC"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup('id'))
def att = rc.lookup('attribute')
def val = rc.lookup('value')
def appearInReport = rc.getBool("appearInReport")
rc.checkEqual(node.getAttribute(att), val, sprintf("Check attribute %s", att), report:appearInReport)
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6XD" name="checkText(negative)">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="value"/>
            <variable name="reportName"/>
            <comment>Negates a normal Textcheck to allow NegationChecks.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The value that should "NOT" be the Text of the Component.
@param reportName	the Name for the check in the report.

@author	QFS,tm
@since	2.9.1

@ignoreanalyzerefcid</comment>
            <TryStep id="_6XE">
              <CheckStringStep client="$(client)" component="$(id)" id="_6Xu"
                               name="$(reportName)" raise="true" timeout="0">
                <text>$(value)</text>
              </CheckStringStep>
              <ProcedureCall id="_6Xv" procedure="qfs.run-log.logError">
                <variable name="message">checkText(negative) failed</variable>
                <variable name="withScreenshots">false</variable>
              </ProcedureCall>
              <CatchSequence exception="ComponentNotFoundException" id="_6Xw"
                             maxerror="0"/>
              <CatchSequence exception="InvisibleTargetComponentException"
                             id="_6XR" maxerror="0"/>
              <CatchSequence exception="CheckFailedException" id="_6Xx"
                             maxerror="0"/>
            </TryStep>
          </Procedure>
          <Procedure id="_6Xy" name="checkElements(negative)">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="value"/>
            <comment>Negates a normal Elementcheck in select elements to allow NegationChecks.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.
@param	value	The value that should "NOT" be the Text of one element the Component.

@author	QFS,tm
@since	2.9.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oH2"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_6XQ"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup('id'))

if (! node.isShowing()) {
    rc.logWarning(sprintf("The target component '%s' is not visible", node))
}

def val = rc.lookup('value')
def iCount = node.getChildCount()
def index = 0

while (index &lt; iCount) {
    def element = node.getChild(index)
    if (element.getSimpleText() == val) {
        if (! element.isShowing()) {
            rc.logWarning(sprintf("The target component '%s' is not visible but present", val))
        } else {
            rc.logError(sprintf("Check elements(negative) for %s failed", val))
        }
        break
    }
    index += 1
}</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6XS" name="checkForElement">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="element"/>
            <comment>Checks if the given element (option-element-text) is in the select-element (combobox).

It writes an error into the run-log, if the element is not found.

@param	id	The id of the select-element.
@param	element	The Option-Element-Text.

@author	QFS,tm
@since	2.9.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oH3"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_6XT"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup('id'))
def val = rc.lookup('element')
def iCount = node.getChildCount()
def index = 0

while (index &lt; iCount) {
    if (node.getChild(index).getSimpleText() == val) {
        break
    }
    index += 1
}

if (index == iCount) {
    rc.logError('Element not found')
}</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_6Xl" name="checkInvisibility">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Negates a normal WaitForComponentCheck to allow VisibilityChecks.

It writes an error into the run-log, if the check fails.

@param	id	The id of the component.

@author	QFS,tm
@since	2.9.1

@ignoreanalyzerefcid</comment>
            <TryStep id="_6Xm">
              <ComponentWaiter client="$(client)" component="$(id)" id="_6Xt"
                               timeout="0"/>
              <ProcedureCall id="_6Xo" procedure="qfs.run-log.logError">
                <variable name="message">checkInvisibility failed</variable>
                <variable name="withScreenshots">false</variable>
              </ProcedureCall>
              <CatchSequence exception="InvisibleTargetComponentException"
                             id="_6Xp" maxerror="0"/>
              <CatchSequence exception="ComponentNotFoundException" id="_6Xs"
                             maxerror="0"/>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_2JkV" name="electron">
          <comment>Procedures for Electron testing.

@author 	QFS
@since 	4.5.0</comment>
          <Procedure id="_2JkW" name="getChromeDriverPath">
            <variable name="chromeDriverVersion">$(chromeDriverVersion)</variable>
            <variable name="download">True</variable>
            <comment>Get the path to the ChromeDriver and download it if neccessary.

@param chromeDriverVersion		The ChromeDriver version to get the path from.
@param download		Whether to download the ChromeDriver if not available.

@return 	The path to the ChromeDriver

@author 	QFS
@since 	4.5.0</comment>
            <ServerScriptStep id="_2Jkj" interpreter="groovy">
              <code>import de.qfs.apps.qftest.shared.web.electron.ElectronChecker
import de.qfs.apps.qftest.shared.exceptions.ReturnException

chromeDriverVersion = rc.lookup("chromeDriverVersion")
download = rc.getBool("download")

path = ElectronChecker.getChromeDriverPath(chromeDriverVersion, download)

if (path) {
    path = path.getAbsolutePath()
} else {
    path = ""
}

throw new ReturnException(path)</code>
            </ServerScriptStep>
          </Procedure>
        </Package>
        <Package id="_6Zw" name="general">
          <comment>Procedures which work for any Web component.

@author	QFS
@since 3.0
</comment>
          <Package id="_1oia" name="_waitFor">
            <comment>Internal Procedures used by clickIncreasinglyHard().</comment>
            <Procedure id="_1oib" name="componentToAppear">
              <variable name="id">${id:theComponentToWaitFor}</variable>
              <comment>Waits for the given time (in ms) for the given component to appear. Used by clickIncreasinglyHard().

@param timeout	the time to wait for the component in ms
@param id		the QF-Test Id of the component to wait for

@return		true if component appeared, false otherwise

@ignoreanalyzerefcid</comment>
              <TryStep id="_1oik" name="has the component appeared?">
                <ComponentWaiter client="$(client)" component="$(id)"
                                 id="_1oil" timeout="$(timeout)"/>
                <ReturnStep id="_1oj5" retval="true"/>
                <CatchSequence exception="ComponentNotFoundException"
                               id="_1oin" maxerror="0">
                  <comment>
</comment>
                  <ReturnStep id="_1oj6" retval="false"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1ojD" name="componentToDisappear">
              <variable name="id">${id:aComponent}</variable>
              <comment>Waits for the given time (in ms) for the given component to disappear. Used by clickIncreasinglyHard().

@param timeout	the time to wait for the component to disappear in ms
@param id		the QF-Test Id of the component to wait for

@return		true if component disappeared, false otherwise

@ignoreanalyzerefcid</comment>
              <TryStep id="_1ojE" name="has the component disappeared?">
                <ComponentWaiter absence="true" client="$(client)"
                                 component="$(id)" id="_1ojF"
                                 timeout="$(timeout)"/>
                <ReturnStep id="_1ojG" retval="true"/>
                <CatchSequence exception="ComponentFoundException" id="_1ojH"
                               maxerror="0">
                  <comment>
</comment>
                  <ReturnStep id="_1ojI" retval="false"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1ojT" name="componentToBeSelected">
              <variable name="id">${id:aComponent}</variable>
              <comment>Waits for the given time (in ms) for the given component to become selected. Used by clickIncreasinglyHard().

@param timeout	the time to wait in ms
@param id		the QF-Test Id of the component to be selected

@return		true if component was selected, false otherwise

@ignoreanalyzerefcid</comment>
              <TryStep id="_1ojU" name="component selected?">
                <CheckBooleanStep checktype="selected" client="$(client)"
                                  component="$(id)" id="_1ojV" raise="true"
                                  timeout="$(timeout)"/>
                <ReturnStep id="_1ojW" retval="true"/>
                <CatchSequence exception="CheckFailedException" id="_1ojX"
                               maxerror="0">
                  <comment>
</comment>
                  <ReturnStep id="_1ojY" retval="false"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
            <Procedure id="_1ojb" name="checkboxState">
              <variable name="id">${id:aComponent}</variable>
              <variable name="checked">true</variable>
              <comment>Waits for the given time (in ms) for the given component to become selected. Used by clickIncreasinglyHard().

@param timeout	the time to wait in ms
@param id		the QF-Test Id of the component to be selected
@param checked	true (default) if the checkbox specified by the parameter id should be checked, false otherwise 

@return		true if component was selected, false otherwise

@ignoreanalyzerefcid</comment>
              <TryStep id="_1ojc" name="component selected?">
                <CheckBooleanStep checktype="checked" client="$(client)"
                                  component="$(id)" id="_1ojd" raise="true"
                                  state="$(checked)" timeout="$(timeout)"/>
                <ReturnStep id="_1oje" retval="true"/>
                <CatchSequence exception="CheckFailedException" id="_1ojv"
                               maxerror="0">
                  <comment>
</comment>
                  <ReturnStep id="_1ojw" retval="false"/>
                </CatchSequence>
              </TryStep>
            </Procedure>
          </Package>
          <Procedure id="_1mIx" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.


@author	QFS,mm
@since	3.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1mIy" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_1n99" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1n96" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_1n97" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_1n98"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_1oi8" name="clickIncreasinglyHard">
            <variable name="id">${id:aComponent}</variable>
            <variable name="clicktype">hard or semihard or soft</variable>
            <variable name="actionToWaitFor">WAIT_FOR_COMPONENT</variable>
            <variable name="componentAddressedByAction">${id:aComponent}</variable>
            <variable name="timeout">10000</variable>
            <variable name="numberOfRetries">5</variable>
            <variable name="doubleclick">false</variable>
            <variable name="popupTrigger">false</variable>
            <variable name="modifier">16</variable>
            <comment>Clicks the given component with increasingly hard mouse clicks and waits for the given action to be performed.

After the click a procedure is executed that checks that the click triggered the expected result, e.g. another component appeared, disappeared or was selected. In case the check fails the click is repeated a step harder. I.e. from software-replayed clicks to actually moving the mouse and using clicks triggered via operating system.

Any procedure that returns true or false as a result can be specified for the parameter actionToWaitFor.
There are predefined actions like WAIT_FOR_COMPONENT or WAIT_FOR_CHECKBOX_STATE (complete list see below) that wait for the respective action to be performed for the component defined by the parameter componentAddressedByAction.

If the parameters are set so that the very last click would be a hard click then the last click will be replayed using the robot, as long it is a normal single or double click (i.e. robot clicks will not be performed if the click works as a popup trigger or has modifiers other than 16).

@param clicktype 	whether to start the click series with a soft, semihard or hard mouse click
@param timeout	timeout used in the procedure specified by the parameter actionToWaitFor
@param numberOfRetries 	the maximum number of times to retry the click (default: 5)
@param clickX		x-coordinate where to click the component
@param clickY		y-coordinate where to click the component
@param actionToWaitFor	a predefined action (keywords see below) or any procedure that returns true or false, thus indicating whether the action to be triggered by the click was successful or not.
@param componentAddressedByAction	the component that is involved with the action specified, e.g. the component to wait for
@param delayBefore	time in ms to wait before the mouse click is performed
@param delayAfter	time in ms to wait after the mouse click was performed
@param doubleclick	determines whether or not to perform a doubleclick (default: false)
@param popupTrigger	determines whether the click triggers a popup (default: false)
@param modifier	determines the modifier that is to be used with the mouse click. Allowed values: 16 (default), 17, 18 and 19, 4 for popup

Keywords for actionToWaitFor
WAIT_FOR_COMPONENT		wait for the compontent specified by the parameter componentAddressedByAction to appear
WAIT_FOR_COMPONENT_TO_DISAPPEAR	wait for the compontent specified by the parameter componentAddressedByAction to disappear
WAIT_FOR_COMPONENT_TO_BE_SELECTED	wait for the compontent specified by the parameter componentAddressedByAction to be selected
WAIT_FOR_CHECKBOX_STATE		wait for the checkbox specified by the parameter componentAddressedByAction to get the state defined by the additional parameter:	
@param checked	true if the checkbox specified by the parameter componentAddressedByAction should be checked, false otherwise (only in combination with actionToWaitFor=WAIT_FOR_CHECKBOX_STATE)

@author	QFS,ue
@since	4.0

@ignoreanalyzerefcid</comment>
            <BasicSequence id="_1okL"
                           name="if a keyword was given for actionToWaitFor expand it">
              <IfSequence id="_1okN"
                          test="&#34;${default:originalAction:}&#34; == &#34;&#34;">
                <SetGlobalStep id="_1okM" local="true"
                               varname="originalAction">
                  <default>$(actionToWaitFor)</default>
                  <comment>used in error message in case of failure</comment>
                </SetGlobalStep>
              </IfSequence>
              <IfSequence id="_1ojC"
                          name="a keyword was given for actionToWaitFor expand it"
                          test="&#34;$(actionToWaitFor)&#34; == &#34;WAIT_FOR_COMPONENT&#34;">
                <SetGlobalStep id="_1ojJ" local="true"
                               varname="actionToWaitFor">
                  <default>._waitFor.componentToAppear</default>
                </SetGlobalStep>
                <ElseifSequence id="_1ojM"
                                test="&#34;$(actionToWaitFor)&#34; == &#34;WAIT_FOR_COMPONENT_TO_DISAPPEAR&#34;">
                  <SetGlobalStep id="_1ojB" local="true"
                                 varname="actionToWaitFor">
                    <default>._waitFor.componentToDisappear</default>
                  </SetGlobalStep>
                </ElseifSequence>
                <ElseifSequence id="_1ojN"
                                test="&#34;$(actionToWaitFor)&#34; == &#34;WAIT_FOR_COMPONENT_TO_BE_SELECTED&#34;">
                  <SetGlobalStep id="_1ojO" local="true"
                                 varname="actionToWaitFor">
                    <default>._waitFor.componentToBeSelected</default>
                  </SetGlobalStep>
                </ElseifSequence>
                <ElseifSequence id="_1ojP"
                                test="&#34;$(actionToWaitFor)&#34; == &#34;WAIT_FOR_CHECKBOX_STATE&#34;">
                  <SetGlobalStep id="_1ojQ" local="true"
                                 varname="actionToWaitFor">
                    <default>._waitFor.checkboxState</default>
                  </SetGlobalStep>
                </ElseifSequence>
              </IfSequence>
            </BasicSequence>
            <IfSequence id="_1okE"
                        name="determine whether 'Delay after' has to be replayed after the single or the double click"
                        test="$(doubleclick)">
              <SetGlobalStep id="_1okH" local="true"
                             varname="delayAfterSingleclick">
                <default>0</default>
              </SetGlobalStep>
              <SetGlobalStep id="_1okD" local="true"
                             varname="delayAfterDoubleclick">
                <default>${default:delayAfter:}</default>
              </SetGlobalStep>
              <ElseSequence id="_1okF">
                <SetGlobalStep id="_1okG" local="true"
                               varname="delayAfterSingleclick">
                  <default>${default:delayAfter:}</default>
                </SetGlobalStep>
              </ElseSequence>
            </IfSequence>
            <BasicSequence id="_1okK"
                           name="Save the original number of retries for the error message in case of failure">
              <IfSequence id="_1okJ"
                          test="&#34;${default:originalNumOfRetries:-1}&#34; == &#34;-1&#34;">
                <SetGlobalStep id="_1okI" local="true"
                               varname="originalNumOfRetries">
                  <default>$(numberOfRetries)</default>
                </SetGlobalStep>
              </IfSequence>
            </BasicSequence>
            <BasicSequence id="_1onG" name="do click">
              <IfSequence id="_1oi9"
                          test="&#34;$(clicktype)&#34; == &#34;soft&#34;">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1oiA" modifiers="$(modifier)"
                                popup="$(popupTrigger)"
                                postdelay="$(delayAfterSingleclick)"
                                predelay="${default:delayBefore:}"
                                x="${default:clickX:}"
                                y="${default:clickY:}"/>
                <IfSequence id="_1ok9" test="$(doubleclick)">
                  <MouseEventStep clicks="2" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1okA" modifiers="$(modifier)"
                                  popup="$(popupTrigger)"
                                  postdelay="$(delayAfterDoubleclick)"
                                  x="${default:clickX:}"
                                  y="${default:clickY:}"/>
                </IfSequence>
                <ElseifSequence id="_1oiB"
                                test="&#34;$(clicktype)&#34; == &#34;semihard&#34;">
                  <ClientScriptStep client="$(client)"
                                    engine="${qftest:engine.$(id)}" id="_1oiC"
                                    interpreter="groovy"
                                    name="set option for semihard clicks">
                    <code>rc.setOption(Options.OPT_WEB_SEMI_HARD_EVENTS, true)
</code>
                  </ClientScriptStep>
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  id="_1oiD" modifiers="$(modifier)"
                                  popup="$(popupTrigger)"
                                  postdelay="$(delayAfterSingleclick)"
                                  predelay="${default:delayBefore:}"
                                  x="${default:clickX:}"
                                  y="${default:clickY:}"/>
                  <IfSequence id="_1ok7" test="$(doubleclick)">
                    <MouseEventStep clicks="2" client="$(client)"
                                    component="$(id)" event="MOUSE_MPRC"
                                    id="_1ok8" modifiers="$(modifier)"
                                    popup="$(popupTrigger)"
                                    postdelay="$(delayAfterDoubleclick)"
                                    x="${default:clickX:}"
                                    y="${default:clickY:}"/>
                  </IfSequence>
                  <ClientScriptStep client="$(client)"
                                    engine="${qftest:engine.$(id)}" id="_1oiE"
                                    interpreter="groovy"
                                    name="unset option for semihard clicks">
                    <code>rc.unsetOption(Options.OPT_WEB_SEMI_HARD_EVENTS)</code>
                  </ClientScriptStep>
                </ElseifSequence>
                <ElseSequence id="_1oiF" name="hard click">
                  <IfSequence id="_1ojx"
                              test="&#34;$(numberOfRetries)&#34; &gt; &#34;0&#34; or $(popupTrigger) or &#34;$(modifier)&#34; != &#34;16&#34;">
                    <comment>The robot click is not implemented for popup triggers or modifiers other than 16</comment>
                    <MouseEventStep clicks="1" client="$(client)"
                                    component="$(id)" event="MOUSE_MPRC"
                                    hardevent="true" id="_1oiG"
                                    modifiers="$(modifier)"
                                    popup="$(popupTrigger)"
                                    postdelay="$(delayAfterSingleclick)"
                                    predelay="${default:delayBefore:}"
                                    x="${default:clickX:}"
                                    y="${default:clickY:}"/>
                    <IfSequence id="_1ok2" test="$(doubleclick)">
                      <MouseEventStep clicks="2" client="$(client)"
                                      component="$(id)" event="MOUSE_MPRC"
                                      hardevent="true" id="_1ok6"
                                      modifiers="$(modifier)"
                                      popup="$(popupTrigger)"
                                      postdelay="$(delayAfterDoubleclick)"
                                      x="${default:clickX:}"
                                      y="${default:clickY:}"/>
                    </IfSequence>
                    <ElseSequence id="_1ojy" name="last try: robot">
                      <SetGlobalStep id="_1okB" local="true"
                                     varname="clicktype">
                        <default>robot</default>
                      </SetGlobalStep>
                      <MouseEventStep clicks="1" client="$(client)"
                                      component="$(id)" event="MOUSE_MOVED"
                                      hardevent="true" id="_1oj+"
                                      modifiers="16"/>
                      <IfSequence id="_1oj-" test="$(doubleclick)">
                        <ClientScriptStep client="$(client)"
                                          engine="${qftest:engine.$(id)}"
                                          id="_1ojz" interpreter="groovy">
                          <code>import java.awt.Robot
import java.awt.event.MouseEvent

def r = new Robot()
r.setAutoDelay(50)

r.mousePress(MouseEvent.BUTTON1_MASK)
r.mouseRelease(MouseEvent.BUTTON1_MASK)
r.mousePress(MouseEvent.BUTTON1_MASK)
r.mouseRelease(MouseEvent.BUTTON1_MASK)</code>
                        </ClientScriptStep>
                        <ElseSequence id="_1ok0" name="single click">
                          <ClientScriptStep client="$(client)"
                                            engine="${qftest:engine.$(id)}"
                                            id="_1ok1" interpreter="groovy">
                            <code>import java.awt.Robot
import java.awt.event.MouseEvent

def r = new Robot()
r.setAutoDelay(50)

r.mousePress(MouseEvent.BUTTON1_MASK)
r.mouseRelease(MouseEvent.BUTTON1_MASK)</code>
                          </ClientScriptStep>
                        </ElseSequence>
                      </IfSequence>
                    </ElseSequence>
                  </IfSequence>
                </ElseSequence>
              </IfSequence>
            </BasicSequence>
            <BasicSequence id="_1oj8"
                           name="wait for the given action to be performed">
              <ProcedureCall id="_1oj7" local="true"
                             procedure="$(actionToWaitFor)"
                             retvarname="successful">
                <variable name="id">$(componentAddressedByAction)</variable>
              </ProcedureCall>
            </BasicSequence>
            <IfSequence id="_1oj9" name="if click not successful try again"
                        test="$(successful)">
              <ProcedureCall id="_1oiJ" procedure="qfs.run-log.logMessage">
                <variable name="message">Click analysis ${default:browser:}: $(originalAction) was successful after a $(clicktype) click to $(id).</variable>
                <variable name="dontcompactify">true</variable>
                <variable name="report">true</variable>
              </ProcedureCall>
              <ElseSequence id="_1ojA" name="retry the hard(er) click">
                <IfSequence id="_1oiL" test="$(numberOfRetries) &gt; 0">
                  <IfSequence id="_1oiM"
                              test="&#34;$(clicktype)&#34; == &#34;soft&#34;">
                    <SetGlobalStep id="_1oiN" local="true"
                                   varname="harderClick">
                      <default>semihard</default>
                    </SetGlobalStep>
                    <ElseSequence id="_1oiO">
                      <SetGlobalStep id="_1oiP" local="true"
                                     varname="harderClick">
                        <default>hard</default>
                      </SetGlobalStep>
                    </ElseSequence>
                  </IfSequence>
                  <ProcedureCall id="_1oiQ"
                                 procedure="qfs.run-log.logWarning">
                    <variable name="message">Click analysis ${default:browser:}: $(originalAction) was not successful with a $(clicktype) click to $(id).
Try again with $(harderClick) click.</variable>
                    <variable name="report">true</variable>
                  </ProcedureCall>
                  <ProcedureCall id="_1ojq"
                                 procedure="qfs.web.general.clickIncreasinglyHard">
                    <variable name="clicktype">$(harderClick)</variable>
                    <variable name="numberOfRetries">$[ int($(numberOfRetries)) - 1]</variable>
                    <variable name="id">$(id)</variable>
                    <variable name="actionToWaitFor">$(actionToWaitFor)</variable>
                    <variable name="componentAddressedByAction">$(componentAddressedByAction)</variable>
                    <variable name="timeout">$(timeout)</variable>
                    <variable name="doubleclick">$(doubleclick)</variable>
                    <variable name="popupTrigger">$(popupTrigger)</variable>
                    <variable name="modifier">$(modifier)</variable>
                  </ProcedureCall>
                  <ElseSequence id="_1oiS">
                    <ProcedureCall id="_1oiT"
                                   procedure="qfs.run-log.logError">
                      <variable name="message">Click analysis ${default:browser:}: $(originalAction) still failed after $[ $(originalNumOfRetries) - $(numberOfRetries) +1] increasingly hard clicks to $(id), the last click being a $(clicktype) click.</variable>
                      <variable name="withScreenshots">true</variable>
                    </ProcedureCall>
                  </ElseSequence>
                </IfSequence>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1j-+" name="deleteOverrideComponent">
            <comment>Delete the current association of PriorityWebComponent.

@param	client		The name of the SUT client.

@author	QFS
@since	3.3.0</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1j--"
                              interpreter="groovy">
              <code>rc.overrideElement("PriorityWebComponent", null)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n9A" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS,mm
@since	2.1.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_1n9B" modifiers="16"/>
          </Procedure>
          <Procedure id="_1n9C" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_1n9D"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1oCB" name="dragFromTo">
            <variable name="fromId"/>
            <variable name="toId"/>
            <variable name="useJavascript">false</variable>
            <comment>Simulate a drag&amp;drop operation. 

@param	fromId	ID of the component to start the drag from.
@param	toId	ID of the component to drop to.
@param         useJavascript   If set to true the events are initiated at javascript level. (only working for Mozilla Firefox or Internet Explorer 9 and above)

@author	QFS, tm
@since	4.0.0.</comment>
            <ComponentWaiter client="$(client)" component="$(fromId)"
                             id="_1oH4"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ComponentWaiter client="$(client)" component="$(toId)" id="_1oH5"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <IfSequence id="_1oCC" test="$(useJavascript)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_1oCD"
                                interpreter="groovy">
                <code>def fromNode = rc.getComponent(rc.lookup("fromId"))
def toNode = rc.getComponent(rc.lookup("toId"))

fromNode.toJS("qf_drag_from_element")
toNode.toJS("qf_drop_to_element")
def value = fromNode.evalJS("""
var qf_dnd_helper = {
    qf_dispatchEvent: function(elem, type, event) {
        if (elem.dispatchEvent) {
                elem.dispatchEvent(event);
        } else if ( elem.fireEvent ) {
                elem.fireEvent("on"+type, event);
        }
    },
    qf_createEvent: function(type) {
        var event = document.createEvent("CustomEvent");
        event.initCustomEvent(type, true, true, null);
        event.dataTransfer = {
                data: {
                },
                setData: function(type, val){
                        this.data[type] = val;
                },
                getData: function(type){
                        return this.data[type];
                }
        };
        return event;
    },
    simulateDND: function(fromElement,toElement) {
        /*Simulating drag start*/
        var type = 'dragstart';
        var event = this.qf_createEvent(type);
        this.qf_dispatchEvent(fromElement, type, event);

        /*Simulating drop*/
        type = 'drop';
        var dropEvent = this.qf_createEvent(type, {});
        dropEvent.dataTransfer = event.dataTransfer;
        this.qf_dispatchEvent(toElement, type, dropEvent);

        /*Simulating drag end*/
        type = 'dragend';
        var dragEndEvent = this.qf_createEvent(type, {});
        dragEndEvent.dataTransfer = event.dataTransfer;
        this.qf_dispatchEvent(fromElement, type, dragEndEvent);
    }
}
qf_dnd_helper.simulateDND(qf_drag_from_element,qf_drop_to_element);
""");</code>
              </ClientScriptStep>
              <ElseSequence id="_1oCE">
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_1oCF"
                                  interpreter="groovy"
                                  name="Determine screen locations">
                  <code>def fromNode = rc.getComponent(rc.lookup("fromId"))
def toNode = rc.getComponent(rc.lookup("toId"))

def fromLoc = fromNode.getLocationOnScreen()
def toLoc = toNode.getLocationOnScreen()

def fromX = rc.getInt("default", "fromX:10")
def fromY = rc.getInt("default", "toX:10")

def toX = rc.getInt("default", "fromY:10")
def toY = rc.getInt("default", "toY:10")

fromSX = fromLoc[0] + fromX
fromSY = fromLoc[1] + fromY
toSX = toLoc[0] + toX
toSY = toLoc[1] + toY

rc.logMessage(sprintf("Drag from %s (%d,%d) = (%d,%d) to %s (%d,%d) = (%d,%d)",
              fromNode, fromX, fromY, fromSX, fromSY, toNode, toX, toY, toSX, toSY))

</code>
                </ClientScriptStep>
                <ClientScriptStep client="$(client)"
                                  engine="${default:guiengine:web}" id="_1oCG"
                                  interpreter="groovy"
                                  name="Simulate events asynchronously to avoid blocking">
                  <code>def h = rc.engine.helper
def p = rc.engine.player

p.moveRobot(fromSX + 3, fromSY+ 3, true)
p.moveRobot(fromSX, fromSY, true)
p.pressRobot(16)
p.moveRobot(fromSX + 15, fromSY, true)
p.moveRobot(fromSX + 10, fromSY, true)

p.moveRobot(toSX + 5, toSY + 5, true)
p.moveRobot(toSX + 1, toSY + 1, true)
p.moveRobot(toSX, toSY, true)
p.releaseRobot(16)
p.moveRobot(toSX + 5, toSY + 5, true)
p.moveRobot(toSX - 3, toSY - 3, true)
p.moveRobot(toSX, toSY, true)

def globals = binding.getVariables()
globals.remove("fromSX")
globals.remove("fromSY")
globals.remove("toSX")
globals.remove("toSY")
</code>
                  <comment>@async</comment>
                </ClientScriptStep>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_1lTL" name="getSourcecode">
            <variable name="docId">${id:genericDocument}</variable>
            <variable name="frameName"/>
            <comment>Return document's source code.

If you leave frameName blank, this procedure logs the source code of every frame of the webpage into the run-log. It returns just the source code of the main document.
If you specify a dedicated frameName, only the source code of that particular frame will be logged and returned.

@param	docId	The Id of the web page.
@param 	frameName	The name of the frame to provide source code.

@return 	The source code.

@author	QFS, mm
@since	3.4.9

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(docId)"
                             id="_1oH8"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1lVB"
                              interpreter="groovy"
                              name="Search source code of frames">
              <code>import de.qfs.apps.qftest.shared.exceptions.UserException
    
def searchInChildDoc(doc, framename) {
    def frames = doc.getFrames()
    if (frames.length == 0) {
        return -1
    }
    for (def frame: frames) {
        def cdoc = frame.getChildDocument()
        if (frame.getFrameName() == framename) {
            def source = cdoc.getSourcecode()
            rc.setLocal("sourcecode", source)
            rc.logMessage("Frame: \'" + frame.getFrameName() + "\':\n" + source, dontcompactify:true, report:false, nowrap:false)
            return 1
        } else {
            def found = searchInChildDoc(cdoc, framename)
            if (found == 1) {
                return 1
            }
        }
    }
    return -1
}

def getAllChildDocs(doc) {
    def frames = doc.getFrames()
    if (frames.length == 0) {
        return 1
    }
    for (def frame: frames) {
        def cdoc = frame.getChildDocument()
        if (cdoc) {
            def source = cdoc.getSourcecode()
            rc.logMessage("Frame: \'" + frame.getFrameName() + "\':\n" + source, dontcompactify:true, report:false, nowrap:false)
            getAllChildDocs(cdoc)
        }
    }
    return 1
}

def doc = rc.getComponent(rc.lookup("docId"))
framename = rc.lookup("frameName")

if (! framename) {
    framename = ""
}

def found = false
if (! framename) {
    def source = doc.getSourcecode()
    rc.logMessage("Document:\n" + source, dontcompactify:true, report:false, nowrap:false)
    found = getAllChildDocs(doc)
    rc.setLocal("sourcecode", source)
} else {
    found = searchInChildDoc(doc, framename)
}

if (found != 1) {
    throw new UserException("No frame with name '" + framename + "' visible.")
}</code>
            </ClientScriptStep>
            <ReturnStep id="_1n4a"
                        retval="$[rc.lookup(&#34;sourcecode&#34;, expand=False)]"/>
          </Procedure>
          <Procedure id="_1mHF" name="integrateFirebug">
            <variable name="docid">${id:genericDocument}</variable>
            <comment>Integrates Firebug Lite from http://getfirebug.com into an open browser window for an easier analysis of the DOM.

@param	client		The name of the SUT client.
@param	docid		The Id of the document.

@author	QFS,tm
@since	3.5.2

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(docid)"
                             id="_1oH9"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1mHG"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup("docid"))
node.evalJS("""
var scriptTag = document.createElement('script');
scriptTag.type = "text/javascript";
scriptTag.src = 'https://cdnjs.cloudflare.com/ajax/libs/firebug-lite/1.4.0/firebug-lite.js#startOpened';
document.getElementsByTagName('head')[0].appendChild(scriptTag);
var ready = function() {console.log('init');};
scriptTag.onreadystatechange = function () {
  if (scriptTag.readyState == 'complete') {
      ready();
  }
}
scriptTag.onload = ready;""")
</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1j-u" name="setOverrideComponent">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Set a given component to the PriorityWebComponent.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS
@since	3.3.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oHA"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1j-v"
                              interpreter="groovy">
              <code>def comp = rc.getComponent(rc.lookup("id"))

rc.overrideElement("PriorityWebComponent", comp)</code>
            </ClientScriptStep>
          </Procedure>
          <Procedure id="_1n5v" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1n5w"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_1n5x" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_1n5y" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_1j+Y" name="input">
          <comment>Procedures to access INPUT elements.

@author QFS
@since 3.2</comment>
          <Procedure id="_1j+Z" name="fileUpload">
            <variable name="id">${id:The id of the FILE:INPUT node}</variable>
            <variable name="filename">The file to upload</variable>
            <comment>Set the value of the INPUT:FILE node by whatever means that are applicable for the browser.

@author	QFS
@since 3.2

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oHB"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1j+a"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup("id"))
def ie = node.isBrowserIE()
rc.setLocal("ie", ie)
def version = node.getBrowser().getInfo().getBrowserVersion()
if (ie) {
    rc.setLocal("version", version.split("\\.")[0])
} else {
    rc.setLocal("version", version.split("/")[-1])
}

rc.setLocal("connectionMode",rc.engine.getConnectionMode())</code>
            </ClientScriptStep>
            <IfSequence id="_1j+G" test="$(ie)">
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_1lSL"
                                interpreter="groovy" name="Get geometry">
                <code>import de.qfs.apps.qftest.client.web.dom.DomNode

def node = rc.getComponent(rc.lookup("id"))
def scroll = DomNode.getScrollAttributes(
    node.getBrowser(), node.getHandle() as long,
    (DomNode.SCROLL_HEIGHT_MASK | DomNode.SCROLL_WIDTH_MASK) as byte, '\0' as char)
rc.setLocal("w", scroll[DomNode.SCROLL_WIDTH_IDX])
rc.setLocal("h", scroll[DomNode.SCROLL_HEIGHT_IDX])
</code>
                <comment>Get the geometry of the text field.
Fetch geometry is not reliable on IE, it may return the total width (including the browse button) or the width of the text field (depending on the length of the entry).</comment>
              </ClientScriptStep>
              <IfSequence id="_1lan"
                          name="Up to IE9: Reported geometry only covers the tesxt field"
                          test="$(version) &lt; 10">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                hardevent="$(version) &gt; 8" id="_1lSQ"
                                modifiers="16" x="$[$(w) + 10]"
                                y="$[$(h) / 2]"/>
                <ElseSequence id="_1lao"
                              name="IE10: Reported geometry includes the button">
                  <MouseEventStep clicks="1" client="$(client)"
                                  component="$(id)" event="MOUSE_MPRC"
                                  hardevent="$(version) &gt; 8" id="_1laq"
                                  modifiers="16" x="$[$(w) - 10]"
                                  y="$[$(h) / 2]"/>
                </ElseSequence>
              </IfSequence>
              <ComponentWaiter client="$(client)"
                               component="genericUploadDialog" id="_1lSR"/>
              <SelectionEventStep client="$(client)"
                                  component="genericUploadDialog"
                                  detail="$(filename)" event="SELECTION"
                                  id="_1lSS"/>
              <ElseifSequence id="_1lSK"
                              test="(&#34;$(connectionMode)&#34;!=&#34;webdriver&#34; and ${qftest:windows}) or &#34;$(connectionMode)&#34;==&#34;cdpdriver&#34;">
                <FetchGeometryStep client="$(client)" component="$(id)"
                                   heightvarname="h" id="_1j+Q"
                                   widthvarname="w"/>
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                hardevent="true" id="_1j+P" modifiers="16"
                                x="$[$(w) - 5]" y="$[$(h) / 2]"/>
                <ComponentWaiter client="$(client)"
                                 component="genericUploadDialog" id="_6uS"/>
                <SelectionEventStep client="$(client)"
                                    component="genericUploadDialog"
                                    detail="$(filename)" event="SELECTION"
                                    id="_61d"/>
              </ElseifSequence>
              <ElseSequence id="_1j+H">
                <SelectionEventStep client="$(client)" component="$(id)"
                                    detail="$(filename)" event="SELECTION"
                                    id="_1j+I"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_1lAm" name="radiobutton">
          <comment>Procedures to set the state of buttons.
(Web component &lt;code&gt;INPUT:RADIO&lt;/code&gt;)

@author	QFS,mm
@since	3.5.0</comment>
          <Procedure id="_1lAn" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  The state of the checkbox.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1lAo">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1lAp"
                                raise="true" timeout="0"/>
              <ReturnStep id="_1lAq" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_1lAr"
                             maxerror="0">
                <ReturnStep id="_1lAs" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lAt" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.

@param	id	The id of the radio button.


@author	QFS,mm
@since	3.5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1lAu">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1lAv"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1lAw"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1mJ0" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1n9E" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	4.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n9F">
              <CheckBooleanStep checktype="selected" client="$(client)"
                                component="$(id)" errorlevel="0" id="_1n9G"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_1n9H"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_1n9I" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_1l9i" name="select">
          <comment>Procedures to access select nodes. It should work with any SELECT element.

@author QFS,mm
@since 3.5.0</comment>
          <Procedure id="_1l9w" name="getItemCount">
            <variable name="id">${id:aSelectBoxId}</variable>
            <comment>Return the number of items of a given select.

@param id 		The component-ID of the select.
@return itemCount

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_1oHC"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:web}" id="_1l9x"
                              interpreter="groovy">
              <code>def node = rc.getComponent(rc.lookup("id"))

rc.setLocal("itemCount", node.getChildrenByTagName("OPTION").length)

</code>
            </ClientScriptStep>
            <ReturnStep id="_1l9y" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_1l9q" name="getIndexOfItem">
            <variable name="id">${id:aSelectBoxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param id  		ID of the select.
@param item 		The item to look for.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return		index   The current index of an item, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_1l9r" local="true" varname="index"/>
            <ReturnStep id="_1l9s" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1l9t" name="getValueOfItem">
            <variable name="id">${id:aSelectBoxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the current text of a given item.

Sample usage:
Can be used to determine the text of the first item.

@param id		ID of the select node.
@param item 		The item to look for.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return  The value of given item of the SELECT node, which has been read by the 'Fetch Text' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_1l9u"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l9v" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1l9j" name="getValue">
            <variable name="id">${id:aSelectBoxId}</variable>
            <comment>Return the current value of a given select node.

@param	id	ID of the select node.

@return  The current value of the SELECT node, which has been read by the 'Fetch Text' node of QF-Test.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l9k"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l9l" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1l9m" name="selectValue">
            <variable name="id">${id:aSelectBoxId}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <comment>Select a given value in a Select node.

@param	id	ID of the select node.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <SelectionEventStep client="$(client)"
                                component="$(id)$(separator)$(value)"
                                detail="0" event="SELECTION" id="_1l9p"/>
          </Procedure>
        </Package>
        <Package id="_1lVa" name="table">
          <comment>Procedures to access web tables.

@author	QFS,kk
@since	3.5</comment>
          <Package id="_1lVr" name="checks">
            <comment>Procedures for checking a table.

@author QFS,kk
@since 3.5</comment>
            <Procedure id="_1lVs" name="checkNumberOfRows">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of rows of a given table according to a specified comparison mode.

Sample usage:
You can check, that a table has exactly 6 rows or that the table has less then 10 rows.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1lVt" local="true"
                             procedure="qfs.web.table.getRowCount"
                             retvarname="rowCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1lVu"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_1lWg" name="checkNumberOfColums">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of columns of a given table according to a specified comparison mode.

Sample usage:
You can check, that a table has exactly 6 columns or that the table has less then 10 columns.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of columns
			&lt;, if the compareValue should be greater than the actual amount of columns.
			&gt;, if the compareValue should be less than the actual amount of columns.
			&lt;=, if the compareValue should be greater or equal than the actual amount of colunns.
			&gt;=, if the compareValue should be less or equal the actual amount of columns.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_1lWh" local="true"
                             procedure="qfs.web.table.getColumnCount"
                             retvarname="columnCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_1lWi"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(columnCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Package id="_1lWq" name="recording">
            <comment>Procedures influencing recording of web tables.

@author QFS,kk
@since 3.5</comment>
            <Procedure id="_1lWb" name="activateItemRecording">
              <variable name="id">${id:tableid}</variable>
              <comment>Activate recording of item based access for  a given web table.

Background: As tables on web pages are both used for layout purposes and for logical tables, QF-Test cannot know where logical tables start. This procedure allows to provide this information and to activate recording items for logical tables. Item based replay on web tables work always.

@param id  		ID of the table.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oHD"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_1lWe"
                                interpreter="groovy">
                <code>import de.qfs.apps.qftest.client.web.dom.DomNode

def tableId = rc.lookup("id")
def node = rc.getComponent(tableId)
node.setProperty(DomNode.TABLE_HAS_ITEMS, true)
println("Item recording activated for table " + tableId + ".")
</code>
              </ClientScriptStep>
            </Procedure>
            <Procedure id="_1lWo" name="deactivateItemRecording">
              <variable name="id">${id:tableid}</variable>
              <comment>Deactivate recording of item based access for  a given web table.

@param id  		ID of the table.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
              <ComponentWaiter client="$(client)" component="$(id)" id="_1oHE"
                               timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
                <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
              </ComponentWaiter>
              <ClientScriptStep client="$(client)"
                                engine="${default:guiengine:web}" id="_1lWp"
                                interpreter="groovy">
                <code>import de.qfs.apps.qftest.client.web.dom.DomNode

def tableId = rc.lookup("id")
def node = rc.getComponent(tableId)
node.setProperty(DomNode.TABLE_HAS_ITEMS, false)
println("Item recording deactivated for table " + tableId + ".")</code>
              </ClientScriptStep>
            </Procedure>
          </Package>
          <Procedure id="_1n9J" name="clickCellWithDetails">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given cell.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author QFS,mm
@since 4.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_1n9K"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_1lW6" name="getColumnCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of columns of a given web table.

@param id 		The component-ID of the table.
@return columnCount

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n63">
              <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                              id="_1lWf" local="true" varname="lastColumn"/>
              <ReturnStep id="_1lW8" retval="$[$(lastColumn) + 1]"/>
              <CatchSequence exception="IndexNotFoundException" id="_1n64"
                             maxerror="0">
                <ReturnStep id="_1n65" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lW9" name="getIndexOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">@</variable>
            <comment>Return the current index of a given column.

Sample usage:
Can be used to determine the numeric index of a column like 'Price'.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the column, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1lXB" local="true"
                           procedure="qfs.swing.table.getIndexOfColumn"
                           retvarname="index">
              <variable name="id">$(id)</variable>
              <variable name="column">$(column)</variable>
              <variable name="columnSeparator">$(columnSeparator)</variable>
            </ProcedureCall>
            <ReturnStep id="_1lXC" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1lWC" name="getNameOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">&amp;</variable>
            <comment>Return the header text of a given column.

Sample usage:
Determine the title of the second column.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   The name of the column.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1lWk" local="true"
                           procedure="qfs.swing.table.getNameOfColumn"
                           retvarname="name">
              <variable name="id">$(id)</variable>
              <variable name="column">$(column)</variable>
              <variable name="columnSeparator">$(columnSeparator)</variable>
            </ProcedureCall>
            <ReturnStep id="_1lXE" retval="$(name)"/>
          </Procedure>
          <Procedure id="_1lWF" name="getRowCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of rows of a given table.

@param id 		The component-id of the table.
@return rowCount

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <TryStep id="_1n60">
              <ServerScriptStep id="_1oHS" interpreter="groovy"
                                name="Disable visibility check and remember current setting">
                <code>def isSet = rc.isOptionSet(Options.OPT_WEB_TEST_VISIBILITY)
rc.setLocal("isSet", isSet)
if (isSet) {
    def currentOption = rc.getOption(Options.OPT_WEB_TEST_VISIBILITY)
    rc.setLocal("currentOption", currentOption)
}
rc.setOption(Options.OPT_WEB_TEST_VISIBILITY, false)</code>
              </ServerScriptStep>
              <FetchIndexStep client="$(client)"
                              component="$(id)&amp;0&amp;-1" id="_1lWa"
                              local="true" varname="lastRow"/>
              <ReturnStep id="_1lWH" retval="$[$(lastRow) + 1]"/>
              <CatchSequence exception="IndexNotFoundException" id="_1n61"
                             maxerror="0">
                <ReturnStep id="_1n62" retval="0"/>
              </CatchSequence>
              <FinallySequence id="_1oHT">
                <ServerScriptStep id="_1oHU" interpreter="groovy"
                                  name="Reset check visibility">
                  <code>if (rc.getBool("isSet")) {
    rc.setOption(Options.OPT_WEB_TEST_VISIBILITY, rc.getBool("currentOption"))
} else {
    rc.unsetOption(Options.OPT_WEB_TEST_VISIBILITY)
}</code>
                </ServerScriptStep>
              </FinallySequence>
            </TryStep>
          </Procedure>
          <Procedure id="_1lWI" name="getRowIndexOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Return the row number of a given cell.

Sample usage:
Can be used to determine in which row a dedicated cell is located.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the row, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1lWl" local="true"
                           procedure="qfs.swing.table.getRowIndexOfCell"
                           retvarname="index">
              <variable name="id">$(id)</variable>
              <variable name="column">$(column)</variable>
              <variable name="columnSeparator">$(columnSeparator)</variable>
              <variable name="row">$(row)</variable>
              <variable name="rowSeparator">$(rowSeparator)</variable>
            </ProcedureCall>
            <ReturnStep id="_1lXD" retval="$(index)"/>
          </Procedure>
          <Procedure id="_1lWL" name="getValueOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">&amp;</variable>
            <comment>Return the text of a given cell.

Sample usage:
Can be used to determine the text of the cell in the first column and first row.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value   The current value of the row, which has been read by the 'Fetch text' node of QF-Test.

@author QFS,kk
@since 3.5

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1lWm" local="true"
                           procedure="qfs.swing.table.getValueOfCell"
                           retvarname="value">
              <variable name="id">$(id)</variable>
              <variable name="column">$(column)</variable>
              <variable name="columnSeparator">$(columnSeparator)</variable>
              <variable name="row">$(row)</variable>
              <variable name="rowSeparator">$(rowSeparator)</variable>
            </ProcedureCall>
            <ReturnStep id="_1lXF" retval="$(value)"/>
          </Procedure>
          <Procedure id="_1lXG" name="selectCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Select a given cell.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" id="_1lXH" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_6ZR" name="text">
          <comment>Procedures to access text fields and text areas. It should work with any INPUT:TEXT elements.

@author QFS
@since 3.0</comment>
          <Procedure id="_6ZS" name="clearArea">
            <variable name="id">${id:aTextArea}</variable>
            <comment>Clear a multi-line text area.

@param	client	The name of the SUT client.
@param	id	The id of the text area.

@author QFS
@since 3.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_6ZT" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_6ZU" name="clearField">
            <variable name="id">${id:aTextField}</variable>
            <comment>Clear a simple text field.

@param	client	The name of the SUT client.
@param	id	The id of the text field.

@author	QFS
@since	3.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_6ZV" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_1l8+" name="getText">
            <variable name="id">${id:aTextField}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  The text of the textfield.

@author QFS,mm
@since 3.5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_1l8-"
                           local="true" varname="currentText"/>
            <ReturnStep id="_1l90" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_1mPp" name="setText">
            <variable name="id">${id:aTextField}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

@param	id	ID of the textfield.
@param 	text	text to be set. 
@param	append	if this value is set to true, the text will be appended to the current values.
@param	clear	If this value is set to true, the text-field will be cleared before the text given as parameter "text" is inserted.
@param	replaySingleEvents If this value is set to true, the text will be inserted replaying single events.
@param	newline	the separator sign for marking a linebreak within the text

@author	QFS
@since	3.0

@ignoreanalyzerefcid</comment>
            <ServerScriptStep id="_1mR3" interpreter="groovy">
              <code>import de.qfs.lib.util.Misc

def text = rc.lookup("text")
def newline = rc.lookup("newline")
if (newline) {
    rc.setLocal("text", text.replace(newline, "\n"))
}
</code>
            </ServerScriptStep>
            <IfSequence id="_1mPs" test="$(append)">
              <IfSequence id="_2JAd" test="${qftest:osx}">
                <KeyEventStep client="$(client)" component="$(id)"
                              event="KEY_PTR" id="_2JAg" keychar="0"
                              keycode="40" modifiers="4"/>
                <ElseSequence id="_2JAe">
                  <KeyEventStep client="$(client)" component="$(id)"
                                event="KEY_PTR" id="_1mR4" keychar="0"
                                keycode="35" modifiers="2"/>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
            <TextInputStep clear="$(clear)" client="$(client)"
                           component="$(id)" id="_1mPu"
                           single="$(replaySingleEvents)">
              <text>$(text)</text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_1jul" name="setTextFromFile">
            <variable name="id">${id:aTextField}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">false</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param id 	The id of the text-field to set.
@param file	The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author QFS
@since 3.1.1

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_1jum" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_1jun" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
      </Package>
      <Package id="_2K1X" name="win">
        <comment>Procedures for advanced manipulation of native windows components.

@author	QFS
@since	5.0</comment>
        <Package id="_2K1r" name="checkbox">
          <comment>Procedures to set the state of checkboxes.

@author	QFS
@since	5.0</comment>
          <Procedure id="_2K2G" name="deselect">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KK0" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(id)</variable>
              <variable name="pattern">Toggle</variable>
            </ProcedureCall>
            <IfSequence id="_2KK1" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="toggle:off" event="SELECTION"
                                  id="_2KK2"/>
              <ElseSequence id="_2KK3">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2KK4" modifiers="16"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2K1s" name="deselectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Deselect a checkbox. If the checkbox is already de-selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2K1t">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2K1u"
                                raise="true" state="false" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2K1v"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2K1w" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2K1x" name="getValue">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Return the value of a checkbox.
It's either 1, if box is selected or 0, if box is not selected.

@param	id	ID of the checkbox.

@return  The state of the checkbox.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2K1y">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2K1z"
                                raise="true" timeout="0"/>
              <ReturnStep id="_2K1+" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_2K1-"
                             maxerror="0">
                <ReturnStep id="_2K20" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2KJq" name="select">
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KJw" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(id)</variable>
              <variable name="pattern">Toggle</variable>
            </ProcedureCall>
            <IfSequence id="_2KJy" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)" component="$(id)"
                                  detail="toggle:on" event="SELECTION"
                                  id="_2KJz"/>
              <ElseSequence id="_2KJ+">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2KJ-" modifiers="16"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2K21" name="selectWithCoordinates">
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a checkbox. If the checkbox is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2K22">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2K23"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2K24"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2K25" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2K26" name="set">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <comment>Set checkbox to the given state.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2K27" test="$(check)">
              <ProcedureCall id="_2K28" procedure=".select">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ElseSequence id="_2K29">
                <ProcedureCall id="_2K2A" procedure=".deselect">
                  <variable name="id">$(id)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2K2B" name="setWithCoordinates">
            <variable name="check">true</variable>
            <variable name="id">${id:aCheckboxId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Set checkbox to the given state.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id	The id of the checkbox.
@param	check	The check value to be set (either true or false).
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2K2C" test="$(check)">
              <ProcedureCall id="_2K2D" procedure=".selectWithCoordinates">
                <variable name="id">$(id)</variable>
                <variable name="x">$(x)</variable>
                <variable name="y">$(y)</variable>
              </ProcedureCall>
              <ElseSequence id="_2K2E">
                <ProcedureCall id="_2K2F"
                               procedure=".deselectWithCoordinates">
                  <variable name="id">$(id)</variable>
                  <variable name="x">$(x)</variable>
                  <variable name="y">$(y)</variable>
                </ProcedureCall>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_2K2Q" name="combobox">
          <comment>Procedures to handle comboboxes.


@author	QFS
@since	5.0</comment>
          <Procedure id="_2KJF" name="getIndexOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.


@param	id	ID of the combobox.
@param	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index	The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_2KJG" local="true" varname="index"/>
            <ReturnStep id="_2KJH" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2KJM" name="getValueOfItem">
            <variable name="id">${id:aComboboxId}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param 	id  	ID of the combobox.
@param 	item 	The item.
@param 	itemSeparator	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_2KJp"
                           local="true" varname="value"/>
            <ReturnStep id="_2KJO" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2K2Y" name="getValue">
            <variable name="id">${id:aComboboxId}</variable>
            <comment>Return the text of a given combobox.

@param	id	ID of the combobox.

@return  The text of the combobox.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_2K2Z"
                           local="true" varname="currentText"/>
            <ReturnStep id="_2K2a" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_2K2e" name="setValue">
            <variable name="id">${id:aComboboxButton}</variable>
            <variable name="value"/>
            <variable name="separator">@</variable>
            <variable name="btnX"/>
            <variable name="btnY"/>
            <variable name="itemX"/>
            <variable name="itemY"/>
            <comment>Select specified value of a given combobox.

If the given value is empty, no action will take place.

You should use this procedure for any standard selections.

@param	client	The name of the SUT client.
@param 	id	ID of the button to open the list.
@param	value	Value, which should be selected.
@param	separator	Separator to use for the list syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	btnX	The x coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	btnY	The y coordinate for the click on the button to open the list, default is empty to click in the middle.
@param	itemX	The x coordinate for the click on the item, default is empty to click in the middle.
@param	itemY	The y coordinate for the click on the item, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2K2f" test="rc.lookup(&#34;value&#34;)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_2K2g" modifiers="16"
                              x="$(btnX)" y="$(btnY)"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(id)$(separator)$(value)"
                              event="MOUSE_MPRC" id="_2K2h" modifiers="16"
                              x="$(itemX)" y="$(itemY)"/>
            </IfSequence>
          </Procedure>
        </Package>
        <Package id="_2K3O" name="general">
          <comment>Procedures which work for any Win component.

@author 	QFS
@since 	5.0
</comment>
          <Procedure id="_2K3P" name="clickAtComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.


@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2K3Q" test="$(click)">
              <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                              event="MOUSE_MPRC" id="_2K3R" modifiers="16"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2K3S" name="clickAtComponentWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="click">false</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">true</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component, but only if the according parameter is set to true.
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	click		If this is set to true, the click will be performed, otherwise nothing happens.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2K3T" test="$(click)">
              <MouseEventStep clicks="$(clickCount)" client="$(client)"
                              component="$(id)" event="MOUSE_MPRC"
                              hardevent="$(hard)" id="_2K3U"
                              modifiers="$(modifier)" popup="$(popupTrigger)"
                              x="$(x)" y="$(y)"/>
            </IfSequence>
          </Procedure>
          <Procedure id="_2K3X" name="doClick">
            <variable name="id">${id:aComponentId}</variable>
            <comment>Click on a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(id)"
                            event="MOUSE_MPRC" id="_2K3Y" modifiers="16"/>
          </Procedure>
          <Procedure id="_2KGY" name="doClickWithDetails">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">true</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Click on a given component. 
You can specify the coordinates for clicking and all other details of that mouse click.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.


@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)" event="MOUSE_MPRC"
                            hardevent="$(hard)" id="_2K3a"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2K3m" name="waitForComponent">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait for a given component.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't appear.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2K3n"
                             raise="$(throwExc)" timeout="$(timeout)"/>
          </Procedure>
          <Procedure id="_2K3o" name="waitForComponentForAbsence">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="timeout">3000</variable>
            <variable name="throwExc">true</variable>
            <comment>Wait till a given component disappears.

@param	client		The name of the SUT client.
@param	id		The Id of the target-component.
@param	timeout		The timeout to wait for that component
@param 	throwExc		True, whether procedure should throw an exception if component didn't disappear.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter absence="true" client="$(client)"
                             component="$(id)" id="_2K3p" raise="$(throwExc)"
                             timeout="$(timeout)"/>
          </Procedure>
        </Package>
        <Package id="_2KIe" name="helpers">
          <Procedure id="_2KIf" name="hasPattern">
            <variable name="id">${id:aComponentId}</variable>
            <variable name="pattern"/>
            <comment>Check whether the component has the given pattern. 

@param	id	The Id of the component.
@param	pattern	The pattern name, e.g &#8221;Invoke&#8221;, &#8221;ExpandCollapse&#8221; etc.

@return	true	If the pattern is supported by the element
	false	If the pattern is not supported by the element

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:win}" id="_2KIg">
              <code>winc = rc.getComponent(rc.lookup("id"))
pattern = rc.lookup("pattern")

rc.setLocal("hasPattern", winc.hasPattern(pattern))

</code>
            </ClientScriptStep>
            <ReturnStep id="_2KIl" retval="$(hasPattern)"/>
          </Procedure>
        </Package>
        <Package id="_2KAZ" name="radiobutton">
          <comment>Procedures to get and set the state of radio buttons.


@author	QFS
@since	5.0</comment>
          <Procedure id="_2KAa" name="getValue">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Return the value of a radio button.
It's either 1, if radio button is selected of 0, if radio button is not selected.

@param	id	ID of the radio button.

@return  The state of the checkbox.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2KAb">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2KAc"
                                raise="true" timeout="0"/>
              <ReturnStep id="_2KAd" retval="1"/>
              <CatchSequence exception="CheckFailedException" id="_2KAe"
                             maxerror="0">
                <ReturnStep id="_2KAf" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2KAg" name="select">
            <variable name="id">${id:aRadioButtonId}</variable>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.

@param	id	The id of the radio button.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2KAh">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2KAi"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2KAj"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2KAk" modifiers="16"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2KAl" name="selectWithCoordinates">
            <variable name="id">${id:aRadioButtonId}</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Select a radio button. If the  radio button is already selected, no action is performed.
You can specify the coordinates for clicking.

@param	id	The id of the radio button.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TryStep id="_2KAm">
              <CheckBooleanStep checktype="checked" client="$(client)"
                                component="$(id)" errorlevel="0" id="_2KAn"
                                raise="true" timeout="0"/>
              <CatchSequence exception="CheckFailedException" id="_2KAo"
                             maxerror="0">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)" event="MOUSE_MPRC"
                                id="_2KAp" modifiers="16" x="$(x)" y="$(y)"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
        </Package>
        <Package id="_2KBC" name="table">
          <comment>Procedures to access tables.


@author	QFS
@since	5.0</comment>
          <Package id="_2KBi" name="checks">
            <comment>Procedures for checking a table.

@author 	QFS
@since 	5.0</comment>
            <Procedure id="_2KBj" name="checkNumberOfRows">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of rows of a given table according to a specified comparison mode.


Sample usage:
You can check, that a table has exactly 6 rows or that the table has less then 10 rows.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  UserException, if wrong comparison mode has been set.

@author	 QFS
@since	 5.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2KBk" local="true"
                             procedure="qfs.win.table.getRowCount"
                             retvarname="rowCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2KBl"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(rowCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
            <Procedure id="_2KEy" name="checkNumberOfColumns">
              <variable name="id">${id:tableid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of columns of a given table according to a specified comparison mode.


Sample usage:
You can check, that a table has exactly 6 columns or that the table has less then 10 columns.

@param	id 		The id of the table.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of columns.
			&lt;, if the compareValue should be greater than the actual amount of columns.
			&gt;, if the compareValue should be less than the actual amount of columns.
			&lt;=, if the compareValue should be greater or equal than the actual amount of columns.
			&gt;=, if the compareValue should be less or equal the actual amount of columns.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.

@throws  	UserException, if wrong comparison mode has been set.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2KEz" local="true"
                             procedure="qfs.win.table.getColumnCount"
                             retvarname="count">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2KE+"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of rows of table '$(id)'</variable>
                <variable name="got">$(count)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_2KC3" name="clickCellWithDetails">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given cell.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param 	id  		ID of the table.
@param 	column 		The column.
@param	row		The row.
@param 	columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x		The x coordinate for the click, default is empty to click in the middle.
@param	y		The y coordinate for the click, default is empty to click in the middle.
@param	clickCount		Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier		Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard		True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_2KC4"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2KC5" name="getColumnCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of columns of a given table.


@param id 		The component-ID of the table.
@return columnCount

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2KC6"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                            id="_2KEp" local="true"
                            varname="indexLastColumn"/>
            <ReturnStep id="_2KC8" retval="$[$(indexLastColumn)+1]"/>
          </Procedure>
          <Procedure id="_2KC9" name="getIndexOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">@</variable>
            <comment>Return the current index of a given column.

Sample usage:
Can be used to determine the numeric index of a column like 'Price'.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the column, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)"
                            id="_2KCA" local="true" varname="index"/>
            <ReturnStep id="_2KCB" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2KCC" name="getNameOfColumn">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="columnSeparator">&amp;</variable>
            <comment>Return the header text of a given column.

Sample usage:
Determine the title of the second column.

@param id  		ID of the table.
@param column 	The column.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	name   The name of the column.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)"
                           id="_2KCD" local="true" varname="name"/>
            <ReturnStep id="_2KCE" retval="$(name)"/>
          </Procedure>
          <Procedure id="_2KCF" name="getRowCount">
            <variable name="id">${id:tableid}</variable>
            <comment>Return the number of rows of a given table.


@param id 		The component-id of the table.
@return rowCount

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2KCG"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <FetchIndexStep client="$(client)" component="$(id)&amp;0&amp;-1"
                            id="_2KEo" local="true" varname="indexLastRow"/>
            <ReturnStep id="_2KCI" retval="$[$(indexLastRow)+1]"/>
          </Procedure>
          <Procedure id="_2KCJ" name="getRowIndexOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Return the row number of a given cell.

Sample usage:
Can be used to determine in which row a dedicated cell is located.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the row, which has been read by the 'Fetch Index' node of QF-Test.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            id="_2KCK" local="true" varname="index"/>
            <ReturnStep id="_2KCL" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2KCM" name="getValueOfCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">&amp;</variable>
            <comment>Return the text of a given cell.

Sample usage:
Can be used to determine the text of the cell in the first column and first row.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value   The current value of the row, which has been read by the 'Fetch text' node of QF-Test.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                           id="_2KCN" local="true" varname="value"/>
            <ReturnStep id="_2KCO" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2KCP" name="resizeColumn">
            <variable name="idColumn">aColumnId</variable>
            <variable name="width">aWidth</variable>
            <variable name="absolute">true</variable>
            <comment>Resize width of a table column.

@param client		The name of the client.
@param idColumn	The id of the table column to be resized.
@param width		The new width - additional or absolute, dependent on the 'absolute' parameter.
                                            For additional width also negative values are possible to shrink the column size.
@param absolute	True, if the with value shall be the absolute new column width (default is 'true').

@author	QFS
@since	5.0</comment>
            <BasicSequence id="_2KCQ">
              <variable name="currentWidth"/>
              <FetchGeometryStep client="$(client)" component="$(idColumn)"
                                 id="_2KCR" local="true"
                                 widthvarname="currentWidth"/>
              <IfSequence id="_2KCS"
                          test="&#34;$(absolute)&#34; == &#34;true&#34;">
                <ElseSequence id="_2KCT">
                  <SetGlobalStep id="_2KCU" local="true" varname="width">
                    <default>$[$(currentWidth) + $(width)]</default>
                  </SetGlobalStep>
                </ElseSequence>
              </IfSequence>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_MOVED"
                              hardevent="true" id="_2KCV" modifiers="0"
                              x="$(currentWidth)" y="1"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(idColumn)" event="MOUSE_PRESSED"
                              hardevent="true" id="_2KCW" modifiers="16"
                              x="$(currentWidth)" y="1"/>
              <MouseEventStep clicks="0" client="$(client)"
                              component="$(idColumn)" event="MOUSE_DRAGGED"
                              hardevent="true" id="_2KCX" modifiers="16"
                              x="$(width)" y="1"/>
              <MouseEventStep clicks="1" client="$(client)"
                              component="$(idColumn)" event="MOUSE_RELEASED"
                              hardevent="true" id="_2KCY" modifiers="16"
                              x="$(width)" y="1"/>
            </BasicSequence>
          </Procedure>
          <Procedure id="_2KCZ" name="selectCell">
            <variable name="id">${id:tableid}</variable>
            <variable name="column">column</variable>
            <variable name="row">row</variable>
            <variable name="columnSeparator">@</variable>
            <variable name="rowSeparator">@</variable>
            <comment>Select a given cell.

@param id  		ID of the table.
@param column 	The column.
@param row		The row.
@param columnSeparator 	Separator to use for the column syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param rowSeparator	Separator to use for the row syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author QFS
@since 5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(columnSeparator)$(column)$(rowSeparator)$(row)"
                            event="MOUSE_MPRC" id="_2KCa" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_2KCb" name="tabbedpane">
          <comment>Procedures to work with TabbedPanes.


@author QFS
@since 5.0</comment>
          <Procedure id="_2KCf" name="getIndexOfTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Return the index of a given tab in a TabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to look for.

@return	The index of the tab.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(separator)$(value)" id="_2KCg"
                            local="true" varname="index"/>
            <ReturnStep id="_2KCh" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2YNY" name="getItemCount">
            <variable name="id">${id:aTabfolder}</variable>
            <comment>Return the number of items of a given tabbedpane.


@param id 		The component-ID of the tabbedpane.
@return itemCount

@author QFS
@since 5.3.1

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2YNZ"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <FetchIndexStep client="$(client)" component="$(id)&amp;-1"
                            id="_2YNl" local="true" varname="itemCount"/>
            <ReturnStep id="_2YNm" retval="$[$(itemCount)+1]"/>
          </Procedure>
          <Procedure id="_2KCi" name="getValueOfTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">&amp;</variable>
            <variable name="value"/>
            <comment>Return the text of a given tab in a TabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The index to look for.

@return	The value of the tab.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(separator)$(value)" id="_2KCj"
                           local="true" varname="value"/>
            <ReturnStep id="_2KCk" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2KCl" name="selectTab">
            <variable name="id">${id:aTabbedPaneId}</variable>
            <variable name="separator">@</variable>
            <variable name="value"/>
            <comment>Select a tab in a given TabbedPane.

@param	client	The name of the SUT client.
@param	id	The component-ID of the tabbedpane to select.
@param	separator	Separator to use for the tab syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	value	The value to select.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(value)"
                            event="MOUSE_MPRC" id="_2KF3" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_2KCo" name="text">
          <comment>Procedures to access text fields and text areas.


@author	QFS
@since	5.0</comment>
          <Procedure id="_2KCp" name="clearArea">
            <variable name="id">${id:aTextArea}</variable>
            <comment>Clear a multi-line text area.

@param	client	The name of the SUT client.
@param	id	The id of the text area.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_2KCq" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2KCr" name="clearField">
            <variable name="id">${id:aTextField}</variable>
            <comment>Clear a simple text field.

@param	client	The name of the SUT client.
@param	id	The id of the text field.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <TextInputStep clear="true" client="$(client)" component="$(id)"
                           id="_2KCs" single="false">
              <text></text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2KCt" name="getText">
            <variable name="id">${id:aTextField}</variable>
            <comment>Return the text of a given textfield.

@param	id	ID of the textfield.

@return  	The text of the textfield.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)" component="$(id)" id="_2KCu"
                           local="true" varname="currentText"/>
            <ReturnStep id="_2KCv" retval="$(currentText)"/>
          </Procedure>
          <Procedure id="_2KEq" name="setText">
            <variable name="id">${id:aTextField}</variable>
            <variable name="text"/>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">true</variable>
            <variable name="newline">\n</variable>
            <comment>Set a given text to a given text-field or text-area.

@param	id		ID of the textfield.
@param 	text		text to be set. 
@param	append		if this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared before the text given as parameter "text" is inserted.
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <IfSequence id="_2KF0"
                        test="not $(clear) and not $(append) and not $(replaySingleEvents)">
              <ProcedureCall id="_2KF1" procedure="qfs.run-log.logWarning">
                <variable name="message">Text cannot be inserted at cursor position (append=false) 
with replaySingleEvents=false 
-&gt; replaying single events</variable>
                <variable name="report">true</variable>
              </ProcedureCall>
              <SetGlobalStep id="_2KE-" local="true"
                             varname="replaySingleEvents">
                <default>true</default>
              </SetGlobalStep>
            </IfSequence>
            <ServerScriptStep id="_2KEr" interpreter="groovy">
              <code>import de.qfs.lib.util.Misc

def text = rc.lookup("text")
def newline = rc.lookup("newline")
if (newline) {
    rc.setLocal("text", text.replace(newline, "\n"))
}
</code>
            </ServerScriptStep>
            <IfSequence id="_2KEs" test="$(append)">
              <IfSequence id="_2KEt" test="${qftest:osx}">
                <KeyEventStep client="$(client)" component="$(id)"
                              event="KEY_PTR" id="_2KEu" keychar="0"
                              keycode="40" modifiers="4"/>
                <ElseSequence id="_2KEv">
                  <KeyEventStep client="$(client)" component="$(id)"
                                event="KEY_PTR" id="_2KEw" keychar="0"
                                keycode="35" modifiers="2"/>
                </ElseSequence>
              </IfSequence>
            </IfSequence>
            <TextInputStep clear="$(clear)" client="$(client)"
                           component="$(id)" id="_2KEx"
                           single="$(replaySingleEvents)">
              <text>$(text)</text>
            </TextInputStep>
          </Procedure>
          <Procedure id="_2KDK" name="setTextFromFile">
            <variable name="id">${id:aTextField}</variable>
            <variable name="file">aFile</variable>
            <variable name="append">false</variable>
            <variable name="clear">true</variable>
            <variable name="replaySingleEvents">true</variable>
            <variable name="newline">\n</variable>
            <comment>Read the content of a given file and set its content to a given text-field.

@param 	id 		The id of the text-field to set.
@param 	file		The path to the file.
@param	append		If this value is set to true, the text will be appended to the current values.
@param	clear		If this value is set to true, the text-field will be cleared in case an empty string is given as parameter "text".
@param	replaySingleEvents 	If this value is set to true, the text will be inserted replaying single events.
@param	newline		the separator sign for marking a linebreak within the text

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KDL" local="true"
                           procedure="qfs.utils.readTextFromFile"
                           retvarname="text">
              <variable name="file">$(file)</variable>
            </ProcedureCall>
            <ProcedureCall id="_2KDM" procedure=".setText">
              <variable name="id">$(id)</variable>
              <variable name="text">$(text)</variable>
              <variable name="append">$(append)</variable>
              <variable name="clear">$(clear)</variable>
              <variable name="replaySingleEvents">$(replaySingleEvents)</variable>
              <variable name="newline">$(newline)</variable>
            </ProcedureCall>
          </Procedure>
        </Package>
        <Package id="_2KGZ" name="list">
          <comment>Procedures for accessing lists.


@author	QFS
@since 	5.0</comment>
          <Package id="_2KGa" name="checks">
            <comment>Procedures for checking a list.

@author 	QFS
@since 	5.0</comment>
            <Procedure id="_2KGb" name="checkNumberOfItems">
              <variable name="id">${id:listid}</variable>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of items of a given list according to a specified comparison mode.

It uses the method getChildCount(() to get the number.
Sample usage:
You can check, that a list has exactly 6 items or that the table has less then 10 items.

@param	id 		The id of the list.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of items.
			&lt;, if the compareValue should be greater than the actual amount of items.
			&gt;, if the compareValue should be less than the actual amount of items.
			&lt;=, if the compareValue should be greater or equal than the actual amount of items.
			&gt;=, if the compareValue should be less or equal the actual amount of items.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2KGc" local="true"
                             procedure="qfs.win.list.getItemCount"
                             retvarname="itemCount">
                <variable name="id">$(id)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2KGd"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of items of list '$(id)'</variable>
                <variable name="got">$(itemCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_2KGx" name="clickItemWithDetails">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given item by a mouse-click on it.  
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_2KGy"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2KGz" name="getItemCount">
            <variable name="id">${id:listid}</variable>
            <comment>Return the number of items of a given list.
It uses the method getChildCount() to get the number.

@param 	id 	The component-ID of the list.
@return 	itemCount

@author	QFS,bp
@since 	5.0

@ignoreanalyzerefcid</comment>
            <ComponentWaiter client="$(client)" component="$(id)" id="_2KG+"
                             timeout="$[rc.getOption(Options.OPT_PLAY_TIMEOUT_COMPONENT)]">
              <comment>Compensation for the fact that rc.getComponent cannot be used with a timeout and thus has timeout 0 instead of the default option value.</comment>
            </ComponentWaiter>
            <ClientScriptStep client="$(client)"
                              engine="${default:guiengine:win}" id="_2KG-">
              <code>list = rc.getComponent(rc.lookup("id"))

itemCount = list.getChildCount()

rc.setLocal("itemCount", itemCount)</code>
            </ClientScriptStep>
            <ReturnStep id="_2KH0" retval="$(itemCount)"/>
          </Procedure>
          <Procedure id="_2KH1" name="getIndexOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Return the current index of a given item.

Sample usage:
Can be used to determine the numeric index of an item like 'Price'.

@param 	id  		ID of the list.
@param	 item 		The item.
@param	 itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	index   The current index of the item, which has been read by the 'Fetch Index' node of QF-Test.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            id="_2KH2" local="true" varname="index"/>
            <ReturnStep id="_2KH3" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2KH4" name="getValueOfItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">&amp;</variable>
            <comment>Return the text of a given item.

Sample usage:
Determine the text of the second item.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return	value	The value of the item.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(itemSeparator)$(item)" id="_2KH5"
                           local="true" varname="value"/>
            <ReturnStep id="_2KH6" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2KH7" name="selectItem">
            <variable name="id">${id:listid}</variable>
            <variable name="item">item</variable>
            <variable name="itemSeparator">@</variable>
            <comment>Select a given item by a mouse-click on it.

@param id  		ID of the list.
@param item 		The item.
@param itemSeparator 	Separator to use for the item syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The x coordinate for the click, default is empty to click in the middle.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(itemSeparator)$(item)"
                            event="MOUSE_MPRC" id="_2KH8" modifiers="16"/>
          </Procedure>
        </Package>
        <Package id="_2KH9" name="tree">
          <comment>Procedures to access trees.


@author	QFS
@since	5.0</comment>
          <Package id="_2KHA" name="checks">
            <comment>Procedures for checking a tree.

@author	QFS
@since 	5.0</comment>
            <Procedure id="_2KHB" name="checkNumberOfChildNodes">
              <variable name="id">${id:treeid}</variable>
              <variable name="node"/>
              <variable name="nodeSeparator"/>
              <variable name="compareValue">0</variable>
              <variable name="compareMode">=</variable>
              <variable name="errorLevel">ERROR</variable>
              <variable name="appearInReport">1</variable>
              <comment>Check the number of child nodes of a given tree node according to a specified comparison mode.

Sample usage:
You can check, that a tree has exactly 6 rows or that the tree has less then 10 rows.

@param	id 		The id of the tree.
@param 	node 		The node. like '/Root/Price' or '/0/0'. Leave 					empty, if you want to count rows of whole tree.
@param 	nodeSeparator 	Separator to use for the node syntax. Default is 				@ for text values, also available &amp; for index and % for regexp.
@param	compareValue		The comparison value.
@param	compareMode		The comparison mode
			= or ==, if the compareValue should be equal than the actual amount of rows.
			&lt;, if the compareValue should be greater than the actual amount of rows.
			&gt;, if the compareValue should be less than the actual amount of rows.
			&lt;=, if the compareValue should be greater or equal than the actual amount of rows.
			&gt;=, if the compareValue should be less or equal the actual amount of rows.
			!=, if the compareValue should be not equal the actual amount of items.
@param 	errorLevel   		The kind of error, which should be logged. Either EXCEPTION, ERROR, WARNING or MESSAGE.
@param appearInReport   Flag, whether to show check in report, if a message or warning are set as errorLevel.
	                If this is set to 1, the check will be shown in the report.


@throws  UserException, if wrong comparison mode has been set.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
              <ProcedureCall id="_2KHC" local="true"
                             procedure="qfs.win.tree.getChildNodeCount"
                             retvarname="nodeCount">
                <variable name="id">$(id)</variable>
                <variable name="node">$(node)</variable>
                <variable name="nodeSeparator">$(nodeSeparator)</variable>
              </ProcedureCall>
              <ProcedureCall id="_2KHD"
                             procedure="qfs.check.compareTwoNumbers">
                <variable name="expected">$(compareValue)</variable>
                <variable name="checkMessage">Compare number of child nodes of tree '$(id)$(nodeSeparator)$(node)'</variable>
                <variable name="got">$(nodeCount)</variable>
                <variable name="compareMode">$(compareMode)</variable>
                <variable name="errorLevel">$(errorLevel)</variable>
                <variable name="appearInReport">$(appearInReport)</variable>
              </ProcedureCall>
            </Procedure>
          </Package>
          <Procedure id="_2KHZ" name="clickNodeWithDetails">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <variable name="clickCount">1</variable>
            <variable name="modifier">16</variable>
            <variable name="hard">false</variable>
            <variable name="popupTrigger">false</variable>
            <comment>Select a given node.
You can specify the coordinates for clicking and all other details of that mouse click.

@param id  		ID of the tree.
@param node 	The node, e.g. '/Root/Price' or '/0/0'.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.
@param	clickCount	Number of clicks. Default is 1. For a double-click set this to 2.
@param	modifier	Modifier for mouse key. 4 for right mouse. 16 for left mouse.
@param	hard	True, if hard event should be replayed. Default is false.
@param	popupTrigger	True, if click should open a popup. Default is false

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="$(clickCount)" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" hardevent="$(hard)" id="_2KHa"
                            modifiers="$(modifier)" popup="$(popupTrigger)"
                            x="$(x)" y="$(y)"/>
          </Procedure>
          <Procedure id="_2KHb" name="collapse">
            <variable name="node">tree.item</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.

@author	QFS
@since	5.0</comment>
            <ProcedureCall id="_2KJ3" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(node)</variable>
              <variable name="pattern">ExpandCollapse</variable>
            </ProcedureCall>
            <IfSequence id="_2KJ4" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)" component="$(node)"
                                  detail="collapse" event="SELECTION"
                                  id="_2KJ5"/>
              <ElseSequence id="_2KJ6">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(node)" event="MOUSE_MPRC"
                                id="_2KJ7" modifiers="16"/>
                <KeyEventStep client="$(client)" component="$(node)"
                              event="KEY_PTR" id="_2KHd" keychar="65535"
                              keycode="37" modifiers="0"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2KHf" name="collapseWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to collapse.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_2KHl" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_2KHh" keychar="65535"
                          keycode="37" modifiers="0"/>
          </Procedure>
          <Procedure id="_2KHj" name="collapseNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KIy" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(id)$(separator)$(node)</variable>
              <variable name="pattern">ExpandCollapse</variable>
            </ProcedureCall>
            <IfSequence id="_2KIz" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)"
                                  component="$(id)$(separator)$(node)"
                                  detail="collapse" event="SELECTION"
                                  id="_2KI+"/>
              <ElseSequence id="_2KI-">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)$(separator)$(node)"
                                event="MOUSE_MPRC" id="_2KJ0" modifiers="16"/>
                <KeyEventStep client="$(client)"
                              component="$(id)$(separator)$(node)"
                              event="KEY_PTR" id="_2KJB" keychar="65535"
                              keycode="37" modifiers="0"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2KHn" name="collapseNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Collapse a tree node.
It clicks on the tree node, replays a left key press event and selects the node again.
If your tree doesn't support keyboard actions to collapse a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. like '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS,mm
@since	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_2KHo" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_2KHp" keychar="65535" keycode="37"
                          modifiers="0"/>
          </Procedure>
          <Procedure id="_2KHu" name="expand">
            <variable name="node">tree.item</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.

@author	QFS
@since	5.0</comment>
            <ProcedureCall id="_2KIm" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(node)</variable>
              <variable name="pattern">ExpandCollapse</variable>
            </ProcedureCall>
            <IfSequence id="_2KIn" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)" component="$(node)"
                                  detail="expand" event="SELECTION"
                                  id="_2KIo"/>
              <ElseSequence id="_2KIp">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(node)" event="MOUSE_MPRC"
                                id="_2KHv" modifiers="16"/>
                <KeyEventStep client="$(client)" component="$(node)"
                              event="KEY_PTR" id="_2KHw" keychar="65535"
                              keycode="39" modifiers="0"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2KHy" name="expandWithCoordinates">
            <variable name="node">tree.item</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	node	The id of the tree node to expand.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0</comment>
            <MouseEventStep clicks="1" client="$(client)" component="$(node)"
                            event="MOUSE_MPRC" id="_2KHz" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)" component="$(node)"
                          event="KEY_PTR" id="_2KH+" keychar="65535"
                          keycode="39" modifiers="0"/>
          </Procedure>
          <Procedure id="_2KI0" name="expandNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.


@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KIr" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(id)$(separator)$(node)</variable>
              <variable name="pattern">ExpandCollapse</variable>
            </ProcedureCall>
            <IfSequence id="_2KIs" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)"
                                  component="$(id)$(separator)$(node)"
                                  detail="expand" event="SELECTION"
                                  id="_2KIb"/>
              <ElseSequence id="_2KIu">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)$(separator)$(node)"
                                event="MOUSE_MPRC" id="_2KIv" modifiers="16"/>
                <KeyEventStep client="$(client)"
                              component="$(id)$(separator)$(node)"
                              event="KEY_PTR" id="_2KIw" keychar="65535"
                              keycode="39" modifiers="0"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
          <Procedure id="_2KI4" name="expandNodeWithCoordinates">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <variable name="x"/>
            <variable name="y"/>
            <comment>Expand a tree node.
It clicks on the tree node, replays a right key press event and selects the node again.
If your tree doesn't support keyboard actions to expand a node, this procedure won't work.
You can specify the coordinates for clicking.

@param	client	The name of the SUT client.
@param	id  	The id of the tree.
@param	node 	The node, e.g. '/Root/Price' or '/0/0'.
@param	separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@param	x	The x coordinate for the click, default is empty to click in the middle.
@param	y	The y coordinate for the click, default is empty to click in the middle.

@author	QFS
@since	5.0

@ignoreanalyzerefcid</comment>
            <MouseEventStep clicks="1" client="$(client)"
                            component="$(id)$(separator)$(node)"
                            event="MOUSE_MPRC" id="_2KI5" modifiers="16"
                            x="$(x)" y="$(y)"/>
            <KeyEventStep client="$(client)"
                          component="$(id)$(separator)$(node)" event="KEY_PTR"
                          id="_2KI6" keychar="65535" keycode="39"
                          modifiers="0"/>
          </Procedure>
          <Procedure id="_2KJC" name="getChildNodeCount">
            <variable name="id">${id:treeid}</variable>
            <variable name="node"/>
            <variable name="nodeSeparator"/>
            <comment>Return the number of child nodes.

@param 	id 		The component-id of the tree.
@param 	node 	The node. like '/Root/Price' or '/0/0'. If no node is specified, QF-Test will count the items of the root node.
@param 	nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@return 	nodeCount

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(nodeSeparator)$(node)" id="_V"
                            local="true" varname="idx"/>
            <TryStep id="_X">
              <ComponentWaiter client="$(client)"
                               component="$(id)&amp;$(idx)/0" id="_W"
                               local="true" timeout="1000"/>
              <ClientScriptStep client="$(client)"
                                engine="${qftest:engine.$(id)}" id="_2KJD"
                                name="child nodes">
                <code>tree = None
winc = None
nodeCount = 0

if not rc.lookup("node") or not rc.lookup("nodeSeparator"):
    raise UserException("No value for 'node' parameter specified!")   

winc = rc.getComponent(rc.lookup("id") + rc.lookup("nodeSeparator") + rc.lookup("node"))

nodes = winc.getElementsByClassName("TreeItem")
for node in nodes:
    if node.getParent() == winc:
        nodeCount = nodeCount +1 
          
rc.setLocal("nodeCount", nodeCount)</code>
              </ClientScriptStep>
              <ReturnStep id="_2KIJ" retval="$(nodeCount)"/>
              <CatchSequence exception="IndexNotFoundException" id="_Y"
                             maxerror="0">
                <ReturnStep id="_2KJE" retval="0"/>
              </CatchSequence>
            </TryStep>
          </Procedure>
          <Procedure id="_2KIK" name="getIndexOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">@</variable>
            <variable name="linear">false</variable>
            <comment>Return the current index of a given node.

Sample usage:
Can be used to determine the numeric index of a node like '/Root/Price'.

@param id  		ID of the tree.
@param node 	The node. like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.
@return	index   The current index of the node

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchIndexStep client="$(client)"
                            component="$(id)$(nodeSeparator)$(node)"
                            id="_2KIN" local="true" varname="index"/>
            <ReturnStep id="_2KIO" retval="$(index)"/>
          </Procedure>
          <Procedure id="_2KIV" name="getValueOfNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="nodeSeparator">&amp;</variable>
            <comment>Return the text of a given node.

Sample usage:
Determine the text value for a node referenced by index like /0/1.

@param id  		ID of the tree.
@param node 	The node. It should be something like '/Root/Price' or '/0/0'.
@param nodeSeparator 	Separator to use for the node syntax. Default is &amp; for index, also available @ for text values and % for regexp.

@return	name   The value of the node.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <FetchTextStep client="$(client)"
                           component="$(id)$(nodeSeparator)$(node)" id="_2KIW"
                           local="true" varname="value"/>
            <ReturnStep id="_2KIX" retval="$(value)"/>
          </Procedure>
          <Procedure id="_2KIY" name="selectNode">
            <variable name="id">${id:treeid}</variable>
            <variable name="node">node</variable>
            <variable name="separator">@</variable>
            <comment>Select a given node.

@param id  		ID of the tree.
@param node 	The node, e.g. '/Root/Price' or '/0/0'.
@param separator 	Separator to use for the node syntax. Default is @ for text values, also available &amp; for index and % for regexp.

@author 	QFS
@since 	5.0

@ignoreanalyzerefcid</comment>
            <ProcedureCall id="_2KIh" local="true"
                           procedure="qfs.win.helpers.hasPattern"
                           retvarname="compHasPattern">
              <variable name="id">$(id)$(separator)$(node)</variable>
              <variable name="pattern">SelectionItem</variable>
            </ProcedureCall>
            <IfSequence id="_2KIi" test="$(compHasPattern)">
              <SelectionEventStep client="$(client)"
                                  component="$(id)$(separator)$(node)"
                                  event="SELECTION" id="_2K53"/>
              <ElseSequence id="_2KIj">
                <MouseEventStep clicks="1" client="$(client)"
                                component="$(id)$(separator)$(node)"
                                event="MOUSE_MPRC" id="_2KIk" modifiers="16"/>
              </ElseSequence>
            </IfSequence>
          </Procedure>
        </Package>
      </Package>
    </Package>
  </PackageRoot>
  <ExtraSequence id="_13"/>
  <WindowList id="_14">
    <WindowStep class="Window" engine="android" id="genericLaunchedAndroidApp"
                uid="_2KFU">
      <extrafeature name="android:package" negate="false" regexp="false"
                    state="2">${qftest:androidLastPackage}</extrafeature>
      <comment>This node will match the window of the most recently launched Android app.

@generic</comment>
    </WindowStep>
    <WindowStep class="Window" engine="android" id="genericAndroidApp"
                uid="_2KFV">
      <comment>This node will match any Android window.

@generic</comment>
    </WindowStep>
    <WindowStep class="PriorityAndroidComponent" engine="android"
                id="PriorityAndroidApp" uid="_2Ye0">
      <comment>Component which can be used by rc.overrideElement which can be used for Android Window Apps.
It will act as assigned window, so the information of the window itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="PriorityAndroidComponent"
                     id="PriorityAndroidComponent" uid="_2Ye1">
        <comment>Component which can be used by rc.overrideElement for Android components.
It will act as assigned node, so the information of the node itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="Window" engine="android" id="genericMainAndroidApp"
                uid="_2Yb2">
      <extrafeature name="android:windowType" negate="false" regexp="false"
                    state="2">APPLICATION</extrafeature>
      <comment>This node will match the main Android window.

@generic</comment>
    </WindowStep>
    <WindowStep class="Window" engine="android" id="genericAndroidInputApp"
                uid="_2Ydj">
      <extrafeature name="android:windowType" negate="false" regexp="false"
                    state="2">INPUT</extrafeature>
      <comment>This node will match any input Android window.

@generic</comment>
    </WindowStep>
    <WindowStep class="java.awt.Dialog" id="genericModalDialog" modal="true"
                uid="_1jys">
      <comment>This node will always match the "most modal" dialog.

@generic</comment>
      <ComponentStep class="FileChooser" classcount="1" classindex="0"
                     height="326" id="genericFileChooser" uid="_1oCk"
                     width="500" x="8" y="30">
        <extrafeature name="qfs:class" negate="false" regexp="false"
                      state="0">javax.swing.JFileChooser</extrafeature>
        <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                      state="0">FileChooser</extrafeature>
        <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                      state="0">javax.swing.JFileChooser</extrafeature>
        <comment>

@generic</comment>
        <ComponentStep class="TextField" classcount="1" classindex="0"
                       feature="Label: Dateiname:|Label: .*file.*" height="-"
                       id="genericFileChooser.textFilename" regexp="true"
                       uid="_1oCl" width="-" x="-" y="-">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JTextField</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">TextField</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JTextField</extrafeature>
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="Button" classcount="11" classindex="9"
                       feature="ffnen|Open" height="26"
                       id="genericFileChooser.buttonOpen" regexp="true"
                       uid="_1oCm" width="96" x="-" y="-">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Button</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="java.awt.Dialog" id="genericNonModalDialog"
                uid="_1jyt">
      <comment>This node will match any non-modal dialog.

@generic</comment>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" feature="Verzeichnis auswhlen"
                height="351" id="JFileChooser.Dialog" modal="true"
                name="JFileChooser.Dialog" regexp="true" uid="_1jyu"
                width="512" x="293" y="145">
      <comment>The JFileChooser Dialog.</comment>
      <ComponentStep class="javax.swing.JFileChooser" classcount="1"
                     classindex="0" height="326" id="JFileChooser.Main"
                     name="JFileChooser.Main" uid="_1jyv" width="500" x="6"
                     y="19">
        <ComponentStep class="javax.swing.JTextField" classcount="1"
                       classindex="0" feature="Label: Dateiname:" height="20"
                       id="JFileChooser.Filename" name="JFileChooser.Filename"
                       uid="_1jyw" width="396" x="93" y="222"/>
        <ComponentStep class="javax.swing.JButton" classcount="11"
                       classindex="9" feature="ffnen" height="26"
                       id="JFileChooser.OK" name="JFileChooser.OK"
                       regexp="true" uid="_1jyx" width="100" x="284" y="289"/>
        <ComponentStep class="javax.swing.JButton" classcount="11"
                       classindex="10" feature="Abbrechen" height="23"
                       id="JFileChooser.Cancel" name="JFileChooser.Cancel"
                       uid="_1k0U" width="99" x="421" y="292"/>
        <ComponentStep class="javax.swing.JScrollPane" classcount="1"
                       classindex="0" height="169"
                       id="JFileChooser.ListScroll"
                       name="JFileChooser.ListScroll" uid="_1jyy" width="500"
                       x="0" y="54">
          <ComponentStep class="apple.laf.AquaFileChooserUI$JTableExtension"
                         classcount="1" classindex="0"
                         id="JFileChooser.ListScroll.table" uid="_1jyz"/>
          <ComponentStep class="javax.swing.JList" classcount="1"
                         classindex="0" id="JFileChooser.List"
                         name="JFileChooser.List" uid="_1jy+"/>
        </ComponentStep>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane" modal="true"
                name="JOptionPane.$(type)" uid="_1lvC">
      <comment>

@generic</comment>
      <ComponentStep class="javax.swing.JButton" id="JOptionPane.OK"
                     name="JOptionPane.$(type).OK" uid="_1lvD">
        <comment>

@generic</comment>
      </ComponentStep>
      <ComponentStep class="javax.swing.JButton" id="JOptionPane.YES"
                     name="JOptionPane.$(type).YES" uid="_1lvE">
        <comment>

@generic</comment>
      </ComponentStep>
      <ComponentStep class="javax.swing.JButton" id="JOptionPane.NO"
                     name="JOptionPane.$(type).NO" uid="_1lvF">
        <comment>

@generic</comment>
      </ComponentStep>
      <ComponentStep class="javax.swing.JButton" id="JOptionPane.CANCEL"
                     name="JOptionPane.$(type).CANCEL" uid="_1lvG">
        <comment>

@generic</comment>
      </ComponentStep>
      <ComponentStep class="javax.swing.JLabel" id="JOptionPane.genericLabel"
                     name="JOptionPane.$(type).Label$(i)" uid="_1lvP">
        <comment>

@generic</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane.ErrorDialog"
                modal="true" name="JOptionPane.ErrorDialog" uid="_1jy-">
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.OK"
                     name="JOptionPane.ErrorDialog.OK" uid="_1jz0"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.YES"
                     name="JOptionPane.ErrorDialog.YES" uid="_1jz1"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.NO"
                     name="JOptionPane.ErrorDialog.NO" uid="_1jz2"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.CANCEL"
                     name="JOptionPane.ErrorDialog.CANCEL" uid="_1jz3"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.Custom1"
                     name="JOptionPane.ErrorDialog.Custom1" uid="_1jz4"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.Custom2"
                     name="JOptionPane.ErrorDialog.Custom2" uid="_1jz5"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.Custom3"
                     name="JOptionPane.ErrorDialog.Custom3" uid="_1jz6"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.ErrorDialog.Custom4"
                     name="JOptionPane.ErrorDialog.Custom4" uid="_1jz7"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.ErrorDialog.Label1"
                     name="JOptionPane.ErrorDialog.Label1" uid="_1jz8"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.ErrorDialog.Label2"
                     name="JOptionPane.ErrorDialog.Label2" uid="_1jz9"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.ErrorDialog.Label3"
                     name="JOptionPane.ErrorDialog.Label3" uid="_1jzA"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.ErrorDialog.Label4"
                     name="JOptionPane.ErrorDialog.Label4" uid="_1jzB"/>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane.InfoDialog"
                modal="true" name="JOptionPane.InfoDialog" uid="_1jzC">
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.OK"
                     name="JOptionPane.InfoDialog.OK" uid="_1jzD"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.YES"
                     name="JOptionPane.InfoDialog.YES" uid="_1jzE"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.NO"
                     name="JOptionPane.InfoDialog.NO" uid="_1jzF"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.CANCEL"
                     name="JOptionPane.InfoDialog.CANCEL" uid="_1jzG"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.Custom1"
                     name="JOptionPane.InfoDialog.Custom1" uid="_1jzH"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.Custom2"
                     name="JOptionPane.InfoDialog.Custom2" uid="_1jzI"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.Custom3"
                     name="JOptionPane.InfoDialog.Custom3" uid="_1jzJ"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.InfoDialog.Custom4"
                     name="JOptionPane.InfoDialog.Custom4" uid="_1jzK"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.InfoDialog.Label1"
                     name="JOptionPane.InfoDialog.Label1" uid="_1jzL"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.InfoDialog.Label2"
                     name="JOptionPane.InfoDialog.Label2" uid="_1jzM"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.InfoDialog.Label3"
                     name="JOptionPane.InfoDialog.Label3" uid="_1jzN"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.InfoDialog.Label4"
                     name="JOptionPane.InfoDialog.Label4" uid="_1jzO"/>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane.WarningDialog"
                modal="true" name="JOptionPane.WarningDialog" uid="_1jzP">
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.OK"
                     name="JOptionPane.WarningDialog.OK" uid="_1jzQ"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.YES"
                     name="JOptionPane.WarningDialog.YES" uid="_1jzR"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.NO"
                     name="JOptionPane.WarningDialog.NO" uid="_1jzS"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.CANCEL"
                     name="JOptionPane.WarningDialog.CANCEL" uid="_1jzT"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.Custom1"
                     name="JOptionPane.WarningDialog.Custom1" uid="_1jzU"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.Custom2"
                     name="JOptionPane.WarningDialog.Custom2" uid="_1jzV"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.Custom3"
                     name="JOptionPane.WarningDialog.Custom3" uid="_1jzW"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.WarningDialog.Custom4"
                     name="JOptionPane.WarningDialog.Custom4" uid="_1jzX"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.WarningDialog.Label1"
                     name="JOptionPane.WarningDialog.Label1" uid="_1jzY"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.WarningDialog.Label2"
                     name="JOptionPane.WarningDialog.Label2" uid="_1jzZ"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.WarningDialog.Label3"
                     name="JOptionPane.WarningDialog.Label3" uid="_1jza"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.WarningDialog.Label4"
                     name="JOptionPane.WarningDialog.Label4" uid="_1jzb"/>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane.QuestionDialog"
                modal="true" name="JOptionPane.QuestionDialog" uid="_1jzc">
      <ComponentStep class="javax.swing.JButton" feature="OK"
                     id="JOptionPane.QuestionDialog.OK"
                     name="JOptionPane.QuestionDialog.OK" uid="_1jzd"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.YES"
                     name="JOptionPane.QuestionDialog.YES" uid="_1jze"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.NO"
                     name="JOptionPane.QuestionDialog.NO" uid="_1jzf"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.CANCEL"
                     name="JOptionPane.QuestionDialog.CANCEL" uid="_1jzg"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.Custom1"
                     name="JOptionPane.QuestionDialog.Custom1" uid="_1jzh"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.Custom2"
                     name="JOptionPane.QuestionDialog.Custom2" uid="_1jzi"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.Custom3"
                     name="JOptionPane.QuestionDialog.Custom3" uid="_1jzj"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.QuestionDialog.Custom4"
                     name="JOptionPane.QuestionDialog.Custom4" uid="_1jzk"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.QuestionDialog.Label1"
                     name="JOptionPane.QuestionDialog.Label1" uid="_1jzl"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.QuestionDialog.Label2"
                     name="JOptionPane.QuestionDialog.Label2" uid="_1jzm"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.QuestionDialog.Label3"
                     name="JOptionPane.QuestionDialog.Label3" uid="_1jzn"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.QuestionDialog.Label4"
                     name="JOptionPane.QuestionDialog.Label4" uid="_1jzo"/>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" id="JOptionPane.PlainDialog"
                modal="true" name="JOptionPane.PlainDialog" uid="_1jzp">
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.OK"
                     name="JOptionPane.PlainDialog.OK" uid="_1jzq"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.YES"
                     name="JOptionPane.PlainDialog.YES" uid="_1jzr"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.NO"
                     name="JOptionPane.PlainDialog.NO" uid="_1jzs"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.CANCEL"
                     name="JOptionPane.PlainDialog.CANCEL" uid="_1jzt"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.Custom1"
                     name="JOptionPane.PlainDialog.Custom1" uid="_1jzu"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.Custom2"
                     name="JOptionPane.PlainDialog.Custom2" uid="_1jzv"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.Custom3"
                     name="JOptionPane.PlainDialog.Custom3" uid="_1jzw"/>
      <ComponentStep class="javax.swing.JButton"
                     id="JOptionPane.PlainDialog.Custom4"
                     name="JOptionPane.PlainDialog.Custom4" uid="_1jzx"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.PlainDialog.Label1"
                     name="JOptionPane.PlainDialog.Label1" uid="_1jzy"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.PlainDialog.Label2"
                     name="JOptionPane.PlainDialog.Label2" uid="_1jzz"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.PlainDialog.Label3"
                     name="JOptionPane.PlainDialog.Label3" uid="_1jz+"/>
      <ComponentStep class="javax.swing.JLabel"
                     id="JOptionPane.PlainDialog.Label4"
                     name="JOptionPane.PlainDialog.Label4" uid="_1jz-"/>
    </WindowStep>
    <WindowStep class="javax.swing.JDialog" engine="${default:engine:awt}"
                feature="$(dialogTitleRegExp)"
                id="JDialog.JavaSecurityWarning" modal="true" regexp="true"
                uid="_1lbF">
      <comment>

@generic</comment>
      <ComponentStep class="javax.swing.JButton" classcount="2" classindex="0"
                     feature="$(runButtonLabelRegExp)" height="25"
                     id="dialogJavaSecurityWarning.buttonRun" regexp="true"
                     uid="_1lbH" width="100" x="293" y="206">
        <extrafeature name="qfs:label" negate="false" regexp="true" state="0">$(runButtonLabelRegExp)</extrafeature>
        <comment>

@generic</comment>
      </ComponentStep>
      <ComponentStep class="javax.swing.JCheckBox" classindex="0"
                     id="dialogJavaSecurityWarning.checkBoxAccept"
                     uid="_1ls6">
        <comment>

@generic</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="com.sun.pdfview.PDFViewer"
                feature="SwingLabs PDF Viewer.*" height="-" id="PDFRenderer"
                regexp="true" uid="_I" width="-" x="-" y="-">
      <ComponentStep class="javax.swing.JMenuBar" classcount="1"
                     classindex="0" height="-" id="PDFRenderer.menubar"
                     uid="_1oE0" width="-" x="-" y="-">
        <ComponentStep class="javax.swing.JMenu" classcount="3" classindex="0"
                       feature="File" height="-" id="PDFRenderer.menuFile"
                       uid="_K" width="-" x="-" y="-">
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">File</extrafeature>
          <ComponentStep class="javax.swing.JMenuItem" feature="Quit"
                         height="-" id="PDFRenderer.menuItemQuit" uid="_L"
                         width="-" x="-" y="-">
            <extrafeature name="qfs:label" negate="false" regexp="false"
                          state="1">Quit</extrafeature>
          </ComponentStep>
          <ComponentStep class="javax.swing.JMenuItem" feature="Open..."
                         height="-" id="PDFRenderer.menuItemOpen" uid="_R"
                         width="-" x="-" y="-">
            <extrafeature name="qfs:label" negate="false" regexp="false"
                          state="1">Open...</extrafeature>
          </ComponentStep>
        </ComponentStep>
        <ComponentStep class="MenuItem" classcount="13" classindex="6"
                       feature="View" height="21" id="PDFRenderer.menuView"
                       uid="_1oDS" width="41" x="31" y="0">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JMenu</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">MenuItem</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">View</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JMenu</extrafeature>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="ToolBar" classcount="1" classindex="0" height="32"
                     id="PDFRenderer.toolbar" uid="_1oCw" width="958" x="8"
                     y="53">
        <extrafeature name="qfs:class" negate="false" regexp="false"
                      state="0">javax.swing.JToolBar</extrafeature>
        <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                      state="0">ToolBar</extrafeature>
        <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                      state="0">javax.swing.JToolBar</extrafeature>
        <ComponentStep class="Button" classcount="5" classindex="0"
                       height="28" id="PDFRenderer.buttonFirst" uid="_1oDA"
                       width="28" x="2" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">-1507393370</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Button</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">first</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
        </ComponentStep>
        <ComponentStep class="Button" classcount="5" classindex="1"
                       height="28" id="PDFRenderer.buttonPrev" uid="_1oCy"
                       width="28" x="30" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">-739408179</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Button</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">prev</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
        </ComponentStep>
        <ComponentStep class="TextField" classcount="1" classindex="0"
                       height="28" id="PDFRenderer.pageNumber" uid="_1oCx"
                       width="37" x="58" y="1">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JTextField</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">TextField</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JTextField</extrafeature>
        </ComponentStep>
        <ComponentStep class="Button" classcount="5" classindex="2"
                       height="28" id="PDFRenderer.buttonNext" uid="_1oD9"
                       width="28" x="95" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">494335413</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Button</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">next</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
        </ComponentStep>
        <ComponentStep class="Button" classcount="5" classindex="3"
                       height="28" id="PDFRenderer.buttonLast" uid="_1oDB"
                       width="28" x="123" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">2032911940</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Button</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">last</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JButton</extrafeature>
        </ComponentStep>
        <ComponentStep class="ToggleButton" classcount="3" classindex="1"
                       height="28" id="PDFRenderer.toggleZoom" uid="_1oDR"
                       width="28" x="639" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">1794657186</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JToggleButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">ToggleButton</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">zoom</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JToggleButton</extrafeature>
        </ComponentStep>
        <ComponentStep class="ToggleButton" classcount="3" classindex="2"
                       height="28" id="PDFRenderer.toggleFit" uid="_1oDN"
                       width="28" x="667" y="1">
          <extrafeature name="imagehash" negate="false" regexp="false"
                        state="1">1745791269</extrafeature>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JToggleButton</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">ToggleButton</extrafeature>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">fit</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JToggleButton</extrafeature>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="javax.swing.JSplitPane" classcount="1"
                     classindex="0" height="-" id="PDFRenderer.split" uid="_k"
                     width="-" x="-" y="-">
        <ComponentStep class="com.sun.pdfview.PagePanel" classcount="1"
                       classindex="0" feature="Split: Right"
                       id="PDFRenderer.content" uid="_l"/>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="javax.swing.JFrame" id="genericJFrame" uid="_7KT">
      <comment>

@generic</comment>
    </WindowStep>
    <WindowStep class="org.eclipse.swt.widgets.Shell" engine="swt"
                id="genericShell" uid="_1j+0">
      <comment>

@generic</comment>
      <ComponentStep class="org.eclipse.swt.widgets.Menu" feature="Bar"
                     id="genericSWTMenuBar" uid="_1j+1" x="-" y="-">
        <comment>

@generic</comment>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       id="genericSWTMenuItem" uid="_1j+2">
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="org.eclipse.swt.widgets.Menu" feature="Popup"
                     height="182" id="genericSWTPopupMenu" uid="_1j-N"
                     width="140" x="-" y="-">
        <comment>

@generic</comment>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem" classcount="9"
                       classindex="8" feature="Close" height="21"
                       id="WorkbenchWindow.menuitemClose" uid="_1j-O"
                       width="136" x="0" y="155">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       feature="Debug" id="WorkbenchWindow.menuitemDebug"
                       regexp="true" uid="_1j-P" x="30000" y="30000">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem" classcount="4"
                       classindex="1" feature="Java Browsing" height="21"
                       id="WorkbenchWindow.menuitemJava_Browsing" uid="_1j-Q"
                       width="131" x="0" y="21">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem" classcount="4"
                       classindex="0" feature="Java" height="21"
                       id="WorkbenchWindow.menuitemJava" uid="_1j-R"
                       width="131" x="0" y="0">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       feature="Project\.\.\." height="30000"
                       id="WorkbenchWindow.menuitemProject..." regexp="true"
                       uid="_1j-S" width="30000" x="0" y="0">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       feature="(Open )?External Tools( Dialog)?\.\.\."
                       height="30000"
                       id="WorkbenchWindow.menuitemExternal_Tools..."
                       regexp="true" uid="_1j-T" width="30000" x="0" y="19">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem" classcount="9"
                       classindex="1" feature="Detached" height="17"
                       id="menuitemDetached" uid="_1j-U" width="84" x="2"
                       y="19">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem" classcount="5"
                       classindex="3"
                       feature="External Tools Configurations..." height="21"
                       id="WorkbenchWindow.menuitemExternal_Tools_Configurations..."
                       uid="_6Wp" width="178" x="0" y="54">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       feature="Configure Contents..."
                       id="WorkbenchWindow.menuitemConfigure_Contents..."
                       regexp="true" uid="_1j-V" x="30000" y="30000">
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.MenuItem"
                       feature="Java Project" height="20"
                       id="WorkbenchWindow.menuitemJava_Project" uid="_6aV"
                       width="180" x="2" y="2">
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="org.eclipse.swt.custom.CTabFolder"
                     feature="withtab:$(tabname)" height="-"
                     id="genericShell.genericCTabFolder"
                     regexp="${default:tabRegex:false}" uid="_1j+3" width="-"
                     x="-" y="-">
        <comment>

@generic</comment>
        <ComponentStep class="org.eclipse.swt.widgets.ToolItem"
                       feature="ToolTip: View Menu" height="-"
                       id="genericShell.genericViewMenu" uid="_1lRw" width="-"
                       x="-" y="-">
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">View Menu</extrafeature>
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.ToolBar" classcount="1"
                       classindex="0" height="26"
                       id="genericShell.genericViewMenuToolbar" uid="_1lRv"
                       width="25" x="224" y="30">
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="org.eclipse.e4.ui.widgets.CTabFolder"
                     feature="withtab:$(tabname)" height="-"
                     id="genericShell.genericE4CTabFolder"
                     regexp="${default:tabRegex:false}" uid="_1lRJ" width="-"
                     x="-" y="-">
        <comment>

@generic</comment>
        <ComponentStep class="org.eclipse.swt.widgets.ToolItem"
                       feature="ToolTip: View Menu" height="-"
                       id="genericShell.genericE4ViewMenu" uid="_1lRy"
                       width="-" x="-" y="-">
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="1">View Menu</extrafeature>
          <comment>

@generic</comment>
        </ComponentStep>
        <ComponentStep class="org.eclipse.swt.widgets.ToolBar" classcount="1"
                       classindex="0" height="26"
                       id="genericShell.genericE4ViewMenuToolbar" uid="_1lRx"
                       width="25" x="224" y="30">
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="org.eclipse.swt.widgets.Control"
                     feature="withtab:$(tabname)" height="-"
                     id="genericShell.genericTabFolder"
                     regexp="${default:tabRegex:false}" uid="_1lRS" width="-"
                     x="-" y="-">
        <comment>

@generic</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="org.eclipse.swt.widgets.Shell" engine="swt"
                id="genericModalShell" modal="true" uid="_1j+4">
      <comment>

@generic</comment>
    </WindowStep>
    <WindowStep class="org.eclipse.swt.widgets.Dialog" engine="swt"
                id="genericSWTDialog" modal="true" uid="_1j+5">
      <comment>

@generic</comment>
    </WindowStep>
    <WebPageStep id="genericDocument" uid="_1j+6">
      <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                    regexp="false" state="1"/>
      <comment>

@generic</comment>
      <ComponentStep class="HTML" classindex="0" height="-" id="genericHtml"
                     uid="_1j+e" width="-" x="-" y="-">
        <comment>

@generic</comment>
        <ComponentStep class="BODY" classindex="0" height="-" id="genericBody"
                       uid="_1j+f" width="-" x="-" y="-">
          <comment>

@generic</comment>
        </ComponentStep>
      </ComponentStep>
    </WebPageStep>
    <WindowStep class="DIALOG:UPLOAD" engine="web" id="genericUploadDialog"
                modal="true" uid="_1j+j">
      <comment>

@generic</comment>
    </WindowStep>
    <WindowStep class="PriorityAwtSwingWindow" id="PriorityAwtSwingWindow"
                uid="_1j-h">
      <comment>Window which can be used by rc.overrideElement for AWT/Swing windows.
It will act as assigned windows/frames/dialogs, so the information of the window itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="PriorityAwtSwingComponent"
                     id="PriorityAwtSwingComponent" uid="_1k03">
        <comment>Component which can be used by rc.overrideElement for AWT/Swing components.
It will act as assigned component, so the information of the component itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="Window" engine="fx" id="PriorityFxWindow" uid="_1j-i">
      <comment>Component which can be used by rc.overrideElement which can be used for FX Stages.
It will act as assigned window, so the information of the window itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="Node" id="PriorityFxNode" uid="_1k04">
        <comment>Component which can be used by rc.overrideElement for FX nodes.
It will act as assigned node, so the information of the node itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="Window" engine="fx" id="genericStage" uid="_P">
      <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                    state="1">Window</extrafeature>
      <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                    state="1">javafx.stage.Stage</extrafeature>
      <comment>
@generic</comment>
      <ComponentStep class="TabPanel" classcount="1" classindex="0"
                     height="300" id="CarConfiguratorFX.TabbedPane"
                     name="TabbedPane" uid="_Q" width="436" x="8" y="54">
        <extrafeature name="qfs:class" negate="false" regexp="false"
                      state="0">javafx.scene.control.TabPane</extrafeature>
        <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                      state="0">TabPanel</extrafeature>
        <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                      state="0">javafx.scene.control.TabPane</extrafeature>
        <extrafeature name="side" negate="false" regexp="false" state="0">TOP</extrafeature>
        <ComponentStep class="Panel" classindex="1" feature="Tab: Fahrzeuge"
                       height="269"
                       id="CarConfiguratorFX.TabbedPane.panelFahrzeuge"
                       uid="_1oUj" width="436" x="0" y="31">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javafx.scene.layout.StackPane</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">Panel</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javafx.scene.layout.StackPane</extrafeature>
          <extrafeature name="qfs:type" negate="false" regexp="false"
                        state="0">Panel:TabPanelContent</extrafeature>
          <ComponentStep class="Panel" classcount="1" classindex="0"
                         height="269" id="CarConfiguratorFX.VehicleTablePanel"
                         name="VehicleTablePanel" uid="_1oUk" width="436"
                         x="0" y="0">
            <extrafeature name="qfs:class" negate="false" regexp="false"
                          state="0">javafx.scene.layout.GridPane</extrafeature>
            <extrafeature name="qfs:genericclass" negate="false"
                          regexp="false" state="0">Panel</extrafeature>
            <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                          state="0">javafx.scene.layout.GridPane</extrafeature>
            <ComponentStep class="Table" classcount="1" classindex="0"
                           height="234" id="CarConfiguratorFX.VehicleTable"
                           name="VehicleTable" uid="_T" width="422" x="7"
                           y="28">
              <extrafeature name="qfs:class" negate="false" regexp="false"
                            state="0">javafx.scene.control.TableView</extrafeature>
              <extrafeature name="qfs:genericclass" negate="false"
                            regexp="false" state="0">Table</extrafeature>
              <extrafeature name="qfs:label" negate="false" regexp="false"
                            state="1">Fahrzeuge</extrafeature>
              <extrafeature name="qfs:systemclass" negate="false"
                            regexp="false" state="0">javafx.scene.control.TableView</extrafeature>
            </ComponentStep>
          </ComponentStep>
        </ComponentStep>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="PrioritySwtWindow" engine="swt" id="PrioritySwtWindow"
                uid="_1nPU">
      <comment>Component which can be used by rc.overrideElement which can be used for SWT shells and dialogs.
It will act as assigned shell/dialog, so the information of the shell/dialog itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="PrioritySwtWidget" id="PrioritySwtWidget"
                     uid="_1nPV">
        <comment>Component which can be used by rc.overrideElement for SWT widgets.
It will act as assigned widget, so the information of the widget itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="PriorityWebpage" engine="web" id="PriorityWebpage"
                uid="_1j-j">
      <comment>WIndow which can be used by rc.overrideElement for Webpages.
It will act as assigned webpage, so the information of the webpage itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="PriorityWebComponent" id="PriorityWebComponent"
                     uid="_1k05">
        <comment>Component which can be used by rc.overrideElement for any web component.
It will act as assigned component, so the information of the component itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="Window" engine="fx" id="genericFxModalDialog"
                modal="true" uid="_1nP1">
      <comment>This node will always match the "most modal" dialog.

@generic</comment>
    </WindowStep>
    <WindowStep class="Window" feature=".*QF-Test PDF Client"
                id="genericPDFWindow" regexp="true" uid="_2JAr">
      <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                    regexp="false" state="1"/>
      <comment>This node will always match the PDF window.

@generic</comment>
      <ComponentStep class="Menu" id="genericPDFMenu" uid="_2JD0">
        <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                      regexp="false" state="1"/>
        <ComponentStep class="MenuItem" id="genericPDFMenuFile" uid="_2JCI">
          <extrafeature name="__mustNotMatchToPreventRecording__"
                        negate="false" regexp="false" state="1"/>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="0">File</extrafeature>
        </ComponentStep>
        <ComponentStep class="MenuItem" id="genericPDFMenuView" uid="_2JCO">
          <extrafeature name="__mustNotMatchToPreventRecording__"
                        negate="false" regexp="false" state="1"/>
          <extrafeature name="qfs:label" negate="false" regexp="false"
                        state="2">View</extrafeature>
          <ComponentStep class="MenuItem"
                         id="genericPDFMenuShowORHideComponents" uid="_2JD1">
            <extrafeature name="__mustNotMatchToPreventRecording__"
                          negate="false" regexp="false" state="1"/>
            <extrafeature name="qfs:label" negate="false" regexp="true"
                          state="2">((Show)|(Hide)) components</extrafeature>
          </ComponentStep>
          <ComponentStep class="MenuItem" id="genericPDFMenuShowComponents"
                         uid="_2JCQ">
            <extrafeature name="__mustNotMatchToPreventRecording__"
                          negate="false" regexp="false" state="1"/>
            <extrafeature name="qfs:label" negate="false" regexp="false"
                          state="2">Show components</extrafeature>
          </ComponentStep>
          <ComponentStep class="MenuItem" id="genericPDFMenuHideComponents"
                         uid="_2JCR">
            <extrafeature name="__mustNotMatchToPreventRecording__"
                          negate="false" regexp="false" state="1"/>
            <extrafeature name="qfs:label" negate="false" regexp="false"
                          state="2">Hide components</extrafeature>
          </ComponentStep>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="Panel" height="-" id="genericPDFPage" uid="_1mYL"
                     width="-" x="-" y="-">
        <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                      regexp="false" state="1"/>
        <ComponentStep class="MainPanel" classcount="1" classindex="0"
                       id="genericPDFMainStage" uid="_1mYl">
          <extrafeature name="__mustNotMatchToPreventRecording__"
                        negate="false" regexp="false" state="1"/>
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="2">de.qfs.apps.qfpdf.ui.MainStage</extrafeature>
        </ComponentStep>
      </ComponentStep>
      <ComponentStep class="Tree" classcount="1" classindex="0"
                     id="genericPDFPageTree" uid="_2JAs">
        <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                      regexp="false" state="1"/>
      </ComponentStep>
      <ComponentStep class="Label" id="genericPDFFinishedLabel" uid="_1mad">
        <extrafeature name="__mustNotMatchToPreventRecording__" negate="false"
                      regexp="false" state="1"/>
        <extrafeature name="qfs:label" negate="false" regexp="false"
                      state="2">Finished</extrafeature>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="Window" feature="ScrolledTabs [ Frame ]" height="219"
                id="ScrolledTabs" name="ScrolledTabs" uid="_2YNg" width="631"
                x="1282" y="183">
      <extrafeature name="qfs:class" negate="false" regexp="false" state="0">javax.swing.JFrame</extrafeature>
      <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                    state="0">Window</extrafeature>
      <extrafeature name="qfs:label" negate="false" regexp="false" state="1">ScrolledTabs [ Frame ]</extrafeature>
      <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                    state="0">javax.swing.JFrame</extrafeature>
      <ComponentStep class="Panel" classcount="17" classindex="4" height="172"
                     id="ScrolledTabs.grid" name="grid" uid="_2YNh"
                     width="613" x="9" y="38">
        <extrafeature name="qfs:class" negate="false" regexp="false"
                      state="0">de.qfs.lib.gui.Grid</extrafeature>
        <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                      state="0">Panel</extrafeature>
        <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                      state="0">javax.swing.JPanel</extrafeature>
        <ComponentStep class="TabPanel" classcount="1" classindex="0"
                       height="142" id="ScrolledTabs.Tabs" name="Tabs"
                       uid="_2YNi" width="613" x="0" y="30">
          <extrafeature name="qfs:class" negate="false" regexp="false"
                        state="0">javax.swing.JTabbedPane</extrafeature>
          <extrafeature name="qfs:genericclass" negate="false" regexp="false"
                        state="0">TabPanel</extrafeature>
          <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                        state="0">javax.swing.JTabbedPane</extrafeature>
          <ComponentStep class="Panel" classcount="12" classindex="0"
                         feature="Button on tab0" height="25"
                         id="ScrolledTabs.Tabs.panelButton_on_tab0"
                         uid="_2YNj" width="613" x="0" y="0">
            <extrafeature name="qfs:class" negate="false" regexp="false"
                          state="0">javax.swing.plaf.basic.BasicTabbedPaneUI$$ScrollableTabViewport</extrafeature>
            <extrafeature name="qfs:genericclass" negate="false"
                          regexp="false" state="0">Panel</extrafeature>
            <extrafeature name="qfs:systemclass" negate="false" regexp="false"
                          state="0">javax.swing.plaf.basic.BasicTabbedPaneUI$$ScrollableTabViewport</extrafeature>
            <extrafeature name="qfs:type" negate="false" regexp="false"
                          state="0">Panel:TabPanelContent</extrafeature>
            <ComponentStep class="Panel" classcount="1" classindex="0"
                           id="ScrolledTabs.Tabs.panel" uid="_2YNk">
              <extrafeature name="qfs:class" negate="false" regexp="false"
                            state="0">javax.swing.plaf.basic.BasicTabbedPaneUI$$ScrollableTabPanel</extrafeature>
              <extrafeature name="qfs:genericclass" negate="false"
                            regexp="false" state="0">Panel</extrafeature>
              <extrafeature name="qfs:systemclass" negate="false"
                            regexp="false" state="0">javax.swing.plaf.basic.BasicTabbedPaneUI$$ScrollableTabPanel</extrafeature>
            </ComponentStep>
          </ComponentStep>
        </ComponentStep>
      </ComponentStep>
    </WindowStep>
    <WindowStep class="PriorityWindowsWindow" engine="window"
                id="PriorityWindowsWindow" uid="_2Ydq">
      <comment>Component which can be used by rc.overrideElement which can be used for Window Window.
It will act as assigned window, so the information of the window itself is not required as it comes from the assigned one.</comment>
      <ComponentStep class="PriorityWindowComponent"
                     id="PriorityWindowComponent" uid="_2Ydn">
        <comment>Component which can be used by rc.overrideElement for Window windows.
It will act as assigned node, so the information of the node itself is not required as it comes from the assigned one.</comment>
      </ComponentStep>
    </WindowStep>
  </WindowList>
</RootStep>
